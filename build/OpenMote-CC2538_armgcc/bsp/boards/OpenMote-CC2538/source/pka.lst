   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"pka.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.align	2
  19              		.global	PKAEnableInt
  20              		.thumb
  21              		.thumb_func
  23              	PKAEnableInt:
  24              	.LFB0:
  25              		.file 1 "bsp/boards/OpenMote-CC2538/source/pka.c"
   1:bsp/boards/OpenMote-CC2538/source/pka.c **** /******************************************************************************
   2:bsp/boards/OpenMote-CC2538/source/pka.c **** *  Filename:       pka.c
   3:bsp/boards/OpenMote-CC2538/source/pka.c **** *  Revised:        $Date: 2012-10-01 11:15:04 -0700 (Mon, 01 Oct 2012) $
   4:bsp/boards/OpenMote-CC2538/source/pka.c **** *  Revision:       $Revision: 31660 $
   5:bsp/boards/OpenMote-CC2538/source/pka.c **** *
   6:bsp/boards/OpenMote-CC2538/source/pka.c **** *  Description:    Driver for the PKA HW module.
   7:bsp/boards/OpenMote-CC2538/source/pka.c **** *
   8:bsp/boards/OpenMote-CC2538/source/pka.c **** *  Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/
   9:bsp/boards/OpenMote-CC2538/source/pka.c **** *
  10:bsp/boards/OpenMote-CC2538/source/pka.c **** *
  11:bsp/boards/OpenMote-CC2538/source/pka.c **** *  Redistribution and use in source and binary forms, with or without
  12:bsp/boards/OpenMote-CC2538/source/pka.c **** *  modification, are permitted provided that the following conditions
  13:bsp/boards/OpenMote-CC2538/source/pka.c **** *  are met:
  14:bsp/boards/OpenMote-CC2538/source/pka.c **** *
  15:bsp/boards/OpenMote-CC2538/source/pka.c **** *    Redistributions of source code must retain the above copyright
  16:bsp/boards/OpenMote-CC2538/source/pka.c **** *    notice, this list of conditions and the following disclaimer.
  17:bsp/boards/OpenMote-CC2538/source/pka.c **** *
  18:bsp/boards/OpenMote-CC2538/source/pka.c **** *    Redistributions in binary form must reproduce the above copyright
  19:bsp/boards/OpenMote-CC2538/source/pka.c **** *    notice, this list of conditions and the following disclaimer in the
  20:bsp/boards/OpenMote-CC2538/source/pka.c **** *    documentation and/or other materials provided with the distribution.
  21:bsp/boards/OpenMote-CC2538/source/pka.c **** *
  22:bsp/boards/OpenMote-CC2538/source/pka.c **** *    Neither the name of Texas Instruments Incorporated nor the names of
  23:bsp/boards/OpenMote-CC2538/source/pka.c **** *    its contributors may be used to endorse or promote products derived
  24:bsp/boards/OpenMote-CC2538/source/pka.c **** *    from this software without specific prior written permission.
  25:bsp/boards/OpenMote-CC2538/source/pka.c **** *
  26:bsp/boards/OpenMote-CC2538/source/pka.c **** *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  27:bsp/boards/OpenMote-CC2538/source/pka.c **** *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  28:bsp/boards/OpenMote-CC2538/source/pka.c **** *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  29:bsp/boards/OpenMote-CC2538/source/pka.c **** *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  30:bsp/boards/OpenMote-CC2538/source/pka.c **** *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  31:bsp/boards/OpenMote-CC2538/source/pka.c **** *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  32:bsp/boards/OpenMote-CC2538/source/pka.c **** *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  33:bsp/boards/OpenMote-CC2538/source/pka.c **** *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  34:bsp/boards/OpenMote-CC2538/source/pka.c **** *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  35:bsp/boards/OpenMote-CC2538/source/pka.c **** *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  36:bsp/boards/OpenMote-CC2538/source/pka.c **** *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  37:bsp/boards/OpenMote-CC2538/source/pka.c **** *
  38:bsp/boards/OpenMote-CC2538/source/pka.c **** ******************************************************************************/
  39:bsp/boards/OpenMote-CC2538/source/pka.c **** 
  40:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
  41:bsp/boards/OpenMote-CC2538/source/pka.c **** //
  42:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \addtogroup pka_driver
  43:bsp/boards/OpenMote-CC2538/source/pka.c **** //! @{
  44:bsp/boards/OpenMote-CC2538/source/pka.c **** //
  45:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
  46:bsp/boards/OpenMote-CC2538/source/pka.c **** 
  47:bsp/boards/OpenMote-CC2538/source/pka.c **** #include <headers/hw_ints.h>
  48:bsp/boards/OpenMote-CC2538/source/pka.c **** #include <headers/hw_memmap.h>
  49:bsp/boards/OpenMote-CC2538/source/pka.c **** #include <headers/hw_pka.h>
  50:bsp/boards/OpenMote-CC2538/source/pka.c **** #include <headers/hw_types.h>
  51:bsp/boards/OpenMote-CC2538/source/pka.c **** #include "interrupt.h"
  52:bsp/boards/OpenMote-CC2538/source/pka.c **** #include "pka.h"
  53:bsp/boards/OpenMote-CC2538/source/pka.c **** #include "sys_ctrl.h"
  54:bsp/boards/OpenMote-CC2538/source/pka.c **** #include "debug.h"
  55:bsp/boards/OpenMote-CC2538/source/pka.c **** 
  56:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
  57:bsp/boards/OpenMote-CC2538/source/pka.c **** //
  58:bsp/boards/OpenMote-CC2538/source/pka.c **** // Macro definition for NULL
  59:bsp/boards/OpenMote-CC2538/source/pka.c **** //
  60:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
  61:bsp/boards/OpenMote-CC2538/source/pka.c **** 
  62:bsp/boards/OpenMote-CC2538/source/pka.c **** #ifndef NULL
  63:bsp/boards/OpenMote-CC2538/source/pka.c **** #define NULL                    ((void*)0)
  64:bsp/boards/OpenMote-CC2538/source/pka.c **** #endif
  65:bsp/boards/OpenMote-CC2538/source/pka.c **** 
  66:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
  67:bsp/boards/OpenMote-CC2538/source/pka.c **** //
  68:bsp/boards/OpenMote-CC2538/source/pka.c **** // Define for the maximum curve size supported by the PKA module in 32 bit
  69:bsp/boards/OpenMote-CC2538/source/pka.c **** // word.
  70:bsp/boards/OpenMote-CC2538/source/pka.c **** // \note PKA hardware module can support upto 384 bit curve size due to the
  71:bsp/boards/OpenMote-CC2538/source/pka.c **** //       2K of PKA RAM.
  72:bsp/boards/OpenMote-CC2538/source/pka.c **** //
  73:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
  74:bsp/boards/OpenMote-CC2538/source/pka.c **** #define PKA_MAX_CURVE_SIZE_32_BIT_WORD \
  75:bsp/boards/OpenMote-CC2538/source/pka.c ****                                 12
  76:bsp/boards/OpenMote-CC2538/source/pka.c **** 
  77:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
  78:bsp/boards/OpenMote-CC2538/source/pka.c **** //
  79:bsp/boards/OpenMote-CC2538/source/pka.c **** // Define for the maximum length of the big number supported by the PKA module
  80:bsp/boards/OpenMote-CC2538/source/pka.c **** // in 32 bit word.
  81:bsp/boards/OpenMote-CC2538/source/pka.c **** //
  82:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
  83:bsp/boards/OpenMote-CC2538/source/pka.c **** #define PKA_MAX_LEN_IN_32_BIT_WORD \
  84:bsp/boards/OpenMote-CC2538/source/pka.c ****                                 PKA_MAX_CURVE_SIZE_32_BIT_WORD
  85:bsp/boards/OpenMote-CC2538/source/pka.c **** 
  86:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
  87:bsp/boards/OpenMote-CC2538/source/pka.c **** //
  88:bsp/boards/OpenMote-CC2538/source/pka.c **** // Define for the PKA RAM size.
  89:bsp/boards/OpenMote-CC2538/source/pka.c **** //
  90:bsp/boards/OpenMote-CC2538/source/pka.c **** //****************************************************************************
  91:bsp/boards/OpenMote-CC2538/source/pka.c **** #define PKA_RAM_SIZE            2000
  92:bsp/boards/OpenMote-CC2538/source/pka.c **** 
  93:bsp/boards/OpenMote-CC2538/source/pka.c **** 
  94:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
  95:bsp/boards/OpenMote-CC2538/source/pka.c **** //
  96:bsp/boards/OpenMote-CC2538/source/pka.c **** //! Enables the PKA interrupt.
  97:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
  98:bsp/boards/OpenMote-CC2538/source/pka.c **** //! This function enables the PKA interrupt.
  99:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 100:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \return None.
 101:bsp/boards/OpenMote-CC2538/source/pka.c **** //
 102:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
 103:bsp/boards/OpenMote-CC2538/source/pka.c **** void
 104:bsp/boards/OpenMote-CC2538/source/pka.c **** PKAEnableInt(void)
 105:bsp/boards/OpenMote-CC2538/source/pka.c **** {
  26              		.loc 1 105 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 0
  29              		@ frame_needed = 1, uses_anonymous_args = 0
  30 0000 80B5     		push	{r7, lr}
  31              	.LCFI0:
  32              		.cfi_def_cfa_offset 8
  33              		.cfi_offset 7, -8
  34              		.cfi_offset 14, -4
  35 0002 00AF     		add	r7, sp, #0
  36              	.LCFI1:
  37              		.cfi_def_cfa_register 7
 106:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 107:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Enable the PKA interrupt.
 108:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 109:bsp/boards/OpenMote-CC2538/source/pka.c ****     IntEnable(INT_PKA);
  38              		.loc 1 109 0
  39 0004 4FF0A000 		mov	r0, #160
  40 0008 FFF7FEFF 		bl	IntEnable
 110:bsp/boards/OpenMote-CC2538/source/pka.c **** }
  41              		.loc 1 110 0
  42 000c 80BD     		pop	{r7, pc}
  43              		.cfi_endproc
  44              	.LFE0:
  46 000e 00BF     		.align	2
  47              		.global	PKADisableInt
  48              		.thumb
  49              		.thumb_func
  51              	PKADisableInt:
  52              	.LFB1:
 111:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 112:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
 113:bsp/boards/OpenMote-CC2538/source/pka.c **** //
 114:bsp/boards/OpenMote-CC2538/source/pka.c **** //! Disables the PKA interrupt.
 115:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 116:bsp/boards/OpenMote-CC2538/source/pka.c **** //! This function disables the PKA interrupt.
 117:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 118:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \return None.
 119:bsp/boards/OpenMote-CC2538/source/pka.c **** //
 120:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
 121:bsp/boards/OpenMote-CC2538/source/pka.c **** void
 122:bsp/boards/OpenMote-CC2538/source/pka.c **** PKADisableInt( void )
 123:bsp/boards/OpenMote-CC2538/source/pka.c **** {
  53              		.loc 1 123 0
  54              		.cfi_startproc
  55              		@ args = 0, pretend = 0, frame = 0
  56              		@ frame_needed = 1, uses_anonymous_args = 0
  57 0010 80B5     		push	{r7, lr}
  58              	.LCFI2:
  59              		.cfi_def_cfa_offset 8
  60              		.cfi_offset 7, -8
  61              		.cfi_offset 14, -4
  62 0012 00AF     		add	r7, sp, #0
  63              	.LCFI3:
  64              		.cfi_def_cfa_register 7
 124:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 125:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Disables the PKA interrupt.
 126:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 127:bsp/boards/OpenMote-CC2538/source/pka.c ****     IntDisable(INT_PKA);
  65              		.loc 1 127 0
  66 0014 4FF0A000 		mov	r0, #160
  67 0018 FFF7FEFF 		bl	IntDisable
 128:bsp/boards/OpenMote-CC2538/source/pka.c **** }
  68              		.loc 1 128 0
  69 001c 80BD     		pop	{r7, pc}
  70              		.cfi_endproc
  71              	.LFE1:
  73 001e 00BF     		.align	2
  74              		.global	PKAClearInt
  75              		.thumb
  76              		.thumb_func
  78              	PKAClearInt:
  79              	.LFB2:
 129:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 130:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
 131:bsp/boards/OpenMote-CC2538/source/pka.c **** //
 132:bsp/boards/OpenMote-CC2538/source/pka.c **** //! Clears the PKA interrupt.
 133:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 134:bsp/boards/OpenMote-CC2538/source/pka.c **** //! This function unpends PKA interrupt.  This will cause any previously
 135:bsp/boards/OpenMote-CC2538/source/pka.c **** //! generated PKA interrupts that have not been handled yet to be discarded.
 136:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 137:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \return None.
 138:bsp/boards/OpenMote-CC2538/source/pka.c **** //
 139:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
 140:bsp/boards/OpenMote-CC2538/source/pka.c **** void
 141:bsp/boards/OpenMote-CC2538/source/pka.c **** PKAClearInt(void)
 142:bsp/boards/OpenMote-CC2538/source/pka.c **** {
  80              		.loc 1 142 0
  81              		.cfi_startproc
  82              		@ args = 0, pretend = 0, frame = 0
  83              		@ frame_needed = 1, uses_anonymous_args = 0
  84 0020 80B5     		push	{r7, lr}
  85              	.LCFI4:
  86              		.cfi_def_cfa_offset 8
  87              		.cfi_offset 7, -8
  88              		.cfi_offset 14, -4
  89 0022 00AF     		add	r7, sp, #0
  90              	.LCFI5:
  91              		.cfi_def_cfa_register 7
 143:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 144:bsp/boards/OpenMote-CC2538/source/pka.c ****     // UnPends the PKA interrupt.
 145:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 146:bsp/boards/OpenMote-CC2538/source/pka.c ****     IntPendClear(INT_PKA);
  92              		.loc 1 146 0
  93 0024 4FF0A000 		mov	r0, #160
  94 0028 FFF7FEFF 		bl	IntPendClear
 147:bsp/boards/OpenMote-CC2538/source/pka.c **** }
  95              		.loc 1 147 0
  96 002c 80BD     		pop	{r7, pc}
  97              		.cfi_endproc
  98              	.LFE2:
 100 002e 00BF     		.align	2
 101              		.global	PKARegInt
 102              		.thumb
 103              		.thumb_func
 105              	PKARegInt:
 106              	.LFB3:
 148:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 149:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
 150:bsp/boards/OpenMote-CC2538/source/pka.c **** //
 151:bsp/boards/OpenMote-CC2538/source/pka.c **** //! Registers an interrupt handler for PKA interrupt.
 152:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 153:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param pfnHandler is a pointer to the function to be called when the
 154:bsp/boards/OpenMote-CC2538/source/pka.c **** //! PKA interrupt occurs.
 155:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 156:bsp/boards/OpenMote-CC2538/source/pka.c **** //! This function does the actual registering of the interrupt handler.  This
 157:bsp/boards/OpenMote-CC2538/source/pka.c **** //! will not enable the PKA interrupt in the interrupt controller, a call to
 158:bsp/boards/OpenMote-CC2538/source/pka.c **** //! the function \sa PKAEnableInt() is needed to enable the PKA interrupt.
 159:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 160:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \sa IntRegister() for important information about registering interrupt
 161:bsp/boards/OpenMote-CC2538/source/pka.c **** //! handlers.
 162:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 163:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \return None.
 164:bsp/boards/OpenMote-CC2538/source/pka.c **** //
 165:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
 166:bsp/boards/OpenMote-CC2538/source/pka.c **** void
 167:bsp/boards/OpenMote-CC2538/source/pka.c **** PKARegInt(void (*pfnHandler)(void))
 168:bsp/boards/OpenMote-CC2538/source/pka.c **** {
 107              		.loc 1 168 0
 108              		.cfi_startproc
 109              		@ args = 0, pretend = 0, frame = 8
 110              		@ frame_needed = 1, uses_anonymous_args = 0
 111 0030 80B5     		push	{r7, lr}
 112              	.LCFI6:
 113              		.cfi_def_cfa_offset 8
 114              		.cfi_offset 7, -8
 115              		.cfi_offset 14, -4
 116 0032 82B0     		sub	sp, sp, #8
 117              	.LCFI7:
 118              		.cfi_def_cfa_offset 16
 119 0034 00AF     		add	r7, sp, #0
 120              	.LCFI8:
 121              		.cfi_def_cfa_register 7
 122 0036 7860     		str	r0, [r7, #4]
 169:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 170:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Register the interrupt handler.
 171:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 172:bsp/boards/OpenMote-CC2538/source/pka.c ****     IntRegister(INT_PKA, pfnHandler);
 123              		.loc 1 172 0
 124 0038 4FF0A000 		mov	r0, #160
 125 003c 7968     		ldr	r1, [r7, #4]
 126 003e FFF7FEFF 		bl	IntRegister
 173:bsp/boards/OpenMote-CC2538/source/pka.c **** }
 127              		.loc 1 173 0
 128 0042 07F10807 		add	r7, r7, #8
 129 0046 BD46     		mov	sp, r7
 130 0048 80BD     		pop	{r7, pc}
 131              		.cfi_endproc
 132              	.LFE3:
 134 004a 00BF     		.align	2
 135              		.global	PKAUnRegInt
 136              		.thumb
 137              		.thumb_func
 139              	PKAUnRegInt:
 140              	.LFB4:
 174:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 175:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
 176:bsp/boards/OpenMote-CC2538/source/pka.c **** //
 177:bsp/boards/OpenMote-CC2538/source/pka.c **** //! Unregisters an interrupt handler for the PKA interrupt.
 178:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 179:bsp/boards/OpenMote-CC2538/source/pka.c **** //! This function deregisters the interrupt service routine.  This function
 180:bsp/boards/OpenMote-CC2538/source/pka.c **** //! will not disable the interrupt and an explicit call to \sa PKADisableInt()
 181:bsp/boards/OpenMote-CC2538/source/pka.c **** //! is needed.
 182:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 183:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \return None.
 184:bsp/boards/OpenMote-CC2538/source/pka.c **** //
 185:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
 186:bsp/boards/OpenMote-CC2538/source/pka.c **** void
 187:bsp/boards/OpenMote-CC2538/source/pka.c **** PKAUnRegInt(void)
 188:bsp/boards/OpenMote-CC2538/source/pka.c **** {
 141              		.loc 1 188 0
 142              		.cfi_startproc
 143              		@ args = 0, pretend = 0, frame = 0
 144              		@ frame_needed = 1, uses_anonymous_args = 0
 145 004c 80B5     		push	{r7, lr}
 146              	.LCFI9:
 147              		.cfi_def_cfa_offset 8
 148              		.cfi_offset 7, -8
 149              		.cfi_offset 14, -4
 150 004e 00AF     		add	r7, sp, #0
 151              	.LCFI10:
 152              		.cfi_def_cfa_register 7
 189:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 190:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Unregister the interrupt handler.
 191:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 192:bsp/boards/OpenMote-CC2538/source/pka.c ****     IntUnregister(INT_PKA);
 153              		.loc 1 192 0
 154 0050 4FF0A000 		mov	r0, #160
 155 0054 FFF7FEFF 		bl	IntUnregister
 193:bsp/boards/OpenMote-CC2538/source/pka.c **** }
 156              		.loc 1 193 0
 157 0058 80BD     		pop	{r7, pc}
 158              		.cfi_endproc
 159              	.LFE4:
 161 005a 00BF     		.align	2
 162              		.global	PKAGetOpsStatus
 163              		.thumb
 164              		.thumb_func
 166              	PKAGetOpsStatus:
 167              	.LFB5:
 194:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 195:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
 196:bsp/boards/OpenMote-CC2538/source/pka.c **** //
 197:bsp/boards/OpenMote-CC2538/source/pka.c **** //! Provides the PKA operation status.
 198:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 199:bsp/boards/OpenMote-CC2538/source/pka.c **** //! This function provides information on whether any PKA operation is in
 200:bsp/boards/OpenMote-CC2538/source/pka.c **** //! progress or not. This function allows to check the PKA operation status
 201:bsp/boards/OpenMote-CC2538/source/pka.c **** //! before starting any new PKA operation.
 202:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 203:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \return Returns: 
 204:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_INPRG if the PKA operation is in progress.
 205:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_OPERATION_NOT_INPRG if the PKA operation is not in progress.
 206:bsp/boards/OpenMote-CC2538/source/pka.c **** //
 207:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
 208:bsp/boards/OpenMote-CC2538/source/pka.c **** tPKAStatus
 209:bsp/boards/OpenMote-CC2538/source/pka.c **** PKAGetOpsStatus(void)
 210:bsp/boards/OpenMote-CC2538/source/pka.c **** {
 168              		.loc 1 210 0
 169              		.cfi_startproc
 170              		@ args = 0, pretend = 0, frame = 0
 171              		@ frame_needed = 1, uses_anonymous_args = 0
 172              		@ link register save eliminated.
 173 005c 80B4     		push	{r7}
 174              	.LCFI11:
 175              		.cfi_def_cfa_offset 4
 176              		.cfi_offset 7, -4
 177 005e 00AF     		add	r7, sp, #0
 178              	.LCFI12:
 179              		.cfi_def_cfa_register 7
 211:bsp/boards/OpenMote-CC2538/source/pka.c ****     if((HWREG(PKA_FUNCTION) & PKA_FUNCTION_RUN) != 0)
 180              		.loc 1 211 0
 181 0060 44F21C03 		movw	r3, #16412
 182 0064 C4F20043 		movt	r3, 17408
 183 0068 1B68     		ldr	r3, [r3, #0]
 184 006a 03F40043 		and	r3, r3, #32768
 185 006e 002B     		cmp	r3, #0
 186 0070 02D0     		beq	.L7
 212:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
 213:bsp/boards/OpenMote-CC2538/source/pka.c ****         return (PKA_STATUS_OPERATION_INPRG);
 187              		.loc 1 213 0
 188 0072 4FF00703 		mov	r3, #7
 189 0076 01E0     		b	.L8
 190              	.L7:
 214:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
 215:bsp/boards/OpenMote-CC2538/source/pka.c ****     else
 216:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
 217:bsp/boards/OpenMote-CC2538/source/pka.c ****         return (PKA_STATUS_OPERATION_NOT_INPRG);
 191              		.loc 1 217 0
 192 0078 4FF00803 		mov	r3, #8
 193              	.L8:
 218:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
 219:bsp/boards/OpenMote-CC2538/source/pka.c **** }
 194              		.loc 1 219 0
 195 007c 1846     		mov	r0, r3
 196 007e BD46     		mov	sp, r7
 197 0080 80BC     		pop	{r7}
 198 0082 7047     		bx	lr
 199              		.cfi_endproc
 200              	.LFE5:
 202              		.align	2
 203              		.global	PKABigNumModStart
 204              		.thumb
 205              		.thumb_func
 207              	PKABigNumModStart:
 208              	.LFB6:
 220:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 221:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
 222:bsp/boards/OpenMote-CC2538/source/pka.c **** //
 223:bsp/boards/OpenMote-CC2538/source/pka.c **** //! Starts the big number modulus operation.
 224:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 225:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param pui32BNum is the pointer to the big number on which modulo operation
 226:bsp/boards/OpenMote-CC2538/source/pka.c **** //! needs to be carried out.
 227:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param ui8BNSize is the size of the big number \sa pui32BNum in 32-bit
 228:bsp/boards/OpenMote-CC2538/source/pka.c **** //! word.
 229:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param pui32Modulus is the pointer to the divisor.
 230:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param ui8ModSize is the size of the divisor \sa pui32Modulus.
 231:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param pui32ResultVector is the pointer to the result vector location
 232:bsp/boards/OpenMote-CC2538/source/pka.c **** //! which will be set by this function.
 233:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 234:bsp/boards/OpenMote-CC2538/source/pka.c **** //! This function starts the modulo operation on the big num \sa pui32BNum
 235:bsp/boards/OpenMote-CC2538/source/pka.c **** //! using the divisor \sa pui32Modulus.  The PKA RAM location where the result
 236:bsp/boards/OpenMote-CC2538/source/pka.c **** //! will be available is stored in \sa pui32ResultVector.
 237:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 238:bsp/boards/OpenMote-CC2538/source/pka.c **** //!\return Returns: 
 239:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_SUCCESS if successful in starting the operation.  
 240:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_OPERATION_INPRG, if the PKA hw module is busy doing
 241:bsp/boards/OpenMote-CC2538/source/pka.c **** //! some other operation.
 242:bsp/boards/OpenMote-CC2538/source/pka.c **** //
 243:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
 244:bsp/boards/OpenMote-CC2538/source/pka.c **** tPKAStatus
 245:bsp/boards/OpenMote-CC2538/source/pka.c **** PKABigNumModStart(uint32_t* pui32BNum, uint8_t ui8BNSize,
 246:bsp/boards/OpenMote-CC2538/source/pka.c ****                   uint32_t* pui32Modulus, uint8_t ui8ModSize,
 247:bsp/boards/OpenMote-CC2538/source/pka.c ****                   uint32_t* pui32ResultVector)
 248:bsp/boards/OpenMote-CC2538/source/pka.c **** {
 209              		.loc 1 248 0
 210              		.cfi_startproc
 211              		@ args = 4, pretend = 0, frame = 32
 212              		@ frame_needed = 1, uses_anonymous_args = 0
 213              		@ link register save eliminated.
 214 0084 80B4     		push	{r7}
 215              	.LCFI13:
 216              		.cfi_def_cfa_offset 4
 217              		.cfi_offset 7, -4
 218 0086 89B0     		sub	sp, sp, #36
 219              	.LCFI14:
 220              		.cfi_def_cfa_offset 40
 221 0088 00AF     		add	r7, sp, #0
 222              	.LCFI15:
 223              		.cfi_def_cfa_register 7
 224 008a F860     		str	r0, [r7, #12]
 225 008c 7A60     		str	r2, [r7, #4]
 226 008e 0A46     		mov	r2, r1
 227 0090 FA72     		strb	r2, [r7, #11]
 228 0092 BB72     		strb	r3, [r7, #10]
 249:bsp/boards/OpenMote-CC2538/source/pka.c ****     uint8_t extraBuf;
 250:bsp/boards/OpenMote-CC2538/source/pka.c ****     uint32_t offset;
 251:bsp/boards/OpenMote-CC2538/source/pka.c ****     int i;
 252:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 253:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 254:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Check the arguments.
 255:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 256:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != pui32BNum);
 257:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != pui32Modulus);
 258:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != pui32ResultVector);
 259:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 260:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 261:bsp/boards/OpenMote-CC2538/source/pka.c ****     // make sure no operation is in progress.
 262:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 263:bsp/boards/OpenMote-CC2538/source/pka.c ****     if((HWREG(PKA_FUNCTION) & PKA_FUNCTION_RUN) != 0)
 229              		.loc 1 263 0
 230 0094 44F21C03 		movw	r3, #16412
 231 0098 C4F20043 		movt	r3, 17408
 232 009c 1B68     		ldr	r3, [r3, #0]
 233 009e 03F40043 		and	r3, r3, #32768
 234 00a2 002B     		cmp	r3, #0
 235 00a4 02D0     		beq	.L10
 264:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
 265:bsp/boards/OpenMote-CC2538/source/pka.c ****         return (PKA_STATUS_OPERATION_INPRG);
 236              		.loc 1 265 0
 237 00a6 4FF00703 		mov	r3, #7
 238 00aa 89E0     		b	.L11
 239              	.L10:
 266:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
 267:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 268:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 269:bsp/boards/OpenMote-CC2538/source/pka.c ****     // calculate the extra buffer requirement.
 270:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 271:bsp/boards/OpenMote-CC2538/source/pka.c ****     extraBuf = 2 + ui8ModSize % 2;
 240              		.loc 1 271 0
 241 00ac BB7A     		ldrb	r3, [r7, #10]
 242 00ae 03F00103 		and	r3, r3, #1
 243 00b2 DBB2     		uxtb	r3, r3
 244 00b4 03F10203 		add	r3, r3, #2
 245 00b8 FB76     		strb	r3, [r7, #27]
 272:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 273:bsp/boards/OpenMote-CC2538/source/pka.c ****     offset = 0;
 246              		.loc 1 273 0
 247 00ba 4FF00003 		mov	r3, #0
 248 00be 7B61     		str	r3, [r7, #20]
 274:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 275:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 276:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Update the A ptr with the offset address of the PKA RAM location
 277:bsp/boards/OpenMote-CC2538/source/pka.c ****     // where the number will be stored.
 278:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 279:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG( (PKA_APTR) ) = offset >>2;
 249              		.loc 1 279 0
 250 00c0 4FF48043 		mov	r3, #16384
 251 00c4 C4F20043 		movt	r3, 17408
 252 00c8 7A69     		ldr	r2, [r7, #20]
 253 00ca 4FEA9202 		lsr	r2, r2, #2
 254 00ce 1A60     		str	r2, [r3, #0]
 280:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 281:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 282:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Load the number in PKA RAM
 283:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 284:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ui8BNSize; i++)
 255              		.loc 1 284 0
 256 00d0 4FF00003 		mov	r3, #0
 257 00d4 FB61     		str	r3, [r7, #28]
 258 00d6 14E0     		b	.L12
 259              	.L13:
 285:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
 286:bsp/boards/OpenMote-CC2538/source/pka.c ****         HWREG((PKA_RAM_BASE + offset + 4*i)) = pui32BNum[i];
 260              		.loc 1 286 0 discriminator 2
 261 00d8 FB69     		ldr	r3, [r7, #28]
 262 00da 4FEA8303 		lsl	r3, r3, #2
 263 00de 1A46     		mov	r2, r3
 264 00e0 7B69     		ldr	r3, [r7, #20]
 265 00e2 D318     		adds	r3, r2, r3
 266 00e4 03F18843 		add	r3, r3, #1140850688
 267 00e8 03F5C043 		add	r3, r3, #24576
 268 00ec FA69     		ldr	r2, [r7, #28]
 269 00ee 4FEA8202 		lsl	r2, r2, #2
 270 00f2 F968     		ldr	r1, [r7, #12]
 271 00f4 8A18     		adds	r2, r1, r2
 272 00f6 1268     		ldr	r2, [r2, #0]
 273 00f8 1A60     		str	r2, [r3, #0]
 284:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ui8BNSize; i++)
 274              		.loc 1 284 0 discriminator 2
 275 00fa FB69     		ldr	r3, [r7, #28]
 276 00fc 03F10103 		add	r3, r3, #1
 277 0100 FB61     		str	r3, [r7, #28]
 278              	.L12:
 284:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ui8BNSize; i++)
 279              		.loc 1 284 0 is_stmt 0 discriminator 1
 280 0102 FA7A     		ldrb	r2, [r7, #11]	@ zero_extendqisi2
 281 0104 FB69     		ldr	r3, [r7, #28]
 282 0106 9A42     		cmp	r2, r3
 283 0108 E6DC     		bgt	.L13
 287:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
 288:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 289:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 290:bsp/boards/OpenMote-CC2538/source/pka.c ****     // determine the offset for the next data input.
 291:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 292:bsp/boards/OpenMote-CC2538/source/pka.c ****     offset += 4 * (i + ui8BNSize % 2);
 284              		.loc 1 292 0 is_stmt 1
 285 010a FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 286 010c 03F00102 		and	r2, r3, #1
 287 0110 FB69     		ldr	r3, [r7, #28]
 288 0112 D318     		adds	r3, r2, r3
 289 0114 4FEA8303 		lsl	r3, r3, #2
 290 0118 7A69     		ldr	r2, [r7, #20]
 291 011a D318     		adds	r3, r2, r3
 292 011c 7B61     		str	r3, [r7, #20]
 293:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 294:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 295:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Update the B ptr with the offset address of the PKA RAM location
 296:bsp/boards/OpenMote-CC2538/source/pka.c ****     // where the divisor will be stored.
 297:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 298:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG( (PKA_BPTR) ) = offset >> 2;
 293              		.loc 1 298 0
 294 011e 44F20403 		movw	r3, #16388
 295 0122 C4F20043 		movt	r3, 17408
 296 0126 7A69     		ldr	r2, [r7, #20]
 297 0128 4FEA9202 		lsr	r2, r2, #2
 298 012c 1A60     		str	r2, [r3, #0]
 299:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 300:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 301:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Load the divisor in PKA RAM.
 302:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 303:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ui8ModSize;  i++)
 299              		.loc 1 303 0
 300 012e 4FF00003 		mov	r3, #0
 301 0132 FB61     		str	r3, [r7, #28]
 302 0134 14E0     		b	.L14
 303              	.L15:
 304:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
 305:bsp/boards/OpenMote-CC2538/source/pka.c ****         HWREG((PKA_RAM_BASE + offset + 4*i)) = pui32Modulus[i];
 304              		.loc 1 305 0 discriminator 2
 305 0136 FB69     		ldr	r3, [r7, #28]
 306 0138 4FEA8303 		lsl	r3, r3, #2
 307 013c 1A46     		mov	r2, r3
 308 013e 7B69     		ldr	r3, [r7, #20]
 309 0140 D318     		adds	r3, r2, r3
 310 0142 03F18843 		add	r3, r3, #1140850688
 311 0146 03F5C043 		add	r3, r3, #24576
 312 014a FA69     		ldr	r2, [r7, #28]
 313 014c 4FEA8202 		lsl	r2, r2, #2
 314 0150 7968     		ldr	r1, [r7, #4]
 315 0152 8A18     		adds	r2, r1, r2
 316 0154 1268     		ldr	r2, [r2, #0]
 317 0156 1A60     		str	r2, [r3, #0]
 303:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ui8ModSize;  i++)
 318              		.loc 1 303 0 discriminator 2
 319 0158 FB69     		ldr	r3, [r7, #28]
 320 015a 03F10103 		add	r3, r3, #1
 321 015e FB61     		str	r3, [r7, #28]
 322              	.L14:
 303:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ui8ModSize;  i++)
 323              		.loc 1 303 0 is_stmt 0 discriminator 1
 324 0160 BA7A     		ldrb	r2, [r7, #10]	@ zero_extendqisi2
 325 0162 FB69     		ldr	r3, [r7, #28]
 326 0164 9A42     		cmp	r2, r3
 327 0166 E6DC     		bgt	.L15
 306:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
 307:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 308:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 309:bsp/boards/OpenMote-CC2538/source/pka.c ****     // determine the offset for the next data.
 310:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 311:bsp/boards/OpenMote-CC2538/source/pka.c ****     offset += 4 * (i + extraBuf);
 328              		.loc 1 311 0 is_stmt 1
 329 0168 FA7E     		ldrb	r2, [r7, #27]	@ zero_extendqisi2
 330 016a FB69     		ldr	r3, [r7, #28]
 331 016c D318     		adds	r3, r2, r3
 332 016e 4FEA8303 		lsl	r3, r3, #2
 333 0172 7A69     		ldr	r2, [r7, #20]
 334 0174 D318     		adds	r3, r2, r3
 335 0176 7B61     		str	r3, [r7, #20]
 312:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 313:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 314:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Copy the result vector address location.
 315:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 316:bsp/boards/OpenMote-CC2538/source/pka.c ****     *pui32ResultVector = PKA_RAM_BASE + offset;
 336              		.loc 1 316 0
 337 0178 7B69     		ldr	r3, [r7, #20]
 338 017a 03F18843 		add	r3, r3, #1140850688
 339 017e 03F5C043 		add	r3, r3, #24576
 340 0182 BA6A     		ldr	r2, [r7, #40]
 341 0184 1360     		str	r3, [r2, #0]
 317:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 318:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 319:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Load C ptr with the result location in PKA RAM
 320:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 321:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG( (PKA_CPTR) ) = offset >> 2;
 342              		.loc 1 321 0
 343 0186 44F20803 		movw	r3, #16392
 344 018a C4F20043 		movt	r3, 17408
 345 018e 7A69     		ldr	r2, [r7, #20]
 346 0190 4FEA9202 		lsr	r2, r2, #2
 347 0194 1A60     		str	r2, [r3, #0]
 322:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 323:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 324:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Load A length registers with Big number length in 32 bit words.
 325:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 326:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG( (PKA_ALENGTH) ) = ui8BNSize;
 348              		.loc 1 326 0
 349 0196 44F21003 		movw	r3, #16400
 350 019a C4F20043 		movt	r3, 17408
 351 019e FA7A     		ldrb	r2, [r7, #11]	@ zero_extendqisi2
 352 01a0 1A60     		str	r2, [r3, #0]
 327:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 328:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 329:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Load B length registers  Divisor length in 32-bit words.
 330:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 331:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG( (PKA_BLENGTH) ) = ui8ModSize;
 353              		.loc 1 331 0
 354 01a2 44F21403 		movw	r3, #16404
 355 01a6 C4F20043 		movt	r3, 17408
 356 01aa BA7A     		ldrb	r2, [r7, #10]	@ zero_extendqisi2
 357 01ac 1A60     		str	r2, [r3, #0]
 332:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 333:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 334:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Start the PKCP modulo operation by setting the PKA Function register.
 335:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 336:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG( (PKA_FUNCTION) ) = (PKA_FUNCTION_RUN | PKA_FUNCTION_MODULO);
 358              		.loc 1 336 0
 359 01ae 44F21C03 		movw	r3, #16412
 360 01b2 C4F20043 		movt	r3, 17408
 361 01b6 4FF40242 		mov	r2, #33280
 362 01ba 1A60     		str	r2, [r3, #0]
 337:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 338:bsp/boards/OpenMote-CC2538/source/pka.c ****     return (PKA_STATUS_SUCCESS);
 363              		.loc 1 338 0
 364 01bc 4FF00003 		mov	r3, #0
 365              	.L11:
 339:bsp/boards/OpenMote-CC2538/source/pka.c **** }
 366              		.loc 1 339 0
 367 01c0 1846     		mov	r0, r3
 368 01c2 07F12407 		add	r7, r7, #36
 369 01c6 BD46     		mov	sp, r7
 370 01c8 80BC     		pop	{r7}
 371 01ca 7047     		bx	lr
 372              		.cfi_endproc
 373              	.LFE6:
 375              		.align	2
 376              		.global	PKABigNumModGetResult
 377              		.thumb
 378              		.thumb_func
 380              	PKABigNumModGetResult:
 381              	.LFB7:
 340:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 341:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
 342:bsp/boards/OpenMote-CC2538/source/pka.c **** //
 343:bsp/boards/OpenMote-CC2538/source/pka.c **** //! Gets the result of the big number modulus operation.
 344:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 345:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param pui32ResultBuf is the pointer to buffer where the result needs to
 346:bsp/boards/OpenMote-CC2538/source/pka.c **** //! be stored.
 347:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param ui8Size is the size of the provided buffer in 32 bit size word.
 348:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param ui32ResVectorLoc is the address of the result location which
 349:bsp/boards/OpenMote-CC2538/source/pka.c **** //! was provided by the start function \sa PKABigNumModStart().
 350:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 351:bsp/boards/OpenMote-CC2538/source/pka.c **** //! This function gets the result of the big number modulus operation which was
 352:bsp/boards/OpenMote-CC2538/source/pka.c **** //! previously started using the function \sa PKABigNumModStart().
 353:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 354:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \return Returns:
 355:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_SUCCESS if successful.
 356:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_OPERATION_INPRG, if the PKA hw module is busy doing
 357:bsp/boards/OpenMote-CC2538/source/pka.c **** //! the operation.
 358:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_RESULT_0 if the result is all zeroes.
 359:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_BUF_UNDERFLOW, if the \e ui8Size is less than the length
 360:bsp/boards/OpenMote-CC2538/source/pka.c **** //! of the result.
 361:bsp/boards/OpenMote-CC2538/source/pka.c **** //
 362:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
 363:bsp/boards/OpenMote-CC2538/source/pka.c **** tPKAStatus
 364:bsp/boards/OpenMote-CC2538/source/pka.c **** PKABigNumModGetResult(uint32_t* pui32ResultBuf,uint8_t ui8Size,
 365:bsp/boards/OpenMote-CC2538/source/pka.c ****                       uint32_t ui32ResVectorLoc)
 366:bsp/boards/OpenMote-CC2538/source/pka.c **** {
 382              		.loc 1 366 0
 383              		.cfi_startproc
 384              		@ args = 0, pretend = 0, frame = 32
 385              		@ frame_needed = 1, uses_anonymous_args = 0
 386              		@ link register save eliminated.
 387 01cc 80B4     		push	{r7}
 388              	.LCFI16:
 389              		.cfi_def_cfa_offset 4
 390              		.cfi_offset 7, -4
 391 01ce 89B0     		sub	sp, sp, #36
 392              	.LCFI17:
 393              		.cfi_def_cfa_offset 40
 394 01d0 00AF     		add	r7, sp, #0
 395              	.LCFI18:
 396              		.cfi_def_cfa_register 7
 397 01d2 F860     		str	r0, [r7, #12]
 398 01d4 0B46     		mov	r3, r1
 399 01d6 7A60     		str	r2, [r7, #4]
 400 01d8 FB72     		strb	r3, [r7, #11]
 367:bsp/boards/OpenMote-CC2538/source/pka.c ****     uint32_t regMSWVal;
 368:bsp/boards/OpenMote-CC2538/source/pka.c ****     uint32_t len;
 369:bsp/boards/OpenMote-CC2538/source/pka.c ****     int i;
 370:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 371:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 372:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Check the arguments.
 373:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 374:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != pui32ResultBuf);
 375:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT((ui32ResVectorLoc > PKA_RAM_BASE) &&
 376:bsp/boards/OpenMote-CC2538/source/pka.c ****            (ui32ResVectorLoc < (PKA_RAM_BASE + PKA_RAM_SIZE)));
 377:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 378:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 379:bsp/boards/OpenMote-CC2538/source/pka.c ****     // verify that the operation is complete.
 380:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 381:bsp/boards/OpenMote-CC2538/source/pka.c ****     if((HWREG(PKA_FUNCTION) & PKA_FUNCTION_RUN) != 0)
 401              		.loc 1 381 0
 402 01da 44F21C03 		movw	r3, #16412
 403 01de C4F20043 		movt	r3, 17408
 404 01e2 1B68     		ldr	r3, [r3, #0]
 405 01e4 03F40043 		and	r3, r3, #32768
 406 01e8 002B     		cmp	r3, #0
 407 01ea 02D0     		beq	.L17
 382:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
 383:bsp/boards/OpenMote-CC2538/source/pka.c ****         return (PKA_STATUS_OPERATION_INPRG);
 408              		.loc 1 383 0
 409 01ec 4FF00703 		mov	r3, #7
 410 01f0 3FE0     		b	.L18
 411              	.L17:
 384:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
 385:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 386:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 387:bsp/boards/OpenMote-CC2538/source/pka.c ****     //  Get the MSW register value.
 388:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 389:bsp/boards/OpenMote-CC2538/source/pka.c ****     regMSWVal = HWREG(PKA_DIVMSW);
 412              		.loc 1 389 0
 413 01f2 44F22803 		movw	r3, #16424
 414 01f6 C4F20043 		movt	r3, 17408
 415 01fa 1B68     		ldr	r3, [r3, #0]
 416 01fc BB61     		str	r3, [r7, #24]
 390:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 391:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 392:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Check to make sure that the result vector is not all zeroes.
 393:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 394:bsp/boards/OpenMote-CC2538/source/pka.c ****     if(regMSWVal & PKA_DIVMSW_RESULT_IS_ZERO)
 417              		.loc 1 394 0
 418 01fe BB69     		ldr	r3, [r7, #24]
 419 0200 03F40043 		and	r3, r3, #32768
 420 0204 002B     		cmp	r3, #0
 421 0206 02D0     		beq	.L19
 395:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
 396:bsp/boards/OpenMote-CC2538/source/pka.c ****         return (PKA_STATUS_RESULT_0);
 422              		.loc 1 396 0
 423 0208 4FF00403 		mov	r3, #4
 424 020c 31E0     		b	.L18
 425              	.L19:
 397:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
 398:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 399:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 400:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Get the length of the result.
 401:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 402:bsp/boards/OpenMote-CC2538/source/pka.c ****     len = ((regMSWVal & PKA_DIVMSW_MSW_ADDRESS_M) + 1) -
 426              		.loc 1 402 0
 427 020e BB69     		ldr	r3, [r7, #24]
 428 0210 4FEA4353 		lsl	r3, r3, #21
 429 0214 4FEA5353 		lsr	r3, r3, #21
 403:bsp/boards/OpenMote-CC2538/source/pka.c ****           ((ui32ResVectorLoc - PKA_RAM_BASE) >> 2);
 430              		.loc 1 403 0
 431 0218 7A68     		ldr	r2, [r7, #4]
 432 021a 02F13C42 		add	r2, r2, #-1140850688
 433 021e A2F5C042 		sub	r2, r2, #24576
 434 0222 4FEA9202 		lsr	r2, r2, #2
 402:bsp/boards/OpenMote-CC2538/source/pka.c ****     len = ((regMSWVal & PKA_DIVMSW_MSW_ADDRESS_M) + 1) -
 435              		.loc 1 402 0
 436 0226 9B1A     		subs	r3, r3, r2
 437 0228 03F10103 		add	r3, r3, #1
 438 022c 7B61     		str	r3, [r7, #20]
 404:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 405:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 406:bsp/boards/OpenMote-CC2538/source/pka.c ****     // If the size of the buffer provided is less than the result length than
 407:bsp/boards/OpenMote-CC2538/source/pka.c ****     // return error.
 408:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 409:bsp/boards/OpenMote-CC2538/source/pka.c ****     if(ui8Size < len)
 439              		.loc 1 409 0
 440 022e FA7A     		ldrb	r2, [r7, #11]	@ zero_extendqisi2
 441 0230 7B69     		ldr	r3, [r7, #20]
 442 0232 9A42     		cmp	r2, r3
 443 0234 02D2     		bcs	.L20
 410:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
 411:bsp/boards/OpenMote-CC2538/source/pka.c ****         return (PKA_STATUS_BUF_UNDERFLOW);
 444              		.loc 1 411 0
 445 0236 4FF00303 		mov	r3, #3
 446 023a 1AE0     		b	.L18
 447              	.L20:
 412:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
 413:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 414:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 415:bsp/boards/OpenMote-CC2538/source/pka.c ****     // copy the result from vector C into the pResult.
 416:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 417:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < len; i++)
 448              		.loc 1 417 0
 449 023c 4FF00003 		mov	r3, #0
 450 0240 FB61     		str	r3, [r7, #28]
 451 0242 10E0     		b	.L21
 452              	.L22:
 418:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
 419:bsp/boards/OpenMote-CC2538/source/pka.c ****         pui32ResultBuf[i]= HWREG( (ui32ResVectorLoc + 4*i) );
 453              		.loc 1 419 0 discriminator 2
 454 0244 FB69     		ldr	r3, [r7, #28]
 455 0246 4FEA8303 		lsl	r3, r3, #2
 456 024a FA68     		ldr	r2, [r7, #12]
 457 024c D318     		adds	r3, r2, r3
 458 024e FA69     		ldr	r2, [r7, #28]
 459 0250 4FEA8202 		lsl	r2, r2, #2
 460 0254 1146     		mov	r1, r2
 461 0256 7A68     		ldr	r2, [r7, #4]
 462 0258 8A18     		adds	r2, r1, r2
 463 025a 1268     		ldr	r2, [r2, #0]
 464 025c 1A60     		str	r2, [r3, #0]
 417:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < len; i++)
 465              		.loc 1 417 0 discriminator 2
 466 025e FB69     		ldr	r3, [r7, #28]
 467 0260 03F10103 		add	r3, r3, #1
 468 0264 FB61     		str	r3, [r7, #28]
 469              	.L21:
 417:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < len; i++)
 470              		.loc 1 417 0 is_stmt 0 discriminator 1
 471 0266 FA69     		ldr	r2, [r7, #28]
 472 0268 7B69     		ldr	r3, [r7, #20]
 473 026a 9A42     		cmp	r2, r3
 474 026c EAD3     		bcc	.L22
 420:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
 421:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 422:bsp/boards/OpenMote-CC2538/source/pka.c ****     return (PKA_STATUS_SUCCESS);
 475              		.loc 1 422 0 is_stmt 1
 476 026e 4FF00003 		mov	r3, #0
 477              	.L18:
 423:bsp/boards/OpenMote-CC2538/source/pka.c **** } // PKABigNumModGetResult()
 478              		.loc 1 423 0
 479 0272 1846     		mov	r0, r3
 480 0274 07F12407 		add	r7, r7, #36
 481 0278 BD46     		mov	sp, r7
 482 027a 80BC     		pop	{r7}
 483 027c 7047     		bx	lr
 484              		.cfi_endproc
 485              	.LFE7:
 487 027e 00BF     		.align	2
 488              		.global	PKABigNumCmpStart
 489              		.thumb
 490              		.thumb_func
 492              	PKABigNumCmpStart:
 493              	.LFB8:
 424:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 425:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
 426:bsp/boards/OpenMote-CC2538/source/pka.c **** //
 427:bsp/boards/OpenMote-CC2538/source/pka.c **** //! Starts the comparison of two big numbers.
 428:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 429:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param pui32BNum1 is the pointer to the first big number.
 430:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param pui32BNum2 is the pointer to the second big number.
 431:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param ui8Size is the size of the big number in 32 bit size word.
 432:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 433:bsp/boards/OpenMote-CC2538/source/pka.c **** //! This function starts the comparison of two big numbers pointed by
 434:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \e pui32BNum1 and \e pui32BNum2.
 435:bsp/boards/OpenMote-CC2538/source/pka.c **** //! Note this function expects the size of the two big numbers equal.
 436:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 437:bsp/boards/OpenMote-CC2538/source/pka.c **** //!\return Returns: 
 438:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_SUCCESS if successful in starting the operation.  
 439:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_OPERATION_INPRG, if the PKA hw module is busy doing
 440:bsp/boards/OpenMote-CC2538/source/pka.c **** //! some other operation.
 441:bsp/boards/OpenMote-CC2538/source/pka.c **** //
 442:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
 443:bsp/boards/OpenMote-CC2538/source/pka.c **** tPKAStatus
 444:bsp/boards/OpenMote-CC2538/source/pka.c **** PKABigNumCmpStart(uint32_t* pui32BNum1, uint32_t* pui32BNum2, uint8_t ui8Size)
 445:bsp/boards/OpenMote-CC2538/source/pka.c **** {
 494              		.loc 1 445 0
 495              		.cfi_startproc
 496              		@ args = 0, pretend = 0, frame = 24
 497              		@ frame_needed = 1, uses_anonymous_args = 0
 498              		@ link register save eliminated.
 499 0280 80B4     		push	{r7}
 500              	.LCFI19:
 501              		.cfi_def_cfa_offset 4
 502              		.cfi_offset 7, -4
 503 0282 87B0     		sub	sp, sp, #28
 504              	.LCFI20:
 505              		.cfi_def_cfa_offset 32
 506 0284 00AF     		add	r7, sp, #0
 507              	.LCFI21:
 508              		.cfi_def_cfa_register 7
 509 0286 F860     		str	r0, [r7, #12]
 510 0288 B960     		str	r1, [r7, #8]
 511 028a 1346     		mov	r3, r2
 512 028c FB71     		strb	r3, [r7, #7]
 446:bsp/boards/OpenMote-CC2538/source/pka.c ****     uint32_t offset;
 447:bsp/boards/OpenMote-CC2538/source/pka.c ****     int i;
 448:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 449:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 450:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Check the arguments.
 451:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 452:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != pui32BNum1);
 453:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != pui32BNum2);
 454:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 455:bsp/boards/OpenMote-CC2538/source/pka.c ****     offset = 0;
 513              		.loc 1 455 0
 514 028e 4FF00003 		mov	r3, #0
 515 0292 3B61     		str	r3, [r7, #16]
 456:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 457:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 458:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Make sure no operation is in progress.
 459:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 460:bsp/boards/OpenMote-CC2538/source/pka.c ****     if((HWREG(PKA_FUNCTION) & PKA_FUNCTION_RUN) != 0)
 516              		.loc 1 460 0
 517 0294 44F21C03 		movw	r3, #16412
 518 0298 C4F20043 		movt	r3, 17408
 519 029c 1B68     		ldr	r3, [r3, #0]
 520 029e 03F40043 		and	r3, r3, #32768
 521 02a2 002B     		cmp	r3, #0
 522 02a4 02D0     		beq	.L24
 461:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
 462:bsp/boards/OpenMote-CC2538/source/pka.c ****         return (PKA_STATUS_OPERATION_INPRG);
 523              		.loc 1 462 0
 524 02a6 4FF00703 		mov	r3, #7
 525 02aa 62E0     		b	.L25
 526              	.L24:
 463:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
 464:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 465:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 466:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Update the A ptr with the offset address of the PKA RAM location
 467:bsp/boards/OpenMote-CC2538/source/pka.c ****     // where the first big number will be stored.
 468:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 469:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG( (PKA_APTR) ) = offset >> 2;
 527              		.loc 1 469 0
 528 02ac 4FF48043 		mov	r3, #16384
 529 02b0 C4F20043 		movt	r3, 17408
 530 02b4 3A69     		ldr	r2, [r7, #16]
 531 02b6 4FEA9202 		lsr	r2, r2, #2
 532 02ba 1A60     		str	r2, [r3, #0]
 470:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 471:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 472:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Load the first big number in PKA RAM.
 473:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 474:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ui8Size; i++)
 533              		.loc 1 474 0
 534 02bc 4FF00003 		mov	r3, #0
 535 02c0 7B61     		str	r3, [r7, #20]
 536 02c2 14E0     		b	.L26
 537              	.L27:
 475:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
 476:bsp/boards/OpenMote-CC2538/source/pka.c ****         HWREG( (PKA_RAM_BASE + offset + 4*i) ) = pui32BNum1[i];
 538              		.loc 1 476 0 discriminator 2
 539 02c4 7B69     		ldr	r3, [r7, #20]
 540 02c6 4FEA8303 		lsl	r3, r3, #2
 541 02ca 1A46     		mov	r2, r3
 542 02cc 3B69     		ldr	r3, [r7, #16]
 543 02ce D318     		adds	r3, r2, r3
 544 02d0 03F18843 		add	r3, r3, #1140850688
 545 02d4 03F5C043 		add	r3, r3, #24576
 546 02d8 7A69     		ldr	r2, [r7, #20]
 547 02da 4FEA8202 		lsl	r2, r2, #2
 548 02de F968     		ldr	r1, [r7, #12]
 549 02e0 8A18     		adds	r2, r1, r2
 550 02e2 1268     		ldr	r2, [r2, #0]
 551 02e4 1A60     		str	r2, [r3, #0]
 474:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ui8Size; i++)
 552              		.loc 1 474 0 discriminator 2
 553 02e6 7B69     		ldr	r3, [r7, #20]
 554 02e8 03F10103 		add	r3, r3, #1
 555 02ec 7B61     		str	r3, [r7, #20]
 556              	.L26:
 474:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ui8Size; i++)
 557              		.loc 1 474 0 is_stmt 0 discriminator 1
 558 02ee FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 559 02f0 7B69     		ldr	r3, [r7, #20]
 560 02f2 9A42     		cmp	r2, r3
 561 02f4 E6DC     		bgt	.L27
 477:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
 478:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 479:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 480:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Determine the offset in PKA RAM for the next pointer.
 481:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 482:bsp/boards/OpenMote-CC2538/source/pka.c ****     offset += 4 * (i + ui8Size % 2);
 562              		.loc 1 482 0 is_stmt 1
 563 02f6 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 564 02f8 03F00102 		and	r2, r3, #1
 565 02fc 7B69     		ldr	r3, [r7, #20]
 566 02fe D318     		adds	r3, r2, r3
 567 0300 4FEA8303 		lsl	r3, r3, #2
 568 0304 3A69     		ldr	r2, [r7, #16]
 569 0306 D318     		adds	r3, r2, r3
 570 0308 3B61     		str	r3, [r7, #16]
 483:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 484:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 485:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Update the B ptr with the offset address of the PKA RAM location
 486:bsp/boards/OpenMote-CC2538/source/pka.c ****     // where the second big number will be stored.
 487:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 488:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG( (PKA_BPTR) ) = offset >> 2;
 571              		.loc 1 488 0
 572 030a 44F20403 		movw	r3, #16388
 573 030e C4F20043 		movt	r3, 17408
 574 0312 3A69     		ldr	r2, [r7, #16]
 575 0314 4FEA9202 		lsr	r2, r2, #2
 576 0318 1A60     		str	r2, [r3, #0]
 489:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 490:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 491:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Load the second big number in PKA RAM.
 492:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 493:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ui8Size;  i++)
 577              		.loc 1 493 0
 578 031a 4FF00003 		mov	r3, #0
 579 031e 7B61     		str	r3, [r7, #20]
 580 0320 14E0     		b	.L28
 581              	.L29:
 494:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
 495:bsp/boards/OpenMote-CC2538/source/pka.c ****         HWREG( (PKA_RAM_BASE + offset + 4*i) ) = pui32BNum2[i];
 582              		.loc 1 495 0 discriminator 2
 583 0322 7B69     		ldr	r3, [r7, #20]
 584 0324 4FEA8303 		lsl	r3, r3, #2
 585 0328 1A46     		mov	r2, r3
 586 032a 3B69     		ldr	r3, [r7, #16]
 587 032c D318     		adds	r3, r2, r3
 588 032e 03F18843 		add	r3, r3, #1140850688
 589 0332 03F5C043 		add	r3, r3, #24576
 590 0336 7A69     		ldr	r2, [r7, #20]
 591 0338 4FEA8202 		lsl	r2, r2, #2
 592 033c B968     		ldr	r1, [r7, #8]
 593 033e 8A18     		adds	r2, r1, r2
 594 0340 1268     		ldr	r2, [r2, #0]
 595 0342 1A60     		str	r2, [r3, #0]
 493:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ui8Size;  i++)
 596              		.loc 1 493 0 discriminator 2
 597 0344 7B69     		ldr	r3, [r7, #20]
 598 0346 03F10103 		add	r3, r3, #1
 599 034a 7B61     		str	r3, [r7, #20]
 600              	.L28:
 493:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ui8Size;  i++)
 601              		.loc 1 493 0 is_stmt 0 discriminator 1
 602 034c FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 603 034e 7B69     		ldr	r3, [r7, #20]
 604 0350 9A42     		cmp	r2, r3
 605 0352 E6DC     		bgt	.L29
 496:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
 497:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 498:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 499:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Load length registers in 32 bit word size.
 500:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 501:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG( (PKA_ALENGTH) ) = ui8Size;
 606              		.loc 1 501 0 is_stmt 1
 607 0354 44F21003 		movw	r3, #16400
 608 0358 C4F20043 		movt	r3, 17408
 609 035c FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 610 035e 1A60     		str	r2, [r3, #0]
 502:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 503:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 504:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Set the PKA Function register for the Compare operation
 505:bsp/boards/OpenMote-CC2538/source/pka.c ****     // and start the operation.
 506:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 507:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG( (PKA_FUNCTION) ) = (PKA_FUNCTION_RUN | PKA_FUNCTION_COMPARE);
 611              		.loc 1 507 0
 612 0360 44F21C03 		movw	r3, #16412
 613 0364 C4F20043 		movt	r3, 17408
 614 0368 4FF40442 		mov	r2, #33792
 615 036c 1A60     		str	r2, [r3, #0]
 508:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 509:bsp/boards/OpenMote-CC2538/source/pka.c ****     return (PKA_STATUS_SUCCESS);
 616              		.loc 1 509 0
 617 036e 4FF00003 		mov	r3, #0
 618              	.L25:
 510:bsp/boards/OpenMote-CC2538/source/pka.c **** }
 619              		.loc 1 510 0
 620 0372 1846     		mov	r0, r3
 621 0374 07F11C07 		add	r7, r7, #28
 622 0378 BD46     		mov	sp, r7
 623 037a 80BC     		pop	{r7}
 624 037c 7047     		bx	lr
 625              		.cfi_endproc
 626              	.LFE8:
 628 037e 00BF     		.align	2
 629              		.global	PKABigNumCmpGetResult
 630              		.thumb
 631              		.thumb_func
 633              	PKABigNumCmpGetResult:
 634              	.LFB9:
 511:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 512:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
 513:bsp/boards/OpenMote-CC2538/source/pka.c **** //
 514:bsp/boards/OpenMote-CC2538/source/pka.c **** //! Gets the result of the comparison operation of two big numbers.
 515:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 516:bsp/boards/OpenMote-CC2538/source/pka.c **** //! This function provides the results of the comparison of two big numbers
 517:bsp/boards/OpenMote-CC2538/source/pka.c **** //! which was started using the \sa PKABigNumCmpStart().
 518:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 519:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \return Returns:
 520:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_OPERATION_INPRG if the operation is in progress.
 521:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_SUCCESS if the two big numbers are equal.
 522:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_A_GR_B  if the first number is greater than the second.
 523:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_A_LT_B if the first number is less than the second.
 524:bsp/boards/OpenMote-CC2538/source/pka.c **** //
 525:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
 526:bsp/boards/OpenMote-CC2538/source/pka.c **** tPKAStatus
 527:bsp/boards/OpenMote-CC2538/source/pka.c **** PKABigNumCmpGetResult(void)
 528:bsp/boards/OpenMote-CC2538/source/pka.c **** {
 635              		.loc 1 528 0
 636              		.cfi_startproc
 637              		@ args = 0, pretend = 0, frame = 8
 638              		@ frame_needed = 1, uses_anonymous_args = 0
 639              		@ link register save eliminated.
 640 0380 80B4     		push	{r7}
 641              	.LCFI22:
 642              		.cfi_def_cfa_offset 4
 643              		.cfi_offset 7, -4
 644 0382 83B0     		sub	sp, sp, #12
 645              	.LCFI23:
 646              		.cfi_def_cfa_offset 16
 647 0384 00AF     		add	r7, sp, #0
 648              	.LCFI24:
 649              		.cfi_def_cfa_register 7
 529:bsp/boards/OpenMote-CC2538/source/pka.c ****     tPKAStatus status;
 530:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 531:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 532:bsp/boards/OpenMote-CC2538/source/pka.c ****     // verify that the operation is complete.
 533:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 534:bsp/boards/OpenMote-CC2538/source/pka.c ****     if((HWREG(PKA_FUNCTION) & PKA_FUNCTION_RUN) != 0)
 650              		.loc 1 534 0
 651 0386 44F21C03 		movw	r3, #16412
 652 038a C4F20043 		movt	r3, 17408
 653 038e 1B68     		ldr	r3, [r3, #0]
 654 0390 03F40043 		and	r3, r3, #32768
 655 0394 002B     		cmp	r3, #0
 656 0396 04D0     		beq	.L31
 535:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
 536:bsp/boards/OpenMote-CC2538/source/pka.c ****         status = PKA_STATUS_OPERATION_INPRG;
 657              		.loc 1 536 0
 658 0398 4FF00703 		mov	r3, #7
 659 039c FB71     		strb	r3, [r7, #7]
 537:bsp/boards/OpenMote-CC2538/source/pka.c ****         return (status);
 660              		.loc 1 537 0
 661 039e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 662 03a0 1BE0     		b	.L32
 663              	.L31:
 538:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
 539:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 540:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 541:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Check the COMPARE register.
 542:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 543:bsp/boards/OpenMote-CC2538/source/pka.c ****     switch(HWREG(PKA_COMPARE))
 664              		.loc 1 543 0
 665 03a2 44F22003 		movw	r3, #16416
 666 03a6 C4F20043 		movt	r3, 17408
 667 03aa 1B68     		ldr	r3, [r3, #0]
 668 03ac 022B     		cmp	r3, #2
 669 03ae 0BD0     		beq	.L35
 670 03b0 042B     		cmp	r3, #4
 671 03b2 05D0     		beq	.L36
 672 03b4 012B     		cmp	r3, #1
 673 03b6 0BD1     		bne	.L38
 674              	.L34:
 544:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
 545:bsp/boards/OpenMote-CC2538/source/pka.c ****         case PKA_COMPARE_A_EQUALS_B:
 546:bsp/boards/OpenMote-CC2538/source/pka.c ****             status = PKA_STATUS_SUCCESS;
 675              		.loc 1 546 0
 676 03b8 4FF00003 		mov	r3, #0
 677 03bc FB71     		strb	r3, [r7, #7]
 547:bsp/boards/OpenMote-CC2538/source/pka.c ****             break;
 678              		.loc 1 547 0
 679 03be 0BE0     		b	.L37
 680              	.L36:
 548:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 549:bsp/boards/OpenMote-CC2538/source/pka.c ****         case PKA_COMPARE_A_GREATER_THAN_B:
 550:bsp/boards/OpenMote-CC2538/source/pka.c ****             status = PKA_STATUS_A_GR_B;
 681              		.loc 1 550 0
 682 03c0 4FF00503 		mov	r3, #5
 683 03c4 FB71     		strb	r3, [r7, #7]
 551:bsp/boards/OpenMote-CC2538/source/pka.c ****             break;
 684              		.loc 1 551 0
 685 03c6 07E0     		b	.L37
 686              	.L35:
 552:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 553:bsp/boards/OpenMote-CC2538/source/pka.c ****         case PKA_COMPARE_A_LESS_THAN_B:
 554:bsp/boards/OpenMote-CC2538/source/pka.c ****             status = PKA_STATUS_A_LT_B;
 687              		.loc 1 554 0
 688 03c8 4FF00603 		mov	r3, #6
 689 03cc FB71     		strb	r3, [r7, #7]
 555:bsp/boards/OpenMote-CC2538/source/pka.c ****             break;
 690              		.loc 1 555 0
 691 03ce 03E0     		b	.L37
 692              	.L38:
 556:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 557:bsp/boards/OpenMote-CC2538/source/pka.c ****         default:
 558:bsp/boards/OpenMote-CC2538/source/pka.c ****             status = PKA_STATUS_FAILURE;
 693              		.loc 1 558 0
 694 03d0 4FF00103 		mov	r3, #1
 695 03d4 FB71     		strb	r3, [r7, #7]
 559:bsp/boards/OpenMote-CC2538/source/pka.c ****             break;
 696              		.loc 1 559 0
 697 03d6 00BF     		nop
 698              	.L37:
 560:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
 561:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 562:bsp/boards/OpenMote-CC2538/source/pka.c ****     return (status);
 699              		.loc 1 562 0
 700 03d8 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 701              	.L32:
 563:bsp/boards/OpenMote-CC2538/source/pka.c **** }
 702              		.loc 1 563 0
 703 03da 1846     		mov	r0, r3
 704 03dc 07F10C07 		add	r7, r7, #12
 705 03e0 BD46     		mov	sp, r7
 706 03e2 80BC     		pop	{r7}
 707 03e4 7047     		bx	lr
 708              		.cfi_endproc
 709              	.LFE9:
 711 03e6 00BF     		.align	2
 712              		.global	PKABigNumInvModStart
 713              		.thumb
 714              		.thumb_func
 716              	PKABigNumInvModStart:
 717              	.LFB10:
 564:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 565:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
 566:bsp/boards/OpenMote-CC2538/source/pka.c **** //
 567:bsp/boards/OpenMote-CC2538/source/pka.c **** //! Starts the big number inverse modulo operation.
 568:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 569:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param pui32BNum is the pointer to the buffer containing the big number
 570:bsp/boards/OpenMote-CC2538/source/pka.c **** //! (dividend).
 571:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param ui8BNSize is the size of the \e pui32BNum in 32 bit word.
 572:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param pui32Modulus is the pointer to the buffer containing the divisor.
 573:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param ui8Size is the size of the divisor in 32 bit word.
 574:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param pui32ResultVector is the pointer to the result vector location
 575:bsp/boards/OpenMote-CC2538/source/pka.c **** //! which will be set by this function.
 576:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 577:bsp/boards/OpenMote-CC2538/source/pka.c **** //! This function starts the the inverse modulo operation on \e pui32BNum
 578:bsp/boards/OpenMote-CC2538/source/pka.c **** //! using the divisor \e pui32Modulus.
 579:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 580:bsp/boards/OpenMote-CC2538/source/pka.c **** //!\return Returns: 
 581:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_SUCCESS if successful in starting the operation.  
 582:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_OPERATION_INPRG, if the PKA hw module is busy doing
 583:bsp/boards/OpenMote-CC2538/source/pka.c **** //! some other operation.
 584:bsp/boards/OpenMote-CC2538/source/pka.c **** //
 585:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
 586:bsp/boards/OpenMote-CC2538/source/pka.c **** tPKAStatus
 587:bsp/boards/OpenMote-CC2538/source/pka.c **** PKABigNumInvModStart(uint32_t* pui32BNum, uint8_t ui8BNSize,
 588:bsp/boards/OpenMote-CC2538/source/pka.c ****                      uint32_t* pui32Modulus, uint8_t ui8Size,
 589:bsp/boards/OpenMote-CC2538/source/pka.c ****                      uint32_t* pui32ResultVector)
 590:bsp/boards/OpenMote-CC2538/source/pka.c **** {
 718              		.loc 1 590 0
 719              		.cfi_startproc
 720              		@ args = 4, pretend = 0, frame = 24
 721              		@ frame_needed = 1, uses_anonymous_args = 0
 722              		@ link register save eliminated.
 723 03e8 80B4     		push	{r7}
 724              	.LCFI25:
 725              		.cfi_def_cfa_offset 4
 726              		.cfi_offset 7, -4
 727 03ea 87B0     		sub	sp, sp, #28
 728              	.LCFI26:
 729              		.cfi_def_cfa_offset 32
 730 03ec 00AF     		add	r7, sp, #0
 731              	.LCFI27:
 732              		.cfi_def_cfa_register 7
 733 03ee F860     		str	r0, [r7, #12]
 734 03f0 7A60     		str	r2, [r7, #4]
 735 03f2 0A46     		mov	r2, r1
 736 03f4 FA72     		strb	r2, [r7, #11]
 737 03f6 BB72     		strb	r3, [r7, #10]
 591:bsp/boards/OpenMote-CC2538/source/pka.c ****     uint32_t offset;
 592:bsp/boards/OpenMote-CC2538/source/pka.c ****     int i;
 593:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 594:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 595:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Check the arguments.
 596:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 597:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != pui32BNum);
 598:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != pui32Modulus);
 599:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != pui32ResultVector);
 600:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 601:bsp/boards/OpenMote-CC2538/source/pka.c ****     offset = 0;
 738              		.loc 1 601 0
 739 03f8 4FF00003 		mov	r3, #0
 740 03fc 3B61     		str	r3, [r7, #16]
 602:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 603:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 604:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Make sure no operation is in progress.
 605:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 606:bsp/boards/OpenMote-CC2538/source/pka.c ****     if((HWREG(PKA_FUNCTION) & PKA_FUNCTION_RUN) != 0)
 741              		.loc 1 606 0
 742 03fe 44F21C03 		movw	r3, #16412
 743 0402 C4F20043 		movt	r3, 17408
 744 0406 1B68     		ldr	r3, [r3, #0]
 745 0408 03F40043 		and	r3, r3, #32768
 746 040c 002B     		cmp	r3, #0
 747 040e 02D0     		beq	.L40
 607:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
 608:bsp/boards/OpenMote-CC2538/source/pka.c ****         return (PKA_STATUS_OPERATION_INPRG);
 748              		.loc 1 608 0
 749 0410 4FF00703 		mov	r3, #7
 750 0414 81E0     		b	.L41
 751              	.L40:
 609:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
 610:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 611:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 612:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Update the A ptr with the offset address of the PKA RAM location
 613:bsp/boards/OpenMote-CC2538/source/pka.c ****     // where the number will be stored.
 614:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 615:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG( (PKA_APTR) ) = offset >>2;
 752              		.loc 1 615 0
 753 0416 4FF48043 		mov	r3, #16384
 754 041a C4F20043 		movt	r3, 17408
 755 041e 3A69     		ldr	r2, [r7, #16]
 756 0420 4FEA9202 		lsr	r2, r2, #2
 757 0424 1A60     		str	r2, [r3, #0]
 616:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 617:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 618:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Load the \e pui32BNum number in PKA RAM.
 619:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 620:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ui8BNSize; i++)
 758              		.loc 1 620 0
 759 0426 4FF00003 		mov	r3, #0
 760 042a 7B61     		str	r3, [r7, #20]
 761 042c 14E0     		b	.L42
 762              	.L43:
 621:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
 622:bsp/boards/OpenMote-CC2538/source/pka.c ****         HWREG( (PKA_RAM_BASE + offset + 4*i) ) = pui32BNum[i];
 763              		.loc 1 622 0 discriminator 2
 764 042e 7B69     		ldr	r3, [r7, #20]
 765 0430 4FEA8303 		lsl	r3, r3, #2
 766 0434 1A46     		mov	r2, r3
 767 0436 3B69     		ldr	r3, [r7, #16]
 768 0438 D318     		adds	r3, r2, r3
 769 043a 03F18843 		add	r3, r3, #1140850688
 770 043e 03F5C043 		add	r3, r3, #24576
 771 0442 7A69     		ldr	r2, [r7, #20]
 772 0444 4FEA8202 		lsl	r2, r2, #2
 773 0448 F968     		ldr	r1, [r7, #12]
 774 044a 8A18     		adds	r2, r1, r2
 775 044c 1268     		ldr	r2, [r2, #0]
 776 044e 1A60     		str	r2, [r3, #0]
 620:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ui8BNSize; i++)
 777              		.loc 1 620 0 discriminator 2
 778 0450 7B69     		ldr	r3, [r7, #20]
 779 0452 03F10103 		add	r3, r3, #1
 780 0456 7B61     		str	r3, [r7, #20]
 781              	.L42:
 620:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ui8BNSize; i++)
 782              		.loc 1 620 0 is_stmt 0 discriminator 1
 783 0458 FA7A     		ldrb	r2, [r7, #11]	@ zero_extendqisi2
 784 045a 7B69     		ldr	r3, [r7, #20]
 785 045c 9A42     		cmp	r2, r3
 786 045e E6DC     		bgt	.L43
 623:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
 624:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 625:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 626:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Determine the offset for next data.
 627:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 628:bsp/boards/OpenMote-CC2538/source/pka.c ****     offset += 4 * (i + ui8BNSize % 2);
 787              		.loc 1 628 0 is_stmt 1
 788 0460 FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 789 0462 03F00102 		and	r2, r3, #1
 790 0466 7B69     		ldr	r3, [r7, #20]
 791 0468 D318     		adds	r3, r2, r3
 792 046a 4FEA8303 		lsl	r3, r3, #2
 793 046e 3A69     		ldr	r2, [r7, #16]
 794 0470 D318     		adds	r3, r2, r3
 795 0472 3B61     		str	r3, [r7, #16]
 629:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 630:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 631:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Update the B ptr with the offset address of the PKA RAM location
 632:bsp/boards/OpenMote-CC2538/source/pka.c ****     // where the modulus will be stored.
 633:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 634:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG( (PKA_BPTR) ) = offset >> 2;
 796              		.loc 1 634 0
 797 0474 44F20403 		movw	r3, #16388
 798 0478 C4F20043 		movt	r3, 17408
 799 047c 3A69     		ldr	r2, [r7, #16]
 800 047e 4FEA9202 		lsr	r2, r2, #2
 801 0482 1A60     		str	r2, [r3, #0]
 635:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 636:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 637:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Load the \e pui32Modulus divisor in PKA RAM.
 638:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 639:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ui8Size;  i++)
 802              		.loc 1 639 0
 803 0484 4FF00003 		mov	r3, #0
 804 0488 7B61     		str	r3, [r7, #20]
 805 048a 14E0     		b	.L44
 806              	.L45:
 640:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
 641:bsp/boards/OpenMote-CC2538/source/pka.c ****         HWREG( (PKA_RAM_BASE + offset + 4*i) ) = pui32Modulus[i];
 807              		.loc 1 641 0 discriminator 2
 808 048c 7B69     		ldr	r3, [r7, #20]
 809 048e 4FEA8303 		lsl	r3, r3, #2
 810 0492 1A46     		mov	r2, r3
 811 0494 3B69     		ldr	r3, [r7, #16]
 812 0496 D318     		adds	r3, r2, r3
 813 0498 03F18843 		add	r3, r3, #1140850688
 814 049c 03F5C043 		add	r3, r3, #24576
 815 04a0 7A69     		ldr	r2, [r7, #20]
 816 04a2 4FEA8202 		lsl	r2, r2, #2
 817 04a6 7968     		ldr	r1, [r7, #4]
 818 04a8 8A18     		adds	r2, r1, r2
 819 04aa 1268     		ldr	r2, [r2, #0]
 820 04ac 1A60     		str	r2, [r3, #0]
 639:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ui8Size;  i++)
 821              		.loc 1 639 0 discriminator 2
 822 04ae 7B69     		ldr	r3, [r7, #20]
 823 04b0 03F10103 		add	r3, r3, #1
 824 04b4 7B61     		str	r3, [r7, #20]
 825              	.L44:
 639:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ui8Size;  i++)
 826              		.loc 1 639 0 is_stmt 0 discriminator 1
 827 04b6 BA7A     		ldrb	r2, [r7, #10]	@ zero_extendqisi2
 828 04b8 7B69     		ldr	r3, [r7, #20]
 829 04ba 9A42     		cmp	r2, r3
 830 04bc E6DC     		bgt	.L45
 642:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
 643:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 644:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 645:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Determine the offset for result data.
 646:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 647:bsp/boards/OpenMote-CC2538/source/pka.c ****     offset += 4 * (i + ui8Size % 2);
 831              		.loc 1 647 0 is_stmt 1
 832 04be BB7A     		ldrb	r3, [r7, #10]	@ zero_extendqisi2
 833 04c0 03F00102 		and	r2, r3, #1
 834 04c4 7B69     		ldr	r3, [r7, #20]
 835 04c6 D318     		adds	r3, r2, r3
 836 04c8 4FEA8303 		lsl	r3, r3, #2
 837 04cc 3A69     		ldr	r2, [r7, #16]
 838 04ce D318     		adds	r3, r2, r3
 839 04d0 3B61     		str	r3, [r7, #16]
 648:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 649:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 650:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Copy the result vector address location.
 651:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 652:bsp/boards/OpenMote-CC2538/source/pka.c ****     *pui32ResultVector = PKA_RAM_BASE + offset;
 840              		.loc 1 652 0
 841 04d2 3B69     		ldr	r3, [r7, #16]
 842 04d4 03F18843 		add	r3, r3, #1140850688
 843 04d8 03F5C043 		add	r3, r3, #24576
 844 04dc 3A6A     		ldr	r2, [r7, #32]
 845 04de 1360     		str	r3, [r2, #0]
 653:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 654:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 655:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Load D ptr with the result location in PKA RAM.
 656:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 657:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG( (PKA_DPTR) ) = offset >> 2;
 846              		.loc 1 657 0
 847 04e0 44F20C03 		movw	r3, #16396
 848 04e4 C4F20043 		movt	r3, 17408
 849 04e8 3A69     		ldr	r2, [r7, #16]
 850 04ea 4FEA9202 		lsr	r2, r2, #2
 851 04ee 1A60     		str	r2, [r3, #0]
 658:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 659:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 660:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Load the respective length registers.
 661:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 662:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG( (PKA_ALENGTH) ) = ui8BNSize;
 852              		.loc 1 662 0
 853 04f0 44F21003 		movw	r3, #16400
 854 04f4 C4F20043 		movt	r3, 17408
 855 04f8 FA7A     		ldrb	r2, [r7, #11]	@ zero_extendqisi2
 856 04fa 1A60     		str	r2, [r3, #0]
 663:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG( (PKA_BLENGTH) ) = ui8Size;
 857              		.loc 1 663 0
 858 04fc 44F21403 		movw	r3, #16404
 859 0500 C4F20043 		movt	r3, 17408
 860 0504 BA7A     		ldrb	r2, [r7, #10]	@ zero_extendqisi2
 861 0506 1A60     		str	r2, [r3, #0]
 664:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 665:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 666:bsp/boards/OpenMote-CC2538/source/pka.c ****     // set the PKA function to InvMod operation and the start the operation.
 667:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 668:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG( (PKA_FUNCTION) ) = 0x0000F000;
 862              		.loc 1 668 0
 863 0508 44F21C03 		movw	r3, #16412
 864 050c C4F20043 		movt	r3, 17408
 865 0510 4FF47042 		mov	r2, #61440
 866 0514 1A60     		str	r2, [r3, #0]
 669:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 670:bsp/boards/OpenMote-CC2538/source/pka.c ****     return (PKA_STATUS_SUCCESS);
 867              		.loc 1 670 0
 868 0516 4FF00003 		mov	r3, #0
 869              	.L41:
 671:bsp/boards/OpenMote-CC2538/source/pka.c **** }
 870              		.loc 1 671 0
 871 051a 1846     		mov	r0, r3
 872 051c 07F11C07 		add	r7, r7, #28
 873 0520 BD46     		mov	sp, r7
 874 0522 80BC     		pop	{r7}
 875 0524 7047     		bx	lr
 876              		.cfi_endproc
 877              	.LFE10:
 879 0526 00BF     		.align	2
 880              		.global	PKABigNumInvModGetResult
 881              		.thumb
 882              		.thumb_func
 884              	PKABigNumInvModGetResult:
 885              	.LFB11:
 672:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 673:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
 674:bsp/boards/OpenMote-CC2538/source/pka.c **** //
 675:bsp/boards/OpenMote-CC2538/source/pka.c **** //! Gets the result of the big number inverse modulo operation.
 676:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 677:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param pui32ResultBuf is the pointer to buffer where the result needs to be
 678:bsp/boards/OpenMote-CC2538/source/pka.c **** //! stored.
 679:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param ui8Size is the size of the provided buffer in 32 bit ui8Size
 680:bsp/boards/OpenMote-CC2538/source/pka.c **** //! word.
 681:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param ui32ResVectorLoc is the address of the result location which
 682:bsp/boards/OpenMote-CC2538/source/pka.c **** //! was provided by the start function \sa PKABigNumInvModStart().
 683:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 684:bsp/boards/OpenMote-CC2538/source/pka.c **** //! This function gets the result of the big number inverse modulo operation
 685:bsp/boards/OpenMote-CC2538/source/pka.c **** //! previously started using the function \sa PKABigNumInvModStart().
 686:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 687:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \return Returns:
 688:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_SUCCESS if the operation is successful. 
 689:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_OPERATION_INPRG, if the PKA hw module is busy performing 
 690:bsp/boards/OpenMote-CC2538/source/pka.c **** //! the operation.
 691:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_RESULT_0 if the result is all zeroes.
 692:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_BUF_UNDERFLOW if the length of the provided buffer is less
 693:bsp/boards/OpenMote-CC2538/source/pka.c **** //! then the result. 
 694:bsp/boards/OpenMote-CC2538/source/pka.c **** //
 695:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
 696:bsp/boards/OpenMote-CC2538/source/pka.c **** tPKAStatus
 697:bsp/boards/OpenMote-CC2538/source/pka.c **** PKABigNumInvModGetResult(uint32_t* pui32ResultBuf, uint8_t ui8Size,
 698:bsp/boards/OpenMote-CC2538/source/pka.c ****                          uint32_t ui32ResVectorLoc)
 699:bsp/boards/OpenMote-CC2538/source/pka.c **** {
 886              		.loc 1 699 0
 887              		.cfi_startproc
 888              		@ args = 0, pretend = 0, frame = 32
 889              		@ frame_needed = 1, uses_anonymous_args = 0
 890              		@ link register save eliminated.
 891 0528 80B4     		push	{r7}
 892              	.LCFI28:
 893              		.cfi_def_cfa_offset 4
 894              		.cfi_offset 7, -4
 895 052a 89B0     		sub	sp, sp, #36
 896              	.LCFI29:
 897              		.cfi_def_cfa_offset 40
 898 052c 00AF     		add	r7, sp, #0
 899              	.LCFI30:
 900              		.cfi_def_cfa_register 7
 901 052e F860     		str	r0, [r7, #12]
 902 0530 0B46     		mov	r3, r1
 903 0532 7A60     		str	r2, [r7, #4]
 904 0534 FB72     		strb	r3, [r7, #11]
 700:bsp/boards/OpenMote-CC2538/source/pka.c ****     uint32_t regMSWVal;
 701:bsp/boards/OpenMote-CC2538/source/pka.c ****     uint32_t len;
 702:bsp/boards/OpenMote-CC2538/source/pka.c ****     int i;
 703:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 704:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 705:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Check the arguments.
 706:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 707:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != pui32ResultBuf);
 708:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT((ui32ResVectorLoc > PKA_RAM_BASE) &&
 709:bsp/boards/OpenMote-CC2538/source/pka.c ****            (ui32ResVectorLoc < (PKA_RAM_BASE + PKA_RAM_SIZE)));
 710:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 711:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 712:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Verify that the operation is complete.
 713:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 714:bsp/boards/OpenMote-CC2538/source/pka.c ****     if((HWREG(PKA_FUNCTION) & PKA_FUNCTION_RUN) != 0)
 905              		.loc 1 714 0
 906 0536 44F21C03 		movw	r3, #16412
 907 053a C4F20043 		movt	r3, 17408
 908 053e 1B68     		ldr	r3, [r3, #0]
 909 0540 03F40043 		and	r3, r3, #32768
 910 0544 002B     		cmp	r3, #0
 911 0546 02D0     		beq	.L47
 715:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
 716:bsp/boards/OpenMote-CC2538/source/pka.c ****         return (PKA_STATUS_OPERATION_INPRG);
 912              		.loc 1 716 0
 913 0548 4FF00703 		mov	r3, #7
 914 054c 3FE0     		b	.L48
 915              	.L47:
 717:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
 718:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 719:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 720:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Get the MSW register value.
 721:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 722:bsp/boards/OpenMote-CC2538/source/pka.c ****     regMSWVal = HWREG(PKA_MSW);
 916              		.loc 1 722 0
 917 054e 44F22403 		movw	r3, #16420
 918 0552 C4F20043 		movt	r3, 17408
 919 0556 1B68     		ldr	r3, [r3, #0]
 920 0558 BB61     		str	r3, [r7, #24]
 723:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 724:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 725:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Check to make sure that the result vector is not all zeroes.
 726:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 727:bsp/boards/OpenMote-CC2538/source/pka.c ****     if(regMSWVal & PKA_MSW_RESULT_IS_ZERO)
 921              		.loc 1 727 0
 922 055a BB69     		ldr	r3, [r7, #24]
 923 055c 03F40043 		and	r3, r3, #32768
 924 0560 002B     		cmp	r3, #0
 925 0562 02D0     		beq	.L49
 728:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
 729:bsp/boards/OpenMote-CC2538/source/pka.c ****         return (PKA_STATUS_RESULT_0);
 926              		.loc 1 729 0
 927 0564 4FF00403 		mov	r3, #4
 928 0568 31E0     		b	.L48
 929              	.L49:
 730:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
 731:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 732:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 733:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Get the length of the result
 734:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 735:bsp/boards/OpenMote-CC2538/source/pka.c ****     len = ((regMSWVal & PKA_MSW_MSW_ADDRESS_M) + 1) -
 930              		.loc 1 735 0
 931 056a BB69     		ldr	r3, [r7, #24]
 932 056c 4FEA4353 		lsl	r3, r3, #21
 933 0570 4FEA5353 		lsr	r3, r3, #21
 736:bsp/boards/OpenMote-CC2538/source/pka.c ****           ((ui32ResVectorLoc - PKA_RAM_BASE) >> 2);
 934              		.loc 1 736 0
 935 0574 7A68     		ldr	r2, [r7, #4]
 936 0576 02F13C42 		add	r2, r2, #-1140850688
 937 057a A2F5C042 		sub	r2, r2, #24576
 938 057e 4FEA9202 		lsr	r2, r2, #2
 735:bsp/boards/OpenMote-CC2538/source/pka.c ****     len = ((regMSWVal & PKA_MSW_MSW_ADDRESS_M) + 1) -
 939              		.loc 1 735 0
 940 0582 9B1A     		subs	r3, r3, r2
 941 0584 03F10103 		add	r3, r3, #1
 942 0588 7B61     		str	r3, [r7, #20]
 737:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 738:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 739:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Check if the provided buffer length is adequate to store the result
 740:bsp/boards/OpenMote-CC2538/source/pka.c ****     // data.
 741:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 742:bsp/boards/OpenMote-CC2538/source/pka.c ****     if(ui8Size < len)
 943              		.loc 1 742 0
 944 058a FA7A     		ldrb	r2, [r7, #11]	@ zero_extendqisi2
 945 058c 7B69     		ldr	r3, [r7, #20]
 946 058e 9A42     		cmp	r2, r3
 947 0590 02D2     		bcs	.L50
 743:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
 744:bsp/boards/OpenMote-CC2538/source/pka.c ****         return (PKA_STATUS_BUF_UNDERFLOW);
 948              		.loc 1 744 0
 949 0592 4FF00303 		mov	r3, #3
 950 0596 1AE0     		b	.L48
 951              	.L50:
 745:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
 746:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 747:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 748:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Copy the result from vector C into the \e pui32ResultBuf.
 749:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < len; i++)
 952              		.loc 1 749 0
 953 0598 4FF00003 		mov	r3, #0
 954 059c FB61     		str	r3, [r7, #28]
 955 059e 10E0     		b	.L51
 956              	.L52:
 750:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
 751:bsp/boards/OpenMote-CC2538/source/pka.c ****         pui32ResultBuf[i]= HWREG( (ui32ResVectorLoc + 4*i) );
 957              		.loc 1 751 0 discriminator 2
 958 05a0 FB69     		ldr	r3, [r7, #28]
 959 05a2 4FEA8303 		lsl	r3, r3, #2
 960 05a6 FA68     		ldr	r2, [r7, #12]
 961 05a8 D318     		adds	r3, r2, r3
 962 05aa FA69     		ldr	r2, [r7, #28]
 963 05ac 4FEA8202 		lsl	r2, r2, #2
 964 05b0 1146     		mov	r1, r2
 965 05b2 7A68     		ldr	r2, [r7, #4]
 966 05b4 8A18     		adds	r2, r1, r2
 967 05b6 1268     		ldr	r2, [r2, #0]
 968 05b8 1A60     		str	r2, [r3, #0]
 749:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < len; i++)
 969              		.loc 1 749 0 discriminator 2
 970 05ba FB69     		ldr	r3, [r7, #28]
 971 05bc 03F10103 		add	r3, r3, #1
 972 05c0 FB61     		str	r3, [r7, #28]
 973              	.L51:
 749:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < len; i++)
 974              		.loc 1 749 0 is_stmt 0 discriminator 1
 975 05c2 FA69     		ldr	r2, [r7, #28]
 976 05c4 7B69     		ldr	r3, [r7, #20]
 977 05c6 9A42     		cmp	r2, r3
 978 05c8 EAD3     		bcc	.L52
 752:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
 753:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 754:bsp/boards/OpenMote-CC2538/source/pka.c ****     return (PKA_STATUS_SUCCESS);
 979              		.loc 1 754 0 is_stmt 1
 980 05ca 4FF00003 		mov	r3, #0
 981              	.L48:
 755:bsp/boards/OpenMote-CC2538/source/pka.c **** }
 982              		.loc 1 755 0
 983 05ce 1846     		mov	r0, r3
 984 05d0 07F12407 		add	r7, r7, #36
 985 05d4 BD46     		mov	sp, r7
 986 05d6 80BC     		pop	{r7}
 987 05d8 7047     		bx	lr
 988              		.cfi_endproc
 989              	.LFE11:
 991 05da 00BF     		.align	2
 992              		.global	PKABigNumMultiplyStart
 993              		.thumb
 994              		.thumb_func
 996              	PKABigNumMultiplyStart:
 997              	.LFB12:
 756:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 757:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
 758:bsp/boards/OpenMote-CC2538/source/pka.c **** //
 759:bsp/boards/OpenMote-CC2538/source/pka.c **** //! Starts the big number multiplication.
 760:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 761:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param pui32Xplicand is the pointer to the buffer containing the big
 762:bsp/boards/OpenMote-CC2538/source/pka.c **** //! number multiplicand.
 763:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param ui8XplicandSize is the size of the multiplicand in 32-bit word.
 764:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param pui32Xplier is the pointer to the buffer containing the big
 765:bsp/boards/OpenMote-CC2538/source/pka.c **** //! number multiplier.
 766:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param ui8XplierSize is the size of the multiplier in 32-bit word.
 767:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param pui32ResultVector is the pointer to the result vector location
 768:bsp/boards/OpenMote-CC2538/source/pka.c **** //! which will be set by this function.
 769:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 770:bsp/boards/OpenMote-CC2538/source/pka.c **** //! This function starts the multiplication of the two big numbers.
 771:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 772:bsp/boards/OpenMote-CC2538/source/pka.c **** //!\return Returns: 
 773:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_SUCCESS if successful in starting the operation.  
 774:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_OPERATION_INPRG, if the PKA hw module is busy doing
 775:bsp/boards/OpenMote-CC2538/source/pka.c **** //! some other operation.
 776:bsp/boards/OpenMote-CC2538/source/pka.c **** //
 777:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
 778:bsp/boards/OpenMote-CC2538/source/pka.c **** tPKAStatus
 779:bsp/boards/OpenMote-CC2538/source/pka.c **** PKABigNumMultiplyStart(uint32_t* pui32Xplicand, uint8_t ui8XplicandSize,
 780:bsp/boards/OpenMote-CC2538/source/pka.c ****                        uint32_t* pui32Xplier, uint8_t ui8XplierSize,
 781:bsp/boards/OpenMote-CC2538/source/pka.c ****                        uint32_t* pui32ResultVector)
 782:bsp/boards/OpenMote-CC2538/source/pka.c **** {
 998              		.loc 1 782 0
 999              		.cfi_startproc
 1000              		@ args = 4, pretend = 0, frame = 24
 1001              		@ frame_needed = 1, uses_anonymous_args = 0
 1002              		@ link register save eliminated.
 1003 05dc 80B4     		push	{r7}
 1004              	.LCFI31:
 1005              		.cfi_def_cfa_offset 4
 1006              		.cfi_offset 7, -4
 1007 05de 87B0     		sub	sp, sp, #28
 1008              	.LCFI32:
 1009              		.cfi_def_cfa_offset 32
 1010 05e0 00AF     		add	r7, sp, #0
 1011              	.LCFI33:
 1012              		.cfi_def_cfa_register 7
 1013 05e2 F860     		str	r0, [r7, #12]
 1014 05e4 7A60     		str	r2, [r7, #4]
 1015 05e6 0A46     		mov	r2, r1
 1016 05e8 FA72     		strb	r2, [r7, #11]
 1017 05ea BB72     		strb	r3, [r7, #10]
 783:bsp/boards/OpenMote-CC2538/source/pka.c ****     uint32_t offset;
 784:bsp/boards/OpenMote-CC2538/source/pka.c ****     int i;
 785:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 786:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 787:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Check for the arguments.
 788:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 789:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != pui32Xplicand);
 790:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != pui32Xplier);
 791:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != pui32ResultVector);
 792:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 793:bsp/boards/OpenMote-CC2538/source/pka.c ****     offset = 0;
 1018              		.loc 1 793 0
 1019 05ec 4FF00003 		mov	r3, #0
 1020 05f0 3B61     		str	r3, [r7, #16]
 794:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 795:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 796:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Make sure no operation is in progress.
 797:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 798:bsp/boards/OpenMote-CC2538/source/pka.c ****     if((HWREG(PKA_FUNCTION) & PKA_FUNCTION_RUN) != 0)
 1021              		.loc 1 798 0
 1022 05f2 44F21C03 		movw	r3, #16412
 1023 05f6 C4F20043 		movt	r3, 17408
 1024 05fa 1B68     		ldr	r3, [r3, #0]
 1025 05fc 03F40043 		and	r3, r3, #32768
 1026 0600 002B     		cmp	r3, #0
 1027 0602 02D0     		beq	.L54
 799:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
 800:bsp/boards/OpenMote-CC2538/source/pka.c ****         return (PKA_STATUS_OPERATION_INPRG);
 1028              		.loc 1 800 0
 1029 0604 4FF00703 		mov	r3, #7
 1030 0608 81E0     		b	.L55
 1031              	.L54:
 801:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
 802:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 803:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 804:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Update the A ptr with the offset address of the PKA RAM location
 805:bsp/boards/OpenMote-CC2538/source/pka.c ****     // where the multiplicand will be stored.
 806:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 807:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG( (PKA_APTR) ) = offset >> 2;
 1032              		.loc 1 807 0
 1033 060a 4FF48043 		mov	r3, #16384
 1034 060e C4F20043 		movt	r3, 17408
 1035 0612 3A69     		ldr	r2, [r7, #16]
 1036 0614 4FEA9202 		lsr	r2, r2, #2
 1037 0618 1A60     		str	r2, [r3, #0]
 808:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 809:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 810:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Load the multiplicand in PKA RAM.
 811:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 812:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ui8XplicandSize; i++)
 1038              		.loc 1 812 0
 1039 061a 4FF00003 		mov	r3, #0
 1040 061e 7B61     		str	r3, [r7, #20]
 1041 0620 14E0     		b	.L56
 1042              	.L57:
 813:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
 814:bsp/boards/OpenMote-CC2538/source/pka.c ****         HWREG((PKA_RAM_BASE + offset + 4*i)) = *pui32Xplicand;
 1043              		.loc 1 814 0 discriminator 2
 1044 0622 7B69     		ldr	r3, [r7, #20]
 1045 0624 4FEA8303 		lsl	r3, r3, #2
 1046 0628 1A46     		mov	r2, r3
 1047 062a 3B69     		ldr	r3, [r7, #16]
 1048 062c D318     		adds	r3, r2, r3
 1049 062e 03F18843 		add	r3, r3, #1140850688
 1050 0632 03F5C043 		add	r3, r3, #24576
 1051 0636 FA68     		ldr	r2, [r7, #12]
 1052 0638 1268     		ldr	r2, [r2, #0]
 1053 063a 1A60     		str	r2, [r3, #0]
 815:bsp/boards/OpenMote-CC2538/source/pka.c ****         pui32Xplicand++;
 1054              		.loc 1 815 0 discriminator 2
 1055 063c FB68     		ldr	r3, [r7, #12]
 1056 063e 03F10403 		add	r3, r3, #4
 1057 0642 FB60     		str	r3, [r7, #12]
 812:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ui8XplicandSize; i++)
 1058              		.loc 1 812 0 discriminator 2
 1059 0644 7B69     		ldr	r3, [r7, #20]
 1060 0646 03F10103 		add	r3, r3, #1
 1061 064a 7B61     		str	r3, [r7, #20]
 1062              	.L56:
 812:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ui8XplicandSize; i++)
 1063              		.loc 1 812 0 is_stmt 0 discriminator 1
 1064 064c FA7A     		ldrb	r2, [r7, #11]	@ zero_extendqisi2
 1065 064e 7B69     		ldr	r3, [r7, #20]
 1066 0650 9A42     		cmp	r2, r3
 1067 0652 E6DC     		bgt	.L57
 816:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
 817:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 818:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 819:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Determine the offset for the next data.
 820:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 821:bsp/boards/OpenMote-CC2538/source/pka.c ****     offset += 4 * (i + (ui8XplicandSize % 2));
 1068              		.loc 1 821 0 is_stmt 1
 1069 0654 FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 1070 0656 03F00102 		and	r2, r3, #1
 1071 065a 7B69     		ldr	r3, [r7, #20]
 1072 065c D318     		adds	r3, r2, r3
 1073 065e 4FEA8303 		lsl	r3, r3, #2
 1074 0662 3A69     		ldr	r2, [r7, #16]
 1075 0664 D318     		adds	r3, r2, r3
 1076 0666 3B61     		str	r3, [r7, #16]
 822:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 823:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 824:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Update the B ptr with the offset address of the PKA RAM location
 825:bsp/boards/OpenMote-CC2538/source/pka.c ****     // where the multiplier will be stored.
 826:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 827:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG( (PKA_BPTR) ) = offset >> 2;
 1077              		.loc 1 827 0
 1078 0668 44F20403 		movw	r3, #16388
 1079 066c C4F20043 		movt	r3, 17408
 1080 0670 3A69     		ldr	r2, [r7, #16]
 1081 0672 4FEA9202 		lsr	r2, r2, #2
 1082 0676 1A60     		str	r2, [r3, #0]
 828:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 829:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 830:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Load the multiplier in PKA RAM.
 831:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 832:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ui8XplierSize; i++)
 1083              		.loc 1 832 0
 1084 0678 4FF00003 		mov	r3, #0
 1085 067c 7B61     		str	r3, [r7, #20]
 1086 067e 14E0     		b	.L58
 1087              	.L59:
 833:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
 834:bsp/boards/OpenMote-CC2538/source/pka.c ****         HWREG( (PKA_RAM_BASE + offset + 4*i) ) = *pui32Xplier;
 1088              		.loc 1 834 0 discriminator 2
 1089 0680 7B69     		ldr	r3, [r7, #20]
 1090 0682 4FEA8303 		lsl	r3, r3, #2
 1091 0686 1A46     		mov	r2, r3
 1092 0688 3B69     		ldr	r3, [r7, #16]
 1093 068a D318     		adds	r3, r2, r3
 1094 068c 03F18843 		add	r3, r3, #1140850688
 1095 0690 03F5C043 		add	r3, r3, #24576
 1096 0694 7A68     		ldr	r2, [r7, #4]
 1097 0696 1268     		ldr	r2, [r2, #0]
 1098 0698 1A60     		str	r2, [r3, #0]
 835:bsp/boards/OpenMote-CC2538/source/pka.c ****         pui32Xplier++;
 1099              		.loc 1 835 0 discriminator 2
 1100 069a 7B68     		ldr	r3, [r7, #4]
 1101 069c 03F10403 		add	r3, r3, #4
 1102 06a0 7B60     		str	r3, [r7, #4]
 832:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ui8XplierSize; i++)
 1103              		.loc 1 832 0 discriminator 2
 1104 06a2 7B69     		ldr	r3, [r7, #20]
 1105 06a4 03F10103 		add	r3, r3, #1
 1106 06a8 7B61     		str	r3, [r7, #20]
 1107              	.L58:
 832:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ui8XplierSize; i++)
 1108              		.loc 1 832 0 is_stmt 0 discriminator 1
 1109 06aa BA7A     		ldrb	r2, [r7, #10]	@ zero_extendqisi2
 1110 06ac 7B69     		ldr	r3, [r7, #20]
 1111 06ae 9A42     		cmp	r2, r3
 1112 06b0 E6DC     		bgt	.L59
 836:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
 837:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 838:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 839:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Determine the offset for the next data.
 840:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 841:bsp/boards/OpenMote-CC2538/source/pka.c ****     offset += 4 * (i + (ui8XplierSize % 2));
 1113              		.loc 1 841 0 is_stmt 1
 1114 06b2 BB7A     		ldrb	r3, [r7, #10]	@ zero_extendqisi2
 1115 06b4 03F00102 		and	r2, r3, #1
 1116 06b8 7B69     		ldr	r3, [r7, #20]
 1117 06ba D318     		adds	r3, r2, r3
 1118 06bc 4FEA8303 		lsl	r3, r3, #2
 1119 06c0 3A69     		ldr	r2, [r7, #16]
 1120 06c2 D318     		adds	r3, r2, r3
 1121 06c4 3B61     		str	r3, [r7, #16]
 842:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 843:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 844:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Copy the result vector address location.
 845:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 846:bsp/boards/OpenMote-CC2538/source/pka.c ****     *pui32ResultVector = PKA_RAM_BASE + offset;
 1122              		.loc 1 846 0
 1123 06c6 3B69     		ldr	r3, [r7, #16]
 1124 06c8 03F18843 		add	r3, r3, #1140850688
 1125 06cc 03F5C043 		add	r3, r3, #24576
 1126 06d0 3A6A     		ldr	r2, [r7, #32]
 1127 06d2 1360     		str	r3, [r2, #0]
 847:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 848:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 849:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Load C ptr with the result location in PKA RAM.
 850:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 851:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG( (PKA_CPTR) ) = offset >> 2;
 1128              		.loc 1 851 0
 1129 06d4 44F20803 		movw	r3, #16392
 1130 06d8 C4F20043 		movt	r3, 17408
 1131 06dc 3A69     		ldr	r2, [r7, #16]
 1132 06de 4FEA9202 		lsr	r2, r2, #2
 1133 06e2 1A60     		str	r2, [r3, #0]
 852:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 853:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 854:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Load the respective length registers.
 855:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 856:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG( (PKA_ALENGTH) ) = ui8XplicandSize;
 1134              		.loc 1 856 0
 1135 06e4 44F21003 		movw	r3, #16400
 1136 06e8 C4F20043 		movt	r3, 17408
 1137 06ec FA7A     		ldrb	r2, [r7, #11]	@ zero_extendqisi2
 1138 06ee 1A60     		str	r2, [r3, #0]
 857:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG( (PKA_BLENGTH) ) = ui8XplierSize;
 1139              		.loc 1 857 0
 1140 06f0 44F21403 		movw	r3, #16404
 1141 06f4 C4F20043 		movt	r3, 17408
 1142 06f8 BA7A     		ldrb	r2, [r7, #10]	@ zero_extendqisi2
 1143 06fa 1A60     		str	r2, [r3, #0]
 858:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 859:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 860:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Set the PKA function to the multiplication and start it.
 861:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 862:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG( (PKA_FUNCTION) ) = (PKA_FUNCTION_RUN | PKA_FUNCTION_MULTIPLY);
 1144              		.loc 1 862 0
 1145 06fc 44F21C03 		movw	r3, #16412
 1146 0700 C4F20043 		movt	r3, 17408
 1147 0704 48F20102 		movw	r2, #32769
 1148 0708 1A60     		str	r2, [r3, #0]
 863:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 864:bsp/boards/OpenMote-CC2538/source/pka.c ****     return (PKA_STATUS_SUCCESS);
 1149              		.loc 1 864 0
 1150 070a 4FF00003 		mov	r3, #0
 1151              	.L55:
 865:bsp/boards/OpenMote-CC2538/source/pka.c **** }
 1152              		.loc 1 865 0
 1153 070e 1846     		mov	r0, r3
 1154 0710 07F11C07 		add	r7, r7, #28
 1155 0714 BD46     		mov	sp, r7
 1156 0716 80BC     		pop	{r7}
 1157 0718 7047     		bx	lr
 1158              		.cfi_endproc
 1159              	.LFE12:
 1161 071a 00BF     		.align	2
 1162              		.global	PKABigNumMultGetResult
 1163              		.thumb
 1164              		.thumb_func
 1166              	PKABigNumMultGetResult:
 1167              	.LFB13:
 866:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 867:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
 868:bsp/boards/OpenMote-CC2538/source/pka.c **** //
 869:bsp/boards/OpenMote-CC2538/source/pka.c **** //! Gets the results of the big number multiplication.
 870:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 871:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param pui32ResultBuf is the pointer to buffer where the result needs to be
 872:bsp/boards/OpenMote-CC2538/source/pka.c **** //! stored.
 873:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param pui32Len is the address of the variable containing the length of the
 874:bsp/boards/OpenMote-CC2538/source/pka.c **** //! buffer.  After the operation, the actual length of the resultant is stored
 875:bsp/boards/OpenMote-CC2538/source/pka.c **** //! at this address.
 876:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param ui32ResVectorLoc is the address of the result location which
 877:bsp/boards/OpenMote-CC2538/source/pka.c **** //! was provided by the start function \sa PKABigNumMultiplyStart().
 878:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 879:bsp/boards/OpenMote-CC2538/source/pka.c **** //! This function gets the result of the multiplication of two big numbers
 880:bsp/boards/OpenMote-CC2538/source/pka.c **** //! operation previously started using the function \sa
 881:bsp/boards/OpenMote-CC2538/source/pka.c **** //! PKABigNumMultiplyStart().
 882:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 883:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \return Returns:
 884:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_SUCCESS if the operation is successful. 
 885:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_OPERATION_INPRG, if the PKA hw module is busy performing 
 886:bsp/boards/OpenMote-CC2538/source/pka.c **** //! the operation.
 887:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_RESULT_0 if the result is all zeroes.
 888:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_FAILURE if the operation is not successful.
 889:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_BUF_UNDERFLOW if the length of the provided buffer is less
 890:bsp/boards/OpenMote-CC2538/source/pka.c **** //! then the length of the result. 
 891:bsp/boards/OpenMote-CC2538/source/pka.c **** //
 892:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
 893:bsp/boards/OpenMote-CC2538/source/pka.c **** tPKAStatus
 894:bsp/boards/OpenMote-CC2538/source/pka.c **** PKABigNumMultGetResult(uint32_t* pui32ResultBuf, uint32_t* pui32Len,
 895:bsp/boards/OpenMote-CC2538/source/pka.c ****                        uint32_t ui32ResVectorLoc)
 896:bsp/boards/OpenMote-CC2538/source/pka.c **** {
 1168              		.loc 1 896 0
 1169              		.cfi_startproc
 1170              		@ args = 0, pretend = 0, frame = 32
 1171              		@ frame_needed = 1, uses_anonymous_args = 0
 1172              		@ link register save eliminated.
 1173 071c 80B4     		push	{r7}
 1174              	.LCFI34:
 1175              		.cfi_def_cfa_offset 4
 1176              		.cfi_offset 7, -4
 1177 071e 89B0     		sub	sp, sp, #36
 1178              	.LCFI35:
 1179              		.cfi_def_cfa_offset 40
 1180 0720 00AF     		add	r7, sp, #0
 1181              	.LCFI36:
 1182              		.cfi_def_cfa_register 7
 1183 0722 F860     		str	r0, [r7, #12]
 1184 0724 B960     		str	r1, [r7, #8]
 1185 0726 7A60     		str	r2, [r7, #4]
 897:bsp/boards/OpenMote-CC2538/source/pka.c ****     uint32_t regMSWVal;
 898:bsp/boards/OpenMote-CC2538/source/pka.c ****     uint32_t len;
 899:bsp/boards/OpenMote-CC2538/source/pka.c ****     int i;
 900:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 901:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 902:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Check for arguments.
 903:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 904:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != pui32ResultBuf);
 905:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != pui32Len);
 906:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT((ui32ResVectorLoc > PKA_RAM_BASE) &&
 907:bsp/boards/OpenMote-CC2538/source/pka.c ****            (ui32ResVectorLoc < (PKA_RAM_BASE + PKA_RAM_SIZE)));
 908:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 909:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 910:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Verify that the operation is complete.
 911:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 912:bsp/boards/OpenMote-CC2538/source/pka.c ****     if((HWREG(PKA_FUNCTION) & PKA_FUNCTION_RUN) != 0)
 1186              		.loc 1 912 0
 1187 0728 44F21C03 		movw	r3, #16412
 1188 072c C4F20043 		movt	r3, 17408
 1189 0730 1B68     		ldr	r3, [r3, #0]
 1190 0732 03F40043 		and	r3, r3, #32768
 1191 0736 002B     		cmp	r3, #0
 1192 0738 02D0     		beq	.L61
 913:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
 914:bsp/boards/OpenMote-CC2538/source/pka.c ****         return (PKA_STATUS_OPERATION_INPRG);
 1193              		.loc 1 914 0
 1194 073a 4FF00703 		mov	r3, #7
 1195 073e 44E0     		b	.L62
 1196              	.L61:
 915:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
 916:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 917:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 918:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Get the MSW register value.
 919:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 920:bsp/boards/OpenMote-CC2538/source/pka.c ****     regMSWVal = HWREG(PKA_MSW);
 1197              		.loc 1 920 0
 1198 0740 44F22403 		movw	r3, #16420
 1199 0744 C4F20043 		movt	r3, 17408
 1200 0748 1B68     		ldr	r3, [r3, #0]
 1201 074a BB61     		str	r3, [r7, #24]
 921:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 922:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 923:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Check to make sure that the result vector is not all zeroes.
 924:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 925:bsp/boards/OpenMote-CC2538/source/pka.c ****     if(regMSWVal & PKA_MSW_RESULT_IS_ZERO)
 1202              		.loc 1 925 0
 1203 074c BB69     		ldr	r3, [r7, #24]
 1204 074e 03F40043 		and	r3, r3, #32768
 1205 0752 002B     		cmp	r3, #0
 1206 0754 02D0     		beq	.L63
 926:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
 927:bsp/boards/OpenMote-CC2538/source/pka.c ****         return (PKA_STATUS_RESULT_0);
 1207              		.loc 1 927 0
 1208 0756 4FF00403 		mov	r3, #4
 1209 075a 36E0     		b	.L62
 1210              	.L63:
 928:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
 929:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 930:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 931:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Get the length of the result.
 932:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 933:bsp/boards/OpenMote-CC2538/source/pka.c ****     len = ((regMSWVal & PKA_MSW_MSW_ADDRESS_M) + 1) -
 1211              		.loc 1 933 0
 1212 075c BB69     		ldr	r3, [r7, #24]
 1213 075e 4FEA4353 		lsl	r3, r3, #21
 1214 0762 4FEA5353 		lsr	r3, r3, #21
 934:bsp/boards/OpenMote-CC2538/source/pka.c ****           ((ui32ResVectorLoc - PKA_RAM_BASE) >> 2);
 1215              		.loc 1 934 0
 1216 0766 7A68     		ldr	r2, [r7, #4]
 1217 0768 02F13C42 		add	r2, r2, #-1140850688
 1218 076c A2F5C042 		sub	r2, r2, #24576
 1219 0770 4FEA9202 		lsr	r2, r2, #2
 933:bsp/boards/OpenMote-CC2538/source/pka.c ****     len = ((regMSWVal & PKA_MSW_MSW_ADDRESS_M) + 1) -
 1220              		.loc 1 933 0
 1221 0774 9B1A     		subs	r3, r3, r2
 1222 0776 03F10103 		add	r3, r3, #1
 1223 077a 7B61     		str	r3, [r7, #20]
 935:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 936:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 937:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Make sure that the length of the supplied result buffer is adequate
 938:bsp/boards/OpenMote-CC2538/source/pka.c ****     // to store the resultant.
 939:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 940:bsp/boards/OpenMote-CC2538/source/pka.c ****     if(*pui32Len < len)
 1224              		.loc 1 940 0
 1225 077c BB68     		ldr	r3, [r7, #8]
 1226 077e 1A68     		ldr	r2, [r3, #0]
 1227 0780 7B69     		ldr	r3, [r7, #20]
 1228 0782 9A42     		cmp	r2, r3
 1229 0784 02D2     		bcs	.L64
 941:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
 942:bsp/boards/OpenMote-CC2538/source/pka.c ****         return (PKA_STATUS_BUF_UNDERFLOW);
 1230              		.loc 1 942 0
 1231 0786 4FF00303 		mov	r3, #3
 1232 078a 1EE0     		b	.L62
 1233              	.L64:
 943:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
 944:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 945:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 946:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Copy the resultant length.
 947:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 948:bsp/boards/OpenMote-CC2538/source/pka.c ****     *pui32Len = len;
 1234              		.loc 1 948 0
 1235 078c BB68     		ldr	r3, [r7, #8]
 1236 078e 7A69     		ldr	r2, [r7, #20]
 1237 0790 1A60     		str	r2, [r3, #0]
 949:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 950:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 951:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Copy the result from vector C into the pResult.
 952:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 953:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < *pui32Len; i++)
 1238              		.loc 1 953 0
 1239 0792 4FF00003 		mov	r3, #0
 1240 0796 FB61     		str	r3, [r7, #28]
 1241 0798 10E0     		b	.L65
 1242              	.L66:
 954:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
 955:bsp/boards/OpenMote-CC2538/source/pka.c ****         pui32ResultBuf[i]= HWREG( (ui32ResVectorLoc + 4*i) );
 1243              		.loc 1 955 0 discriminator 2
 1244 079a FB69     		ldr	r3, [r7, #28]
 1245 079c 4FEA8303 		lsl	r3, r3, #2
 1246 07a0 FA68     		ldr	r2, [r7, #12]
 1247 07a2 D318     		adds	r3, r2, r3
 1248 07a4 FA69     		ldr	r2, [r7, #28]
 1249 07a6 4FEA8202 		lsl	r2, r2, #2
 1250 07aa 1146     		mov	r1, r2
 1251 07ac 7A68     		ldr	r2, [r7, #4]
 1252 07ae 8A18     		adds	r2, r1, r2
 1253 07b0 1268     		ldr	r2, [r2, #0]
 1254 07b2 1A60     		str	r2, [r3, #0]
 953:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < *pui32Len; i++)
 1255              		.loc 1 953 0 discriminator 2
 1256 07b4 FB69     		ldr	r3, [r7, #28]
 1257 07b6 03F10103 		add	r3, r3, #1
 1258 07ba FB61     		str	r3, [r7, #28]
 1259              	.L65:
 953:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < *pui32Len; i++)
 1260              		.loc 1 953 0 is_stmt 0 discriminator 1
 1261 07bc FA69     		ldr	r2, [r7, #28]
 1262 07be BB68     		ldr	r3, [r7, #8]
 1263 07c0 1B68     		ldr	r3, [r3, #0]
 1264 07c2 9A42     		cmp	r2, r3
 1265 07c4 E9D3     		bcc	.L66
 956:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
 957:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 958:bsp/boards/OpenMote-CC2538/source/pka.c ****     return (PKA_STATUS_SUCCESS);
 1266              		.loc 1 958 0 is_stmt 1
 1267 07c6 4FF00003 		mov	r3, #0
 1268              	.L62:
 959:bsp/boards/OpenMote-CC2538/source/pka.c **** }
 1269              		.loc 1 959 0
 1270 07ca 1846     		mov	r0, r3
 1271 07cc 07F12407 		add	r7, r7, #36
 1272 07d0 BD46     		mov	sp, r7
 1273 07d2 80BC     		pop	{r7}
 1274 07d4 7047     		bx	lr
 1275              		.cfi_endproc
 1276              	.LFE13:
 1278 07d6 00BF     		.align	2
 1279              		.global	PKABigNumAddStart
 1280              		.thumb
 1281              		.thumb_func
 1283              	PKABigNumAddStart:
 1284              	.LFB14:
 960:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 961:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
 962:bsp/boards/OpenMote-CC2538/source/pka.c **** //
 963:bsp/boards/OpenMote-CC2538/source/pka.c **** //! Starts the addition of two big number.
 964:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 965:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param pui32BN1 is the pointer to the buffer containing the first
 966:bsp/boards/OpenMote-CC2538/source/pka.c **** //! big mumber.
 967:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param ui8BN1Size is the size of the first big number in 32-bit word.
 968:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param pui32BN2 is the pointer to the buffer containing the second
 969:bsp/boards/OpenMote-CC2538/source/pka.c **** //! big number.
 970:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param ui8BN2Size is the size of the second big number in 32-bit word.
 971:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param pui32ResultVector is the pointer to the result vector location
 972:bsp/boards/OpenMote-CC2538/source/pka.c **** //! which will be set by this function.
 973:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 974:bsp/boards/OpenMote-CC2538/source/pka.c **** //! This function starts the addition of the two big numbers.
 975:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
 976:bsp/boards/OpenMote-CC2538/source/pka.c **** //!\return Returns: 
 977:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_SUCCESS if successful in starting the operation.  
 978:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_OPERATION_INPRG, if the PKA hw module is busy doing
 979:bsp/boards/OpenMote-CC2538/source/pka.c **** //! some other operation.
 980:bsp/boards/OpenMote-CC2538/source/pka.c **** //
 981:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
 982:bsp/boards/OpenMote-CC2538/source/pka.c **** tPKAStatus
 983:bsp/boards/OpenMote-CC2538/source/pka.c **** PKABigNumAddStart(uint32_t* pui32BN1, uint8_t ui8BN1Size,
 984:bsp/boards/OpenMote-CC2538/source/pka.c ****                   uint32_t* pui32BN2, uint8_t ui8BN2Size,
 985:bsp/boards/OpenMote-CC2538/source/pka.c ****                   uint32_t* pui32ResultVector)
 986:bsp/boards/OpenMote-CC2538/source/pka.c **** {
 1285              		.loc 1 986 0
 1286              		.cfi_startproc
 1287              		@ args = 4, pretend = 0, frame = 24
 1288              		@ frame_needed = 1, uses_anonymous_args = 0
 1289              		@ link register save eliminated.
 1290 07d8 80B4     		push	{r7}
 1291              	.LCFI37:
 1292              		.cfi_def_cfa_offset 4
 1293              		.cfi_offset 7, -4
 1294 07da 87B0     		sub	sp, sp, #28
 1295              	.LCFI38:
 1296              		.cfi_def_cfa_offset 32
 1297 07dc 00AF     		add	r7, sp, #0
 1298              	.LCFI39:
 1299              		.cfi_def_cfa_register 7
 1300 07de F860     		str	r0, [r7, #12]
 1301 07e0 7A60     		str	r2, [r7, #4]
 1302 07e2 0A46     		mov	r2, r1
 1303 07e4 FA72     		strb	r2, [r7, #11]
 1304 07e6 BB72     		strb	r3, [r7, #10]
 987:bsp/boards/OpenMote-CC2538/source/pka.c ****     uint32_t offset;
 988:bsp/boards/OpenMote-CC2538/source/pka.c ****     int i;
 989:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 990:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 991:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Check for arguments.
 992:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
 993:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != pui32BN1);
 994:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != pui32BN2);
 995:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != pui32ResultVector);
 996:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 997:bsp/boards/OpenMote-CC2538/source/pka.c ****     offset = 0;
 1305              		.loc 1 997 0
 1306 07e8 4FF00003 		mov	r3, #0
 1307 07ec 3B61     		str	r3, [r7, #16]
 998:bsp/boards/OpenMote-CC2538/source/pka.c **** 
 999:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1000:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Make sure no operation is in progress.
1001:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1002:bsp/boards/OpenMote-CC2538/source/pka.c ****     if((HWREG(PKA_FUNCTION) & PKA_FUNCTION_RUN) != 0)
 1308              		.loc 1 1002 0
 1309 07ee 44F21C03 		movw	r3, #16412
 1310 07f2 C4F20043 		movt	r3, 17408
 1311 07f6 1B68     		ldr	r3, [r3, #0]
 1312 07f8 03F40043 		and	r3, r3, #32768
 1313 07fc 002B     		cmp	r3, #0
 1314 07fe 02D0     		beq	.L68
1003:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
1004:bsp/boards/OpenMote-CC2538/source/pka.c ****         return (PKA_STATUS_OPERATION_INPRG);
 1315              		.loc 1 1004 0
 1316 0800 4FF00703 		mov	r3, #7
 1317 0804 81E0     		b	.L69
 1318              	.L68:
1005:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
1006:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1007:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1008:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Update the A ptr with the offset address of the PKA RAM location
1009:bsp/boards/OpenMote-CC2538/source/pka.c ****     // where the big number 1 will be stored.
1010:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1011:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG( (PKA_APTR) ) = offset >> 2;
 1319              		.loc 1 1011 0
 1320 0806 4FF48043 		mov	r3, #16384
 1321 080a C4F20043 		movt	r3, 17408
 1322 080e 3A69     		ldr	r2, [r7, #16]
 1323 0810 4FEA9202 		lsr	r2, r2, #2
 1324 0814 1A60     		str	r2, [r3, #0]
1012:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1013:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1014:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Load the big number 1 in PKA RAM.
1015:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1016:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ui8BN1Size; i++)
 1325              		.loc 1 1016 0
 1326 0816 4FF00003 		mov	r3, #0
 1327 081a 7B61     		str	r3, [r7, #20]
 1328 081c 14E0     		b	.L70
 1329              	.L71:
1017:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
1018:bsp/boards/OpenMote-CC2538/source/pka.c ****         HWREG((PKA_RAM_BASE + offset + 4*i)) = pui32BN1[i];
 1330              		.loc 1 1018 0 discriminator 2
 1331 081e 7B69     		ldr	r3, [r7, #20]
 1332 0820 4FEA8303 		lsl	r3, r3, #2
 1333 0824 1A46     		mov	r2, r3
 1334 0826 3B69     		ldr	r3, [r7, #16]
 1335 0828 D318     		adds	r3, r2, r3
 1336 082a 03F18843 		add	r3, r3, #1140850688
 1337 082e 03F5C043 		add	r3, r3, #24576
 1338 0832 7A69     		ldr	r2, [r7, #20]
 1339 0834 4FEA8202 		lsl	r2, r2, #2
 1340 0838 F968     		ldr	r1, [r7, #12]
 1341 083a 8A18     		adds	r2, r1, r2
 1342 083c 1268     		ldr	r2, [r2, #0]
 1343 083e 1A60     		str	r2, [r3, #0]
1016:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ui8BN1Size; i++)
 1344              		.loc 1 1016 0 discriminator 2
 1345 0840 7B69     		ldr	r3, [r7, #20]
 1346 0842 03F10103 		add	r3, r3, #1
 1347 0846 7B61     		str	r3, [r7, #20]
 1348              	.L70:
1016:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ui8BN1Size; i++)
 1349              		.loc 1 1016 0 is_stmt 0 discriminator 1
 1350 0848 FA7A     		ldrb	r2, [r7, #11]	@ zero_extendqisi2
 1351 084a 7B69     		ldr	r3, [r7, #20]
 1352 084c 9A42     		cmp	r2, r3
 1353 084e E6DC     		bgt	.L71
1019:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
1020:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1021:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1022:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Determine the offset in PKA RAM for the next data.
1023:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1024:bsp/boards/OpenMote-CC2538/source/pka.c ****     offset += 4 * (i + (ui8BN1Size % 2));
 1354              		.loc 1 1024 0 is_stmt 1
 1355 0850 FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 1356 0852 03F00102 		and	r2, r3, #1
 1357 0856 7B69     		ldr	r3, [r7, #20]
 1358 0858 D318     		adds	r3, r2, r3
 1359 085a 4FEA8303 		lsl	r3, r3, #2
 1360 085e 3A69     		ldr	r2, [r7, #16]
 1361 0860 D318     		adds	r3, r2, r3
 1362 0862 3B61     		str	r3, [r7, #16]
1025:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1026:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1027:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Update the B ptr with the offset address of the PKA RAM location
1028:bsp/boards/OpenMote-CC2538/source/pka.c ****     // where the big number 2 will be stored.
1029:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1030:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG( (PKA_BPTR) ) = offset >> 2;
 1363              		.loc 1 1030 0
 1364 0864 44F20403 		movw	r3, #16388
 1365 0868 C4F20043 		movt	r3, 17408
 1366 086c 3A69     		ldr	r2, [r7, #16]
 1367 086e 4FEA9202 		lsr	r2, r2, #2
 1368 0872 1A60     		str	r2, [r3, #0]
1031:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1032:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1033:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Load the big number 2 in PKA RAM.
1034:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1035:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ui8BN2Size; i++)
 1369              		.loc 1 1035 0
 1370 0874 4FF00003 		mov	r3, #0
 1371 0878 7B61     		str	r3, [r7, #20]
 1372 087a 14E0     		b	.L72
 1373              	.L73:
1036:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
1037:bsp/boards/OpenMote-CC2538/source/pka.c ****         HWREG((PKA_RAM_BASE + offset + 4*i)) = pui32BN2[i];
 1374              		.loc 1 1037 0 discriminator 2
 1375 087c 7B69     		ldr	r3, [r7, #20]
 1376 087e 4FEA8303 		lsl	r3, r3, #2
 1377 0882 1A46     		mov	r2, r3
 1378 0884 3B69     		ldr	r3, [r7, #16]
 1379 0886 D318     		adds	r3, r2, r3
 1380 0888 03F18843 		add	r3, r3, #1140850688
 1381 088c 03F5C043 		add	r3, r3, #24576
 1382 0890 7A69     		ldr	r2, [r7, #20]
 1383 0892 4FEA8202 		lsl	r2, r2, #2
 1384 0896 7968     		ldr	r1, [r7, #4]
 1385 0898 8A18     		adds	r2, r1, r2
 1386 089a 1268     		ldr	r2, [r2, #0]
 1387 089c 1A60     		str	r2, [r3, #0]
1035:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ui8BN2Size; i++)
 1388              		.loc 1 1035 0 discriminator 2
 1389 089e 7B69     		ldr	r3, [r7, #20]
 1390 08a0 03F10103 		add	r3, r3, #1
 1391 08a4 7B61     		str	r3, [r7, #20]
 1392              	.L72:
1035:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ui8BN2Size; i++)
 1393              		.loc 1 1035 0 is_stmt 0 discriminator 1
 1394 08a6 BA7A     		ldrb	r2, [r7, #10]	@ zero_extendqisi2
 1395 08a8 7B69     		ldr	r3, [r7, #20]
 1396 08aa 9A42     		cmp	r2, r3
 1397 08ac E6DC     		bgt	.L73
1038:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
1039:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1040:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1041:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Determine the offset in PKA RAM for the next data.
1042:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1043:bsp/boards/OpenMote-CC2538/source/pka.c ****     offset += 4 * (i + (ui8BN2Size % 2));
 1398              		.loc 1 1043 0 is_stmt 1
 1399 08ae BB7A     		ldrb	r3, [r7, #10]	@ zero_extendqisi2
 1400 08b0 03F00102 		and	r2, r3, #1
 1401 08b4 7B69     		ldr	r3, [r7, #20]
 1402 08b6 D318     		adds	r3, r2, r3
 1403 08b8 4FEA8303 		lsl	r3, r3, #2
 1404 08bc 3A69     		ldr	r2, [r7, #16]
 1405 08be D318     		adds	r3, r2, r3
 1406 08c0 3B61     		str	r3, [r7, #16]
1044:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1045:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1046:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Copy the result vector address location.
1047:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1048:bsp/boards/OpenMote-CC2538/source/pka.c ****     *pui32ResultVector = PKA_RAM_BASE + offset;
 1407              		.loc 1 1048 0
 1408 08c2 3B69     		ldr	r3, [r7, #16]
 1409 08c4 03F18843 		add	r3, r3, #1140850688
 1410 08c8 03F5C043 		add	r3, r3, #24576
 1411 08cc 3A6A     		ldr	r2, [r7, #32]
 1412 08ce 1360     		str	r3, [r2, #0]
1049:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1050:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1051:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Load C ptr with the result location in PKA RAM.
1052:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1053:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG( (PKA_CPTR) ) = offset >> 2;
 1413              		.loc 1 1053 0
 1414 08d0 44F20803 		movw	r3, #16392
 1415 08d4 C4F20043 		movt	r3, 17408
 1416 08d8 3A69     		ldr	r2, [r7, #16]
 1417 08da 4FEA9202 		lsr	r2, r2, #2
 1418 08de 1A60     		str	r2, [r3, #0]
1054:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1055:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1056:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Load respective length registers.
1057:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1058:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG( (PKA_ALENGTH) ) = ui8BN1Size;
 1419              		.loc 1 1058 0
 1420 08e0 44F21003 		movw	r3, #16400
 1421 08e4 C4F20043 		movt	r3, 17408
 1422 08e8 FA7A     		ldrb	r2, [r7, #11]	@ zero_extendqisi2
 1423 08ea 1A60     		str	r2, [r3, #0]
1059:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG( (PKA_BLENGTH) ) = ui8BN2Size;
 1424              		.loc 1 1059 0
 1425 08ec 44F21403 		movw	r3, #16404
 1426 08f0 C4F20043 		movt	r3, 17408
 1427 08f4 BA7A     		ldrb	r2, [r7, #10]	@ zero_extendqisi2
 1428 08f6 1A60     		str	r2, [r3, #0]
1060:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1061:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1062:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Set the function for the add operation and start the operation.
1063:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1064:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG( (PKA_FUNCTION) ) = (PKA_FUNCTION_RUN | PKA_FUNCTION_ADD);
 1429              		.loc 1 1064 0
 1430 08f8 44F21C03 		movw	r3, #16412
 1431 08fc C4F20043 		movt	r3, 17408
 1432 0900 48F21002 		movw	r2, #32784
 1433 0904 1A60     		str	r2, [r3, #0]
1065:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1066:bsp/boards/OpenMote-CC2538/source/pka.c ****     return (PKA_STATUS_SUCCESS);
 1434              		.loc 1 1066 0
 1435 0906 4FF00003 		mov	r3, #0
 1436              	.L69:
1067:bsp/boards/OpenMote-CC2538/source/pka.c **** }
 1437              		.loc 1 1067 0
 1438 090a 1846     		mov	r0, r3
 1439 090c 07F11C07 		add	r7, r7, #28
 1440 0910 BD46     		mov	sp, r7
 1441 0912 80BC     		pop	{r7}
 1442 0914 7047     		bx	lr
 1443              		.cfi_endproc
 1444              	.LFE14:
 1446 0916 00BF     		.align	2
 1447              		.global	PKABigNumAddGetResult
 1448              		.thumb
 1449              		.thumb_func
 1451              	PKABigNumAddGetResult:
 1452              	.LFB15:
1068:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1069:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
1070:bsp/boards/OpenMote-CC2538/source/pka.c **** //
1071:bsp/boards/OpenMote-CC2538/source/pka.c **** //! Gets the result of the addition operation on two big number.
1072:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
1073:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param pui32ResultBuf is the pointer to buffer where the result
1074:bsp/boards/OpenMote-CC2538/source/pka.c **** //! needs to be stored.
1075:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param pui32Len is the address of the variable containing the length of
1076:bsp/boards/OpenMote-CC2538/source/pka.c **** //! the buffer.  After the operation the actual length of the resultant is
1077:bsp/boards/OpenMote-CC2538/source/pka.c **** //! stored at this address.
1078:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param ui32ResVectorLoc is the address of the result location which
1079:bsp/boards/OpenMote-CC2538/source/pka.c **** //! was provided by the start function \sa PKABigNumAddStart().
1080:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
1081:bsp/boards/OpenMote-CC2538/source/pka.c **** //! This function gets the result of the addition operation on two big numbers,
1082:bsp/boards/OpenMote-CC2538/source/pka.c **** //! previously started using the function \sa PKABigNumAddStart().
1083:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
1084:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \return Returns:
1085:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_SUCCESS if the operation is successful. 
1086:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_OPERATION_INPRG, if the PKA hw module is busy performing 
1087:bsp/boards/OpenMote-CC2538/source/pka.c **** //! the operation.
1088:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_RESULT_0 if the result is all zeroes.
1089:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_FAILURE if the operation is not successful.
1090:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_BUF_UNDERFLOW if the length of the provided buffer is less
1091:bsp/boards/OpenMote-CC2538/source/pka.c **** //! then the length of the result. 
1092:bsp/boards/OpenMote-CC2538/source/pka.c **** //
1093:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
1094:bsp/boards/OpenMote-CC2538/source/pka.c **** tPKAStatus
1095:bsp/boards/OpenMote-CC2538/source/pka.c **** PKABigNumAddGetResult(uint32_t* pui32ResultBuf, uint32_t* pui32Len,
1096:bsp/boards/OpenMote-CC2538/source/pka.c ****                       uint32_t ui32ResVectorLoc)
1097:bsp/boards/OpenMote-CC2538/source/pka.c **** {
 1453              		.loc 1 1097 0
 1454              		.cfi_startproc
 1455              		@ args = 0, pretend = 0, frame = 32
 1456              		@ frame_needed = 1, uses_anonymous_args = 0
 1457              		@ link register save eliminated.
 1458 0918 80B4     		push	{r7}
 1459              	.LCFI40:
 1460              		.cfi_def_cfa_offset 4
 1461              		.cfi_offset 7, -4
 1462 091a 89B0     		sub	sp, sp, #36
 1463              	.LCFI41:
 1464              		.cfi_def_cfa_offset 40
 1465 091c 00AF     		add	r7, sp, #0
 1466              	.LCFI42:
 1467              		.cfi_def_cfa_register 7
 1468 091e F860     		str	r0, [r7, #12]
 1469 0920 B960     		str	r1, [r7, #8]
 1470 0922 7A60     		str	r2, [r7, #4]
1098:bsp/boards/OpenMote-CC2538/source/pka.c ****     uint32_t regMSWVal;
1099:bsp/boards/OpenMote-CC2538/source/pka.c ****     uint32_t len;
1100:bsp/boards/OpenMote-CC2538/source/pka.c ****     int i;
1101:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1102:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1103:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Check for the arguments.
1104:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1105:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != pui32ResultBuf);
1106:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != pui32Len);
1107:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT((ui32ResVectorLoc > PKA_RAM_BASE) &&
1108:bsp/boards/OpenMote-CC2538/source/pka.c ****            (ui32ResVectorLoc < (PKA_RAM_BASE + PKA_RAM_SIZE)));
1109:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1110:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1111:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Verify that the operation is complete.
1112:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1113:bsp/boards/OpenMote-CC2538/source/pka.c ****     if((HWREG(PKA_FUNCTION) & PKA_FUNCTION_RUN) != 0)
 1471              		.loc 1 1113 0
 1472 0924 44F21C03 		movw	r3, #16412
 1473 0928 C4F20043 		movt	r3, 17408
 1474 092c 1B68     		ldr	r3, [r3, #0]
 1475 092e 03F40043 		and	r3, r3, #32768
 1476 0932 002B     		cmp	r3, #0
 1477 0934 02D0     		beq	.L75
1114:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
1115:bsp/boards/OpenMote-CC2538/source/pka.c ****         return (PKA_STATUS_OPERATION_INPRG);
 1478              		.loc 1 1115 0
 1479 0936 4FF00703 		mov	r3, #7
 1480 093a 44E0     		b	.L76
 1481              	.L75:
1116:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
1117:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1118:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1119:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Get the MSW register value.
1120:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1121:bsp/boards/OpenMote-CC2538/source/pka.c ****     regMSWVal = HWREG(PKA_MSW);
 1482              		.loc 1 1121 0
 1483 093c 44F22403 		movw	r3, #16420
 1484 0940 C4F20043 		movt	r3, 17408
 1485 0944 1B68     		ldr	r3, [r3, #0]
 1486 0946 BB61     		str	r3, [r7, #24]
1122:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1123:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1124:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Check to make sure that the result vector is not all zeroes.
1125:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1126:bsp/boards/OpenMote-CC2538/source/pka.c ****     if(regMSWVal & PKA_MSW_RESULT_IS_ZERO)
 1487              		.loc 1 1126 0
 1488 0948 BB69     		ldr	r3, [r7, #24]
 1489 094a 03F40043 		and	r3, r3, #32768
 1490 094e 002B     		cmp	r3, #0
 1491 0950 02D0     		beq	.L77
1127:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
1128:bsp/boards/OpenMote-CC2538/source/pka.c ****         return (PKA_STATUS_RESULT_0);
 1492              		.loc 1 1128 0
 1493 0952 4FF00403 		mov	r3, #4
 1494 0956 36E0     		b	.L76
 1495              	.L77:
1129:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
1130:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1131:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1132:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Get the length of the result.
1133:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1134:bsp/boards/OpenMote-CC2538/source/pka.c ****     len = ((regMSWVal & PKA_MSW_MSW_ADDRESS_M) + 1) -
 1496              		.loc 1 1134 0
 1497 0958 BB69     		ldr	r3, [r7, #24]
 1498 095a 4FEA4353 		lsl	r3, r3, #21
 1499 095e 4FEA5353 		lsr	r3, r3, #21
1135:bsp/boards/OpenMote-CC2538/source/pka.c ****           ((ui32ResVectorLoc - PKA_RAM_BASE) >> 2);
 1500              		.loc 1 1135 0
 1501 0962 7A68     		ldr	r2, [r7, #4]
 1502 0964 02F13C42 		add	r2, r2, #-1140850688
 1503 0968 A2F5C042 		sub	r2, r2, #24576
 1504 096c 4FEA9202 		lsr	r2, r2, #2
1134:bsp/boards/OpenMote-CC2538/source/pka.c ****     len = ((regMSWVal & PKA_MSW_MSW_ADDRESS_M) + 1) -
 1505              		.loc 1 1134 0
 1506 0970 9B1A     		subs	r3, r3, r2
 1507 0972 03F10103 		add	r3, r3, #1
 1508 0976 7B61     		str	r3, [r7, #20]
1136:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1137:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1138:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Make sure that the supplied result buffer is adequate to store the
1139:bsp/boards/OpenMote-CC2538/source/pka.c ****     // resultant data.
1140:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1141:bsp/boards/OpenMote-CC2538/source/pka.c ****     if(*pui32Len < len)
 1509              		.loc 1 1141 0
 1510 0978 BB68     		ldr	r3, [r7, #8]
 1511 097a 1A68     		ldr	r2, [r3, #0]
 1512 097c 7B69     		ldr	r3, [r7, #20]
 1513 097e 9A42     		cmp	r2, r3
 1514 0980 02D2     		bcs	.L78
1142:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
1143:bsp/boards/OpenMote-CC2538/source/pka.c ****         return (PKA_STATUS_BUF_UNDERFLOW);
 1515              		.loc 1 1143 0
 1516 0982 4FF00303 		mov	r3, #3
 1517 0986 1EE0     		b	.L76
 1518              	.L78:
1144:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
1145:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1146:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1147:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Copy the length.
1148:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1149:bsp/boards/OpenMote-CC2538/source/pka.c ****     *pui32Len = len;
 1519              		.loc 1 1149 0
 1520 0988 BB68     		ldr	r3, [r7, #8]
 1521 098a 7A69     		ldr	r2, [r7, #20]
 1522 098c 1A60     		str	r2, [r3, #0]
1150:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1151:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1152:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Copy the result from vector C into the provided buffer.
1153:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < *pui32Len; i++)
 1523              		.loc 1 1153 0
 1524 098e 4FF00003 		mov	r3, #0
 1525 0992 FB61     		str	r3, [r7, #28]
 1526 0994 10E0     		b	.L79
 1527              	.L80:
1154:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
1155:bsp/boards/OpenMote-CC2538/source/pka.c ****         pui32ResultBuf[i] = HWREG( (ui32ResVectorLoc +  4*i) );
 1528              		.loc 1 1155 0 discriminator 2
 1529 0996 FB69     		ldr	r3, [r7, #28]
 1530 0998 4FEA8303 		lsl	r3, r3, #2
 1531 099c FA68     		ldr	r2, [r7, #12]
 1532 099e D318     		adds	r3, r2, r3
 1533 09a0 FA69     		ldr	r2, [r7, #28]
 1534 09a2 4FEA8202 		lsl	r2, r2, #2
 1535 09a6 1146     		mov	r1, r2
 1536 09a8 7A68     		ldr	r2, [r7, #4]
 1537 09aa 8A18     		adds	r2, r1, r2
 1538 09ac 1268     		ldr	r2, [r2, #0]
 1539 09ae 1A60     		str	r2, [r3, #0]
1153:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < *pui32Len; i++)
 1540              		.loc 1 1153 0 discriminator 2
 1541 09b0 FB69     		ldr	r3, [r7, #28]
 1542 09b2 03F10103 		add	r3, r3, #1
 1543 09b6 FB61     		str	r3, [r7, #28]
 1544              	.L79:
1153:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < *pui32Len; i++)
 1545              		.loc 1 1153 0 is_stmt 0 discriminator 1
 1546 09b8 FA69     		ldr	r2, [r7, #28]
 1547 09ba BB68     		ldr	r3, [r7, #8]
 1548 09bc 1B68     		ldr	r3, [r3, #0]
 1549 09be 9A42     		cmp	r2, r3
 1550 09c0 E9D3     		bcc	.L80
1156:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
1157:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1158:bsp/boards/OpenMote-CC2538/source/pka.c ****     return (PKA_STATUS_SUCCESS);
 1551              		.loc 1 1158 0 is_stmt 1
 1552 09c2 4FF00003 		mov	r3, #0
 1553              	.L76:
1159:bsp/boards/OpenMote-CC2538/source/pka.c **** }
 1554              		.loc 1 1159 0
 1555 09c6 1846     		mov	r0, r3
 1556 09c8 07F12407 		add	r7, r7, #36
 1557 09cc BD46     		mov	sp, r7
 1558 09ce 80BC     		pop	{r7}
 1559 09d0 7047     		bx	lr
 1560              		.cfi_endproc
 1561              	.LFE15:
 1563 09d2 00BF     		.align	2
 1564              		.global	PKAECCMultiplyStart
 1565              		.thumb
 1566              		.thumb_func
 1568              	PKAECCMultiplyStart:
 1569              	.LFB16:
1160:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1161:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
1162:bsp/boards/OpenMote-CC2538/source/pka.c **** //
1163:bsp/boards/OpenMote-CC2538/source/pka.c **** //! Starts ECC Multiplication.
1164:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
1165:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param pui32Scalar is pointer to the buffer containing the scalar
1166:bsp/boards/OpenMote-CC2538/source/pka.c **** //! value to be multiplied.
1167:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param ptEcPt is the pointer to the structure containing the
1168:bsp/boards/OpenMote-CC2538/source/pka.c **** //! elliptic curve point to be multiplied.  The point should be on the given
1169:bsp/boards/OpenMote-CC2538/source/pka.c **** //! curve.
1170:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param ptCurve is the pointer to the structure containing the curve
1171:bsp/boards/OpenMote-CC2538/source/pka.c **** //! info.
1172:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param pui32ResultVector is the pointer to the result vector location
1173:bsp/boards/OpenMote-CC2538/source/pka.c **** //! which will be set by this function.
1174:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
1175:bsp/boards/OpenMote-CC2538/source/pka.c **** //! This function starts the Elliptical curve cryptography (ECC) point
1176:bsp/boards/OpenMote-CC2538/source/pka.c **** //! multiplication operation on the EC point and the scalar value.
1177:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
1178:bsp/boards/OpenMote-CC2538/source/pka.c **** //!\return Returns: 
1179:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_SUCCESS if successful in starting the operation.  
1180:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_OPERATION_INPRG, if the PKA hw module is busy doing
1181:bsp/boards/OpenMote-CC2538/source/pka.c **** //! some other operation.
1182:bsp/boards/OpenMote-CC2538/source/pka.c **** //
1183:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
1184:bsp/boards/OpenMote-CC2538/source/pka.c **** tPKAStatus
1185:bsp/boards/OpenMote-CC2538/source/pka.c **** PKAECCMultiplyStart(uint32_t* pui32Scalar, tECPt* ptEcPt,
1186:bsp/boards/OpenMote-CC2538/source/pka.c ****                     tECCCurveInfo* ptCurve, uint32_t* pui32ResultVector)
1187:bsp/boards/OpenMote-CC2538/source/pka.c **** {
 1570              		.loc 1 1187 0
 1571              		.cfi_startproc
 1572              		@ args = 0, pretend = 0, frame = 32
 1573              		@ frame_needed = 1, uses_anonymous_args = 0
 1574              		@ link register save eliminated.
 1575 09d4 80B4     		push	{r7}
 1576              	.LCFI43:
 1577              		.cfi_def_cfa_offset 4
 1578              		.cfi_offset 7, -4
 1579 09d6 89B0     		sub	sp, sp, #36
 1580              	.LCFI44:
 1581              		.cfi_def_cfa_offset 40
 1582 09d8 00AF     		add	r7, sp, #0
 1583              	.LCFI45:
 1584              		.cfi_def_cfa_register 7
 1585 09da F860     		str	r0, [r7, #12]
 1586 09dc B960     		str	r1, [r7, #8]
 1587 09de 7A60     		str	r2, [r7, #4]
 1588 09e0 3B60     		str	r3, [r7, #0]
1188:bsp/boards/OpenMote-CC2538/source/pka.c ****     uint8_t extraBuf;
1189:bsp/boards/OpenMote-CC2538/source/pka.c ****     uint32_t offset;
1190:bsp/boards/OpenMote-CC2538/source/pka.c ****     int i;
1191:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1192:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1193:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Check for the arguments.
1194:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1195:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != pui32Scalar);
1196:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != ptEcPt);
1197:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != ptEcPt->pui32X);
1198:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != ptEcPt->pui32Y);
1199:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != ptCurve);
1200:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(ptCurve->ui8Size <= PKA_MAX_CURVE_SIZE_32_BIT_WORD);
1201:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != pui32ResultVector);
1202:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1203:bsp/boards/OpenMote-CC2538/source/pka.c ****     offset = 0;
 1589              		.loc 1 1203 0
 1590 09e2 4FF00003 		mov	r3, #0
 1591 09e6 BB61     		str	r3, [r7, #24]
1204:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1205:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1206:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Make sure no PKA operation is in progress.
1207:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1208:bsp/boards/OpenMote-CC2538/source/pka.c ****     if((HWREG(PKA_FUNCTION) & PKA_FUNCTION_RUN) != 0)
 1592              		.loc 1 1208 0
 1593 09e8 44F21C03 		movw	r3, #16412
 1594 09ec C4F20043 		movt	r3, 17408
 1595 09f0 1B68     		ldr	r3, [r3, #0]
 1596 09f2 03F40043 		and	r3, r3, #32768
 1597 09f6 002B     		cmp	r3, #0
 1598 09f8 02D0     		beq	.L82
1209:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
1210:bsp/boards/OpenMote-CC2538/source/pka.c ****         return (PKA_STATUS_OPERATION_INPRG);
 1599              		.loc 1 1210 0
 1600 09fa 4FF00703 		mov	r3, #7
 1601 09fe 37E1     		b	.L83
 1602              	.L82:
1211:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
1212:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1213:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1214:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Calculate the extra buffer requirement.
1215:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1216:bsp/boards/OpenMote-CC2538/source/pka.c ****     extraBuf = 2 + ptCurve->ui8Size % 2;
 1603              		.loc 1 1216 0
 1604 0a00 7B68     		ldr	r3, [r7, #4]
 1605 0a02 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 1606 0a04 03F00103 		and	r3, r3, #1
 1607 0a08 DBB2     		uxtb	r3, r3
 1608 0a0a 03F10203 		add	r3, r3, #2
 1609 0a0e FB75     		strb	r3, [r7, #23]
1217:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1218:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1219:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Update the A ptr with the offset address of the PKA RAM location
1220:bsp/boards/OpenMote-CC2538/source/pka.c ****     // where the scalar will be stored.
1221:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1222:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG((PKA_APTR)) = offset >> 2;
 1610              		.loc 1 1222 0
 1611 0a10 4FF48043 		mov	r3, #16384
 1612 0a14 C4F20043 		movt	r3, 17408
 1613 0a18 BA69     		ldr	r2, [r7, #24]
 1614 0a1a 4FEA9202 		lsr	r2, r2, #2
 1615 0a1e 1A60     		str	r2, [r3, #0]
1223:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1224:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1225:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Load the scalar in PKA RAM.
1226:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1227:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 1616              		.loc 1 1227 0
 1617 0a20 4FF00003 		mov	r3, #0
 1618 0a24 FB61     		str	r3, [r7, #28]
 1619 0a26 14E0     		b	.L84
 1620              	.L85:
1228:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
1229:bsp/boards/OpenMote-CC2538/source/pka.c ****         HWREG((PKA_RAM_BASE + offset + 4*i)) = *pui32Scalar++;
 1621              		.loc 1 1229 0 discriminator 2
 1622 0a28 FB69     		ldr	r3, [r7, #28]
 1623 0a2a 4FEA8303 		lsl	r3, r3, #2
 1624 0a2e 1A46     		mov	r2, r3
 1625 0a30 BB69     		ldr	r3, [r7, #24]
 1626 0a32 D318     		adds	r3, r2, r3
 1627 0a34 03F18843 		add	r3, r3, #1140850688
 1628 0a38 03F5C043 		add	r3, r3, #24576
 1629 0a3c FA68     		ldr	r2, [r7, #12]
 1630 0a3e 1268     		ldr	r2, [r2, #0]
 1631 0a40 1A60     		str	r2, [r3, #0]
 1632 0a42 FB68     		ldr	r3, [r7, #12]
 1633 0a44 03F10403 		add	r3, r3, #4
 1634 0a48 FB60     		str	r3, [r7, #12]
1227:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 1635              		.loc 1 1227 0 discriminator 2
 1636 0a4a FB69     		ldr	r3, [r7, #28]
 1637 0a4c 03F10103 		add	r3, r3, #1
 1638 0a50 FB61     		str	r3, [r7, #28]
 1639              	.L84:
1227:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 1640              		.loc 1 1227 0 is_stmt 0 discriminator 1
 1641 0a52 7B68     		ldr	r3, [r7, #4]
 1642 0a54 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 1643 0a56 1A46     		mov	r2, r3
 1644 0a58 FB69     		ldr	r3, [r7, #28]
 1645 0a5a 9A42     		cmp	r2, r3
 1646 0a5c E4DC     		bgt	.L85
1230:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
1231:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1232:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1233:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Determine the offset for the next data.
1234:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1235:bsp/boards/OpenMote-CC2538/source/pka.c ****     offset += 4 * (i + (ptCurve->ui8Size % 2));
 1647              		.loc 1 1235 0 is_stmt 1
 1648 0a5e 7B68     		ldr	r3, [r7, #4]
 1649 0a60 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 1650 0a62 03F00102 		and	r2, r3, #1
 1651 0a66 FB69     		ldr	r3, [r7, #28]
 1652 0a68 D318     		adds	r3, r2, r3
 1653 0a6a 4FEA8303 		lsl	r3, r3, #2
 1654 0a6e BA69     		ldr	r2, [r7, #24]
 1655 0a70 D318     		adds	r3, r2, r3
 1656 0a72 BB61     		str	r3, [r7, #24]
1236:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1237:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1238:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Update the B ptr with the offset address of the PKA RAM location
1239:bsp/boards/OpenMote-CC2538/source/pka.c ****     // where the curve parameters will be stored.
1240:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1241:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG((PKA_BPTR)) = offset >> 2;
 1657              		.loc 1 1241 0
 1658 0a74 44F20403 		movw	r3, #16388
 1659 0a78 C4F20043 		movt	r3, 17408
 1660 0a7c BA69     		ldr	r2, [r7, #24]
 1661 0a7e 4FEA9202 		lsr	r2, r2, #2
 1662 0a82 1A60     		str	r2, [r3, #0]
1242:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1243:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1244:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Write curve parameter 'p' as 1st part of vector B immediately
1245:bsp/boards/OpenMote-CC2538/source/pka.c ****     // following vector A at PKA RAM
1246:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1247:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 1663              		.loc 1 1247 0
 1664 0a84 4FF00003 		mov	r3, #0
 1665 0a88 FB61     		str	r3, [r7, #28]
 1666 0a8a 15E0     		b	.L86
 1667              	.L87:
1248:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
1249:bsp/boards/OpenMote-CC2538/source/pka.c ****         HWREG((PKA_RAM_BASE + offset + 4*i)) =
 1668              		.loc 1 1249 0 discriminator 2
 1669 0a8c FB69     		ldr	r3, [r7, #28]
 1670 0a8e 4FEA8303 		lsl	r3, r3, #2
 1671 0a92 1A46     		mov	r2, r3
 1672 0a94 BB69     		ldr	r3, [r7, #24]
 1673 0a96 D318     		adds	r3, r2, r3
 1674 0a98 03F18843 		add	r3, r3, #1140850688
 1675 0a9c 03F5C043 		add	r3, r3, #24576
1250:bsp/boards/OpenMote-CC2538/source/pka.c ****             (uint32_t)ptCurve->pui32Prime[i];
 1676              		.loc 1 1250 0 discriminator 2
 1677 0aa0 7A68     		ldr	r2, [r7, #4]
 1678 0aa2 9168     		ldr	r1, [r2, #8]
 1679 0aa4 FA69     		ldr	r2, [r7, #28]
 1680 0aa6 4FEA8202 		lsl	r2, r2, #2
 1681 0aaa 8A18     		adds	r2, r1, r2
 1682 0aac 1268     		ldr	r2, [r2, #0]
1249:bsp/boards/OpenMote-CC2538/source/pka.c ****         HWREG((PKA_RAM_BASE + offset + 4*i)) =
 1683              		.loc 1 1249 0 discriminator 2
 1684 0aae 1A60     		str	r2, [r3, #0]
1247:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 1685              		.loc 1 1247 0 discriminator 2
 1686 0ab0 FB69     		ldr	r3, [r7, #28]
 1687 0ab2 03F10103 		add	r3, r3, #1
 1688 0ab6 FB61     		str	r3, [r7, #28]
 1689              	.L86:
1247:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 1690              		.loc 1 1247 0 is_stmt 0 discriminator 1
 1691 0ab8 7B68     		ldr	r3, [r7, #4]
 1692 0aba 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 1693 0abc 1A46     		mov	r2, r3
 1694 0abe FB69     		ldr	r3, [r7, #28]
 1695 0ac0 9A42     		cmp	r2, r3
 1696 0ac2 E3DC     		bgt	.L87
1251:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
1252:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1253:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1254:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Determine the offset for the next data.
1255:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1256:bsp/boards/OpenMote-CC2538/source/pka.c ****     offset += 4 * (i + extraBuf);
 1697              		.loc 1 1256 0 is_stmt 1
 1698 0ac4 FA7D     		ldrb	r2, [r7, #23]	@ zero_extendqisi2
 1699 0ac6 FB69     		ldr	r3, [r7, #28]
 1700 0ac8 D318     		adds	r3, r2, r3
 1701 0aca 4FEA8303 		lsl	r3, r3, #2
 1702 0ace BA69     		ldr	r2, [r7, #24]
 1703 0ad0 D318     		adds	r3, r2, r3
 1704 0ad2 BB61     		str	r3, [r7, #24]
1257:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1258:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1259:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Copy curve parameter 'a' in PKA RAM.
1260:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1261:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 1705              		.loc 1 1261 0
 1706 0ad4 4FF00003 		mov	r3, #0
 1707 0ad8 FB61     		str	r3, [r7, #28]
 1708 0ada 15E0     		b	.L88
 1709              	.L89:
1262:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
1263:bsp/boards/OpenMote-CC2538/source/pka.c ****         HWREG((PKA_RAM_BASE + offset + 4*i)) = (uint32_t)ptCurve->pui32A[i];
 1710              		.loc 1 1263 0 discriminator 2
 1711 0adc FB69     		ldr	r3, [r7, #28]
 1712 0ade 4FEA8303 		lsl	r3, r3, #2
 1713 0ae2 1A46     		mov	r2, r3
 1714 0ae4 BB69     		ldr	r3, [r7, #24]
 1715 0ae6 D318     		adds	r3, r2, r3
 1716 0ae8 03F18843 		add	r3, r3, #1140850688
 1717 0aec 03F5C043 		add	r3, r3, #24576
 1718 0af0 7A68     		ldr	r2, [r7, #4]
 1719 0af2 1169     		ldr	r1, [r2, #16]
 1720 0af4 FA69     		ldr	r2, [r7, #28]
 1721 0af6 4FEA8202 		lsl	r2, r2, #2
 1722 0afa 8A18     		adds	r2, r1, r2
 1723 0afc 1268     		ldr	r2, [r2, #0]
 1724 0afe 1A60     		str	r2, [r3, #0]
1261:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 1725              		.loc 1 1261 0 discriminator 2
 1726 0b00 FB69     		ldr	r3, [r7, #28]
 1727 0b02 03F10103 		add	r3, r3, #1
 1728 0b06 FB61     		str	r3, [r7, #28]
 1729              	.L88:
1261:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 1730              		.loc 1 1261 0 is_stmt 0 discriminator 1
 1731 0b08 7B68     		ldr	r3, [r7, #4]
 1732 0b0a 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 1733 0b0c 1A46     		mov	r2, r3
 1734 0b0e FB69     		ldr	r3, [r7, #28]
 1735 0b10 9A42     		cmp	r2, r3
 1736 0b12 E3DC     		bgt	.L89
1264:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
1265:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1266:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1267:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Determine the offset for the next data.
1268:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1269:bsp/boards/OpenMote-CC2538/source/pka.c ****     offset += 4 * (i + extraBuf);
 1737              		.loc 1 1269 0 is_stmt 1
 1738 0b14 FA7D     		ldrb	r2, [r7, #23]	@ zero_extendqisi2
 1739 0b16 FB69     		ldr	r3, [r7, #28]
 1740 0b18 D318     		adds	r3, r2, r3
 1741 0b1a 4FEA8303 		lsl	r3, r3, #2
 1742 0b1e BA69     		ldr	r2, [r7, #24]
 1743 0b20 D318     		adds	r3, r2, r3
 1744 0b22 BB61     		str	r3, [r7, #24]
1270:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1271:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1272:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Copy curve parameter 'b' in PKA RAM.
1273:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1274:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 1745              		.loc 1 1274 0
 1746 0b24 4FF00003 		mov	r3, #0
 1747 0b28 FB61     		str	r3, [r7, #28]
 1748 0b2a 15E0     		b	.L90
 1749              	.L91:
1275:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
1276:bsp/boards/OpenMote-CC2538/source/pka.c ****         HWREG((PKA_RAM_BASE + offset + 4*i)) = (uint32_t)ptCurve->pui32B[i];
 1750              		.loc 1 1276 0 discriminator 2
 1751 0b2c FB69     		ldr	r3, [r7, #28]
 1752 0b2e 4FEA8303 		lsl	r3, r3, #2
 1753 0b32 1A46     		mov	r2, r3
 1754 0b34 BB69     		ldr	r3, [r7, #24]
 1755 0b36 D318     		adds	r3, r2, r3
 1756 0b38 03F18843 		add	r3, r3, #1140850688
 1757 0b3c 03F5C043 		add	r3, r3, #24576
 1758 0b40 7A68     		ldr	r2, [r7, #4]
 1759 0b42 5169     		ldr	r1, [r2, #20]
 1760 0b44 FA69     		ldr	r2, [r7, #28]
 1761 0b46 4FEA8202 		lsl	r2, r2, #2
 1762 0b4a 8A18     		adds	r2, r1, r2
 1763 0b4c 1268     		ldr	r2, [r2, #0]
 1764 0b4e 1A60     		str	r2, [r3, #0]
1274:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 1765              		.loc 1 1274 0 discriminator 2
 1766 0b50 FB69     		ldr	r3, [r7, #28]
 1767 0b52 03F10103 		add	r3, r3, #1
 1768 0b56 FB61     		str	r3, [r7, #28]
 1769              	.L90:
1274:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 1770              		.loc 1 1274 0 is_stmt 0 discriminator 1
 1771 0b58 7B68     		ldr	r3, [r7, #4]
 1772 0b5a 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 1773 0b5c 1A46     		mov	r2, r3
 1774 0b5e FB69     		ldr	r3, [r7, #28]
 1775 0b60 9A42     		cmp	r2, r3
 1776 0b62 E3DC     		bgt	.L91
1277:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
1278:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1279:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1280:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Determine the offset for the next data.
1281:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1282:bsp/boards/OpenMote-CC2538/source/pka.c ****     offset += 4 * (i + extraBuf);
 1777              		.loc 1 1282 0 is_stmt 1
 1778 0b64 FA7D     		ldrb	r2, [r7, #23]	@ zero_extendqisi2
 1779 0b66 FB69     		ldr	r3, [r7, #28]
 1780 0b68 D318     		adds	r3, r2, r3
 1781 0b6a 4FEA8303 		lsl	r3, r3, #2
 1782 0b6e BA69     		ldr	r2, [r7, #24]
 1783 0b70 D318     		adds	r3, r2, r3
 1784 0b72 BB61     		str	r3, [r7, #24]
1283:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1284:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1285:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Update the C ptr with the offset address of the PKA RAM location
1286:bsp/boards/OpenMote-CC2538/source/pka.c ****     // where the Gx, Gy will be stored.
1287:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1288:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG((PKA_CPTR)) = offset >> 2;
 1785              		.loc 1 1288 0
 1786 0b74 44F20803 		movw	r3, #16392
 1787 0b78 C4F20043 		movt	r3, 17408
 1788 0b7c BA69     		ldr	r2, [r7, #24]
 1789 0b7e 4FEA9202 		lsr	r2, r2, #2
 1790 0b82 1A60     		str	r2, [r3, #0]
1289:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1290:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1291:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Write elliptic curve point x co-ordinate value.
1292:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1293:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 1791              		.loc 1 1293 0
 1792 0b84 4FF00003 		mov	r3, #0
 1793 0b88 FB61     		str	r3, [r7, #28]
 1794 0b8a 15E0     		b	.L92
 1795              	.L93:
1294:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
1295:bsp/boards/OpenMote-CC2538/source/pka.c ****         HWREG((PKA_RAM_BASE + offset + 4*i)) = ptEcPt->pui32X[i];
 1796              		.loc 1 1295 0 discriminator 2
 1797 0b8c FB69     		ldr	r3, [r7, #28]
 1798 0b8e 4FEA8303 		lsl	r3, r3, #2
 1799 0b92 1A46     		mov	r2, r3
 1800 0b94 BB69     		ldr	r3, [r7, #24]
 1801 0b96 D318     		adds	r3, r2, r3
 1802 0b98 03F18843 		add	r3, r3, #1140850688
 1803 0b9c 03F5C043 		add	r3, r3, #24576
 1804 0ba0 BA68     		ldr	r2, [r7, #8]
 1805 0ba2 1168     		ldr	r1, [r2, #0]
 1806 0ba4 FA69     		ldr	r2, [r7, #28]
 1807 0ba6 4FEA8202 		lsl	r2, r2, #2
 1808 0baa 8A18     		adds	r2, r1, r2
 1809 0bac 1268     		ldr	r2, [r2, #0]
 1810 0bae 1A60     		str	r2, [r3, #0]
1293:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 1811              		.loc 1 1293 0 discriminator 2
 1812 0bb0 FB69     		ldr	r3, [r7, #28]
 1813 0bb2 03F10103 		add	r3, r3, #1
 1814 0bb6 FB61     		str	r3, [r7, #28]
 1815              	.L92:
1293:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 1816              		.loc 1 1293 0 is_stmt 0 discriminator 1
 1817 0bb8 7B68     		ldr	r3, [r7, #4]
 1818 0bba 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 1819 0bbc 1A46     		mov	r2, r3
 1820 0bbe FB69     		ldr	r3, [r7, #28]
 1821 0bc0 9A42     		cmp	r2, r3
 1822 0bc2 E3DC     		bgt	.L93
1296:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
1297:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1298:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1299:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Determine the offset for the next data.
1300:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1301:bsp/boards/OpenMote-CC2538/source/pka.c ****     offset += 4 * (i + extraBuf);
 1823              		.loc 1 1301 0 is_stmt 1
 1824 0bc4 FA7D     		ldrb	r2, [r7, #23]	@ zero_extendqisi2
 1825 0bc6 FB69     		ldr	r3, [r7, #28]
 1826 0bc8 D318     		adds	r3, r2, r3
 1827 0bca 4FEA8303 		lsl	r3, r3, #2
 1828 0bce BA69     		ldr	r2, [r7, #24]
 1829 0bd0 D318     		adds	r3, r2, r3
 1830 0bd2 BB61     		str	r3, [r7, #24]
1302:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1303:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1304:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Write elliptic curve point y co-ordinate value.
1305:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1306:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 1831              		.loc 1 1306 0
 1832 0bd4 4FF00003 		mov	r3, #0
 1833 0bd8 FB61     		str	r3, [r7, #28]
 1834 0bda 15E0     		b	.L94
 1835              	.L95:
1307:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
1308:bsp/boards/OpenMote-CC2538/source/pka.c ****         HWREG((PKA_RAM_BASE + offset + 4*i)) = ptEcPt->pui32Y[i];
 1836              		.loc 1 1308 0 discriminator 2
 1837 0bdc FB69     		ldr	r3, [r7, #28]
 1838 0bde 4FEA8303 		lsl	r3, r3, #2
 1839 0be2 1A46     		mov	r2, r3
 1840 0be4 BB69     		ldr	r3, [r7, #24]
 1841 0be6 D318     		adds	r3, r2, r3
 1842 0be8 03F18843 		add	r3, r3, #1140850688
 1843 0bec 03F5C043 		add	r3, r3, #24576
 1844 0bf0 BA68     		ldr	r2, [r7, #8]
 1845 0bf2 5168     		ldr	r1, [r2, #4]
 1846 0bf4 FA69     		ldr	r2, [r7, #28]
 1847 0bf6 4FEA8202 		lsl	r2, r2, #2
 1848 0bfa 8A18     		adds	r2, r1, r2
 1849 0bfc 1268     		ldr	r2, [r2, #0]
 1850 0bfe 1A60     		str	r2, [r3, #0]
1306:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 1851              		.loc 1 1306 0 discriminator 2
 1852 0c00 FB69     		ldr	r3, [r7, #28]
 1853 0c02 03F10103 		add	r3, r3, #1
 1854 0c06 FB61     		str	r3, [r7, #28]
 1855              	.L94:
1306:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 1856              		.loc 1 1306 0 is_stmt 0 discriminator 1
 1857 0c08 7B68     		ldr	r3, [r7, #4]
 1858 0c0a 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 1859 0c0c 1A46     		mov	r2, r3
 1860 0c0e FB69     		ldr	r3, [r7, #28]
 1861 0c10 9A42     		cmp	r2, r3
 1862 0c12 E3DC     		bgt	.L95
1309:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
1310:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1311:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1312:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Determine the offset for the next data.
1313:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1314:bsp/boards/OpenMote-CC2538/source/pka.c ****     offset += 4 * (i + extraBuf);
 1863              		.loc 1 1314 0 is_stmt 1
 1864 0c14 FA7D     		ldrb	r2, [r7, #23]	@ zero_extendqisi2
 1865 0c16 FB69     		ldr	r3, [r7, #28]
 1866 0c18 D318     		adds	r3, r2, r3
 1867 0c1a 4FEA8303 		lsl	r3, r3, #2
 1868 0c1e BA69     		ldr	r2, [r7, #24]
 1869 0c20 D318     		adds	r3, r2, r3
 1870 0c22 BB61     		str	r3, [r7, #24]
1315:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1316:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1317:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Update the result location.
1318:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1319:bsp/boards/OpenMote-CC2538/source/pka.c ****     *pui32ResultVector =  PKA_RAM_BASE + offset;
 1871              		.loc 1 1319 0
 1872 0c24 BB69     		ldr	r3, [r7, #24]
 1873 0c26 03F18843 		add	r3, r3, #1140850688
 1874 0c2a 03F5C043 		add	r3, r3, #24576
 1875 0c2e 3A68     		ldr	r2, [r7, #0]
 1876 0c30 1360     		str	r3, [r2, #0]
1320:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1321:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1322:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Load D ptr with the result location in PKA RAM.
1323:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1324:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG(PKA_DPTR) = offset >> 2;
 1877              		.loc 1 1324 0
 1878 0c32 44F20C03 		movw	r3, #16396
 1879 0c36 C4F20043 		movt	r3, 17408
 1880 0c3a BA69     		ldr	r2, [r7, #24]
 1881 0c3c 4FEA9202 		lsr	r2, r2, #2
 1882 0c40 1A60     		str	r2, [r3, #0]
1325:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1326:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1327:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Load length registers.
1328:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1329:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG(PKA_ALENGTH) = ptCurve->ui8Size;
 1883              		.loc 1 1329 0
 1884 0c42 44F21003 		movw	r3, #16400
 1885 0c46 C4F20043 		movt	r3, 17408
 1886 0c4a 7A68     		ldr	r2, [r7, #4]
 1887 0c4c 1279     		ldrb	r2, [r2, #4]	@ zero_extendqisi2
 1888 0c4e 1A60     		str	r2, [r3, #0]
1330:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG(PKA_BLENGTH) = ptCurve->ui8Size;
 1889              		.loc 1 1330 0
 1890 0c50 44F21403 		movw	r3, #16404
 1891 0c54 C4F20043 		movt	r3, 17408
 1892 0c58 7A68     		ldr	r2, [r7, #4]
 1893 0c5a 1279     		ldrb	r2, [r2, #4]	@ zero_extendqisi2
 1894 0c5c 1A60     		str	r2, [r3, #0]
1331:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1332:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1333:bsp/boards/OpenMote-CC2538/source/pka.c ****     // set the PKA function to ECC-MULT and start the operation.
1334:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1335:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG(PKA_FUNCTION) = 0x0000D000;
 1895              		.loc 1 1335 0
 1896 0c5e 44F21C03 		movw	r3, #16412
 1897 0c62 C4F20043 		movt	r3, 17408
 1898 0c66 4FF45042 		mov	r2, #53248
 1899 0c6a 1A60     		str	r2, [r3, #0]
1336:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1337:bsp/boards/OpenMote-CC2538/source/pka.c ****     return (PKA_STATUS_SUCCESS);
 1900              		.loc 1 1337 0
 1901 0c6c 4FF00003 		mov	r3, #0
 1902              	.L83:
1338:bsp/boards/OpenMote-CC2538/source/pka.c **** }
 1903              		.loc 1 1338 0
 1904 0c70 1846     		mov	r0, r3
 1905 0c72 07F12407 		add	r7, r7, #36
 1906 0c76 BD46     		mov	sp, r7
 1907 0c78 80BC     		pop	{r7}
 1908 0c7a 7047     		bx	lr
 1909              		.cfi_endproc
 1910              	.LFE16:
 1912              		.align	2
 1913              		.global	PKAECCMultiplyGetResult
 1914              		.thumb
 1915              		.thumb_func
 1917              	PKAECCMultiplyGetResult:
 1918              	.LFB17:
1339:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1340:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
1341:bsp/boards/OpenMote-CC2538/source/pka.c **** //
1342:bsp/boards/OpenMote-CC2538/source/pka.c **** //! Gets the result of ECC Multiplication
1343:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
1344:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param ptOutEcPt is the pointer to the structure where the resultant EC
1345:bsp/boards/OpenMote-CC2538/source/pka.c **** //! point will be stored.  The callee is responsible to allocate the space for
1346:bsp/boards/OpenMote-CC2538/source/pka.c **** //! the ec point structure and the x and y co-ordinate as well.
1347:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param ui32ResVectorLoc is the address of the result location which
1348:bsp/boards/OpenMote-CC2538/source/pka.c **** //! was provided by the start function \sa PKAECCMultiplyStart().
1349:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
1350:bsp/boards/OpenMote-CC2538/source/pka.c **** //! This function gets the result of ecc point multiplication operation on the
1351:bsp/boards/OpenMote-CC2538/source/pka.c **** //! ec point and the scalar value, previously started using the function
1352:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \sa PKAECCMultiplyStart().
1353:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
1354:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \return Returns:
1355:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_SUCCESS if the operation is successful. 
1356:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_OPERATION_INPRG, if the PKA hw module is busy performing 
1357:bsp/boards/OpenMote-CC2538/source/pka.c **** //! the operation.
1358:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_RESULT_0 if the result is all zeroes.
1359:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_FAILURE if the operation is not successful.
1360:bsp/boards/OpenMote-CC2538/source/pka.c **** //
1361:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
1362:bsp/boards/OpenMote-CC2538/source/pka.c **** tPKAStatus
1363:bsp/boards/OpenMote-CC2538/source/pka.c **** PKAECCMultiplyGetResult(tECPt* ptOutEcPt, uint32_t ui32ResVectorLoc)
1364:bsp/boards/OpenMote-CC2538/source/pka.c **** {
 1919              		.loc 1 1364 0
 1920              		.cfi_startproc
 1921              		@ args = 0, pretend = 0, frame = 24
 1922              		@ frame_needed = 1, uses_anonymous_args = 0
 1923              		@ link register save eliminated.
 1924 0c7c 80B4     		push	{r7}
 1925              	.LCFI46:
 1926              		.cfi_def_cfa_offset 4
 1927              		.cfi_offset 7, -4
 1928 0c7e 87B0     		sub	sp, sp, #28
 1929              	.LCFI47:
 1930              		.cfi_def_cfa_offset 32
 1931 0c80 00AF     		add	r7, sp, #0
 1932              	.LCFI48:
 1933              		.cfi_def_cfa_register 7
 1934 0c82 7860     		str	r0, [r7, #4]
 1935 0c84 3960     		str	r1, [r7, #0]
1365:bsp/boards/OpenMote-CC2538/source/pka.c ****     int i;
1366:bsp/boards/OpenMote-CC2538/source/pka.c ****     uint32_t addr;
1367:bsp/boards/OpenMote-CC2538/source/pka.c ****     uint32_t regMSWVal;
1368:bsp/boards/OpenMote-CC2538/source/pka.c ****     uint32_t len;
1369:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1370:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1371:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Check for the arguments.
1372:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1373:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != ptOutEcPt);
1374:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != ptOutEcPt->pui32X);
1375:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != ptOutEcPt->pui32Y);
1376:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT((ui32ResVectorLoc > PKA_RAM_BASE) &&
1377:bsp/boards/OpenMote-CC2538/source/pka.c ****            (ui32ResVectorLoc < (PKA_RAM_BASE + PKA_RAM_SIZE)));
1378:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1379:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1380:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Verify that the operation is completed.
1381:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1382:bsp/boards/OpenMote-CC2538/source/pka.c ****     if((HWREG(PKA_FUNCTION) & PKA_FUNCTION_RUN) != 0)
 1936              		.loc 1 1382 0
 1937 0c86 44F21C03 		movw	r3, #16412
 1938 0c8a C4F20043 		movt	r3, 17408
 1939 0c8e 1B68     		ldr	r3, [r3, #0]
 1940 0c90 03F40043 		and	r3, r3, #32768
 1941 0c94 002B     		cmp	r3, #0
 1942 0c96 02D0     		beq	.L97
1383:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
1384:bsp/boards/OpenMote-CC2538/source/pka.c ****         return (PKA_STATUS_OPERATION_INPRG);
 1943              		.loc 1 1384 0
 1944 0c98 4FF00703 		mov	r3, #7
 1945 0c9c 6BE0     		b	.L98
 1946              	.L97:
1385:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
1386:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1387:bsp/boards/OpenMote-CC2538/source/pka.c ****     if(HWREG(PKA_SHIFT) == 0x00000000)
 1947              		.loc 1 1387 0
 1948 0c9e 44F21803 		movw	r3, #16408
 1949 0ca2 C4F20043 		movt	r3, 17408
 1950 0ca6 1B68     		ldr	r3, [r3, #0]
 1951 0ca8 002B     		cmp	r3, #0
 1952 0caa 62D1     		bne	.L99
1388:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
1389:bsp/boards/OpenMote-CC2538/source/pka.c ****         //
1390:bsp/boards/OpenMote-CC2538/source/pka.c ****         // Get the MSW register value.
1391:bsp/boards/OpenMote-CC2538/source/pka.c ****         //
1392:bsp/boards/OpenMote-CC2538/source/pka.c ****         regMSWVal = HWREG(PKA_MSW);
 1953              		.loc 1 1392 0
 1954 0cac 44F22403 		movw	r3, #16420
 1955 0cb0 C4F20043 		movt	r3, 17408
 1956 0cb4 1B68     		ldr	r3, [r3, #0]
 1957 0cb6 3B61     		str	r3, [r7, #16]
1393:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1394:bsp/boards/OpenMote-CC2538/source/pka.c ****         //
1395:bsp/boards/OpenMote-CC2538/source/pka.c ****         // Check to make sure that the result vector is not all zeroes.
1396:bsp/boards/OpenMote-CC2538/source/pka.c ****         //
1397:bsp/boards/OpenMote-CC2538/source/pka.c ****         if(regMSWVal & PKA_MSW_RESULT_IS_ZERO)
 1958              		.loc 1 1397 0
 1959 0cb8 3B69     		ldr	r3, [r7, #16]
 1960 0cba 03F40043 		and	r3, r3, #32768
 1961 0cbe 002B     		cmp	r3, #0
 1962 0cc0 02D0     		beq	.L100
1398:bsp/boards/OpenMote-CC2538/source/pka.c ****         {
1399:bsp/boards/OpenMote-CC2538/source/pka.c ****             return (PKA_STATUS_RESULT_0);
 1963              		.loc 1 1399 0
 1964 0cc2 4FF00403 		mov	r3, #4
 1965 0cc6 56E0     		b	.L98
 1966              	.L100:
1400:bsp/boards/OpenMote-CC2538/source/pka.c ****         }
1401:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1402:bsp/boards/OpenMote-CC2538/source/pka.c ****         //
1403:bsp/boards/OpenMote-CC2538/source/pka.c ****         // Get the length of the result
1404:bsp/boards/OpenMote-CC2538/source/pka.c ****         //
1405:bsp/boards/OpenMote-CC2538/source/pka.c ****         len = ((regMSWVal & PKA_MSW_MSW_ADDRESS_M) + 1) -
 1967              		.loc 1 1405 0
 1968 0cc8 3B69     		ldr	r3, [r7, #16]
 1969 0cca 4FEA4353 		lsl	r3, r3, #21
 1970 0cce 4FEA5353 		lsr	r3, r3, #21
1406:bsp/boards/OpenMote-CC2538/source/pka.c ****               ((ui32ResVectorLoc - PKA_RAM_BASE) >> 2);
 1971              		.loc 1 1406 0
 1972 0cd2 3A68     		ldr	r2, [r7, #0]
 1973 0cd4 02F13C42 		add	r2, r2, #-1140850688
 1974 0cd8 A2F5C042 		sub	r2, r2, #24576
 1975 0cdc 4FEA9202 		lsr	r2, r2, #2
1405:bsp/boards/OpenMote-CC2538/source/pka.c ****         len = ((regMSWVal & PKA_MSW_MSW_ADDRESS_M) + 1) -
 1976              		.loc 1 1405 0
 1977 0ce0 9B1A     		subs	r3, r3, r2
 1978 0ce2 03F10103 		add	r3, r3, #1
 1979 0ce6 FB60     		str	r3, [r7, #12]
1407:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1408:bsp/boards/OpenMote-CC2538/source/pka.c ****         addr = ui32ResVectorLoc;
 1980              		.loc 1 1408 0
 1981 0ce8 3B68     		ldr	r3, [r7, #0]
 1982 0cea BB60     		str	r3, [r7, #8]
1409:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1410:bsp/boards/OpenMote-CC2538/source/pka.c ****         //
1411:bsp/boards/OpenMote-CC2538/source/pka.c ****         // copy the x co-ordinate value of the result from vector D into
1412:bsp/boards/OpenMote-CC2538/source/pka.c ****         // the \e ptOutEcPt.
1413:bsp/boards/OpenMote-CC2538/source/pka.c ****         //
1414:bsp/boards/OpenMote-CC2538/source/pka.c ****         for(i = 0; i < len; i++)
 1983              		.loc 1 1414 0
 1984 0cec 4FF00003 		mov	r3, #0
 1985 0cf0 7B61     		str	r3, [r7, #20]
 1986 0cf2 11E0     		b	.L101
 1987              	.L102:
1415:bsp/boards/OpenMote-CC2538/source/pka.c ****         {
1416:bsp/boards/OpenMote-CC2538/source/pka.c ****             ptOutEcPt->pui32X[i] = HWREG(addr + 4*i);
 1988              		.loc 1 1416 0 discriminator 2
 1989 0cf4 7B68     		ldr	r3, [r7, #4]
 1990 0cf6 1A68     		ldr	r2, [r3, #0]
 1991 0cf8 7B69     		ldr	r3, [r7, #20]
 1992 0cfa 4FEA8303 		lsl	r3, r3, #2
 1993 0cfe D318     		adds	r3, r2, r3
 1994 0d00 7A69     		ldr	r2, [r7, #20]
 1995 0d02 4FEA8202 		lsl	r2, r2, #2
 1996 0d06 1146     		mov	r1, r2
 1997 0d08 BA68     		ldr	r2, [r7, #8]
 1998 0d0a 8A18     		adds	r2, r1, r2
 1999 0d0c 1268     		ldr	r2, [r2, #0]
 2000 0d0e 1A60     		str	r2, [r3, #0]
1414:bsp/boards/OpenMote-CC2538/source/pka.c ****         for(i = 0; i < len; i++)
 2001              		.loc 1 1414 0 discriminator 2
 2002 0d10 7B69     		ldr	r3, [r7, #20]
 2003 0d12 03F10103 		add	r3, r3, #1
 2004 0d16 7B61     		str	r3, [r7, #20]
 2005              	.L101:
1414:bsp/boards/OpenMote-CC2538/source/pka.c ****         for(i = 0; i < len; i++)
 2006              		.loc 1 1414 0 is_stmt 0 discriminator 1
 2007 0d18 7A69     		ldr	r2, [r7, #20]
 2008 0d1a FB68     		ldr	r3, [r7, #12]
 2009 0d1c 9A42     		cmp	r2, r3
 2010 0d1e E9D3     		bcc	.L102
1417:bsp/boards/OpenMote-CC2538/source/pka.c ****         }
1418:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1419:bsp/boards/OpenMote-CC2538/source/pka.c ****         addr += 4 * (i + 2 + len % 2);
 2011              		.loc 1 1419 0 is_stmt 1
 2012 0d20 FB68     		ldr	r3, [r7, #12]
 2013 0d22 03F00102 		and	r2, r3, #1
 2014 0d26 7B69     		ldr	r3, [r7, #20]
 2015 0d28 D318     		adds	r3, r2, r3
 2016 0d2a 03F10203 		add	r3, r3, #2
 2017 0d2e 4FEA8303 		lsl	r3, r3, #2
 2018 0d32 BA68     		ldr	r2, [r7, #8]
 2019 0d34 D318     		adds	r3, r2, r3
 2020 0d36 BB60     		str	r3, [r7, #8]
1420:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1421:bsp/boards/OpenMote-CC2538/source/pka.c ****         //
1422:bsp/boards/OpenMote-CC2538/source/pka.c ****         // copy the y co-ordinate value of the result from vector D into
1423:bsp/boards/OpenMote-CC2538/source/pka.c ****         // the \e ptOutEcPt.
1424:bsp/boards/OpenMote-CC2538/source/pka.c ****         //
1425:bsp/boards/OpenMote-CC2538/source/pka.c ****         for(i = 0; i < len; i++)
 2021              		.loc 1 1425 0
 2022 0d38 4FF00003 		mov	r3, #0
 2023 0d3c 7B61     		str	r3, [r7, #20]
 2024 0d3e 11E0     		b	.L103
 2025              	.L104:
1426:bsp/boards/OpenMote-CC2538/source/pka.c ****         {
1427:bsp/boards/OpenMote-CC2538/source/pka.c ****             ptOutEcPt->pui32Y[i] = HWREG(addr + 4*i);
 2026              		.loc 1 1427 0 discriminator 2
 2027 0d40 7B68     		ldr	r3, [r7, #4]
 2028 0d42 5A68     		ldr	r2, [r3, #4]
 2029 0d44 7B69     		ldr	r3, [r7, #20]
 2030 0d46 4FEA8303 		lsl	r3, r3, #2
 2031 0d4a D318     		adds	r3, r2, r3
 2032 0d4c 7A69     		ldr	r2, [r7, #20]
 2033 0d4e 4FEA8202 		lsl	r2, r2, #2
 2034 0d52 1146     		mov	r1, r2
 2035 0d54 BA68     		ldr	r2, [r7, #8]
 2036 0d56 8A18     		adds	r2, r1, r2
 2037 0d58 1268     		ldr	r2, [r2, #0]
 2038 0d5a 1A60     		str	r2, [r3, #0]
1425:bsp/boards/OpenMote-CC2538/source/pka.c ****         for(i = 0; i < len; i++)
 2039              		.loc 1 1425 0 discriminator 2
 2040 0d5c 7B69     		ldr	r3, [r7, #20]
 2041 0d5e 03F10103 		add	r3, r3, #1
 2042 0d62 7B61     		str	r3, [r7, #20]
 2043              	.L103:
1425:bsp/boards/OpenMote-CC2538/source/pka.c ****         for(i = 0; i < len; i++)
 2044              		.loc 1 1425 0 is_stmt 0 discriminator 1
 2045 0d64 7A69     		ldr	r2, [r7, #20]
 2046 0d66 FB68     		ldr	r3, [r7, #12]
 2047 0d68 9A42     		cmp	r2, r3
 2048 0d6a E9D3     		bcc	.L104
1428:bsp/boards/OpenMote-CC2538/source/pka.c ****         }
1429:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1430:bsp/boards/OpenMote-CC2538/source/pka.c ****         return (PKA_STATUS_SUCCESS);
 2049              		.loc 1 1430 0 is_stmt 1
 2050 0d6c 4FF00003 		mov	r3, #0
 2051 0d70 01E0     		b	.L98
 2052              	.L99:
1431:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
1432:bsp/boards/OpenMote-CC2538/source/pka.c ****     else
1433:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
1434:bsp/boards/OpenMote-CC2538/source/pka.c ****         return (PKA_STATUS_FAILURE);
 2053              		.loc 1 1434 0
 2054 0d72 4FF00103 		mov	r3, #1
 2055              	.L98:
1435:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
1436:bsp/boards/OpenMote-CC2538/source/pka.c **** }
 2056              		.loc 1 1436 0
 2057 0d76 1846     		mov	r0, r3
 2058 0d78 07F11C07 		add	r7, r7, #28
 2059 0d7c BD46     		mov	sp, r7
 2060 0d7e 80BC     		pop	{r7}
 2061 0d80 7047     		bx	lr
 2062              		.cfi_endproc
 2063              	.LFE17:
 2065 0d82 00BF     		.align	2
 2066              		.global	PKAECCMultGenPtStart
 2067              		.thumb
 2068              		.thumb_func
 2070              	PKAECCMultGenPtStart:
 2071              	.LFB18:
1437:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1438:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
1439:bsp/boards/OpenMote-CC2538/source/pka.c **** //
1440:bsp/boards/OpenMote-CC2538/source/pka.c **** //! Starts the ECC Multiplication with Generator point.
1441:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
1442:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param pui32Scalar is the to pointer to the buffer containing the scalar
1443:bsp/boards/OpenMote-CC2538/source/pka.c **** //! value.
1444:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param ptCurve is the pointer to the structure containing the curve
1445:bsp/boards/OpenMote-CC2538/source/pka.c **** //! info.
1446:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param pui32ResultVector is the pointer to the result vector location
1447:bsp/boards/OpenMote-CC2538/source/pka.c **** //! which will be set by this function.
1448:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
1449:bsp/boards/OpenMote-CC2538/source/pka.c **** //! This function starts the ecc point multiplication operation of the
1450:bsp/boards/OpenMote-CC2538/source/pka.c **** //! scalar value with the well known generator point of the given curve.
1451:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
1452:bsp/boards/OpenMote-CC2538/source/pka.c **** //!\return Returns: 
1453:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_SUCCESS if successful in starting the operation.  
1454:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_OPERATION_INPRG, if the PKA hw module is busy doing
1455:bsp/boards/OpenMote-CC2538/source/pka.c **** //! some other operation.
1456:bsp/boards/OpenMote-CC2538/source/pka.c **** //
1457:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
1458:bsp/boards/OpenMote-CC2538/source/pka.c **** tPKAStatus
1459:bsp/boards/OpenMote-CC2538/source/pka.c **** PKAECCMultGenPtStart(uint32_t* pui32Scalar, tECCCurveInfo* ptCurve,
1460:bsp/boards/OpenMote-CC2538/source/pka.c ****                      uint32_t* pui32ResultVector)
1461:bsp/boards/OpenMote-CC2538/source/pka.c **** {
 2072              		.loc 1 1461 0
 2073              		.cfi_startproc
 2074              		@ args = 0, pretend = 0, frame = 32
 2075              		@ frame_needed = 1, uses_anonymous_args = 0
 2076              		@ link register save eliminated.
 2077 0d84 80B4     		push	{r7}
 2078              	.LCFI49:
 2079              		.cfi_def_cfa_offset 4
 2080              		.cfi_offset 7, -4
 2081 0d86 89B0     		sub	sp, sp, #36
 2082              	.LCFI50:
 2083              		.cfi_def_cfa_offset 40
 2084 0d88 00AF     		add	r7, sp, #0
 2085              	.LCFI51:
 2086              		.cfi_def_cfa_register 7
 2087 0d8a F860     		str	r0, [r7, #12]
 2088 0d8c B960     		str	r1, [r7, #8]
 2089 0d8e 7A60     		str	r2, [r7, #4]
1462:bsp/boards/OpenMote-CC2538/source/pka.c ****     uint8_t extraBuf;
1463:bsp/boards/OpenMote-CC2538/source/pka.c ****     uint32_t offset;
1464:bsp/boards/OpenMote-CC2538/source/pka.c ****     int i;
1465:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1466:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1467:bsp/boards/OpenMote-CC2538/source/pka.c ****     // check for the arguments.
1468:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1469:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != pui32Scalar);
1470:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != ptCurve);
1471:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(ptCurve->ui8Size <= PKA_MAX_CURVE_SIZE_32_BIT_WORD);
1472:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != pui32ResultVector);
1473:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1474:bsp/boards/OpenMote-CC2538/source/pka.c ****     offset = 0;
 2090              		.loc 1 1474 0
 2091 0d90 4FF00003 		mov	r3, #0
 2092 0d94 BB61     		str	r3, [r7, #24]
1475:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1476:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1477:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Make sure no operation is in progress.
1478:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1479:bsp/boards/OpenMote-CC2538/source/pka.c ****     if((HWREG(PKA_FUNCTION) & PKA_FUNCTION_RUN) != 0)
 2093              		.loc 1 1479 0
 2094 0d96 44F21C03 		movw	r3, #16412
 2095 0d9a C4F20043 		movt	r3, 17408
 2096 0d9e 1B68     		ldr	r3, [r3, #0]
 2097 0da0 03F40043 		and	r3, r3, #32768
 2098 0da4 002B     		cmp	r3, #0
 2099 0da6 02D0     		beq	.L106
1480:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
1481:bsp/boards/OpenMote-CC2538/source/pka.c ****         return (PKA_STATUS_OPERATION_INPRG);
 2100              		.loc 1 1481 0
 2101 0da8 4FF00703 		mov	r3, #7
 2102 0dac 37E1     		b	.L107
 2103              	.L106:
1482:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
1483:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1484:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1485:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Calculate the extra buffer requirement.
1486:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1487:bsp/boards/OpenMote-CC2538/source/pka.c ****     extraBuf = 2 + ptCurve->ui8Size % 2;
 2104              		.loc 1 1487 0
 2105 0dae BB68     		ldr	r3, [r7, #8]
 2106 0db0 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2107 0db2 03F00103 		and	r3, r3, #1
 2108 0db6 DBB2     		uxtb	r3, r3
 2109 0db8 03F10203 		add	r3, r3, #2
 2110 0dbc FB75     		strb	r3, [r7, #23]
1488:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1489:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1490:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Update the A ptr with the offset address of the PKA RAM location
1491:bsp/boards/OpenMote-CC2538/source/pka.c ****     // where the scalar will be stored.
1492:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1493:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG(PKA_APTR) = offset >> 2;
 2111              		.loc 1 1493 0
 2112 0dbe 4FF48043 		mov	r3, #16384
 2113 0dc2 C4F20043 		movt	r3, 17408
 2114 0dc6 BA69     		ldr	r2, [r7, #24]
 2115 0dc8 4FEA9202 		lsr	r2, r2, #2
 2116 0dcc 1A60     		str	r2, [r3, #0]
1494:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1495:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1496:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Load the scalar in PKA RAM.
1497:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1498:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 2117              		.loc 1 1498 0
 2118 0dce 4FF00003 		mov	r3, #0
 2119 0dd2 FB61     		str	r3, [r7, #28]
 2120 0dd4 14E0     		b	.L108
 2121              	.L109:
1499:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
1500:bsp/boards/OpenMote-CC2538/source/pka.c ****         HWREG((PKA_RAM_BASE + offset + 4*i)) = *pui32Scalar++;
 2122              		.loc 1 1500 0 discriminator 2
 2123 0dd6 FB69     		ldr	r3, [r7, #28]
 2124 0dd8 4FEA8303 		lsl	r3, r3, #2
 2125 0ddc 1A46     		mov	r2, r3
 2126 0dde BB69     		ldr	r3, [r7, #24]
 2127 0de0 D318     		adds	r3, r2, r3
 2128 0de2 03F18843 		add	r3, r3, #1140850688
 2129 0de6 03F5C043 		add	r3, r3, #24576
 2130 0dea FA68     		ldr	r2, [r7, #12]
 2131 0dec 1268     		ldr	r2, [r2, #0]
 2132 0dee 1A60     		str	r2, [r3, #0]
 2133 0df0 FB68     		ldr	r3, [r7, #12]
 2134 0df2 03F10403 		add	r3, r3, #4
 2135 0df6 FB60     		str	r3, [r7, #12]
1498:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 2136              		.loc 1 1498 0 discriminator 2
 2137 0df8 FB69     		ldr	r3, [r7, #28]
 2138 0dfa 03F10103 		add	r3, r3, #1
 2139 0dfe FB61     		str	r3, [r7, #28]
 2140              	.L108:
1498:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 2141              		.loc 1 1498 0 is_stmt 0 discriminator 1
 2142 0e00 BB68     		ldr	r3, [r7, #8]
 2143 0e02 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2144 0e04 1A46     		mov	r2, r3
 2145 0e06 FB69     		ldr	r3, [r7, #28]
 2146 0e08 9A42     		cmp	r2, r3
 2147 0e0a E4DC     		bgt	.L109
1501:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
1502:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1503:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1504:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Determine the offset in PKA RAM for the next data.
1505:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1506:bsp/boards/OpenMote-CC2538/source/pka.c ****     offset += 4 * (i + (ptCurve->ui8Size % 2));
 2148              		.loc 1 1506 0 is_stmt 1
 2149 0e0c BB68     		ldr	r3, [r7, #8]
 2150 0e0e 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2151 0e10 03F00102 		and	r2, r3, #1
 2152 0e14 FB69     		ldr	r3, [r7, #28]
 2153 0e16 D318     		adds	r3, r2, r3
 2154 0e18 4FEA8303 		lsl	r3, r3, #2
 2155 0e1c BA69     		ldr	r2, [r7, #24]
 2156 0e1e D318     		adds	r3, r2, r3
 2157 0e20 BB61     		str	r3, [r7, #24]
1507:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1508:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1509:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Update the B ptr with the offset address of the PKA RAM location
1510:bsp/boards/OpenMote-CC2538/source/pka.c ****     // where the curve parameters will be stored.
1511:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1512:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG(PKA_BPTR) = offset >> 2;
 2158              		.loc 1 1512 0
 2159 0e22 44F20403 		movw	r3, #16388
 2160 0e26 C4F20043 		movt	r3, 17408
 2161 0e2a BA69     		ldr	r2, [r7, #24]
 2162 0e2c 4FEA9202 		lsr	r2, r2, #2
 2163 0e30 1A60     		str	r2, [r3, #0]
1513:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1514:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1515:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Write curve parameter 'p' as 1st part of vector B.
1516:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1517:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 2164              		.loc 1 1517 0
 2165 0e32 4FF00003 		mov	r3, #0
 2166 0e36 FB61     		str	r3, [r7, #28]
 2167 0e38 15E0     		b	.L110
 2168              	.L111:
1518:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
1519:bsp/boards/OpenMote-CC2538/source/pka.c ****         HWREG((PKA_RAM_BASE + offset + 4*i)) =
 2169              		.loc 1 1519 0 discriminator 2
 2170 0e3a FB69     		ldr	r3, [r7, #28]
 2171 0e3c 4FEA8303 		lsl	r3, r3, #2
 2172 0e40 1A46     		mov	r2, r3
 2173 0e42 BB69     		ldr	r3, [r7, #24]
 2174 0e44 D318     		adds	r3, r2, r3
 2175 0e46 03F18843 		add	r3, r3, #1140850688
 2176 0e4a 03F5C043 		add	r3, r3, #24576
1520:bsp/boards/OpenMote-CC2538/source/pka.c ****             (uint32_t)ptCurve->pui32Prime[i];
 2177              		.loc 1 1520 0 discriminator 2
 2178 0e4e BA68     		ldr	r2, [r7, #8]
 2179 0e50 9168     		ldr	r1, [r2, #8]
 2180 0e52 FA69     		ldr	r2, [r7, #28]
 2181 0e54 4FEA8202 		lsl	r2, r2, #2
 2182 0e58 8A18     		adds	r2, r1, r2
 2183 0e5a 1268     		ldr	r2, [r2, #0]
1519:bsp/boards/OpenMote-CC2538/source/pka.c ****         HWREG((PKA_RAM_BASE + offset + 4*i)) =
 2184              		.loc 1 1519 0 discriminator 2
 2185 0e5c 1A60     		str	r2, [r3, #0]
1517:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 2186              		.loc 1 1517 0 discriminator 2
 2187 0e5e FB69     		ldr	r3, [r7, #28]
 2188 0e60 03F10103 		add	r3, r3, #1
 2189 0e64 FB61     		str	r3, [r7, #28]
 2190              	.L110:
1517:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 2191              		.loc 1 1517 0 is_stmt 0 discriminator 1
 2192 0e66 BB68     		ldr	r3, [r7, #8]
 2193 0e68 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2194 0e6a 1A46     		mov	r2, r3
 2195 0e6c FB69     		ldr	r3, [r7, #28]
 2196 0e6e 9A42     		cmp	r2, r3
 2197 0e70 E3DC     		bgt	.L111
1521:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
1522:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1523:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1524:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Determine the offset in PKA RAM for the next data.
1525:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1526:bsp/boards/OpenMote-CC2538/source/pka.c ****     offset += 4 * (i + extraBuf);
 2198              		.loc 1 1526 0 is_stmt 1
 2199 0e72 FA7D     		ldrb	r2, [r7, #23]	@ zero_extendqisi2
 2200 0e74 FB69     		ldr	r3, [r7, #28]
 2201 0e76 D318     		adds	r3, r2, r3
 2202 0e78 4FEA8303 		lsl	r3, r3, #2
 2203 0e7c BA69     		ldr	r2, [r7, #24]
 2204 0e7e D318     		adds	r3, r2, r3
 2205 0e80 BB61     		str	r3, [r7, #24]
1527:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1528:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1529:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Write curve parameter 'a' in PKA RAM.
1530:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1531:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 2206              		.loc 1 1531 0
 2207 0e82 4FF00003 		mov	r3, #0
 2208 0e86 FB61     		str	r3, [r7, #28]
 2209 0e88 15E0     		b	.L112
 2210              	.L113:
1532:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
1533:bsp/boards/OpenMote-CC2538/source/pka.c ****         HWREG((PKA_RAM_BASE + offset + 4*i)) = (uint32_t)ptCurve->pui32A[i];
 2211              		.loc 1 1533 0 discriminator 2
 2212 0e8a FB69     		ldr	r3, [r7, #28]
 2213 0e8c 4FEA8303 		lsl	r3, r3, #2
 2214 0e90 1A46     		mov	r2, r3
 2215 0e92 BB69     		ldr	r3, [r7, #24]
 2216 0e94 D318     		adds	r3, r2, r3
 2217 0e96 03F18843 		add	r3, r3, #1140850688
 2218 0e9a 03F5C043 		add	r3, r3, #24576
 2219 0e9e BA68     		ldr	r2, [r7, #8]
 2220 0ea0 1169     		ldr	r1, [r2, #16]
 2221 0ea2 FA69     		ldr	r2, [r7, #28]
 2222 0ea4 4FEA8202 		lsl	r2, r2, #2
 2223 0ea8 8A18     		adds	r2, r1, r2
 2224 0eaa 1268     		ldr	r2, [r2, #0]
 2225 0eac 1A60     		str	r2, [r3, #0]
1531:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 2226              		.loc 1 1531 0 discriminator 2
 2227 0eae FB69     		ldr	r3, [r7, #28]
 2228 0eb0 03F10103 		add	r3, r3, #1
 2229 0eb4 FB61     		str	r3, [r7, #28]
 2230              	.L112:
1531:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 2231              		.loc 1 1531 0 is_stmt 0 discriminator 1
 2232 0eb6 BB68     		ldr	r3, [r7, #8]
 2233 0eb8 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2234 0eba 1A46     		mov	r2, r3
 2235 0ebc FB69     		ldr	r3, [r7, #28]
 2236 0ebe 9A42     		cmp	r2, r3
 2237 0ec0 E3DC     		bgt	.L113
1534:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
1535:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1536:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1537:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Determine the offset in PKA RAM for the next data.
1538:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1539:bsp/boards/OpenMote-CC2538/source/pka.c ****     offset += 4 * (i + extraBuf);
 2238              		.loc 1 1539 0 is_stmt 1
 2239 0ec2 FA7D     		ldrb	r2, [r7, #23]	@ zero_extendqisi2
 2240 0ec4 FB69     		ldr	r3, [r7, #28]
 2241 0ec6 D318     		adds	r3, r2, r3
 2242 0ec8 4FEA8303 		lsl	r3, r3, #2
 2243 0ecc BA69     		ldr	r2, [r7, #24]
 2244 0ece D318     		adds	r3, r2, r3
 2245 0ed0 BB61     		str	r3, [r7, #24]
1540:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1541:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1542:bsp/boards/OpenMote-CC2538/source/pka.c ****     // write curve parameter 'b' in PKA RAM.
1543:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1544:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 2246              		.loc 1 1544 0
 2247 0ed2 4FF00003 		mov	r3, #0
 2248 0ed6 FB61     		str	r3, [r7, #28]
 2249 0ed8 15E0     		b	.L114
 2250              	.L115:
1545:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
1546:bsp/boards/OpenMote-CC2538/source/pka.c ****         HWREG((PKA_RAM_BASE + offset + 4*i)) = (uint32_t)ptCurve->pui32B[i];
 2251              		.loc 1 1546 0 discriminator 2
 2252 0eda FB69     		ldr	r3, [r7, #28]
 2253 0edc 4FEA8303 		lsl	r3, r3, #2
 2254 0ee0 1A46     		mov	r2, r3
 2255 0ee2 BB69     		ldr	r3, [r7, #24]
 2256 0ee4 D318     		adds	r3, r2, r3
 2257 0ee6 03F18843 		add	r3, r3, #1140850688
 2258 0eea 03F5C043 		add	r3, r3, #24576
 2259 0eee BA68     		ldr	r2, [r7, #8]
 2260 0ef0 5169     		ldr	r1, [r2, #20]
 2261 0ef2 FA69     		ldr	r2, [r7, #28]
 2262 0ef4 4FEA8202 		lsl	r2, r2, #2
 2263 0ef8 8A18     		adds	r2, r1, r2
 2264 0efa 1268     		ldr	r2, [r2, #0]
 2265 0efc 1A60     		str	r2, [r3, #0]
1544:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 2266              		.loc 1 1544 0 discriminator 2
 2267 0efe FB69     		ldr	r3, [r7, #28]
 2268 0f00 03F10103 		add	r3, r3, #1
 2269 0f04 FB61     		str	r3, [r7, #28]
 2270              	.L114:
1544:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 2271              		.loc 1 1544 0 is_stmt 0 discriminator 1
 2272 0f06 BB68     		ldr	r3, [r7, #8]
 2273 0f08 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2274 0f0a 1A46     		mov	r2, r3
 2275 0f0c FB69     		ldr	r3, [r7, #28]
 2276 0f0e 9A42     		cmp	r2, r3
 2277 0f10 E3DC     		bgt	.L115
1547:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
1548:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1549:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1550:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Determine the offset in PKA RAM for the next data.
1551:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1552:bsp/boards/OpenMote-CC2538/source/pka.c ****     offset += 4 * (i + extraBuf);
 2278              		.loc 1 1552 0 is_stmt 1
 2279 0f12 FA7D     		ldrb	r2, [r7, #23]	@ zero_extendqisi2
 2280 0f14 FB69     		ldr	r3, [r7, #28]
 2281 0f16 D318     		adds	r3, r2, r3
 2282 0f18 4FEA8303 		lsl	r3, r3, #2
 2283 0f1c BA69     		ldr	r2, [r7, #24]
 2284 0f1e D318     		adds	r3, r2, r3
 2285 0f20 BB61     		str	r3, [r7, #24]
1553:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1554:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1555:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Update the C ptr with the offset address of the PKA RAM location
1556:bsp/boards/OpenMote-CC2538/source/pka.c ****     // where the Gx, Gy will be stored.
1557:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1558:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG(PKA_CPTR) = offset >> 2;
 2286              		.loc 1 1558 0
 2287 0f22 44F20803 		movw	r3, #16392
 2288 0f26 C4F20043 		movt	r3, 17408
 2289 0f2a BA69     		ldr	r2, [r7, #24]
 2290 0f2c 4FEA9202 		lsr	r2, r2, #2
 2291 0f30 1A60     		str	r2, [r3, #0]
1559:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1560:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1561:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Write x co-ordinate value of the Generator point in PKA RAM.
1562:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1563:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 2292              		.loc 1 1563 0
 2293 0f32 4FF00003 		mov	r3, #0
 2294 0f36 FB61     		str	r3, [r7, #28]
 2295 0f38 15E0     		b	.L116
 2296              	.L117:
1564:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
1565:bsp/boards/OpenMote-CC2538/source/pka.c ****         HWREG((PKA_RAM_BASE + offset + 4*i)) = (uint32_t)ptCurve->pui32Gx[i];
 2297              		.loc 1 1565 0 discriminator 2
 2298 0f3a FB69     		ldr	r3, [r7, #28]
 2299 0f3c 4FEA8303 		lsl	r3, r3, #2
 2300 0f40 1A46     		mov	r2, r3
 2301 0f42 BB69     		ldr	r3, [r7, #24]
 2302 0f44 D318     		adds	r3, r2, r3
 2303 0f46 03F18843 		add	r3, r3, #1140850688
 2304 0f4a 03F5C043 		add	r3, r3, #24576
 2305 0f4e BA68     		ldr	r2, [r7, #8]
 2306 0f50 9169     		ldr	r1, [r2, #24]
 2307 0f52 FA69     		ldr	r2, [r7, #28]
 2308 0f54 4FEA8202 		lsl	r2, r2, #2
 2309 0f58 8A18     		adds	r2, r1, r2
 2310 0f5a 1268     		ldr	r2, [r2, #0]
 2311 0f5c 1A60     		str	r2, [r3, #0]
1563:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 2312              		.loc 1 1563 0 discriminator 2
 2313 0f5e FB69     		ldr	r3, [r7, #28]
 2314 0f60 03F10103 		add	r3, r3, #1
 2315 0f64 FB61     		str	r3, [r7, #28]
 2316              	.L116:
1563:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 2317              		.loc 1 1563 0 is_stmt 0 discriminator 1
 2318 0f66 BB68     		ldr	r3, [r7, #8]
 2319 0f68 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2320 0f6a 1A46     		mov	r2, r3
 2321 0f6c FB69     		ldr	r3, [r7, #28]
 2322 0f6e 9A42     		cmp	r2, r3
 2323 0f70 E3DC     		bgt	.L117
1566:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
1567:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1568:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1569:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Determine the offset in PKA RAM for the next data.
1570:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1571:bsp/boards/OpenMote-CC2538/source/pka.c ****     offset += 4 * (i + extraBuf);
 2324              		.loc 1 1571 0 is_stmt 1
 2325 0f72 FA7D     		ldrb	r2, [r7, #23]	@ zero_extendqisi2
 2326 0f74 FB69     		ldr	r3, [r7, #28]
 2327 0f76 D318     		adds	r3, r2, r3
 2328 0f78 4FEA8303 		lsl	r3, r3, #2
 2329 0f7c BA69     		ldr	r2, [r7, #24]
 2330 0f7e D318     		adds	r3, r2, r3
 2331 0f80 BB61     		str	r3, [r7, #24]
1572:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1573:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1574:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Write y co-ordinate value of the Generator point in PKA RAM.
1575:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1576:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 2332              		.loc 1 1576 0
 2333 0f82 4FF00003 		mov	r3, #0
 2334 0f86 FB61     		str	r3, [r7, #28]
 2335 0f88 15E0     		b	.L118
 2336              	.L119:
1577:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
1578:bsp/boards/OpenMote-CC2538/source/pka.c ****         HWREG((PKA_RAM_BASE + offset + 4*i)) = (uint32_t)ptCurve->pui32Gy[i];
 2337              		.loc 1 1578 0 discriminator 2
 2338 0f8a FB69     		ldr	r3, [r7, #28]
 2339 0f8c 4FEA8303 		lsl	r3, r3, #2
 2340 0f90 1A46     		mov	r2, r3
 2341 0f92 BB69     		ldr	r3, [r7, #24]
 2342 0f94 D318     		adds	r3, r2, r3
 2343 0f96 03F18843 		add	r3, r3, #1140850688
 2344 0f9a 03F5C043 		add	r3, r3, #24576
 2345 0f9e BA68     		ldr	r2, [r7, #8]
 2346 0fa0 D169     		ldr	r1, [r2, #28]
 2347 0fa2 FA69     		ldr	r2, [r7, #28]
 2348 0fa4 4FEA8202 		lsl	r2, r2, #2
 2349 0fa8 8A18     		adds	r2, r1, r2
 2350 0faa 1268     		ldr	r2, [r2, #0]
 2351 0fac 1A60     		str	r2, [r3, #0]
1576:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 2352              		.loc 1 1576 0 discriminator 2
 2353 0fae FB69     		ldr	r3, [r7, #28]
 2354 0fb0 03F10103 		add	r3, r3, #1
 2355 0fb4 FB61     		str	r3, [r7, #28]
 2356              	.L118:
1576:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 2357              		.loc 1 1576 0 is_stmt 0 discriminator 1
 2358 0fb6 BB68     		ldr	r3, [r7, #8]
 2359 0fb8 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2360 0fba 1A46     		mov	r2, r3
 2361 0fbc FB69     		ldr	r3, [r7, #28]
 2362 0fbe 9A42     		cmp	r2, r3
 2363 0fc0 E3DC     		bgt	.L119
1579:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
1580:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1581:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1582:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Determine the offset in PKA RAM for the next data.
1583:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1584:bsp/boards/OpenMote-CC2538/source/pka.c ****     offset += 4 * (i + extraBuf);
 2364              		.loc 1 1584 0 is_stmt 1
 2365 0fc2 FA7D     		ldrb	r2, [r7, #23]	@ zero_extendqisi2
 2366 0fc4 FB69     		ldr	r3, [r7, #28]
 2367 0fc6 D318     		adds	r3, r2, r3
 2368 0fc8 4FEA8303 		lsl	r3, r3, #2
 2369 0fcc BA69     		ldr	r2, [r7, #24]
 2370 0fce D318     		adds	r3, r2, r3
 2371 0fd0 BB61     		str	r3, [r7, #24]
1585:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1586:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1587:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Update the result location.
1588:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1589:bsp/boards/OpenMote-CC2538/source/pka.c ****     *pui32ResultVector =  PKA_RAM_BASE + offset;
 2372              		.loc 1 1589 0
 2373 0fd2 BB69     		ldr	r3, [r7, #24]
 2374 0fd4 03F18843 		add	r3, r3, #1140850688
 2375 0fd8 03F5C043 		add	r3, r3, #24576
 2376 0fdc 7A68     		ldr	r2, [r7, #4]
 2377 0fde 1360     		str	r3, [r2, #0]
1590:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1591:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1592:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Load D ptr with the result location in PKA RAM.
1593:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1594:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG(PKA_DPTR) = offset >> 2;
 2378              		.loc 1 1594 0
 2379 0fe0 44F20C03 		movw	r3, #16396
 2380 0fe4 C4F20043 		movt	r3, 17408
 2381 0fe8 BA69     		ldr	r2, [r7, #24]
 2382 0fea 4FEA9202 		lsr	r2, r2, #2
 2383 0fee 1A60     		str	r2, [r3, #0]
1595:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1596:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1597:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Load length registers.
1598:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1599:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG(PKA_ALENGTH) = ptCurve->ui8Size;
 2384              		.loc 1 1599 0
 2385 0ff0 44F21003 		movw	r3, #16400
 2386 0ff4 C4F20043 		movt	r3, 17408
 2387 0ff8 BA68     		ldr	r2, [r7, #8]
 2388 0ffa 1279     		ldrb	r2, [r2, #4]	@ zero_extendqisi2
 2389 0ffc 1A60     		str	r2, [r3, #0]
1600:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG(PKA_BLENGTH) = ptCurve->ui8Size;
 2390              		.loc 1 1600 0
 2391 0ffe 44F21403 		movw	r3, #16404
 2392 1002 C4F20043 		movt	r3, 17408
 2393 1006 BA68     		ldr	r2, [r7, #8]
 2394 1008 1279     		ldrb	r2, [r2, #4]	@ zero_extendqisi2
 2395 100a 1A60     		str	r2, [r3, #0]
1601:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1602:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1603:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Set the PKA function to ECC-MULT and start the operation.
1604:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1605:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG( (PKA_FUNCTION) ) = 0x0000D000;
 2396              		.loc 1 1605 0
 2397 100c 44F21C03 		movw	r3, #16412
 2398 1010 C4F20043 		movt	r3, 17408
 2399 1014 4FF45042 		mov	r2, #53248
 2400 1018 1A60     		str	r2, [r3, #0]
1606:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1607:bsp/boards/OpenMote-CC2538/source/pka.c ****     return (PKA_STATUS_SUCCESS);
 2401              		.loc 1 1607 0
 2402 101a 4FF00003 		mov	r3, #0
 2403              	.L107:
1608:bsp/boards/OpenMote-CC2538/source/pka.c **** }
 2404              		.loc 1 1608 0
 2405 101e 1846     		mov	r0, r3
 2406 1020 07F12407 		add	r7, r7, #36
 2407 1024 BD46     		mov	sp, r7
 2408 1026 80BC     		pop	{r7}
 2409 1028 7047     		bx	lr
 2410              		.cfi_endproc
 2411              	.LFE18:
 2413 102a 00BF     		.align	2
 2414              		.global	PKAECCMultGenPtGetResult
 2415              		.thumb
 2416              		.thumb_func
 2418              	PKAECCMultGenPtGetResult:
 2419              	.LFB19:
1609:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1610:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
1611:bsp/boards/OpenMote-CC2538/source/pka.c **** //
1612:bsp/boards/OpenMote-CC2538/source/pka.c **** //! Gets the result of ECC Multiplication with Generator point.
1613:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
1614:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param ptOutEcPt is the pointer to the structure where the resultant EC
1615:bsp/boards/OpenMote-CC2538/source/pka.c **** //! point will be stored.  The callee is responsible to allocate the space for
1616:bsp/boards/OpenMote-CC2538/source/pka.c **** //! the ec point structure and the x and y co-ordinate as well.
1617:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param ui32ResVectorLoc is the address of the result location which
1618:bsp/boards/OpenMote-CC2538/source/pka.c **** //! was provided by the start function \sa PKAECCMultGenPtStart().
1619:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
1620:bsp/boards/OpenMote-CC2538/source/pka.c **** //! This function gets the result of ecc point multiplication operation on the
1621:bsp/boards/OpenMote-CC2538/source/pka.c **** //! scalar point and the known generator point on the curve, previously started
1622:bsp/boards/OpenMote-CC2538/source/pka.c **** //! using the function \sa PKAECCMultGenPtStart().
1623:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
1624:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \return Returns:
1625:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_SUCCESS if the operation is successful. 
1626:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_OPERATION_INPRG, if the PKA hw module is busy performing 
1627:bsp/boards/OpenMote-CC2538/source/pka.c **** //! the operation.
1628:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_RESULT_0 if the result is all zeroes.
1629:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_FAILURE if the operation is not successful.
1630:bsp/boards/OpenMote-CC2538/source/pka.c **** //
1631:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
1632:bsp/boards/OpenMote-CC2538/source/pka.c **** tPKAStatus
1633:bsp/boards/OpenMote-CC2538/source/pka.c **** PKAECCMultGenPtGetResult(tECPt* ptOutEcPt, uint32_t ui32ResVectorLoc)
1634:bsp/boards/OpenMote-CC2538/source/pka.c **** {
 2420              		.loc 1 1634 0
 2421              		.cfi_startproc
 2422              		@ args = 0, pretend = 0, frame = 24
 2423              		@ frame_needed = 1, uses_anonymous_args = 0
 2424              		@ link register save eliminated.
 2425 102c 80B4     		push	{r7}
 2426              	.LCFI52:
 2427              		.cfi_def_cfa_offset 4
 2428              		.cfi_offset 7, -4
 2429 102e 87B0     		sub	sp, sp, #28
 2430              	.LCFI53:
 2431              		.cfi_def_cfa_offset 32
 2432 1030 00AF     		add	r7, sp, #0
 2433              	.LCFI54:
 2434              		.cfi_def_cfa_register 7
 2435 1032 7860     		str	r0, [r7, #4]
 2436 1034 3960     		str	r1, [r7, #0]
1635:bsp/boards/OpenMote-CC2538/source/pka.c ****     int i;
1636:bsp/boards/OpenMote-CC2538/source/pka.c ****     uint32_t regMSWVal;
1637:bsp/boards/OpenMote-CC2538/source/pka.c ****     uint32_t addr;
1638:bsp/boards/OpenMote-CC2538/source/pka.c ****     uint32_t len;
1639:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1640:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1641:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Check for the arguments.
1642:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1643:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != ptOutEcPt);
1644:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != ptOutEcPt->pui32X);
1645:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != ptOutEcPt->pui32Y);
1646:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT((ui32ResVectorLoc > PKA_RAM_BASE) &&
1647:bsp/boards/OpenMote-CC2538/source/pka.c ****            (ui32ResVectorLoc < (PKA_RAM_BASE + PKA_RAM_SIZE)));
1648:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1649:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1650:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Verify that the operation is completed.
1651:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1652:bsp/boards/OpenMote-CC2538/source/pka.c ****     if((HWREG(PKA_FUNCTION) & PKA_FUNCTION_RUN) != 0)
 2437              		.loc 1 1652 0
 2438 1036 44F21C03 		movw	r3, #16412
 2439 103a C4F20043 		movt	r3, 17408
 2440 103e 1B68     		ldr	r3, [r3, #0]
 2441 1040 03F40043 		and	r3, r3, #32768
 2442 1044 002B     		cmp	r3, #0
 2443 1046 02D0     		beq	.L121
1653:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
1654:bsp/boards/OpenMote-CC2538/source/pka.c ****         return (PKA_STATUS_OPERATION_INPRG);
 2444              		.loc 1 1654 0
 2445 1048 4FF00703 		mov	r3, #7
 2446 104c 6BE0     		b	.L122
 2447              	.L121:
1655:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
1656:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1657:bsp/boards/OpenMote-CC2538/source/pka.c ****     if(HWREG(PKA_SHIFT) == 0x00000000)
 2448              		.loc 1 1657 0
 2449 104e 44F21803 		movw	r3, #16408
 2450 1052 C4F20043 		movt	r3, 17408
 2451 1056 1B68     		ldr	r3, [r3, #0]
 2452 1058 002B     		cmp	r3, #0
 2453 105a 62D1     		bne	.L123
1658:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
1659:bsp/boards/OpenMote-CC2538/source/pka.c ****         //
1660:bsp/boards/OpenMote-CC2538/source/pka.c ****         // Get the MSW register value.
1661:bsp/boards/OpenMote-CC2538/source/pka.c ****         //
1662:bsp/boards/OpenMote-CC2538/source/pka.c ****         regMSWVal = HWREG(PKA_MSW);
 2454              		.loc 1 1662 0
 2455 105c 44F22403 		movw	r3, #16420
 2456 1060 C4F20043 		movt	r3, 17408
 2457 1064 1B68     		ldr	r3, [r3, #0]
 2458 1066 3B61     		str	r3, [r7, #16]
1663:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1664:bsp/boards/OpenMote-CC2538/source/pka.c ****         //
1665:bsp/boards/OpenMote-CC2538/source/pka.c ****         // Check to make sure that the result vector is not all zeroes.
1666:bsp/boards/OpenMote-CC2538/source/pka.c ****         //
1667:bsp/boards/OpenMote-CC2538/source/pka.c ****         if(regMSWVal & PKA_MSW_RESULT_IS_ZERO)
 2459              		.loc 1 1667 0
 2460 1068 3B69     		ldr	r3, [r7, #16]
 2461 106a 03F40043 		and	r3, r3, #32768
 2462 106e 002B     		cmp	r3, #0
 2463 1070 02D0     		beq	.L124
1668:bsp/boards/OpenMote-CC2538/source/pka.c ****         {
1669:bsp/boards/OpenMote-CC2538/source/pka.c ****             return (PKA_STATUS_RESULT_0);
 2464              		.loc 1 1669 0
 2465 1072 4FF00403 		mov	r3, #4
 2466 1076 56E0     		b	.L122
 2467              	.L124:
1670:bsp/boards/OpenMote-CC2538/source/pka.c ****         }
1671:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1672:bsp/boards/OpenMote-CC2538/source/pka.c ****         //
1673:bsp/boards/OpenMote-CC2538/source/pka.c ****         // Get the length of the result.
1674:bsp/boards/OpenMote-CC2538/source/pka.c ****         //
1675:bsp/boards/OpenMote-CC2538/source/pka.c ****         len = ((regMSWVal & PKA_MSW_MSW_ADDRESS_M) + 1) -
 2468              		.loc 1 1675 0
 2469 1078 3B69     		ldr	r3, [r7, #16]
 2470 107a 4FEA4353 		lsl	r3, r3, #21
 2471 107e 4FEA5353 		lsr	r3, r3, #21
1676:bsp/boards/OpenMote-CC2538/source/pka.c ****               ((ui32ResVectorLoc - PKA_RAM_BASE) >> 2);
 2472              		.loc 1 1676 0
 2473 1082 3A68     		ldr	r2, [r7, #0]
 2474 1084 02F13C42 		add	r2, r2, #-1140850688
 2475 1088 A2F5C042 		sub	r2, r2, #24576
 2476 108c 4FEA9202 		lsr	r2, r2, #2
1675:bsp/boards/OpenMote-CC2538/source/pka.c ****         len = ((regMSWVal & PKA_MSW_MSW_ADDRESS_M) + 1) -
 2477              		.loc 1 1675 0
 2478 1090 9B1A     		subs	r3, r3, r2
 2479 1092 03F10103 		add	r3, r3, #1
 2480 1096 FB60     		str	r3, [r7, #12]
1677:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1678:bsp/boards/OpenMote-CC2538/source/pka.c ****         addr = ui32ResVectorLoc;
 2481              		.loc 1 1678 0
 2482 1098 3B68     		ldr	r3, [r7, #0]
 2483 109a BB60     		str	r3, [r7, #8]
1679:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1680:bsp/boards/OpenMote-CC2538/source/pka.c ****         //
1681:bsp/boards/OpenMote-CC2538/source/pka.c ****         // Copy the x co-ordinate value of the result from vector D into the
1682:bsp/boards/OpenMote-CC2538/source/pka.c ****         // EC point.
1683:bsp/boards/OpenMote-CC2538/source/pka.c ****         //
1684:bsp/boards/OpenMote-CC2538/source/pka.c ****         for(i = 0; i < len; i++)
 2484              		.loc 1 1684 0
 2485 109c 4FF00003 		mov	r3, #0
 2486 10a0 7B61     		str	r3, [r7, #20]
 2487 10a2 11E0     		b	.L125
 2488              	.L126:
1685:bsp/boards/OpenMote-CC2538/source/pka.c ****         {
1686:bsp/boards/OpenMote-CC2538/source/pka.c ****             ptOutEcPt->pui32X[i] = HWREG( (addr + 4*i) );
 2489              		.loc 1 1686 0 discriminator 2
 2490 10a4 7B68     		ldr	r3, [r7, #4]
 2491 10a6 1A68     		ldr	r2, [r3, #0]
 2492 10a8 7B69     		ldr	r3, [r7, #20]
 2493 10aa 4FEA8303 		lsl	r3, r3, #2
 2494 10ae D318     		adds	r3, r2, r3
 2495 10b0 7A69     		ldr	r2, [r7, #20]
 2496 10b2 4FEA8202 		lsl	r2, r2, #2
 2497 10b6 1146     		mov	r1, r2
 2498 10b8 BA68     		ldr	r2, [r7, #8]
 2499 10ba 8A18     		adds	r2, r1, r2
 2500 10bc 1268     		ldr	r2, [r2, #0]
 2501 10be 1A60     		str	r2, [r3, #0]
1684:bsp/boards/OpenMote-CC2538/source/pka.c ****         for(i = 0; i < len; i++)
 2502              		.loc 1 1684 0 discriminator 2
 2503 10c0 7B69     		ldr	r3, [r7, #20]
 2504 10c2 03F10103 		add	r3, r3, #1
 2505 10c6 7B61     		str	r3, [r7, #20]
 2506              	.L125:
1684:bsp/boards/OpenMote-CC2538/source/pka.c ****         for(i = 0; i < len; i++)
 2507              		.loc 1 1684 0 is_stmt 0 discriminator 1
 2508 10c8 7A69     		ldr	r2, [r7, #20]
 2509 10ca FB68     		ldr	r3, [r7, #12]
 2510 10cc 9A42     		cmp	r2, r3
 2511 10ce E9D3     		bcc	.L126
1687:bsp/boards/OpenMote-CC2538/source/pka.c ****         }
1688:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1689:bsp/boards/OpenMote-CC2538/source/pka.c ****         addr += 4 * (i + 2 + len % 2);
 2512              		.loc 1 1689 0 is_stmt 1
 2513 10d0 FB68     		ldr	r3, [r7, #12]
 2514 10d2 03F00102 		and	r2, r3, #1
 2515 10d6 7B69     		ldr	r3, [r7, #20]
 2516 10d8 D318     		adds	r3, r2, r3
 2517 10da 03F10203 		add	r3, r3, #2
 2518 10de 4FEA8303 		lsl	r3, r3, #2
 2519 10e2 BA68     		ldr	r2, [r7, #8]
 2520 10e4 D318     		adds	r3, r2, r3
 2521 10e6 BB60     		str	r3, [r7, #8]
1690:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1691:bsp/boards/OpenMote-CC2538/source/pka.c ****         //
1692:bsp/boards/OpenMote-CC2538/source/pka.c ****         // Copy the y co-ordinate value of the result from vector D into the
1693:bsp/boards/OpenMote-CC2538/source/pka.c ****         // EC point.
1694:bsp/boards/OpenMote-CC2538/source/pka.c ****         //
1695:bsp/boards/OpenMote-CC2538/source/pka.c ****         for(i = 0; i < len; i++)
 2522              		.loc 1 1695 0
 2523 10e8 4FF00003 		mov	r3, #0
 2524 10ec 7B61     		str	r3, [r7, #20]
 2525 10ee 11E0     		b	.L127
 2526              	.L128:
1696:bsp/boards/OpenMote-CC2538/source/pka.c ****         {
1697:bsp/boards/OpenMote-CC2538/source/pka.c ****             ptOutEcPt->pui32Y[i] = HWREG( (addr + 4*i) );
 2527              		.loc 1 1697 0 discriminator 2
 2528 10f0 7B68     		ldr	r3, [r7, #4]
 2529 10f2 5A68     		ldr	r2, [r3, #4]
 2530 10f4 7B69     		ldr	r3, [r7, #20]
 2531 10f6 4FEA8303 		lsl	r3, r3, #2
 2532 10fa D318     		adds	r3, r2, r3
 2533 10fc 7A69     		ldr	r2, [r7, #20]
 2534 10fe 4FEA8202 		lsl	r2, r2, #2
 2535 1102 1146     		mov	r1, r2
 2536 1104 BA68     		ldr	r2, [r7, #8]
 2537 1106 8A18     		adds	r2, r1, r2
 2538 1108 1268     		ldr	r2, [r2, #0]
 2539 110a 1A60     		str	r2, [r3, #0]
1695:bsp/boards/OpenMote-CC2538/source/pka.c ****         for(i = 0; i < len; i++)
 2540              		.loc 1 1695 0 discriminator 2
 2541 110c 7B69     		ldr	r3, [r7, #20]
 2542 110e 03F10103 		add	r3, r3, #1
 2543 1112 7B61     		str	r3, [r7, #20]
 2544              	.L127:
1695:bsp/boards/OpenMote-CC2538/source/pka.c ****         for(i = 0; i < len; i++)
 2545              		.loc 1 1695 0 is_stmt 0 discriminator 1
 2546 1114 7A69     		ldr	r2, [r7, #20]
 2547 1116 FB68     		ldr	r3, [r7, #12]
 2548 1118 9A42     		cmp	r2, r3
 2549 111a E9D3     		bcc	.L128
1698:bsp/boards/OpenMote-CC2538/source/pka.c ****         }
1699:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1700:bsp/boards/OpenMote-CC2538/source/pka.c ****         return (PKA_STATUS_SUCCESS);
 2550              		.loc 1 1700 0 is_stmt 1
 2551 111c 4FF00003 		mov	r3, #0
 2552 1120 01E0     		b	.L122
 2553              	.L123:
1701:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
1702:bsp/boards/OpenMote-CC2538/source/pka.c ****     else
1703:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
1704:bsp/boards/OpenMote-CC2538/source/pka.c ****         return (PKA_STATUS_FAILURE);
 2554              		.loc 1 1704 0
 2555 1122 4FF00103 		mov	r3, #1
 2556              	.L122:
1705:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
1706:bsp/boards/OpenMote-CC2538/source/pka.c **** }
 2557              		.loc 1 1706 0
 2558 1126 1846     		mov	r0, r3
 2559 1128 07F11C07 		add	r7, r7, #28
 2560 112c BD46     		mov	sp, r7
 2561 112e 80BC     		pop	{r7}
 2562 1130 7047     		bx	lr
 2563              		.cfi_endproc
 2564              	.LFE19:
 2566 1132 00BF     		.align	2
 2567              		.global	PKAECCAddStart
 2568              		.thumb
 2569              		.thumb_func
 2571              	PKAECCAddStart:
 2572              	.LFB20:
1707:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1708:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
1709:bsp/boards/OpenMote-CC2538/source/pka.c **** //
1710:bsp/boards/OpenMote-CC2538/source/pka.c **** //! Starts the ECC Addition.
1711:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
1712:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param ptEcPt1 is the pointer to the structure containing the first
1713:bsp/boards/OpenMote-CC2538/source/pka.c **** //! ecc point.
1714:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param ptEcPt2 is the pointer to the structure containing the
1715:bsp/boards/OpenMote-CC2538/source/pka.c **** //! second ecc point.
1716:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param ptCurve is the pointer to the structure containing the curve
1717:bsp/boards/OpenMote-CC2538/source/pka.c **** //! info.
1718:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param pui32ResultVector is the pointer to the result vector location
1719:bsp/boards/OpenMote-CC2538/source/pka.c **** //! which will be set by this function.
1720:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
1721:bsp/boards/OpenMote-CC2538/source/pka.c **** //! This function starts the ecc point addition operation on the
1722:bsp/boards/OpenMote-CC2538/source/pka.c **** //! two given ec points and generates the resultant ecc point.
1723:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
1724:bsp/boards/OpenMote-CC2538/source/pka.c **** //!\return Returns: 
1725:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_SUCCESS if successful in starting the operation.  
1726:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_OPERATION_INPRG, if the PKA hw module is busy doing
1727:bsp/boards/OpenMote-CC2538/source/pka.c **** //! some other operation.
1728:bsp/boards/OpenMote-CC2538/source/pka.c **** //
1729:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
1730:bsp/boards/OpenMote-CC2538/source/pka.c **** tPKAStatus
1731:bsp/boards/OpenMote-CC2538/source/pka.c **** PKAECCAddStart(tECPt* ptEcPt1, tECPt* ptEcPt2,tECCCurveInfo* ptCurve,
1732:bsp/boards/OpenMote-CC2538/source/pka.c ****                uint32_t* pui32ResultVector)
1733:bsp/boards/OpenMote-CC2538/source/pka.c **** {
 2573              		.loc 1 1733 0
 2574              		.cfi_startproc
 2575              		@ args = 0, pretend = 0, frame = 32
 2576              		@ frame_needed = 1, uses_anonymous_args = 0
 2577              		@ link register save eliminated.
 2578 1134 80B4     		push	{r7}
 2579              	.LCFI55:
 2580              		.cfi_def_cfa_offset 4
 2581              		.cfi_offset 7, -4
 2582 1136 89B0     		sub	sp, sp, #36
 2583              	.LCFI56:
 2584              		.cfi_def_cfa_offset 40
 2585 1138 00AF     		add	r7, sp, #0
 2586              	.LCFI57:
 2587              		.cfi_def_cfa_register 7
 2588 113a F860     		str	r0, [r7, #12]
 2589 113c B960     		str	r1, [r7, #8]
 2590 113e 7A60     		str	r2, [r7, #4]
 2591 1140 3B60     		str	r3, [r7, #0]
1734:bsp/boards/OpenMote-CC2538/source/pka.c ****     uint8_t extraBuf;
1735:bsp/boards/OpenMote-CC2538/source/pka.c ****     uint32_t offset;
1736:bsp/boards/OpenMote-CC2538/source/pka.c ****     int i;
1737:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1738:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1739:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Check for the arguments.
1740:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1741:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != ptEcPt1);
1742:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != ptEcPt1->pui32X);
1743:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != ptEcPt1->pui32Y);
1744:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != ptEcPt2);
1745:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != ptEcPt2->pui32X);
1746:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != ptEcPt2->pui32Y);
1747:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != ptCurve);
1748:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != pui32ResultVector);
1749:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1750:bsp/boards/OpenMote-CC2538/source/pka.c ****     offset = 0;
 2592              		.loc 1 1750 0
 2593 1142 4FF00003 		mov	r3, #0
 2594 1146 BB61     		str	r3, [r7, #24]
1751:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1752:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1753:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Make sure no operation is in progress.
1754:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1755:bsp/boards/OpenMote-CC2538/source/pka.c ****     if((HWREG(PKA_FUNCTION) & PKA_FUNCTION_RUN) != 0)
 2595              		.loc 1 1755 0
 2596 1148 44F21C03 		movw	r3, #16412
 2597 114c C4F20043 		movt	r3, 17408
 2598 1150 1B68     		ldr	r3, [r3, #0]
 2599 1152 03F40043 		and	r3, r3, #32768
 2600 1156 002B     		cmp	r3, #0
 2601 1158 02D0     		beq	.L130
1756:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
1757:bsp/boards/OpenMote-CC2538/source/pka.c ****         return (PKA_STATUS_OPERATION_INPRG);
 2602              		.loc 1 1757 0
 2603 115a 4FF00703 		mov	r3, #7
 2604 115e 2EE1     		b	.L131
 2605              	.L130:
1758:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
1759:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1760:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1761:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Calculate the extra buffer requirement.
1762:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1763:bsp/boards/OpenMote-CC2538/source/pka.c ****     extraBuf = 2 + ptCurve->ui8Size % 2;
 2606              		.loc 1 1763 0
 2607 1160 7B68     		ldr	r3, [r7, #4]
 2608 1162 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2609 1164 03F00103 		and	r3, r3, #1
 2610 1168 DBB2     		uxtb	r3, r3
 2611 116a 03F10203 		add	r3, r3, #2
 2612 116e FB75     		strb	r3, [r7, #23]
1764:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1765:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1766:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Update the A ptr with the offset address of the PKA RAM location
1767:bsp/boards/OpenMote-CC2538/source/pka.c ****     // where the first ecPt will be stored.
1768:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1769:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG(PKA_APTR) = offset >> 2;
 2613              		.loc 1 1769 0
 2614 1170 4FF48043 		mov	r3, #16384
 2615 1174 C4F20043 		movt	r3, 17408
 2616 1178 BA69     		ldr	r2, [r7, #24]
 2617 117a 4FEA9202 		lsr	r2, r2, #2
 2618 117e 1A60     		str	r2, [r3, #0]
1770:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1771:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1772:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Load the x co-ordinate value of the first EC point in PKA RAM.
1773:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1774:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 2619              		.loc 1 1774 0
 2620 1180 4FF00003 		mov	r3, #0
 2621 1184 FB61     		str	r3, [r7, #28]
 2622 1186 15E0     		b	.L132
 2623              	.L133:
1775:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
1776:bsp/boards/OpenMote-CC2538/source/pka.c ****         HWREG((PKA_RAM_BASE + offset + 4*i)) = ptEcPt1->pui32X[i];
 2624              		.loc 1 1776 0 discriminator 2
 2625 1188 FB69     		ldr	r3, [r7, #28]
 2626 118a 4FEA8303 		lsl	r3, r3, #2
 2627 118e 1A46     		mov	r2, r3
 2628 1190 BB69     		ldr	r3, [r7, #24]
 2629 1192 D318     		adds	r3, r2, r3
 2630 1194 03F18843 		add	r3, r3, #1140850688
 2631 1198 03F5C043 		add	r3, r3, #24576
 2632 119c FA68     		ldr	r2, [r7, #12]
 2633 119e 1168     		ldr	r1, [r2, #0]
 2634 11a0 FA69     		ldr	r2, [r7, #28]
 2635 11a2 4FEA8202 		lsl	r2, r2, #2
 2636 11a6 8A18     		adds	r2, r1, r2
 2637 11a8 1268     		ldr	r2, [r2, #0]
 2638 11aa 1A60     		str	r2, [r3, #0]
1774:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 2639              		.loc 1 1774 0 discriminator 2
 2640 11ac FB69     		ldr	r3, [r7, #28]
 2641 11ae 03F10103 		add	r3, r3, #1
 2642 11b2 FB61     		str	r3, [r7, #28]
 2643              	.L132:
1774:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 2644              		.loc 1 1774 0 is_stmt 0 discriminator 1
 2645 11b4 7B68     		ldr	r3, [r7, #4]
 2646 11b6 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2647 11b8 1A46     		mov	r2, r3
 2648 11ba FB69     		ldr	r3, [r7, #28]
 2649 11bc 9A42     		cmp	r2, r3
 2650 11be E3DC     		bgt	.L133
1777:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
1778:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1779:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1780:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Determine the offset in PKA RAM for the next data.
1781:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1782:bsp/boards/OpenMote-CC2538/source/pka.c ****     offset += 4 * (i + extraBuf);
 2651              		.loc 1 1782 0 is_stmt 1
 2652 11c0 FA7D     		ldrb	r2, [r7, #23]	@ zero_extendqisi2
 2653 11c2 FB69     		ldr	r3, [r7, #28]
 2654 11c4 D318     		adds	r3, r2, r3
 2655 11c6 4FEA8303 		lsl	r3, r3, #2
 2656 11ca BA69     		ldr	r2, [r7, #24]
 2657 11cc D318     		adds	r3, r2, r3
 2658 11ce BB61     		str	r3, [r7, #24]
1783:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1784:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1785:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Load the y co-ordinate value of the first EC point in PKA RAM.
1786:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1787:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 2659              		.loc 1 1787 0
 2660 11d0 4FF00003 		mov	r3, #0
 2661 11d4 FB61     		str	r3, [r7, #28]
 2662 11d6 15E0     		b	.L134
 2663              	.L135:
1788:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
1789:bsp/boards/OpenMote-CC2538/source/pka.c ****         HWREG((PKA_RAM_BASE + offset + 4*i)) = ptEcPt1->pui32Y[i];
 2664              		.loc 1 1789 0 discriminator 2
 2665 11d8 FB69     		ldr	r3, [r7, #28]
 2666 11da 4FEA8303 		lsl	r3, r3, #2
 2667 11de 1A46     		mov	r2, r3
 2668 11e0 BB69     		ldr	r3, [r7, #24]
 2669 11e2 D318     		adds	r3, r2, r3
 2670 11e4 03F18843 		add	r3, r3, #1140850688
 2671 11e8 03F5C043 		add	r3, r3, #24576
 2672 11ec FA68     		ldr	r2, [r7, #12]
 2673 11ee 5168     		ldr	r1, [r2, #4]
 2674 11f0 FA69     		ldr	r2, [r7, #28]
 2675 11f2 4FEA8202 		lsl	r2, r2, #2
 2676 11f6 8A18     		adds	r2, r1, r2
 2677 11f8 1268     		ldr	r2, [r2, #0]
 2678 11fa 1A60     		str	r2, [r3, #0]
1787:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 2679              		.loc 1 1787 0 discriminator 2
 2680 11fc FB69     		ldr	r3, [r7, #28]
 2681 11fe 03F10103 		add	r3, r3, #1
 2682 1202 FB61     		str	r3, [r7, #28]
 2683              	.L134:
1787:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 2684              		.loc 1 1787 0 is_stmt 0 discriminator 1
 2685 1204 7B68     		ldr	r3, [r7, #4]
 2686 1206 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2687 1208 1A46     		mov	r2, r3
 2688 120a FB69     		ldr	r3, [r7, #28]
 2689 120c 9A42     		cmp	r2, r3
 2690 120e E3DC     		bgt	.L135
1790:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
1791:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1792:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1793:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Determine the offset in PKA RAM for the next data.
1794:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1795:bsp/boards/OpenMote-CC2538/source/pka.c ****     offset += 4 * (i + extraBuf);
 2691              		.loc 1 1795 0 is_stmt 1
 2692 1210 FA7D     		ldrb	r2, [r7, #23]	@ zero_extendqisi2
 2693 1212 FB69     		ldr	r3, [r7, #28]
 2694 1214 D318     		adds	r3, r2, r3
 2695 1216 4FEA8303 		lsl	r3, r3, #2
 2696 121a BA69     		ldr	r2, [r7, #24]
 2697 121c D318     		adds	r3, r2, r3
 2698 121e BB61     		str	r3, [r7, #24]
1796:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1797:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1798:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Update the B ptr with the offset address of the PKA RAM location
1799:bsp/boards/OpenMote-CC2538/source/pka.c ****     // where the curve parameters will be stored.
1800:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1801:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG(PKA_BPTR) = offset >> 2;
 2699              		.loc 1 1801 0
 2700 1220 44F20403 		movw	r3, #16388
 2701 1224 C4F20043 		movt	r3, 17408
 2702 1228 BA69     		ldr	r2, [r7, #24]
 2703 122a 4FEA9202 		lsr	r2, r2, #2
 2704 122e 1A60     		str	r2, [r3, #0]
1802:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1803:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1804:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Write curve parameter 'p' as 1st part of vector B
1805:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1806:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 2705              		.loc 1 1806 0
 2706 1230 4FF00003 		mov	r3, #0
 2707 1234 FB61     		str	r3, [r7, #28]
 2708 1236 15E0     		b	.L136
 2709              	.L137:
1807:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
1808:bsp/boards/OpenMote-CC2538/source/pka.c ****         HWREG((PKA_RAM_BASE + offset + 4*i)) =
 2710              		.loc 1 1808 0 discriminator 2
 2711 1238 FB69     		ldr	r3, [r7, #28]
 2712 123a 4FEA8303 		lsl	r3, r3, #2
 2713 123e 1A46     		mov	r2, r3
 2714 1240 BB69     		ldr	r3, [r7, #24]
 2715 1242 D318     		adds	r3, r2, r3
 2716 1244 03F18843 		add	r3, r3, #1140850688
 2717 1248 03F5C043 		add	r3, r3, #24576
1809:bsp/boards/OpenMote-CC2538/source/pka.c ****             (uint32_t)ptCurve->pui32Prime[i];
 2718              		.loc 1 1809 0 discriminator 2
 2719 124c 7A68     		ldr	r2, [r7, #4]
 2720 124e 9168     		ldr	r1, [r2, #8]
 2721 1250 FA69     		ldr	r2, [r7, #28]
 2722 1252 4FEA8202 		lsl	r2, r2, #2
 2723 1256 8A18     		adds	r2, r1, r2
 2724 1258 1268     		ldr	r2, [r2, #0]
1808:bsp/boards/OpenMote-CC2538/source/pka.c ****         HWREG((PKA_RAM_BASE + offset + 4*i)) =
 2725              		.loc 1 1808 0 discriminator 2
 2726 125a 1A60     		str	r2, [r3, #0]
1806:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 2727              		.loc 1 1806 0 discriminator 2
 2728 125c FB69     		ldr	r3, [r7, #28]
 2729 125e 03F10103 		add	r3, r3, #1
 2730 1262 FB61     		str	r3, [r7, #28]
 2731              	.L136:
1806:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 2732              		.loc 1 1806 0 is_stmt 0 discriminator 1
 2733 1264 7B68     		ldr	r3, [r7, #4]
 2734 1266 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2735 1268 1A46     		mov	r2, r3
 2736 126a FB69     		ldr	r3, [r7, #28]
 2737 126c 9A42     		cmp	r2, r3
 2738 126e E3DC     		bgt	.L137
1810:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
1811:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1812:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1813:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Determine the offset in PKA RAM for the next data.
1814:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1815:bsp/boards/OpenMote-CC2538/source/pka.c ****     offset += 4 * (i + extraBuf);
 2739              		.loc 1 1815 0 is_stmt 1
 2740 1270 FA7D     		ldrb	r2, [r7, #23]	@ zero_extendqisi2
 2741 1272 FB69     		ldr	r3, [r7, #28]
 2742 1274 D318     		adds	r3, r2, r3
 2743 1276 4FEA8303 		lsl	r3, r3, #2
 2744 127a BA69     		ldr	r2, [r7, #24]
 2745 127c D318     		adds	r3, r2, r3
 2746 127e BB61     		str	r3, [r7, #24]
1816:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1817:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1818:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Write curve parameter 'a'.
1819:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1820:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 2747              		.loc 1 1820 0
 2748 1280 4FF00003 		mov	r3, #0
 2749 1284 FB61     		str	r3, [r7, #28]
 2750 1286 15E0     		b	.L138
 2751              	.L139:
1821:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
1822:bsp/boards/OpenMote-CC2538/source/pka.c ****         HWREG((PKA_RAM_BASE + offset + 4*i)) = (uint32_t)ptCurve->pui32A[i];
 2752              		.loc 1 1822 0 discriminator 2
 2753 1288 FB69     		ldr	r3, [r7, #28]
 2754 128a 4FEA8303 		lsl	r3, r3, #2
 2755 128e 1A46     		mov	r2, r3
 2756 1290 BB69     		ldr	r3, [r7, #24]
 2757 1292 D318     		adds	r3, r2, r3
 2758 1294 03F18843 		add	r3, r3, #1140850688
 2759 1298 03F5C043 		add	r3, r3, #24576
 2760 129c 7A68     		ldr	r2, [r7, #4]
 2761 129e 1169     		ldr	r1, [r2, #16]
 2762 12a0 FA69     		ldr	r2, [r7, #28]
 2763 12a2 4FEA8202 		lsl	r2, r2, #2
 2764 12a6 8A18     		adds	r2, r1, r2
 2765 12a8 1268     		ldr	r2, [r2, #0]
 2766 12aa 1A60     		str	r2, [r3, #0]
1820:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 2767              		.loc 1 1820 0 discriminator 2
 2768 12ac FB69     		ldr	r3, [r7, #28]
 2769 12ae 03F10103 		add	r3, r3, #1
 2770 12b2 FB61     		str	r3, [r7, #28]
 2771              	.L138:
1820:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 2772              		.loc 1 1820 0 is_stmt 0 discriminator 1
 2773 12b4 7B68     		ldr	r3, [r7, #4]
 2774 12b6 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2775 12b8 1A46     		mov	r2, r3
 2776 12ba FB69     		ldr	r3, [r7, #28]
 2777 12bc 9A42     		cmp	r2, r3
 2778 12be E3DC     		bgt	.L139
1823:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
1824:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1825:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1826:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Determine the offset in PKA RAM for the next data.
1827:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1828:bsp/boards/OpenMote-CC2538/source/pka.c ****     offset += 4 * (i + extraBuf);
 2779              		.loc 1 1828 0 is_stmt 1
 2780 12c0 FA7D     		ldrb	r2, [r7, #23]	@ zero_extendqisi2
 2781 12c2 FB69     		ldr	r3, [r7, #28]
 2782 12c4 D318     		adds	r3, r2, r3
 2783 12c6 4FEA8303 		lsl	r3, r3, #2
 2784 12ca BA69     		ldr	r2, [r7, #24]
 2785 12cc D318     		adds	r3, r2, r3
 2786 12ce BB61     		str	r3, [r7, #24]
1829:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1830:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1831:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Update the C ptr with the offset address of the PKA RAM location
1832:bsp/boards/OpenMote-CC2538/source/pka.c ****     // where the ecPt2 will be stored.
1833:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1834:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG(PKA_CPTR) = offset >> 2;
 2787              		.loc 1 1834 0
 2788 12d0 44F20803 		movw	r3, #16392
 2789 12d4 C4F20043 		movt	r3, 17408
 2790 12d8 BA69     		ldr	r2, [r7, #24]
 2791 12da 4FEA9202 		lsr	r2, r2, #2
 2792 12de 1A60     		str	r2, [r3, #0]
1835:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1836:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1837:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Load the x co-ordinate value of the second EC point in PKA RAM.
1838:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1839:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 2793              		.loc 1 1839 0
 2794 12e0 4FF00003 		mov	r3, #0
 2795 12e4 FB61     		str	r3, [r7, #28]
 2796 12e6 15E0     		b	.L140
 2797              	.L141:
1840:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
1841:bsp/boards/OpenMote-CC2538/source/pka.c ****         HWREG((PKA_RAM_BASE + offset + 4*i)) = ptEcPt2->pui32X[i];
 2798              		.loc 1 1841 0 discriminator 2
 2799 12e8 FB69     		ldr	r3, [r7, #28]
 2800 12ea 4FEA8303 		lsl	r3, r3, #2
 2801 12ee 1A46     		mov	r2, r3
 2802 12f0 BB69     		ldr	r3, [r7, #24]
 2803 12f2 D318     		adds	r3, r2, r3
 2804 12f4 03F18843 		add	r3, r3, #1140850688
 2805 12f8 03F5C043 		add	r3, r3, #24576
 2806 12fc BA68     		ldr	r2, [r7, #8]
 2807 12fe 1168     		ldr	r1, [r2, #0]
 2808 1300 FA69     		ldr	r2, [r7, #28]
 2809 1302 4FEA8202 		lsl	r2, r2, #2
 2810 1306 8A18     		adds	r2, r1, r2
 2811 1308 1268     		ldr	r2, [r2, #0]
 2812 130a 1A60     		str	r2, [r3, #0]
1839:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 2813              		.loc 1 1839 0 discriminator 2
 2814 130c FB69     		ldr	r3, [r7, #28]
 2815 130e 03F10103 		add	r3, r3, #1
 2816 1312 FB61     		str	r3, [r7, #28]
 2817              	.L140:
1839:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 2818              		.loc 1 1839 0 is_stmt 0 discriminator 1
 2819 1314 7B68     		ldr	r3, [r7, #4]
 2820 1316 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2821 1318 1A46     		mov	r2, r3
 2822 131a FB69     		ldr	r3, [r7, #28]
 2823 131c 9A42     		cmp	r2, r3
 2824 131e E3DC     		bgt	.L141
1842:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
1843:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1844:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1845:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Determine the offset in PKA RAM for the next data.
1846:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1847:bsp/boards/OpenMote-CC2538/source/pka.c ****     offset += 4 * (i + extraBuf);
 2825              		.loc 1 1847 0 is_stmt 1
 2826 1320 FA7D     		ldrb	r2, [r7, #23]	@ zero_extendqisi2
 2827 1322 FB69     		ldr	r3, [r7, #28]
 2828 1324 D318     		adds	r3, r2, r3
 2829 1326 4FEA8303 		lsl	r3, r3, #2
 2830 132a BA69     		ldr	r2, [r7, #24]
 2831 132c D318     		adds	r3, r2, r3
 2832 132e BB61     		str	r3, [r7, #24]
1848:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1849:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1850:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Load the y co-ordinate value of the second EC point in PKA RAM.
1851:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1852:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 2833              		.loc 1 1852 0
 2834 1330 4FF00003 		mov	r3, #0
 2835 1334 FB61     		str	r3, [r7, #28]
 2836 1336 15E0     		b	.L142
 2837              	.L143:
1853:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
1854:bsp/boards/OpenMote-CC2538/source/pka.c ****         HWREG((PKA_RAM_BASE + offset + 4*i)) = ptEcPt2->pui32Y[i];
 2838              		.loc 1 1854 0 discriminator 2
 2839 1338 FB69     		ldr	r3, [r7, #28]
 2840 133a 4FEA8303 		lsl	r3, r3, #2
 2841 133e 1A46     		mov	r2, r3
 2842 1340 BB69     		ldr	r3, [r7, #24]
 2843 1342 D318     		adds	r3, r2, r3
 2844 1344 03F18843 		add	r3, r3, #1140850688
 2845 1348 03F5C043 		add	r3, r3, #24576
 2846 134c BA68     		ldr	r2, [r7, #8]
 2847 134e 5168     		ldr	r1, [r2, #4]
 2848 1350 FA69     		ldr	r2, [r7, #28]
 2849 1352 4FEA8202 		lsl	r2, r2, #2
 2850 1356 8A18     		adds	r2, r1, r2
 2851 1358 1268     		ldr	r2, [r2, #0]
 2852 135a 1A60     		str	r2, [r3, #0]
1852:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 2853              		.loc 1 1852 0 discriminator 2
 2854 135c FB69     		ldr	r3, [r7, #28]
 2855 135e 03F10103 		add	r3, r3, #1
 2856 1362 FB61     		str	r3, [r7, #28]
 2857              	.L142:
1852:bsp/boards/OpenMote-CC2538/source/pka.c ****     for(i = 0; i < ptCurve->ui8Size; i++)
 2858              		.loc 1 1852 0 is_stmt 0 discriminator 1
 2859 1364 7B68     		ldr	r3, [r7, #4]
 2860 1366 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2861 1368 1A46     		mov	r2, r3
 2862 136a FB69     		ldr	r3, [r7, #28]
 2863 136c 9A42     		cmp	r2, r3
 2864 136e E3DC     		bgt	.L143
1855:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
1856:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1857:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1858:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Determine the offset in PKA RAM for the next data.
1859:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1860:bsp/boards/OpenMote-CC2538/source/pka.c ****     offset += 4 * (i + extraBuf);
 2865              		.loc 1 1860 0 is_stmt 1
 2866 1370 FA7D     		ldrb	r2, [r7, #23]	@ zero_extendqisi2
 2867 1372 FB69     		ldr	r3, [r7, #28]
 2868 1374 D318     		adds	r3, r2, r3
 2869 1376 4FEA8303 		lsl	r3, r3, #2
 2870 137a BA69     		ldr	r2, [r7, #24]
 2871 137c D318     		adds	r3, r2, r3
 2872 137e BB61     		str	r3, [r7, #24]
1861:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1862:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1863:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Copy the result vector location.
1864:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1865:bsp/boards/OpenMote-CC2538/source/pka.c ****     *pui32ResultVector = PKA_RAM_BASE + offset;
 2873              		.loc 1 1865 0
 2874 1380 BB69     		ldr	r3, [r7, #24]
 2875 1382 03F18843 		add	r3, r3, #1140850688
 2876 1386 03F5C043 		add	r3, r3, #24576
 2877 138a 3A68     		ldr	r2, [r7, #0]
 2878 138c 1360     		str	r3, [r2, #0]
1866:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1867:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1868:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Load D ptr with the result location in PKA RAM.
1869:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1870:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG(PKA_DPTR) = offset >> 2;
 2879              		.loc 1 1870 0
 2880 138e 44F20C03 		movw	r3, #16396
 2881 1392 C4F20043 		movt	r3, 17408
 2882 1396 BA69     		ldr	r2, [r7, #24]
 2883 1398 4FEA9202 		lsr	r2, r2, #2
 2884 139c 1A60     		str	r2, [r3, #0]
1871:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1872:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1873:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Load length registers.
1874:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1875:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG(PKA_BLENGTH) = ptCurve->ui8Size;
 2885              		.loc 1 1875 0
 2886 139e 44F21403 		movw	r3, #16404
 2887 13a2 C4F20043 		movt	r3, 17408
 2888 13a6 7A68     		ldr	r2, [r7, #4]
 2889 13a8 1279     		ldrb	r2, [r2, #4]	@ zero_extendqisi2
 2890 13aa 1A60     		str	r2, [r3, #0]
1876:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1877:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1878:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Set the PKA Function to ECC-ADD and start the operation.
1879:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1880:bsp/boards/OpenMote-CC2538/source/pka.c ****     HWREG( (PKA_FUNCTION) ) = 0x0000B000;
 2891              		.loc 1 1880 0
 2892 13ac 44F21C03 		movw	r3, #16412
 2893 13b0 C4F20043 		movt	r3, 17408
 2894 13b4 4FF43042 		mov	r2, #45056
 2895 13b8 1A60     		str	r2, [r3, #0]
1881:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1882:bsp/boards/OpenMote-CC2538/source/pka.c ****     return (PKA_STATUS_SUCCESS);
 2896              		.loc 1 1882 0
 2897 13ba 4FF00003 		mov	r3, #0
 2898              	.L131:
1883:bsp/boards/OpenMote-CC2538/source/pka.c **** }
 2899              		.loc 1 1883 0
 2900 13be 1846     		mov	r0, r3
 2901 13c0 07F12407 		add	r7, r7, #36
 2902 13c4 BD46     		mov	sp, r7
 2903 13c6 80BC     		pop	{r7}
 2904 13c8 7047     		bx	lr
 2905              		.cfi_endproc
 2906              	.LFE20:
 2908 13ca 00BF     		.align	2
 2909              		.global	PKAECCAddGetResult
 2910              		.thumb
 2911              		.thumb_func
 2913              	PKAECCAddGetResult:
 2914              	.LFB21:
1884:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1885:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
1886:bsp/boards/OpenMote-CC2538/source/pka.c **** //
1887:bsp/boards/OpenMote-CC2538/source/pka.c **** //! Gets the result of the ECC Addition
1888:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
1889:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param ptOutEcPt is the pointer to the structure where the resultant
1890:bsp/boards/OpenMote-CC2538/source/pka.c **** //!        point will be stored. The callee is responsible to allocate memory,
1891:bsp/boards/OpenMote-CC2538/source/pka.c **** //!        for the ec point structure including the memory for x and y
1892:bsp/boards/OpenMote-CC2538/source/pka.c **** //!        co-ordinate values.
1893:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \param ui32ResVectorLoc is the address of the result location which
1894:bsp/boards/OpenMote-CC2538/source/pka.c **** //!        was provided by the function \sa PKAECCAddStart().
1895:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
1896:bsp/boards/OpenMote-CC2538/source/pka.c **** //! This function gets the result of ecc point addition operation on the
1897:bsp/boards/OpenMote-CC2538/source/pka.c **** //! on the two given ec points, previously started using the function \sa
1898:bsp/boards/OpenMote-CC2538/source/pka.c **** //! PKAECCAddStart().
1899:bsp/boards/OpenMote-CC2538/source/pka.c **** //!
1900:bsp/boards/OpenMote-CC2538/source/pka.c **** //! \return Returns:
1901:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_SUCCESS if the operation is successful. 
1902:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_OPERATION_INPRG, if the PKA hw module is busy performing 
1903:bsp/boards/OpenMote-CC2538/source/pka.c **** //! the operation.
1904:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_RESULT_0 if the result is all zeroes.
1905:bsp/boards/OpenMote-CC2538/source/pka.c **** //! - \b PKA_STATUS_FAILURE if the operation is not successful.
1906:bsp/boards/OpenMote-CC2538/source/pka.c **** //
1907:bsp/boards/OpenMote-CC2538/source/pka.c **** //*****************************************************************************
1908:bsp/boards/OpenMote-CC2538/source/pka.c **** tPKAStatus
1909:bsp/boards/OpenMote-CC2538/source/pka.c **** PKAECCAddGetResult(tECPt* ptOutEcPt, uint32_t ui32ResVectorLoc)
1910:bsp/boards/OpenMote-CC2538/source/pka.c **** {
 2915              		.loc 1 1910 0
 2916              		.cfi_startproc
 2917              		@ args = 0, pretend = 0, frame = 24
 2918              		@ frame_needed = 1, uses_anonymous_args = 0
 2919              		@ link register save eliminated.
 2920 13cc 80B4     		push	{r7}
 2921              	.LCFI58:
 2922              		.cfi_def_cfa_offset 4
 2923              		.cfi_offset 7, -4
 2924 13ce 87B0     		sub	sp, sp, #28
 2925              	.LCFI59:
 2926              		.cfi_def_cfa_offset 32
 2927 13d0 00AF     		add	r7, sp, #0
 2928              	.LCFI60:
 2929              		.cfi_def_cfa_register 7
 2930 13d2 7860     		str	r0, [r7, #4]
 2931 13d4 3960     		str	r1, [r7, #0]
1911:bsp/boards/OpenMote-CC2538/source/pka.c ****     uint32_t regMSWVal;
1912:bsp/boards/OpenMote-CC2538/source/pka.c ****     uint32_t addr;
1913:bsp/boards/OpenMote-CC2538/source/pka.c ****     int i;
1914:bsp/boards/OpenMote-CC2538/source/pka.c ****     uint32_t len;
1915:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1916:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1917:bsp/boards/OpenMote-CC2538/source/pka.c ****     // Check for the arguments.
1918:bsp/boards/OpenMote-CC2538/source/pka.c ****     //
1919:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != ptOutEcPt);
1920:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != ptOutEcPt->pui32X);
1921:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT(NULL != ptOutEcPt->pui32Y);
1922:bsp/boards/OpenMote-CC2538/source/pka.c ****     ASSERT((ui32ResVectorLoc > PKA_RAM_BASE) &&
1923:bsp/boards/OpenMote-CC2538/source/pka.c ****            (ui32ResVectorLoc < (PKA_RAM_BASE + PKA_RAM_SIZE)));
1924:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1925:bsp/boards/OpenMote-CC2538/source/pka.c ****     if((HWREG(PKA_FUNCTION) & PKA_FUNCTION_RUN) != 0)
 2932              		.loc 1 1925 0
 2933 13d6 44F21C03 		movw	r3, #16412
 2934 13da C4F20043 		movt	r3, 17408
 2935 13de 1B68     		ldr	r3, [r3, #0]
 2936 13e0 03F40043 		and	r3, r3, #32768
 2937 13e4 002B     		cmp	r3, #0
 2938 13e6 02D0     		beq	.L145
1926:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
1927:bsp/boards/OpenMote-CC2538/source/pka.c ****         return (PKA_STATUS_OPERATION_INPRG);
 2939              		.loc 1 1927 0
 2940 13e8 4FF00703 		mov	r3, #7
 2941 13ec 6BE0     		b	.L146
 2942              	.L145:
1928:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
1929:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1930:bsp/boards/OpenMote-CC2538/source/pka.c ****     if(HWREG(PKA_SHIFT) == 0x00000000)
 2943              		.loc 1 1930 0
 2944 13ee 44F21803 		movw	r3, #16408
 2945 13f2 C4F20043 		movt	r3, 17408
 2946 13f6 1B68     		ldr	r3, [r3, #0]
 2947 13f8 002B     		cmp	r3, #0
 2948 13fa 62D1     		bne	.L147
1931:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
1932:bsp/boards/OpenMote-CC2538/source/pka.c ****         //
1933:bsp/boards/OpenMote-CC2538/source/pka.c ****         // Get the MSW register value.
1934:bsp/boards/OpenMote-CC2538/source/pka.c ****         //
1935:bsp/boards/OpenMote-CC2538/source/pka.c ****         regMSWVal = HWREG(PKA_MSW);
 2949              		.loc 1 1935 0
 2950 13fc 44F22403 		movw	r3, #16420
 2951 1400 C4F20043 		movt	r3, 17408
 2952 1404 1B68     		ldr	r3, [r3, #0]
 2953 1406 3B61     		str	r3, [r7, #16]
1936:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1937:bsp/boards/OpenMote-CC2538/source/pka.c ****         //
1938:bsp/boards/OpenMote-CC2538/source/pka.c ****         // Check to make sure that the result vector is not all zeroes.
1939:bsp/boards/OpenMote-CC2538/source/pka.c ****         //
1940:bsp/boards/OpenMote-CC2538/source/pka.c ****         if(regMSWVal & PKA_MSW_RESULT_IS_ZERO)
 2954              		.loc 1 1940 0
 2955 1408 3B69     		ldr	r3, [r7, #16]
 2956 140a 03F40043 		and	r3, r3, #32768
 2957 140e 002B     		cmp	r3, #0
 2958 1410 02D0     		beq	.L148
1941:bsp/boards/OpenMote-CC2538/source/pka.c ****         {
1942:bsp/boards/OpenMote-CC2538/source/pka.c ****             return (PKA_STATUS_RESULT_0);
 2959              		.loc 1 1942 0
 2960 1412 4FF00403 		mov	r3, #4
 2961 1416 56E0     		b	.L146
 2962              	.L148:
1943:bsp/boards/OpenMote-CC2538/source/pka.c ****         }
1944:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1945:bsp/boards/OpenMote-CC2538/source/pka.c ****         //
1946:bsp/boards/OpenMote-CC2538/source/pka.c ****         // Get the length of the result.
1947:bsp/boards/OpenMote-CC2538/source/pka.c ****         //
1948:bsp/boards/OpenMote-CC2538/source/pka.c ****         len = ((regMSWVal & PKA_MSW_MSW_ADDRESS_M) + 1) -
 2963              		.loc 1 1948 0
 2964 1418 3B69     		ldr	r3, [r7, #16]
 2965 141a 4FEA4353 		lsl	r3, r3, #21
 2966 141e 4FEA5353 		lsr	r3, r3, #21
1949:bsp/boards/OpenMote-CC2538/source/pka.c ****               ((ui32ResVectorLoc - PKA_RAM_BASE) >> 2);
 2967              		.loc 1 1949 0
 2968 1422 3A68     		ldr	r2, [r7, #0]
 2969 1424 02F13C42 		add	r2, r2, #-1140850688
 2970 1428 A2F5C042 		sub	r2, r2, #24576
 2971 142c 4FEA9202 		lsr	r2, r2, #2
1948:bsp/boards/OpenMote-CC2538/source/pka.c ****         len = ((regMSWVal & PKA_MSW_MSW_ADDRESS_M) + 1) -
 2972              		.loc 1 1948 0
 2973 1430 9B1A     		subs	r3, r3, r2
 2974 1432 03F10103 		add	r3, r3, #1
 2975 1436 FB60     		str	r3, [r7, #12]
1950:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1951:bsp/boards/OpenMote-CC2538/source/pka.c ****         addr = ui32ResVectorLoc;
 2976              		.loc 1 1951 0
 2977 1438 3B68     		ldr	r3, [r7, #0]
 2978 143a BB60     		str	r3, [r7, #8]
1952:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1953:bsp/boards/OpenMote-CC2538/source/pka.c ****         //
1954:bsp/boards/OpenMote-CC2538/source/pka.c ****         // Copy the x co-ordinate value of result from vector D into the
1955:bsp/boards/OpenMote-CC2538/source/pka.c ****         // the output EC Point.
1956:bsp/boards/OpenMote-CC2538/source/pka.c ****         //
1957:bsp/boards/OpenMote-CC2538/source/pka.c ****         for(i = 0; i < len; i++)
 2979              		.loc 1 1957 0
 2980 143c 4FF00003 		mov	r3, #0
 2981 1440 7B61     		str	r3, [r7, #20]
 2982 1442 11E0     		b	.L149
 2983              	.L150:
1958:bsp/boards/OpenMote-CC2538/source/pka.c ****         {
1959:bsp/boards/OpenMote-CC2538/source/pka.c ****             ptOutEcPt->pui32X[i] = HWREG((addr + 4*i));
 2984              		.loc 1 1959 0 discriminator 2
 2985 1444 7B68     		ldr	r3, [r7, #4]
 2986 1446 1A68     		ldr	r2, [r3, #0]
 2987 1448 7B69     		ldr	r3, [r7, #20]
 2988 144a 4FEA8303 		lsl	r3, r3, #2
 2989 144e D318     		adds	r3, r2, r3
 2990 1450 7A69     		ldr	r2, [r7, #20]
 2991 1452 4FEA8202 		lsl	r2, r2, #2
 2992 1456 1146     		mov	r1, r2
 2993 1458 BA68     		ldr	r2, [r7, #8]
 2994 145a 8A18     		adds	r2, r1, r2
 2995 145c 1268     		ldr	r2, [r2, #0]
 2996 145e 1A60     		str	r2, [r3, #0]
1957:bsp/boards/OpenMote-CC2538/source/pka.c ****         for(i = 0; i < len; i++)
 2997              		.loc 1 1957 0 discriminator 2
 2998 1460 7B69     		ldr	r3, [r7, #20]
 2999 1462 03F10103 		add	r3, r3, #1
 3000 1466 7B61     		str	r3, [r7, #20]
 3001              	.L149:
1957:bsp/boards/OpenMote-CC2538/source/pka.c ****         for(i = 0; i < len; i++)
 3002              		.loc 1 1957 0 is_stmt 0 discriminator 1
 3003 1468 7A69     		ldr	r2, [r7, #20]
 3004 146a FB68     		ldr	r3, [r7, #12]
 3005 146c 9A42     		cmp	r2, r3
 3006 146e E9D3     		bcc	.L150
1960:bsp/boards/OpenMote-CC2538/source/pka.c ****         }
1961:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1962:bsp/boards/OpenMote-CC2538/source/pka.c ****         addr += 4 * (i + 2 + len % 2);
 3007              		.loc 1 1962 0 is_stmt 1
 3008 1470 FB68     		ldr	r3, [r7, #12]
 3009 1472 03F00102 		and	r2, r3, #1
 3010 1476 7B69     		ldr	r3, [r7, #20]
 3011 1478 D318     		adds	r3, r2, r3
 3012 147a 03F10203 		add	r3, r3, #2
 3013 147e 4FEA8303 		lsl	r3, r3, #2
 3014 1482 BA68     		ldr	r2, [r7, #8]
 3015 1484 D318     		adds	r3, r2, r3
 3016 1486 BB60     		str	r3, [r7, #8]
1963:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1964:bsp/boards/OpenMote-CC2538/source/pka.c ****         //
1965:bsp/boards/OpenMote-CC2538/source/pka.c ****         // Copy the y co-ordinate value of result from vector D into the
1966:bsp/boards/OpenMote-CC2538/source/pka.c ****         // the output EC Point.
1967:bsp/boards/OpenMote-CC2538/source/pka.c ****         //
1968:bsp/boards/OpenMote-CC2538/source/pka.c ****         for(i = 0; i < len; i++)
 3017              		.loc 1 1968 0
 3018 1488 4FF00003 		mov	r3, #0
 3019 148c 7B61     		str	r3, [r7, #20]
 3020 148e 11E0     		b	.L151
 3021              	.L152:
1969:bsp/boards/OpenMote-CC2538/source/pka.c ****         {
1970:bsp/boards/OpenMote-CC2538/source/pka.c ****             ptOutEcPt->pui32Y[i] = HWREG((addr + 4*i));
 3022              		.loc 1 1970 0 discriminator 2
 3023 1490 7B68     		ldr	r3, [r7, #4]
 3024 1492 5A68     		ldr	r2, [r3, #4]
 3025 1494 7B69     		ldr	r3, [r7, #20]
 3026 1496 4FEA8303 		lsl	r3, r3, #2
 3027 149a D318     		adds	r3, r2, r3
 3028 149c 7A69     		ldr	r2, [r7, #20]
 3029 149e 4FEA8202 		lsl	r2, r2, #2
 3030 14a2 1146     		mov	r1, r2
 3031 14a4 BA68     		ldr	r2, [r7, #8]
 3032 14a6 8A18     		adds	r2, r1, r2
 3033 14a8 1268     		ldr	r2, [r2, #0]
 3034 14aa 1A60     		str	r2, [r3, #0]
1968:bsp/boards/OpenMote-CC2538/source/pka.c ****         for(i = 0; i < len; i++)
 3035              		.loc 1 1968 0 discriminator 2
 3036 14ac 7B69     		ldr	r3, [r7, #20]
 3037 14ae 03F10103 		add	r3, r3, #1
 3038 14b2 7B61     		str	r3, [r7, #20]
 3039              	.L151:
1968:bsp/boards/OpenMote-CC2538/source/pka.c ****         for(i = 0; i < len; i++)
 3040              		.loc 1 1968 0 is_stmt 0 discriminator 1
 3041 14b4 7A69     		ldr	r2, [r7, #20]
 3042 14b6 FB68     		ldr	r3, [r7, #12]
 3043 14b8 9A42     		cmp	r2, r3
 3044 14ba E9D3     		bcc	.L152
1971:bsp/boards/OpenMote-CC2538/source/pka.c ****         }
1972:bsp/boards/OpenMote-CC2538/source/pka.c **** 
1973:bsp/boards/OpenMote-CC2538/source/pka.c ****         return (PKA_STATUS_SUCCESS);
 3045              		.loc 1 1973 0 is_stmt 1
 3046 14bc 4FF00003 		mov	r3, #0
 3047 14c0 01E0     		b	.L146
 3048              	.L147:
1974:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
1975:bsp/boards/OpenMote-CC2538/source/pka.c ****     else
1976:bsp/boards/OpenMote-CC2538/source/pka.c ****     {
1977:bsp/boards/OpenMote-CC2538/source/pka.c ****         return (PKA_STATUS_FAILURE);
 3049              		.loc 1 1977 0
 3050 14c2 4FF00103 		mov	r3, #1
 3051              	.L146:
1978:bsp/boards/OpenMote-CC2538/source/pka.c ****     }
1979:bsp/boards/OpenMote-CC2538/source/pka.c **** }
 3052              		.loc 1 1979 0
 3053 14c6 1846     		mov	r0, r3
 3054 14c8 07F11C07 		add	r7, r7, #28
 3055 14cc BD46     		mov	sp, r7
 3056 14ce 80BC     		pop	{r7}
 3057 14d0 7047     		bx	lr
 3058              		.cfi_endproc
 3059              	.LFE21:
 3061              	.Letext0:
 3062              		.file 2 "/opt/gcc-arm-none-eabi-4_7-2013q3/bin/../lib/gcc/arm-none-eabi/4.7.4/../../../../arm-none
 3063              		.file 3 "bsp/boards/OpenMote-CC2538/source/ecc_curveinfo.h"
 3064              		.file 4 "bsp/boards/OpenMote-CC2538/source/pka.h"
DEFINED SYMBOLS
                            *ABS*:00000000 pka.c
     /tmp/ccoImdaG.s:18     .text:00000000 $t
     /tmp/ccoImdaG.s:23     .text:00000000 PKAEnableInt
     /tmp/ccoImdaG.s:51     .text:00000010 PKADisableInt
     /tmp/ccoImdaG.s:78     .text:00000020 PKAClearInt
     /tmp/ccoImdaG.s:105    .text:00000030 PKARegInt
     /tmp/ccoImdaG.s:139    .text:0000004c PKAUnRegInt
     /tmp/ccoImdaG.s:166    .text:0000005c PKAGetOpsStatus
     /tmp/ccoImdaG.s:207    .text:00000084 PKABigNumModStart
     /tmp/ccoImdaG.s:380    .text:000001cc PKABigNumModGetResult
     /tmp/ccoImdaG.s:492    .text:00000280 PKABigNumCmpStart
     /tmp/ccoImdaG.s:633    .text:00000380 PKABigNumCmpGetResult
     /tmp/ccoImdaG.s:716    .text:000003e8 PKABigNumInvModStart
     /tmp/ccoImdaG.s:884    .text:00000528 PKABigNumInvModGetResult
     /tmp/ccoImdaG.s:996    .text:000005dc PKABigNumMultiplyStart
     /tmp/ccoImdaG.s:1166   .text:0000071c PKABigNumMultGetResult
     /tmp/ccoImdaG.s:1283   .text:000007d8 PKABigNumAddStart
     /tmp/ccoImdaG.s:1451   .text:00000918 PKABigNumAddGetResult
     /tmp/ccoImdaG.s:1568   .text:000009d4 PKAECCMultiplyStart
     /tmp/ccoImdaG.s:1917   .text:00000c7c PKAECCMultiplyGetResult
     /tmp/ccoImdaG.s:2070   .text:00000d84 PKAECCMultGenPtStart
     /tmp/ccoImdaG.s:2418   .text:0000102c PKAECCMultGenPtGetResult
     /tmp/ccoImdaG.s:2571   .text:00001134 PKAECCAddStart
     /tmp/ccoImdaG.s:2913   .text:000013cc PKAECCAddGetResult
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.1.e96eee74da26538b12ac9582e3798382
                           .group:00000000 wm4.hw_ints.h.42.85b9479f2be35b086f1bb7cbb15bc097
                           .group:00000000 wm4.hw_memmap.h.39.19283c377d449c9bca5fdd8ccb62628c
                           .group:00000000 wm4.hw_pka.h.39.21ddda4008595aed4ecf0317dc241440
                           .group:00000000 wm4.newlib.h.8.a9901dc52d1357e3e94003403d43f8b5
                           .group:00000000 wm4.features.h.22.b72b3baab2bb2eab3661375590100b6b
                           .group:00000000 wm4.config.h.193.5fb8ef056cdff92dec3dee9552839d8c
                           .group:00000000 wm4._ansi.h.23.b5bb84d7ba97d82b5b1dc1826a7ae811
                           .group:00000000 wm4.stdint.h.20.54ad762faa59e3c05491630641c8d8bf
                           .group:00000000 wm4.stdbool.h.29.1c9ee6859ce8145f7838a4f2549ccec2
                           .group:00000000 wm4.hw_types.h.67.b10589a0806dcc2d274d6fab6b736519
                           .group:00000000 wm4.interrupt.h.41.272fc4ec0e276feb439e7974d0f77eaf
                           .group:00000000 wm4.pka.h.64.e6658a746a1332f9f0f055d6d08ac005
                           .group:00000000 wm4.sys_ctrl.h.41.c6bbd4dace326d685c1afa45bc1ba1e2
                           .group:00000000 wm4.debug.h.41.b891e613993738d067c45a5ff528d11a

UNDEFINED SYMBOLS
IntEnable
IntDisable
IntPendClear
IntRegister
IntUnregister
