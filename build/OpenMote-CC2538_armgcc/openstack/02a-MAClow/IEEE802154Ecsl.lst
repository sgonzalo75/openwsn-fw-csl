   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"IEEE802154Ecsl.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.rodata
  19              		.align	2
  22              	rreg_uriquery:
  23 0000 683D7563 		.ascii	"h=ucb\000"
  23      6200
  24 0006 0000     		.align	2
  27              	infoBoardname:
  28 0008 43433235 		.ascii	"CC2538\000"
  28      333800
  29 000f 00       		.align	2
  32              	infouCName:
  33 0010 43433235 		.ascii	"CC2538\000"
  33      333800
  34 0017 00       		.align	2
  37              	infoRadioName:
  38 0018 43433235 		.ascii	"CC2538 SoC\000"
  38      33382053 
  38      6F4300
  39 0023 00       		.align	2
  42              	infoStackName:
  43 0024 4F70656E 		.ascii	"OpenWSN \000"
  43      57534E20 
  43      00
  44 002d 000000   		.align	2
  47              	all_routers_multicast:
  48 0030 FF       		.byte	-1
  49 0031 02       		.byte	2
  50 0032 00       		.byte	0
  51 0033 00       		.byte	0
  52 0034 00       		.byte	0
  53 0035 00       		.byte	0
  54 0036 00       		.byte	0
  55 0037 00       		.byte	0
  56 0038 00       		.byte	0
  57 0039 00       		.byte	0
  58 003a 00       		.byte	0
  59 003b 00       		.byte	0
  60 003c 00       		.byte	0
  61 003d 00       		.byte	0
  62 003e 00       		.byte	0
  63 003f 02       		.byte	2
  64              		.comm	ieee154e_vars,76,4
  65              		.comm	ieee154e_stats,15,4
  66              		.comm	ieee154e_dbg,20,4
  67              		.text
  68              		.align	2
  69              		.global	ieee154e_init
  70              		.thumb
  71              		.thumb_func
  73              	ieee154e_init:
  74              	.LFB0:
  75              		.file 1 "openstack/02a-MAClow/IEEE802154Ecsl.c"
   1:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "IEEE802154Ecsl.h"
   2:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
   3:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "opendefs.h"
   4:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "radio.h"
   5:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "radiotimer.h"
   6:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "IEEE802154.h"
   7:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "openqueue.h"
   8:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "idmanager.h"
   9:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "openserial.h"
  10:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "schedule.h"
  11:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "packetfunctions.h"
  12:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "scheduler.h"
  13:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "leds.h"
  14:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "neighbors.h"
  15:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "debugpins.h"
  16:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "sixtop.h"
  17:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "adaptive_sync.h"
  18:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "processIE.h"
  19:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  20:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
  21:openstack/02a-MAClow/IEEE802154Ecsl.c **** //=========================== VARIABLES ================================
  22:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
  23:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  24:openstack/02a-MAClow/IEEE802154Ecsl.c **** ieee154e_vars_t    ieee154e_vars;
  25:openstack/02a-MAClow/IEEE802154Ecsl.c **** ieee154e_stats_t   ieee154e_stats;
  26:openstack/02a-MAClow/IEEE802154Ecsl.c **** ieee154e_dbg_t     ieee154e_dbg;
  27:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  28:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
  29:openstack/02a-MAClow/IEEE802154Ecsl.c **** //========================== PROTOTYPES ================================
  30:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
  31:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  32:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  33:openstack/02a-MAClow/IEEE802154Ecsl.c **** // TX-MODE: CSL Frame sending activities prototypes
  34:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ti1(void);
  35:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ti2(void);
  36:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_tie1(void);
  37:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ti3(void);
  38:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_tie2(void);
  39:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ti4(PORT_RADIOTIMER_WIDTH capturedTime);
  40:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_tie3(void);
  41:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ti5(PORT_RADIOTIMER_WIDTH capturedTime);
  42:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  43:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti2(void);
  44:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_tie1(void);
  45:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti3(void);
  46:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_tie2(void);
  47:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti4(PORT_RADIOTIMER_WIDTH capturedTime);
  48:openstack/02a-MAClow/IEEE802154Ecsl.c **** void	activity_csl_data_tie3(void);
  49:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti5(PORT_RADIOTIMER_WIDTH capturedTime);
  50:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti6(void);
  51:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_tie4(void);
  52:openstack/02a-MAClow/IEEE802154Ecsl.c **** void	activity_csl_data_ti7(void);
  53:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_tie5(void);
  54:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti8(PORT_RADIOTIMER_WIDTH capturedTime);
  55:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_tie6(void);
  56:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti9(PORT_RADIOTIMER_WIDTH capturedTime);
  57:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  58:openstack/02a-MAClow/IEEE802154Ecsl.c **** // RX-MODE: CSL Sampling activities prototypes
  59:openstack/02a-MAClow/IEEE802154Ecsl.c **** void 	activity_csl_wakeup_ri1(void);
  60:openstack/02a-MAClow/IEEE802154Ecsl.c **** void 	activity_csl_wakeup_ri2(void);
  61:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_rie1(void);
  62:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ri3(void);
  63:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_rie2(void);
  64:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ri4(PORT_RADIOTIMER_WIDTH capturedTime);
  65:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_rie3(void);
  66:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ri5(PORT_RADIOTIMER_WIDTH capturedTime);
  67:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_rie4(void);
  68:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  69:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ri2(void);
  70:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_rie1(void);
  71:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ri3(void);
  72:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_rie2(void);
  73:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ri4(PORT_RADIOTIMER_WIDTH capturedTime);
  74:openstack/02a-MAClow/IEEE802154Ecsl.c **** void	activity_csl_data_rie3(void);
  75:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ri5(PORT_RADIOTIMER_WIDTH capturedTime);
  76:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ri6(void);
  77:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_rie4(void);
  78:openstack/02a-MAClow/IEEE802154Ecsl.c **** void	activity_csl_data_ri7(void);
  79:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_rie5(void);
  80:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ri8(PORT_RADIOTIMER_WIDTH capturedTime);
  81:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_rie6(void);
  82:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ri9(PORT_RADIOTIMER_WIDTH capturedTime);
  83:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  84:openstack/02a-MAClow/IEEE802154Ecsl.c **** // frame validity check
  85:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool     isValidRxFrame(ieee802154_header_iht* ieee802514_header);
  86:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool     isValidAck(ieee802154_header_iht*     ieee802514_header,
  87:openstack/02a-MAClow/IEEE802154Ecsl.c ****                     OpenQueueEntry_t*          packetSent);
  88:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     changeIsSync(bool newIsSync);
  89:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  90:openstack/02a-MAClow/IEEE802154Ecsl.c **** // statistics
  91:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     resetStats(void);
  92:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     updateStats(PORT_SIGNED_INT_WIDTH timeCorrection);
  93:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  94:openstack/02a-MAClow/IEEE802154Ecsl.c **** // notifying upper layer
  95:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     notif_sendDone(OpenQueueEntry_t* packetSent, owerror_t error);
  96:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     notif_receive(OpenQueueEntry_t* packetReceived, uint8_t action);
  97:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  98:openstack/02a-MAClow/IEEE802154Ecsl.c **** // IEs Handling
  99:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool     ieee154e_processIEs(OpenQueueEntry_t* pkt, uint16_t* lenIE);
 100:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 101:openstack/02a-MAClow/IEEE802154Ecsl.c **** // ASN handling
 102:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     incrementAsnOffset(void);
 103:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     asnStoreFromAdv(uint8_t* asn);
 104:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     joinPriorityStoreFromAdv(uint8_t jp);
 105:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 106:openstack/02a-MAClow/IEEE802154Ecsl.c **** // misc
 107:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     changeState(ieee154e_state_t newstate);
 108:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     endOps(void);
 109:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool     debugPrint_asn(void);
 110:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool     debugPrint_isSync(void);
 111:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 112:openstack/02a-MAClow/IEEE802154Ecsl.c **** // CSL Sampling interrupts
 113:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     isr_ieee154ecsl_newChannelSample(void);
 114:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     isr_ieee154ecsl_timer(void);
 115:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 116:openstack/02a-MAClow/IEEE802154Ecsl.c **** // CSL queue checking for local transmissions
 117:openstack/02a-MAClow/IEEE802154Ecsl.c **** void 	 isr_ieee154ecsl_txtimer_cb(void);
 118:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 119:openstack/02a-MAClow/IEEE802154Ecsl.c **** // Testing callback to put a packet on queue for testing CSL Tx mode.
 120:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     isr_ieee154ecsl_addPacketToQueueForTestingCslTx_cb (void);
 121:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 122:openstack/02a-MAClow/IEEE802154Ecsl.c **** // CSL Wake-up frames (create and retrieve methods).
 123:openstack/02a-MAClow/IEEE802154Ecsl.c **** void 	ieee802154_retrieveWakeUpFrame(OpenQueueEntry_t* msg, ieee802154_header_iht* ieee802514_heade
 124:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    ieee802154_createWakeUpFrame(OpenQueueEntry_t* msg, uint8_t sequenceNumber, open_addr_t* ne
 125:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 126:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 127:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 128:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
 129:openstack/02a-MAClow/IEEE802154Ecsl.c **** //========================== INITIALIZATION ============================
 130:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
 131:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 132:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 133:openstack/02a-MAClow/IEEE802154Ecsl.c ****   \brief This function initializes this module.
 134:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 135:openstack/02a-MAClow/IEEE802154Ecsl.c ****   Call this function once before any other function in this module, possibly during boot-up.
 136:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 137:openstack/02a-MAClow/IEEE802154Ecsl.c **** void ieee154e_init() {
  76              		.loc 1 137 0
  77              		.cfi_startproc
  78              		@ args = 0, pretend = 0, frame = 0
  79              		@ frame_needed = 1, uses_anonymous_args = 0
  80 0000 80B5     		push	{r7, lr}
  81              	.LCFI0:
  82              		.cfi_def_cfa_offset 8
  83              		.cfi_offset 7, -8
  84              		.cfi_offset 14, -4
  85 0002 00AF     		add	r7, sp, #0
  86              	.LCFI1:
  87              		.cfi_def_cfa_register 7
 138:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
 139:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // initialize variables
 140:openstack/02a-MAClow/IEEE802154Ecsl.c ****    memset(&ieee154e_vars,0,sizeof(ieee154e_vars_t));
  88              		.loc 1 140 0
  89 0004 40F20000 		movw	r0, #:lower16:ieee154e_vars
  90 0008 C0F20000 		movt	r0, #:upper16:ieee154e_vars
  91 000c 4FF00001 		mov	r1, #0
  92 0010 4FF04C02 		mov	r2, #76
  93 0014 FFF7FEFF 		bl	memset
 141:openstack/02a-MAClow/IEEE802154Ecsl.c ****    memset(&ieee154e_dbg,0,sizeof(ieee154e_dbg_t));
  94              		.loc 1 141 0
  95 0018 40F20000 		movw	r0, #:lower16:ieee154e_dbg
  96 001c C0F20000 		movt	r0, #:upper16:ieee154e_dbg
  97 0020 4FF00001 		mov	r1, #0
  98 0024 4FF01402 		mov	r2, #20
  99 0028 FFF7FEFF 		bl	memset
 142:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
 143:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (idmanager_getIsDAGroot()==TRUE) {
 100              		.loc 1 143 0
 101 002c FFF7FEFF 		bl	idmanager_getIsDAGroot
 102 0030 0346     		mov	r3, r0
 103 0032 002B     		cmp	r3, #0
 104 0034 04D0     		beq	.L2
 144:openstack/02a-MAClow/IEEE802154Ecsl.c ****       changeIsSync(TRUE);
 105              		.loc 1 144 0
 106 0036 4FF00100 		mov	r0, #1
 107 003a FFF7FEFF 		bl	changeIsSync
 108 003e 03E0     		b	.L3
 109              	.L2:
 145:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
 146:openstack/02a-MAClow/IEEE802154Ecsl.c ****       changeIsSync(FALSE);
 110              		.loc 1 146 0
 111 0040 4FF00000 		mov	r0, #0
 112 0044 FFF7FEFF 		bl	changeIsSync
 113              	.L3:
 147:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 148:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
 149:openstack/02a-MAClow/IEEE802154Ecsl.c ****    resetStats();
 114              		.loc 1 149 0
 115 0048 FFF7FEFF 		bl	resetStats
 150:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.numDeSync                 = 0;
 116              		.loc 1 150 0
 117 004c 40F20003 		movw	r3, #:lower16:ieee154e_stats
 118 0050 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 119 0054 4FF00002 		mov	r2, #0
 120 0058 9A71     		strb	r2, [r3, #6]
 151:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
 152:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // update CSL Mode to SLEEP in order to allow RX o TX.
 153:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.cslMode = CSL_SLEEP_MODE;
 121              		.loc 1 153 0
 122 005a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 123 005e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 124 0062 4FF00002 		mov	r2, #0
 125 0066 83F84520 		strb	r2, [r3, #69]
 154:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Set initial DSN counter for wake-up sequence frames.
 155:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.cslDSN	 = 0;
 126              		.loc 1 155 0
 127 006a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 128 006e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 129 0072 4FF00002 		mov	r2, #0
 130 0076 83F84420 		strb	r2, [r3, #68]
 156:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 157:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // switch radio on - Does this function really do anything?. Its contents are commented...
 158:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rfOn();
 131              		.loc 1 158 0
 132 007a FFF7FEFF 		bl	radio_rfOn
 159:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
 160:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // set callback functions for the radio
 161:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_setOverflowCb(isr_ieee154ecsl_newChannelSample); // Fires every macCSLPeriod for CSL chann
 133              		.loc 1 161 0
 134 007e 40F20000 		movw	r0, #:lower16:isr_ieee154ecsl_newChannelSample
 135 0082 C0F20000 		movt	r0, #:upper16:isr_ieee154ecsl_newChannelSample
 136 0086 FFF7FEFF 		bl	radio_setOverflowCb
 162:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_setCompareCb(isr_ieee154ecsl_timer);             // Fires for FSM state changing
 137              		.loc 1 162 0
 138 008a 40F20000 		movw	r0, #:lower16:isr_ieee154ecsl_timer
 139 008e C0F20000 		movt	r0, #:upper16:isr_ieee154ecsl_timer
 140 0092 FFF7FEFF 		bl	radio_setCompareCb
 163:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_setStartFrameCb(ieee154ecsl_startOfFrame);
 141              		.loc 1 163 0
 142 0096 40F20000 		movw	r0, #:lower16:ieee154ecsl_startOfFrame
 143 009a C0F20000 		movt	r0, #:upper16:ieee154ecsl_startOfFrame
 144 009e FFF7FEFF 		bl	radio_setStartFrameCb
 164:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_setEndFrameCb(ieee154ecsl_endOfFrame);
 145              		.loc 1 164 0
 146 00a2 40F20000 		movw	r0, #:lower16:ieee154ecsl_endOfFrame
 147 00a6 C0F20000 		movt	r0, #:upper16:ieee154ecsl_endOfFrame
 148 00aa FFF7FEFF 		bl	radio_setEndFrameCb
 165:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 166:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // set timer for checking frames on local queue to transmit.
 167:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.txTimer = opentimers_start(macCSLTxChkFreq, TIMER_PERIODIC, TIME_TICS, isr_ieee154
 149              		.loc 1 167 0
 150 00ae 40F2AE70 		movw	r0, #1966
 151 00b2 4FF00001 		mov	r1, #0
 152 00b6 4FF00102 		mov	r2, #1
 153 00ba 40F20003 		movw	r3, #:lower16:isr_ieee154ecsl_txtimer_cb
 154 00be C0F20003 		movt	r3, #:upper16:isr_ieee154ecsl_txtimer_cb
 155 00c2 FFF7FEFF 		bl	opentimers_start
 156 00c6 0346     		mov	r3, r0
 157 00c8 1A46     		mov	r2, r3
 158 00ca 40F20003 		movw	r3, #:lower16:ieee154e_vars
 159 00ce C0F20003 		movt	r3, #:upper16:ieee154e_vars
 160 00d2 83F84620 		strb	r2, [r3, #70]
 168:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 169:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // set timer for callback to add packet to queue for testing CSL TX (every 5 seconds)
 170:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.cslTxTestTimer = opentimers_start(2000, TIMER_PERIODIC, TIME_MS, isr_ieee154ecsl_a
 161              		.loc 1 170 0
 162 00d6 4FF4FA60 		mov	r0, #2000
 163 00da 4FF00001 		mov	r1, #0
 164 00de 4FF00002 		mov	r2, #0
 165 00e2 40F20003 		movw	r3, #:lower16:isr_ieee154ecsl_addPacketToQueueForTestingCslTx_cb
 166 00e6 C0F20003 		movt	r3, #:upper16:isr_ieee154ecsl_addPacketToQueueForTestingCslTx_cb
 167 00ea FFF7FEFF 		bl	opentimers_start
 168 00ee 0346     		mov	r3, r0
 169 00f0 1A46     		mov	r2, r3
 170 00f2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 171 00f6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 172 00fa 83F84720 		strb	r2, [r3, #71]
 171:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 172:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // have the radio start its timer for channel sampling (macCSLPeriod)
 173:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_startTimer(macCSLPeriod);
 173              		.loc 1 173 0
 174 00fe 41F69A10 		movw	r0, #6554
 175 0102 FFF7FEFF 		bl	radio_startTimer
 174:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 176              		.loc 1 174 0
 177 0106 80BD     		pop	{r7, pc}
 178              		.cfi_endproc
 179              	.LFE0:
 181              		.align	2
 182              		.global	isr_ieee154ecsl_newChannelSample
 183              		.thumb
 184              		.thumb_func
 186              	isr_ieee154ecsl_newChannelSample:
 187              	.LFB1:
 175:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 176:openstack/02a-MAClow/IEEE802154Ecsl.c **** //=========================== public ==========================================
 177:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 178:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
 179:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================  EVENTS & CALLBACKS ===========================
 180:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
 181:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 182:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 183:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Indicates a new CSL Channel Sample has just started.
 184:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 185:openstack/02a-MAClow/IEEE802154Ecsl.c **** This function executes in ISR mode, when the new CSÑ Channel Sample timer fires.
 186:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 187:openstack/02a-MAClow/IEEE802154Ecsl.c **** void isr_ieee154ecsl_newChannelSample() {
 188              		.loc 1 187 0
 189              		.cfi_startproc
 190              		@ args = 0, pretend = 0, frame = 0
 191              		@ frame_needed = 1, uses_anonymous_args = 0
 192 0108 80B5     		push	{r7, lr}
 193              	.LCFI2:
 194              		.cfi_def_cfa_offset 8
 195              		.cfi_offset 7, -8
 196              		.cfi_offset 14, -4
 197 010a 00AF     		add	r7, sp, #0
 198              	.LCFI3:
 199              		.cfi_def_cfa_register 7
 188:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Establish the new timer for the next channel sample
 189:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_setTimerPeriod(macCSLPeriod);
 200              		.loc 1 189 0
 201 010c 41F69A10 		movw	r0, #6554
 202 0110 FFF7FEFF 		bl	radio_setTimerPeriod
 190:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 191:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Verificamos que no estamos ya en un proceso de TX o RX previo.
 192:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if(ieee154e_vars.cslMode == CSL_SLEEP_MODE) {
 203              		.loc 1 192 0
 204 0114 40F20003 		movw	r3, #:lower16:ieee154e_vars
 205 0118 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 206 011c 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 207 0120 002B     		cmp	r3, #0
 208 0122 02D1     		bne	.L5
 193:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // We call the first activity on FSM for channel sampling (CSL FSM RX mode)
 194:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  activity_csl_wakeup_ri1();
 209              		.loc 1 194 0
 210 0124 FFF7FEFF 		bl	activity_csl_wakeup_ri1
 211 0128 12E0     		b	.L6
 212              	.L5:
 195:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
 196:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // log the info about a operation in progress
 197:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printInfo(COMPONENT_IEEE802154E,ERR_MAC_OPERATION_IN_PROGRESS,
 198:openstack/02a-MAClow/IEEE802154Ecsl.c **** 						  (errorparameter_t)ieee154e_vars.cslMode, (errorparameter_t)ieee154e_dbg.num_cslSamples);
 213              		.loc 1 198 0
 214 012a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 215 012e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 216 0132 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 197:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printInfo(COMPONENT_IEEE802154E,ERR_MAC_OPERATION_IN_PROGRESS,
 217              		.loc 1 197 0
 218 0136 1A46     		mov	r2, r3
 219              		.loc 1 198 0
 220 0138 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 221 013c C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 222 0140 1B69     		ldr	r3, [r3, #16]
 197:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printInfo(COMPONENT_IEEE802154E,ERR_MAC_OPERATION_IN_PROGRESS,
 223              		.loc 1 197 0
 224 0142 9BB2     		uxth	r3, r3
 225 0144 4FF00900 		mov	r0, #9
 226 0148 4FF04001 		mov	r1, #64
 227 014c FFF7FEFF 		bl	openserial_printInfo
 228              	.L6:
 199:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 200:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 201:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Increment the number of cslSamples.
 202:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_dbg.num_cslSamples++;
 229              		.loc 1 202 0
 230 0150 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 231 0154 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 232 0158 1B69     		ldr	r3, [r3, #16]
 233 015a 03F10102 		add	r2, r3, #1
 234 015e 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 235 0162 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 236 0166 1A61     		str	r2, [r3, #16]
 203:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 237              		.loc 1 203 0
 238 0168 80BD     		pop	{r7, pc}
 239              		.cfi_endproc
 240              	.LFE1:
 242 016a 00BF     		.align	2
 243              		.global	isr_ieee154ecsl_timer
 244              		.thumb
 245              		.thumb_func
 247              	isr_ieee154ecsl_timer:
 248              	.LFB2:
 204:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 205:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 206:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Indicates the FSM timer has fired.
 207:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 208:openstack/02a-MAClow/IEEE802154Ecsl.c **** This function executes in ISR mode, when the FSM timer fires.
 209:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 210:openstack/02a-MAClow/IEEE802154Ecsl.c **** void isr_ieee154ecsl_timer() {
 249              		.loc 1 210 0
 250              		.cfi_startproc
 251              		@ args = 0, pretend = 0, frame = 0
 252              		@ frame_needed = 1, uses_anonymous_args = 0
 253 016c 80B5     		push	{r7, lr}
 254              	.LCFI4:
 255              		.cfi_def_cfa_offset 8
 256              		.cfi_offset 7, -8
 257              		.cfi_offset 14, -4
 258 016e 00AF     		add	r7, sp, #0
 259              	.LCFI5:
 260              		.cfi_def_cfa_register 7
 211:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.cslMode == CSL_RX_MODE)  { // Current CSL operation mode is channel sampling a
 261              		.loc 1 211 0
 262 0170 40F20003 		movw	r3, #:lower16:ieee154e_vars
 263 0174 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 264 0178 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 265 017c 012B     		cmp	r3, #1
 266 017e 71D1     		bne	.L8
 212:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   switch (ieee154e_vars.state) {
 267              		.loc 1 212 0
 268 0180 40F20003 		movw	r3, #:lower16:ieee154e_vars
 269 0184 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 270 0188 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 271 018a A3F12A03 		sub	r3, r3, #42
 272 018e 0F2B     		cmp	r3, #15
 273 0190 53D8     		bhi	.L9
 274 0192 01A2     		adr	r2, .L26
 275 0194 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 276              		.align	2
 277              	.L26:
 278 0198 D9010000 		.word	.L10+1
 279 019c DF010000 		.word	.L11+1
 280 01a0 E5010000 		.word	.L12+1
 281 01a4 EB010000 		.word	.L13+1
 282 01a8 F1010000 		.word	.L14+1
 283 01ac F7010000 		.word	.L15+1
 284 01b0 FD010000 		.word	.L16+1
 285 01b4 03020000 		.word	.L17+1
 286 01b8 09020000 		.word	.L18+1
 287 01bc 0F020000 		.word	.L19+1
 288 01c0 15020000 		.word	.L20+1
 289 01c4 1B020000 		.word	.L21+1
 290 01c8 21020000 		.word	.L22+1
 291 01cc 27020000 		.word	.L23+1
 292 01d0 2D020000 		.word	.L24+1
 293 01d4 33020000 		.word	.L25+1
 294              	.L10:
 213:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      // RX-MODE
 214:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUPOFFSET:      activity_csl_wakeup_ri2();  break;
 295              		.loc 1 214 0
 296 01d8 FFF7FEFF 		bl	activity_csl_wakeup_ri2
 297 01dc B6E0     		b	.L28
 298              	.L11:
 215:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUPPREPARE:     activity_csl_wakeup_rie1(); break;
 299              		.loc 1 215 0
 300 01de FFF7FEFF 		bl	activity_csl_wakeup_rie1
 301 01e2 B3E0     		b	.L28
 302              	.L12:
 216:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUPREADY:       activity_csl_wakeup_ri3();  break;
 303              		.loc 1 216 0
 304 01e4 FFF7FEFF 		bl	activity_csl_wakeup_ri3
 305 01e8 B0E0     		b	.L28
 306              	.L13:
 217:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUPLISTEN:      activity_csl_wakeup_rie2(); break;
 307              		.loc 1 217 0
 308 01ea FFF7FEFF 		bl	activity_csl_wakeup_rie2
 309 01ee ADE0     		b	.L28
 310              	.L14:
 218:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUP:			 activity_csl_wakeup_rie3(); break;
 311              		.loc 1 218 0
 312 01f0 FFF7FEFF 		bl	activity_csl_wakeup_rie3
 313 01f4 AAE0     		b	.L28
 314              	.L15:
 219:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUPVALIDATE: 	 activity_csl_wakeup_rie4(); break;
 315              		.loc 1 219 0
 316 01f6 FFF7FEFF 		bl	activity_csl_wakeup_rie4
 317 01fa A7E0     		b	.L28
 318              	.L16:
 220:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 221:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXDATAOFFSET:    	 activity_csl_data_ri2();    break;
 319              		.loc 1 221 0
 320 01fc FFF7FEFF 		bl	activity_csl_data_ri2
 321 0200 A4E0     		b	.L28
 322              	.L17:
 222:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXDATAPREPARE:       activity_csl_data_rie1();   break;
 323              		.loc 1 222 0
 324 0202 FFF7FEFF 		bl	activity_csl_data_rie1
 325 0206 A1E0     		b	.L28
 326              	.L18:
 223:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXDATAREADY:         activity_csl_data_ri3();    break;
 327              		.loc 1 223 0
 328 0208 FFF7FEFF 		bl	activity_csl_data_ri3
 329 020c 9EE0     		b	.L28
 330              	.L19:
 224:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXDATALISTEN:        activity_csl_data_rie2();   break;
 331              		.loc 1 224 0
 332 020e FFF7FEFF 		bl	activity_csl_data_rie2
 333 0212 9BE0     		b	.L28
 334              	.L20:
 225:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXDATA:			     activity_csl_data_rie3();   break;
 335              		.loc 1 225 0
 336 0214 FFF7FEFF 		bl	activity_csl_data_rie3
 337 0218 98E0     		b	.L28
 338              	.L21:
 226:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 227:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLTXACKOFFSET: 	     activity_csl_data_ri6();    break;
 339              		.loc 1 227 0
 340 021a FFF7FEFF 		bl	activity_csl_data_ri6
 341 021e 95E0     		b	.L28
 342              	.L22:
 228:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLTXACKPREPARE:        activity_csl_data_rie4();   break;
 343              		.loc 1 228 0
 344 0220 FFF7FEFF 		bl	activity_csl_data_rie4
 345 0224 92E0     		b	.L28
 346              	.L23:
 229:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLTXACKREADY:          activity_csl_data_ri7();    break;
 347              		.loc 1 229 0
 348 0226 FFF7FEFF 		bl	activity_csl_data_ri7
 349 022a 8FE0     		b	.L28
 350              	.L24:
 230:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLTXACKDELAY:          activity_csl_data_rie5();   break;
 351              		.loc 1 230 0
 352 022c FFF7FEFF 		bl	activity_csl_data_rie5
 353 0230 8CE0     		b	.L28
 354              	.L25:
 231:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLTXACK:               activity_csl_data_rie6();   break;
 355              		.loc 1 231 0
 356 0232 FFF7FEFF 		bl	activity_csl_data_rie6
 357 0236 00BF     		nop
 358 0238 88E0     		b	.L28
 359              	.L9:
 232:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  default:
 233:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 // log the error
 234:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_TIMERFIRES,
 235:openstack/02a-MAClow/IEEE802154Ecsl.c **** 								   (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_dbg.num_cslSamples);
 360              		.loc 1 235 0
 361 023a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 362 023e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 363 0242 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 234:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_TIMERFIRES,
 364              		.loc 1 234 0
 365 0244 1A46     		mov	r2, r3
 366              		.loc 1 235 0
 367 0246 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 368 024a C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 369 024e 1B69     		ldr	r3, [r3, #16]
 234:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_TIMERFIRES,
 370              		.loc 1 234 0
 371 0250 9BB2     		uxth	r3, r3
 372 0252 4FF00900 		mov	r0, #9
 373 0256 4FF03B01 		mov	r1, #59
 374 025a FFF7FEFF 		bl	openserial_printError
 236:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 // abort
 237:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 endOps();
 375              		.loc 1 237 0
 376 025e FFF7FEFF 		bl	endOps
 238:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 break;
 377              		.loc 1 238 0
 378 0262 73E0     		b	.L28
 379              	.L8:
 239:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 240:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else if (ieee154e_vars.cslMode == CSL_TX_MODE)  { // Current CSL operation mode is frame TX.
 380              		.loc 1 240 0
 381 0264 40F20003 		movw	r3, #:lower16:ieee154e_vars
 382 0268 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 383 026c 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 384 0270 022B     		cmp	r3, #2
 385 0272 6BD1     		bne	.L28
 241:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   switch (ieee154e_vars.state) {
 386              		.loc 1 241 0
 387 0274 40F20003 		movw	r3, #:lower16:ieee154e_vars
 388 0278 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 389 027c 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 390 027e A3F11A03 		sub	r3, r3, #26
 391 0282 0E2B     		cmp	r3, #14
 392 0284 4DD8     		bhi	.L29
 393 0286 01A2     		adr	r2, .L45
 394 0288 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 395              		.align	2
 396              	.L45:
 397 028c C9020000 		.word	.L30+1
 398 0290 CF020000 		.word	.L31+1
 399 0294 D5020000 		.word	.L32+1
 400 0298 DB020000 		.word	.L33+1
 401 029c E1020000 		.word	.L34+1
 402 02a0 E7020000 		.word	.L35+1
 403 02a4 ED020000 		.word	.L36+1
 404 02a8 F3020000 		.word	.L37+1
 405 02ac F9020000 		.word	.L38+1
 406 02b0 FF020000 		.word	.L39+1
 407 02b4 05030000 		.word	.L40+1
 408 02b8 0B030000 		.word	.L41+1
 409 02bc 11030000 		.word	.L42+1
 410 02c0 17030000 		.word	.L43+1
 411 02c4 1D030000 		.word	.L44+1
 412              	.L30:
 242:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      // TX-MODE
 243:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXWAKEUPOFFSET:		 activity_csl_wakeup_ti2();  break;
 413              		.loc 1 243 0
 414 02c8 FFF7FEFF 		bl	activity_csl_wakeup_ti2
 415 02cc 3EE0     		b	.L28
 416              	.L31:
 244:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXWAKEUPPREPARE:	 activity_csl_wakeup_tie1(); break;
 417              		.loc 1 244 0
 418 02ce FFF7FEFF 		bl	activity_csl_wakeup_tie1
 419 02d2 3BE0     		b	.L28
 420              	.L32:
 245:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXWAKEUPREADY:	     activity_csl_wakeup_ti3();  break;
 421              		.loc 1 245 0
 422 02d4 FFF7FEFF 		bl	activity_csl_wakeup_ti3
 423 02d8 38E0     		b	.L28
 424              	.L33:
 246:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXWAKEUPDELAY:	     activity_csl_wakeup_tie2(); break;
 425              		.loc 1 246 0
 426 02da FFF7FEFF 		bl	activity_csl_wakeup_tie2
 427 02de 35E0     		b	.L28
 428              	.L34:
 247:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXWAKEUP: 	         activity_csl_wakeup_tie3(); break;
 429              		.loc 1 247 0
 430 02e0 FFF7FEFF 		bl	activity_csl_wakeup_tie3
 431 02e4 32E0     		b	.L28
 432              	.L35:
 248:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 249:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXDATAOFFSET:        activity_csl_data_ti2();    break;
 433              		.loc 1 249 0
 434 02e6 FFF7FEFF 		bl	activity_csl_data_ti2
 435 02ea 2FE0     		b	.L28
 436              	.L36:
 250:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXDATAPREPARE:	     activity_csl_data_tie1(); 	 break;
 437              		.loc 1 250 0
 438 02ec FFF7FEFF 		bl	activity_csl_data_tie1
 439 02f0 2CE0     		b	.L28
 440              	.L37:
 251:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXDATAREADY:	     activity_csl_data_ti3(); 	 break;
 441              		.loc 1 251 0
 442 02f2 FFF7FEFF 		bl	activity_csl_data_ti3
 443 02f6 29E0     		b	.L28
 444              	.L38:
 252:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXDATADELAY:	     activity_csl_data_tie2(); 	 break;
 445              		.loc 1 252 0
 446 02f8 FFF7FEFF 		bl	activity_csl_data_tie2
 447 02fc 26E0     		b	.L28
 448              	.L39:
 253:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXDATA: 	         activity_csl_data_tie3();	 break;
 449              		.loc 1 253 0
 450 02fe FFF7FEFF 		bl	activity_csl_data_tie3
 451 0302 23E0     		b	.L28
 452              	.L40:
 254:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 255:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLRXACKOFFSET: 	     activity_csl_data_ti6();	 break;
 453              		.loc 1 255 0
 454 0304 FFF7FEFF 		bl	activity_csl_data_ti6
 455 0308 20E0     		b	.L28
 456              	.L41:
 256:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLRXACKPREPARE:	     activity_csl_data_tie4(); 	 break;
 457              		.loc 1 256 0
 458 030a FFF7FEFF 		bl	activity_csl_data_tie4
 459 030e 1DE0     		b	.L28
 460              	.L42:
 257:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLRXACKREADY: 	     activity_csl_data_ti7(); 	 break;
 461              		.loc 1 257 0
 462 0310 FFF7FEFF 		bl	activity_csl_data_ti7
 463 0314 1AE0     		b	.L28
 464              	.L43:
 258:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLRXACKLISTEN: 	     activity_csl_data_tie5(); 	 break;
 465              		.loc 1 258 0
 466 0316 FFF7FEFF 		bl	activity_csl_data_tie5
 467 031a 17E0     		b	.L28
 468              	.L44:
 259:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLRXACK:     	         activity_csl_data_tie6(); 	 break;
 469              		.loc 1 259 0
 470 031c FFF7FEFF 		bl	activity_csl_data_tie6
 471 0320 14E0     		b	.L28
 472              	.L29:
 260:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 261:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  default:
 262:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 // log the error
 263:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_TIMERFIRES,
 264:openstack/02a-MAClow/IEEE802154Ecsl.c **** 								   (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_dbg.num_cslSamples);
 473              		.loc 1 264 0
 474 0322 40F20003 		movw	r3, #:lower16:ieee154e_vars
 475 0326 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 476 032a 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 263:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_TIMERFIRES,
 477              		.loc 1 263 0
 478 032c 1A46     		mov	r2, r3
 479              		.loc 1 264 0
 480 032e 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 481 0332 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 482 0336 1B69     		ldr	r3, [r3, #16]
 263:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_TIMERFIRES,
 483              		.loc 1 263 0
 484 0338 9BB2     		uxth	r3, r3
 485 033a 4FF00900 		mov	r0, #9
 486 033e 4FF03B01 		mov	r1, #59
 487 0342 FFF7FEFF 		bl	openserial_printError
 265:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 // abort
 266:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 endOps();
 488              		.loc 1 266 0
 489 0346 FFF7FEFF 		bl	endOps
 267:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 break;
 490              		.loc 1 267 0
 491 034a 00BF     		nop
 492              	.L28:
 268:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 269:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 270:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_dbg.num_timer++;
 493              		.loc 1 270 0
 494 034c 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 495 0350 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 496 0354 5B68     		ldr	r3, [r3, #4]
 497 0356 03F10102 		add	r2, r3, #1
 498 035a 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 499 035e C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 500 0362 5A60     		str	r2, [r3, #4]
 271:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 501              		.loc 1 271 0
 502 0364 80BD     		pop	{r7, pc}
 503              		.cfi_endproc
 504              	.LFE2:
 506 0366 00BF     		.align	2
 507              		.global	ieee154ecsl_startOfFrame
 508              		.thumb
 509              		.thumb_func
 511              	ieee154ecsl_startOfFrame:
 512              	.LFB3:
 272:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 273:openstack/02a-MAClow/IEEE802154Ecsl.c **** void ieee154ecsl_startOfFrame(PORT_RADIOTIMER_WIDTH capturedTime) {
 513              		.loc 1 273 0
 514              		.cfi_startproc
 515              		@ args = 0, pretend = 0, frame = 8
 516              		@ frame_needed = 1, uses_anonymous_args = 0
 517 0368 80B5     		push	{r7, lr}
 518              	.LCFI6:
 519              		.cfi_def_cfa_offset 8
 520              		.cfi_offset 7, -8
 521              		.cfi_offset 14, -4
 522 036a 82B0     		sub	sp, sp, #8
 523              	.LCFI7:
 524              		.cfi_def_cfa_offset 16
 525 036c 00AF     		add	r7, sp, #0
 526              	.LCFI8:
 527              		.cfi_def_cfa_register 7
 528 036e 7860     		str	r0, [r7, #4]
 274:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	if(ieee154e_vars.cslMode == CSL_RX_MODE)  { // Current CSL operation mode is channel sampling and 
 529              		.loc 1 274 0
 530 0370 40F20003 		movw	r3, #:lower16:ieee154e_vars
 531 0374 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 532 0378 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 533 037c 012B     		cmp	r3, #1
 534 037e 30D1     		bne	.L47
 275:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   switch (ieee154e_vars.state) {
 535              		.loc 1 275 0
 536 0380 40F20003 		movw	r3, #:lower16:ieee154e_vars
 537 0384 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 538 0388 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 539 038a A3F12D03 		sub	r3, r3, #45
 540 038e 0B2B     		cmp	r3, #11
 541 0390 73D8     		bhi	.L60
 542 0392 01A2     		adr	r2, .L52
 543 0394 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 544              		.align	2
 545              	.L52:
 546 0398 C9030000 		.word	.L49+1
 547 039c C9030000 		.word	.L49+1
 548 03a0 7B040000 		.word	.L60+1
 549 03a4 7B040000 		.word	.L60+1
 550 03a8 7B040000 		.word	.L60+1
 551 03ac D1030000 		.word	.L50+1
 552 03b0 D1030000 		.word	.L50+1
 553 03b4 7B040000 		.word	.L60+1
 554 03b8 7B040000 		.word	.L60+1
 555 03bc 7B040000 		.word	.L60+1
 556 03c0 7B040000 		.word	.L60+1
 557 03c4 D9030000 		.word	.L51+1
 558              	.L49:
 276:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  // RX MODE
 277:openstack/02a-MAClow/IEEE802154Ecsl.c ****           /*
 278:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   It is possible to receive in this state for radio where there is no way of differentiated betw
 279:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   (e.g. CC2420). We must therefore expect to the start of a packet in this "ready" state.
 280:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  */
 281:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUP:    			 // no break!
 282:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUPLISTEN:	 	     activity_csl_wakeup_ri4(capturedTime); break;
 559              		.loc 1 282 0
 560 03c8 7868     		ldr	r0, [r7, #4]
 561 03ca FFF7FEFF 		bl	activity_csl_wakeup_ri4
 562 03ce 55E0     		b	.L54
 563              	.L50:
 283:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 284:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXDATAREADY:		     // no break!
 285:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXDATALISTEN:            activity_csl_data_ri4(capturedTime);   break;
 564              		.loc 1 285 0
 565 03d0 7868     		ldr	r0, [r7, #4]
 566 03d2 FFF7FEFF 		bl	activity_csl_data_ri4
 567 03d6 51E0     		b	.L54
 568              	.L51:
 286:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 287:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLTXACKDELAY:              activity_csl_data_ri8(capturedTime);   break;
 569              		.loc 1 287 0
 570 03d8 7868     		ldr	r0, [r7, #4]
 571 03da FFF7FEFF 		bl	activity_csl_data_ri8
 572 03de 00BF     		nop
 573 03e0 4CE0     		b	.L54
 574              	.L47:
 288:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  default:
 289:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			// log the error
 290:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			//openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_SAMPLE,
 291:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			//					  (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_dbg.num_cslSamples);
 292:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			// abort
 293:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			//endOps();
 294:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			break;
 295:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		}
 296:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	} else if (ieee154e_vars.cslMode == CSL_TX_MODE)  { // Current CSL operation mode is frame TX.
 575              		.loc 1 296 0
 576 03e2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 577 03e6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 578 03ea 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 579 03ee 022B     		cmp	r3, #2
 580 03f0 44D1     		bne	.L54
 297:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   switch (ieee154e_vars.state) {
 581              		.loc 1 297 0
 582 03f2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 583 03f6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 584 03fa 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 585 03fc A3F11D03 		sub	r3, r3, #29
 586 0400 0A2B     		cmp	r3, #10
 587 0402 25D8     		bhi	.L55
 588 0404 01A2     		adr	r2, .L59
 589 0406 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 590 040a 00BF     		.align	2
 591              	.L59:
 592 040c 41040000 		.word	.L56+1
 593 0410 51040000 		.word	.L55+1
 594 0414 51040000 		.word	.L55+1
 595 0418 51040000 		.word	.L55+1
 596 041c 51040000 		.word	.L55+1
 597 0420 49040000 		.word	.L57+1
 598 0424 51040000 		.word	.L55+1
 599 0428 51040000 		.word	.L55+1
 600 042c 51040000 		.word	.L55+1
 601 0430 39040000 		.word	.L58+1
 602 0434 39040000 		.word	.L58+1
 603              	.L58:
 298:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  // TX MODE
 299:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 300:openstack/02a-MAClow/IEEE802154Ecsl.c ****           /*
 301:openstack/02a-MAClow/IEEE802154Ecsl.c ****           It is possible to receive in this state for radio where there is no way of differentiated
 302:openstack/02a-MAClow/IEEE802154Ecsl.c ****           (e.g. CC2420). We must therefore expect to the start of a packet in this "ready" state.
 303:openstack/02a-MAClow/IEEE802154Ecsl.c ****           */
 304:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLRXACKREADY:               // no break!
 305:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLRXACKLISTEN:              activity_csl_data_ti8(capturedTime);  break;
 604              		.loc 1 305 0
 605 0438 7868     		ldr	r0, [r7, #4]
 606 043a FFF7FEFF 		bl	activity_csl_data_ti8
 607 043e 1DE0     		b	.L54
 608              	.L56:
 306:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 307:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXWAKEUPDELAY:            activity_csl_wakeup_ti4(capturedTime); break;
 609              		.loc 1 307 0
 610 0440 7868     		ldr	r0, [r7, #4]
 611 0442 FFF7FEFF 		bl	activity_csl_wakeup_ti4
 612 0446 19E0     		b	.L54
 613              	.L57:
 308:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXDATADELAY:              activity_csl_data_ti4(capturedTime);   break;
 614              		.loc 1 308 0
 615 0448 7868     		ldr	r0, [r7, #4]
 616 044a FFF7FEFF 		bl	activity_csl_data_ti4
 617 044e 15E0     		b	.L54
 618              	.L55:
 309:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 310:openstack/02a-MAClow/IEEE802154Ecsl.c ****           default:
 311:openstack/02a-MAClow/IEEE802154Ecsl.c ****    			// log the error
 312:openstack/02a-MAClow/IEEE802154Ecsl.c ****    			openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_SAMPLE,
 313:openstack/02a-MAClow/IEEE802154Ecsl.c ****    								  (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_dbg.num_cslSamples);
 619              		.loc 1 313 0
 620 0450 40F20003 		movw	r3, #:lower16:ieee154e_vars
 621 0454 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 622 0458 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 312:openstack/02a-MAClow/IEEE802154Ecsl.c ****    			openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_SAMPLE,
 623              		.loc 1 312 0
 624 045a 1A46     		mov	r2, r3
 625              		.loc 1 313 0
 626 045c 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 627 0460 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 628 0464 1B69     		ldr	r3, [r3, #16]
 312:openstack/02a-MAClow/IEEE802154Ecsl.c ****    			openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_SAMPLE,
 629              		.loc 1 312 0
 630 0466 9BB2     		uxth	r3, r3
 631 0468 4FF00900 		mov	r0, #9
 632 046c 4FF03E01 		mov	r1, #62
 633 0470 FFF7FEFF 		bl	openserial_printError
 314:openstack/02a-MAClow/IEEE802154Ecsl.c ****    			// abort
 315:openstack/02a-MAClow/IEEE802154Ecsl.c ****    			endOps();
 634              		.loc 1 315 0
 635 0474 FFF7FEFF 		bl	endOps
 316:openstack/02a-MAClow/IEEE802154Ecsl.c ****    			break;
 636              		.loc 1 316 0
 637 0478 00E0     		b	.L54
 638              	.L60:
 294:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			break;
 639              		.loc 1 294 0
 640 047a 00BF     		nop
 641              	.L54:
 317:openstack/02a-MAClow/IEEE802154Ecsl.c ****    		}
 318:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	}
 319:openstack/02a-MAClow/IEEE802154Ecsl.c ****   ieee154e_dbg.num_startOfFrame++;
 642              		.loc 1 319 0
 643 047c 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 644 0480 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 645 0484 9B68     		ldr	r3, [r3, #8]
 646 0486 03F10102 		add	r2, r3, #1
 647 048a 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 648 048e C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 649 0492 9A60     		str	r2, [r3, #8]
 320:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 650              		.loc 1 320 0
 651 0494 07F10807 		add	r7, r7, #8
 652 0498 BD46     		mov	sp, r7
 653 049a 80BD     		pop	{r7, pc}
 654              		.cfi_endproc
 655              	.LFE3:
 657              		.align	2
 658              		.global	ieee154ecsl_endOfFrame
 659              		.thumb
 660              		.thumb_func
 662              	ieee154ecsl_endOfFrame:
 663              	.LFB4:
 321:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 322:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 323:openstack/02a-MAClow/IEEE802154Ecsl.c **** void ieee154ecsl_endOfFrame(PORT_RADIOTIMER_WIDTH capturedTime) {
 664              		.loc 1 323 0
 665              		.cfi_startproc
 666              		@ args = 0, pretend = 0, frame = 8
 667              		@ frame_needed = 1, uses_anonymous_args = 0
 668 049c 80B5     		push	{r7, lr}
 669              	.LCFI9:
 670              		.cfi_def_cfa_offset 8
 671              		.cfi_offset 7, -8
 672              		.cfi_offset 14, -4
 673 049e 82B0     		sub	sp, sp, #8
 674              	.LCFI10:
 675              		.cfi_def_cfa_offset 16
 676 04a0 00AF     		add	r7, sp, #0
 677              	.LCFI11:
 678              		.cfi_def_cfa_register 7
 679 04a2 7860     		str	r0, [r7, #4]
 324:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	if(ieee154e_vars.cslMode == CSL_RX_MODE)  { // Current CSL operation mode is channel sampling and 
 680              		.loc 1 324 0
 681 04a4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 682 04a8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 683 04ac 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 684 04b0 012B     		cmp	r3, #1
 685 04b2 2CD1     		bne	.L62
 325:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   switch (ieee154e_vars.state) {
 686              		.loc 1 325 0
 687 04b4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 688 04b8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 689 04bc 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 690 04be 342B     		cmp	r3, #52
 691 04c0 07D0     		beq	.L65
 692 04c2 392B     		cmp	r3, #57
 693 04c4 09D0     		beq	.L66
 694 04c6 2E2B     		cmp	r3, #46
 695 04c8 0CD1     		bne	.L73
 696              	.L64:
 326:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		 // RX MODE
 327:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		 case S_CSLRXWAKEUP:           activity_csl_wakeup_ri5(capturedTime);  break;
 697              		.loc 1 327 0
 698 04ca 7868     		ldr	r0, [r7, #4]
 699 04cc FFF7FEFF 		bl	activity_csl_wakeup_ri5
 700 04d0 51E0     		b	.L68
 701              	.L65:
 328:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		 case S_CSLRXDATA:             activity_csl_data_ri5(capturedTime);    break;
 702              		.loc 1 328 0
 703 04d2 7868     		ldr	r0, [r7, #4]
 704 04d4 FFF7FEFF 		bl	activity_csl_data_ri5
 705 04d8 4DE0     		b	.L68
 706              	.L66:
 329:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		 case S_CSLTXACK:              activity_csl_data_ri9(capturedTime);    break;
 707              		.loc 1 329 0
 708 04da 7868     		ldr	r0, [r7, #4]
 709 04dc FFF7FEFF 		bl	activity_csl_data_ri9
 710 04e0 00BF     		nop
 711 04e2 48E0     		b	.L68
 712              	.L73:
 330:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		 default:
 331:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			// log the error
 332:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_ENDOFFRAME,
 333:openstack/02a-MAClow/IEEE802154Ecsl.c **** 								  (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_dbg.num_cslSamples);
 713              		.loc 1 333 0
 714 04e4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 715 04e8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 716 04ec 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 332:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_ENDOFFRAME,
 717              		.loc 1 332 0
 718 04ee 1A46     		mov	r2, r3
 719              		.loc 1 333 0
 720 04f0 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 721 04f4 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 722 04f8 1B69     		ldr	r3, [r3, #16]
 332:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_ENDOFFRAME,
 723              		.loc 1 332 0
 724 04fa 9BB2     		uxth	r3, r3
 725 04fc 4FF00900 		mov	r0, #9
 726 0500 4FF03F01 		mov	r1, #63
 727 0504 FFF7FEFF 		bl	openserial_printError
 334:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			// abort
 335:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			endOps();
 728              		.loc 1 335 0
 729 0508 FFF7FEFF 		bl	endOps
 336:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			break;
 730              		.loc 1 336 0
 731 050c 33E0     		b	.L68
 732              	.L62:
 337:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 338:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	} else if (ieee154e_vars.cslMode == CSL_TX_MODE)  { // Current CSL operation mode is frame TX.
 733              		.loc 1 338 0
 734 050e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 735 0512 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 736 0516 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 737 051a 022B     		cmp	r3, #2
 738 051c 2BD1     		bne	.L68
 339:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  switch (ieee154e_vars.state) {
 739              		.loc 1 339 0
 740 051e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 741 0522 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 742 0526 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 743 0528 232B     		cmp	r3, #35
 744 052a 07D0     		beq	.L71
 745 052c 282B     		cmp	r3, #40
 746 052e 09D0     		beq	.L72
 747 0530 1E2B     		cmp	r3, #30
 748 0532 0BD1     		bne	.L74
 749              	.L70:
 340:openstack/02a-MAClow/IEEE802154Ecsl.c ****         // TX MODE
 341:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	    case S_CSLTXWAKEUP:            activity_csl_wakeup_ti5(capturedTime); break;
 750              		.loc 1 341 0
 751 0534 7868     		ldr	r0, [r7, #4]
 752 0536 FFF7FEFF 		bl	activity_csl_wakeup_ti5
 753 053a 1CE0     		b	.L68
 754              	.L71:
 342:openstack/02a-MAClow/IEEE802154Ecsl.c ****         case S_CSLTXDATA:              activity_csl_data_ti5(capturedTime);   break;
 755              		.loc 1 342 0
 756 053c 7868     		ldr	r0, [r7, #4]
 757 053e FFF7FEFF 		bl	activity_csl_data_ti5
 758 0542 18E0     		b	.L68
 759              	.L72:
 343:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	    case S_CSLRXACK:               activity_csl_data_ti9(capturedTime);   break;
 760              		.loc 1 343 0
 761 0544 7868     		ldr	r0, [r7, #4]
 762 0546 FFF7FEFF 		bl	activity_csl_data_ti9
 763 054a 14E0     		b	.L68
 764              	.L74:
 344:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	    default:
 345:openstack/02a-MAClow/IEEE802154Ecsl.c ****            // log the error
 346:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_ENDOFFRAME,
 347:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			   				    (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_dbg.num_cslSamples)
 765              		.loc 1 347 0
 766 054c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 767 0550 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 768 0554 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 346:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_ENDOFFRAME,
 769              		.loc 1 346 0
 770 0556 1A46     		mov	r2, r3
 771              		.loc 1 347 0
 772 0558 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 773 055c C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 774 0560 1B69     		ldr	r3, [r3, #16]
 346:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_ENDOFFRAME,
 775              		.loc 1 346 0
 776 0562 9BB2     		uxth	r3, r3
 777 0564 4FF00900 		mov	r0, #9
 778 0568 4FF03F01 		mov	r1, #63
 779 056c FFF7FEFF 		bl	openserial_printError
 348:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	   // abort
 349:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   endOps();
 780              		.loc 1 349 0
 781 0570 FFF7FEFF 		bl	endOps
 350:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   break;
 782              		.loc 1 350 0
 783 0574 00BF     		nop
 784              	.L68:
 351:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  }
 352:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	}
 353:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_dbg.num_endOfFrame++;
 785              		.loc 1 353 0
 786 0576 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 787 057a C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 788 057e DB68     		ldr	r3, [r3, #12]
 789 0580 03F10102 		add	r2, r3, #1
 790 0584 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 791 0588 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 792 058c DA60     		str	r2, [r3, #12]
 354:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 793              		.loc 1 354 0
 794 058e 07F10807 		add	r7, r7, #8
 795 0592 BD46     		mov	sp, r7
 796 0594 80BD     		pop	{r7, pc}
 797              		.cfi_endproc
 798              	.LFE4:
 800 0596 00BF     		.align	2
 801              		.global	isr_ieee154ecsl_txtimer_cb
 802              		.thumb
 803              		.thumb_func
 805              	isr_ieee154ecsl_txtimer_cb:
 806              	.LFB5:
 355:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 356:openstack/02a-MAClow/IEEE802154Ecsl.c **** // tx timer interrupt callbacks
 357:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 358:openstack/02a-MAClow/IEEE802154Ecsl.c **** void isr_ieee154ecsl_txtimer_cb() {
 807              		.loc 1 358 0
 808              		.cfi_startproc
 809              		@ args = 0, pretend = 0, frame = 0
 810              		@ frame_needed = 1, uses_anonymous_args = 0
 811 0598 80B5     		push	{r7, lr}
 812              	.LCFI12:
 813              		.cfi_def_cfa_offset 8
 814              		.cfi_offset 7, -8
 815              		.cfi_offset 14, -4
 816 059a 00AF     		add	r7, sp, #0
 817              	.LCFI13:
 818              		.cfi_def_cfa_register 7
 359:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 360:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// Verificamos que no estamos ya en un proceso de TX o RX previo.
 361:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if(ieee154e_vars.cslMode == CSL_SLEEP_MODE) {
 819              		.loc 1 361 0
 820 059c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 821 05a0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 822 05a4 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 823 05a8 002B     		cmp	r3, #0
 824 05aa 02D1     		bne	.L76
 362:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // We call the first activity on FSM for channel sampling (CSL FSM RX mode)
 363:openstack/02a-MAClow/IEEE802154Ecsl.c ****       activity_csl_wakeup_ti1();
 825              		.loc 1 363 0
 826 05ac FFF7FEFF 		bl	activity_csl_wakeup_ti1
 827 05b0 12E0     		b	.L75
 828              	.L76:
 364:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 365:openstack/02a-MAClow/IEEE802154Ecsl.c ****    else {
 366:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // log the info about a operation in progress
 367:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printInfo(COMPONENT_IEEE802154E,ERR_MAC_OPERATION_IN_PROGRESS,
 368:openstack/02a-MAClow/IEEE802154Ecsl.c **** 						  (errorparameter_t)ieee154e_vars.cslMode, (errorparameter_t)ieee154e_dbg.num_cslSamples);
 829              		.loc 1 368 0
 830 05b2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 831 05b6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 832 05ba 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 367:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printInfo(COMPONENT_IEEE802154E,ERR_MAC_OPERATION_IN_PROGRESS,
 833              		.loc 1 367 0
 834 05be 1A46     		mov	r2, r3
 835              		.loc 1 368 0
 836 05c0 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 837 05c4 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 838 05c8 1B69     		ldr	r3, [r3, #16]
 367:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printInfo(COMPONENT_IEEE802154E,ERR_MAC_OPERATION_IN_PROGRESS,
 839              		.loc 1 367 0
 840 05ca 9BB2     		uxth	r3, r3
 841 05cc 4FF00900 		mov	r0, #9
 842 05d0 4FF04001 		mov	r1, #64
 843 05d4 FFF7FEFF 		bl	openserial_printInfo
 844              	.L75:
 369:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 370:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 845              		.loc 1 370 0
 846 05d8 80BD     		pop	{r7, pc}
 847              		.cfi_endproc
 848              	.LFE5:
 850 05da 00BF     		.align	2
 851              		.global	isr_ieee154ecsl_addPacketToQueueForTestingCslTx_cb
 852              		.thumb
 853              		.thumb_func
 855              	isr_ieee154ecsl_addPacketToQueueForTestingCslTx_cb:
 856              	.LFB6:
 371:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 372:openstack/02a-MAClow/IEEE802154Ecsl.c **** // test timer interrupt callback to put a new packet on queue for testing CSL TX mode.
 373:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 374:openstack/02a-MAClow/IEEE802154Ecsl.c **** void isr_ieee154ecsl_addPacketToQueueForTestingCslTx_cb () {
 857              		.loc 1 374 0
 858              		.cfi_startproc
 859              		@ args = 0, pretend = 0, frame = 24
 860              		@ frame_needed = 1, uses_anonymous_args = 0
 861 05dc B0B5     		push	{r4, r5, r7, lr}
 862              	.LCFI14:
 863              		.cfi_def_cfa_offset 16
 864              		.cfi_offset 4, -16
 865              		.cfi_offset 5, -12
 866              		.cfi_offset 7, -8
 867              		.cfi_offset 14, -4
 868 05de 8AB0     		sub	sp, sp, #40
 869              	.LCFI15:
 870              		.cfi_def_cfa_offset 56
 871 05e0 04AF     		add	r7, sp, #16
 872              	.LCFI16:
 873              		.cfi_def_cfa 7, 40
 375:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 376:openstack/02a-MAClow/IEEE802154Ecsl.c ****   OpenQueueEntry_t* pkt;
 377:openstack/02a-MAClow/IEEE802154Ecsl.c ****   open_addr_t neighbor;
 378:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 379:openstack/02a-MAClow/IEEE802154Ecsl.c ****   // Simulate a ficticious address for CSL testing.
 380:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[0]=0x00;
 874              		.loc 1 380 0
 875 05e2 4FF00003 		mov	r3, #0
 876 05e6 7B70     		strb	r3, [r7, #1]
 381:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[1]=0x11;
 877              		.loc 1 381 0
 878 05e8 4FF01103 		mov	r3, #17
 879 05ec BB70     		strb	r3, [r7, #2]
 382:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[2]=0x22;
 880              		.loc 1 382 0
 881 05ee 4FF02203 		mov	r3, #34
 882 05f2 FB70     		strb	r3, [r7, #3]
 383:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[3]=0x33;
 883              		.loc 1 383 0
 884 05f4 4FF03303 		mov	r3, #51
 885 05f8 3B71     		strb	r3, [r7, #4]
 384:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[4]=0x44;
 886              		.loc 1 384 0
 887 05fa 4FF04403 		mov	r3, #68
 888 05fe 7B71     		strb	r3, [r7, #5]
 385:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[5]=0x55;
 889              		.loc 1 385 0
 890 0600 4FF05503 		mov	r3, #85
 891 0604 BB71     		strb	r3, [r7, #6]
 386:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[6]=0x66;
 892              		.loc 1 386 0
 893 0606 4FF06603 		mov	r3, #102
 894 060a FB71     		strb	r3, [r7, #7]
 387:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[7]=0x77;
 895              		.loc 1 387 0
 896 060c 4FF07703 		mov	r3, #119
 897 0610 3B72     		strb	r3, [r7, #8]
 388:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 389:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.type=ADDR_64B;
 898              		.loc 1 389 0
 899 0612 4FF00203 		mov	r3, #2
 900 0616 3B70     		strb	r3, [r7, #0]
 390:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 391:openstack/02a-MAClow/IEEE802154Ecsl.c ****   // Switch off all the leds.
 392:openstack/02a-MAClow/IEEE802154Ecsl.c ****   leds_all_off();
 901              		.loc 1 392 0
 902 0618 FFF7FEFF 		bl	leds_all_off
 393:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 394:openstack/02a-MAClow/IEEE802154Ecsl.c ****   // CREATE DATA PACKET ONLY IF NOT ALREADY EXISTS ON QUEUE.
 395:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 396:openstack/02a-MAClow/IEEE802154Ecsl.c ****   if (openqueue_macGetDataPacket(&neighbor) == NULL) {
 903              		.loc 1 396 0
 904 061c 3B46     		mov	r3, r7
 905 061e 1846     		mov	r0, r3
 906 0620 FFF7FEFF 		bl	openqueue_macGetDataPacket
 907 0624 0346     		mov	r3, r0
 908 0626 002B     		cmp	r3, #0
 909 0628 6FD1     		bne	.L78
 397:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 398:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // get freebuffer.
 399:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt = openqueue_getFreePacketBuffer(COMPONENT_IEEE802154E);
 910              		.loc 1 399 0
 911 062a 4FF00900 		mov	r0, #9
 912 062e FFF7FEFF 		bl	openqueue_getFreePacketBuffer
 913 0632 7861     		str	r0, [r7, #20]
 400:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  if(pkt==NULL) {
 914              		.loc 1 400 0
 915 0634 7B69     		ldr	r3, [r7, #20]
 916 0636 002B     		cmp	r3, #0
 917 0638 0CD1     		bne	.L80
 401:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		// registro del error & fin de operaciones.
 402:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		openserial_printError(COMPONENT_IEEE802154E,ERR_NO_FREE_PACKET_BUFFER, (errorparameter_t)0, (erro
 918              		.loc 1 402 0
 919 063a 4FF00900 		mov	r0, #9
 920 063e 4FF02C01 		mov	r1, #44
 921 0642 4FF00002 		mov	r2, #0
 922 0646 4FF00003 		mov	r3, #0
 923 064a FFF7FEFF 		bl	openserial_printError
 403:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		endOps();
 924              		.loc 1 403 0
 925 064e FFF7FEFF 		bl	endOps
 926 0652 5AE0     		b	.L78
 927              	.L80:
 404:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		return;
 405:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  }
 406:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 407:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // Declaración de propiedad sobre el paquete.
 408:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->creator = COMPONENT_SIXTOP_TO_IEEE802154E;
 928              		.loc 1 408 0
 929 0654 7B69     		ldr	r3, [r7, #20]
 930 0656 4FF00A02 		mov	r2, #10
 931 065a 1A70     		strb	r2, [r3, #0]
 409:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->owner   = COMPONENT_SIXTOP_TO_IEEE802154E;
 932              		.loc 1 409 0
 933 065c 7B69     		ldr	r3, [r7, #20]
 934 065e 4FF00A02 		mov	r2, #10
 935 0662 5A70     		strb	r2, [r3, #1]
 410:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 411:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // Frame type (data frame).
 412:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->l2_frameType=IEEE154_TYPE_DATA;
 936              		.loc 1 412 0
 937 0664 7B69     		ldr	r3, [r7, #20]
 938 0666 4FF00102 		mov	r2, #1
 939 066a 83F84920 		strb	r2, [r3, #73]
 413:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 414:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // Flag created only to discriminate and toggle led indicator.
 415:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->cslFlag=123;
 940              		.loc 1 415 0
 941 066e 7B69     		ldr	r3, [r7, #20]
 942 0670 4FF07B02 		mov	r2, #123
 943 0674 83F8ED20 		strb	r2, [r3, #237]
 416:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 417:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // Neighbor address.
 418:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  memcpy(&(pkt->l2_nextORpreviousHop),&neighbor,sizeof(open_addr_t));
 944              		.loc 1 418 0
 945 0678 7B69     		ldr	r3, [r7, #20]
 946 067a 03F13803 		add	r3, r3, #56
 947 067e 1D46     		mov	r5, r3
 948 0680 3C46     		mov	r4, r7
 949 0682 0FCC     		ldmia	r4!, {r0, r1, r2, r3}
 950 0684 2860     		str	r0, [r5, #0]	@ unaligned
 951 0686 6960     		str	r1, [r5, #4]	@ unaligned
 952 0688 AA60     		str	r2, [r5, #8]	@ unaligned
 953 068a EB60     		str	r3, [r5, #12]	@ unaligned
 954 068c 2378     		ldrb	r3, [r4, #0]
 955 068e 2B74     		strb	r3, [r5, #16]
 419:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 420:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // TX retries
 421:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->l2_retriesLeft = TXRETRIES;
 956              		.loc 1 421 0
 957 0690 7B69     		ldr	r3, [r7, #20]
 958 0692 4FF00302 		mov	r2, #3
 959 0696 83F84B20 		strb	r2, [r3, #75]
 422:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 423:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // record this packet's dsn (for matching the ACK)
 424:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->l2_dsn = ieee154e_vars.cslDSN++;
 960              		.loc 1 424 0
 961 069a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 962 069e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 963 06a2 93F84430 		ldrb	r3, [r3, #68]	@ zero_extendqisi2
 964 06a6 7A69     		ldr	r2, [r7, #20]
 965 06a8 1946     		mov	r1, r3
 966 06aa 82F84A10 		strb	r1, [r2, #74]
 967 06ae 03F10103 		add	r3, r3, #1
 968 06b2 DAB2     		uxtb	r2, r3
 969 06b4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 970 06b8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 971 06bc 83F84420 		strb	r2, [r3, #68]
 425:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 426:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // this is a new packet which I never attempted to send
 427:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->l2_numTxAttempts = 0;
 972              		.loc 1 427 0
 973 06c0 7B69     		ldr	r3, [r7, #20]
 974 06c2 4FF00002 		mov	r2, #0
 975 06c6 83F84C20 		strb	r2, [r3, #76]
 428:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 429:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // transmit with the default TX power
 430:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->l1_txPower = TX_POWER;
 976              		.loc 1 430 0
 977 06ca 7B69     		ldr	r3, [r7, #20]
 978 06cc 4FF01F02 		mov	r2, #31
 979 06d0 83F86720 		strb	r2, [r3, #103]
 431:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 432:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // add a IEEE802.15.4 header
 433:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  ieee802154_prependHeader(pkt,
 434:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							   pkt->l2_frameType,
 980              		.loc 1 434 0
 981 06d4 7B69     		ldr	r3, [r7, #20]
 433:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  ieee802154_prependHeader(pkt,
 982              		.loc 1 433 0
 983 06d6 93F84930 		ldrb	r3, [r3, #73]	@ zero_extendqisi2
 435:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							   IEEE154_IELIST_NO,
 436:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							   IEEE154_FRAMEVERSION,
 437:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							   IEEE154_SEC_NO_SECURITY,
 438:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							   pkt->l2_dsn,
 984              		.loc 1 438 0
 985 06da 7A69     		ldr	r2, [r7, #20]
 433:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  ieee802154_prependHeader(pkt,
 986              		.loc 1 433 0
 987 06dc 92F84A10 		ldrb	r1, [r2, #74]	@ zero_extendqisi2
 988 06e0 7A69     		ldr	r2, [r7, #20]
 989 06e2 02F13802 		add	r2, r2, #56
 990 06e6 4FF00000 		mov	r0, #0
 991 06ea 0090     		str	r0, [sp, #0]
 992 06ec 0191     		str	r1, [sp, #4]
 993 06ee 0292     		str	r2, [sp, #8]
 994 06f0 7869     		ldr	r0, [r7, #20]
 995 06f2 1946     		mov	r1, r3
 996 06f4 4FF00002 		mov	r2, #0
 997 06f8 4FF00203 		mov	r3, #2
 998 06fc FFF7FEFF 		bl	ieee802154_prependHeader
 439:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							   &(pkt->l2_nextORpreviousHop)
 440:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							   );
 441:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 442:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // reserve space for 2-byte CRC
 443:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  packetfunctions_reserveFooterSize(pkt,2);
 999              		.loc 1 443 0
 1000 0700 7869     		ldr	r0, [r7, #20]
 1001 0702 4FF00201 		mov	r1, #2
 1002 0706 FFF7FEFF 		bl	packetfunctions_reserveFooterSize
 1003              	.L78:
 444:openstack/02a-MAClow/IEEE802154Ecsl.c ****   }
 445:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 446:openstack/02a-MAClow/IEEE802154Ecsl.c ****   return;
 447:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1004              		.loc 1 447 0
 1005 070a 07F11807 		add	r7, r7, #24
 1006 070e BD46     		mov	sp, r7
 1007 0710 B0BD     		pop	{r4, r5, r7, pc}
 1008              		.cfi_endproc
 1009              	.LFE6:
 1011 0712 00BF     		.align	2
 1012              		.global	activity_csl_wakeup_ti1
 1013              		.thumb
 1014              		.thumb_func
 1016              	activity_csl_wakeup_ti1:
 1017              	.LFB7:
 448:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 449:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 450:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
 451:openstack/02a-MAClow/IEEE802154Ecsl.c **** //========================== CSL TX MODE ===============================
 452:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
 453:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 454:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 455:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [wake-up ti1].
 456:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 457:openstack/02a-MAClow/IEEE802154Ecsl.c ****  This method is invoked in ISR-mode from "isr_ieee154ecsl_txtimer_cb" function when TX Timer is fir
 458:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 459:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 460:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ti1() {
 1018              		.loc 1 460 0
 1019              		.cfi_startproc
 1020              		@ args = 0, pretend = 0, frame = 24
 1021              		@ frame_needed = 1, uses_anonymous_args = 0
 1022 0714 80B5     		push	{r7, lr}
 1023              	.LCFI17:
 1024              		.cfi_def_cfa_offset 8
 1025              		.cfi_offset 7, -8
 1026              		.cfi_offset 14, -4
 1027 0716 86B0     		sub	sp, sp, #24
 1028              	.LCFI18:
 1029              		.cfi_def_cfa_offset 32
 1030 0718 00AF     		add	r7, sp, #0
 1031              	.LCFI19:
 1032              		.cfi_def_cfa_register 7
 461:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   cellType_t  cellType;
 462:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   open_addr_t neighbor;
 463:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 464:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // update CSL Mode to TX in order to avoid problems in FSM.
 465:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   ieee154e_vars.cslMode = CSL_TX_MODE;
 1033              		.loc 1 465 0
 1034 071a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1035 071e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1036 0722 4FF00202 		mov	r2, #2
 1037 0726 83F84520 		strb	r2, [r3, #69]
 466:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 467:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // Las acciones que realizaremos son las siguientes:
 468:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   //  - Avanzar el schedule para posicionar la siguiente posición en éste, el cual marcará la 
 469:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   //  - Verificar el estado actual dentro de la FSM para comprobar que efectivamente nos encontra
 470:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   //  - Si no hay problema en ambos, verificamos el tipo de slot en el schedule y preparamos un p
 471:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   //    destino asociado a dicho slot.
 472:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 473:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // increment ASN (do this first so debug pins are in sync)
 474:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   incrementAsnOffset();
 1038              		.loc 1 474 0
 1039 072a FFF7FEFF 		bl	incrementAsnOffset
 475:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 476:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // wiggle debug pins
 477:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   debugpins_slot_toggle();
 1040              		.loc 1 477 0
 1041 072e FFF7FEFF 		bl	debugpins_slot_toggle
 478:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   if (ieee154e_vars.slotOffset==0) {
 1042              		.loc 1 478 0
 1043 0732 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1044 0736 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1045 073a DB88     		ldrh	r3, [r3, #6]
 1046 073c 002B     		cmp	r3, #0
 1047 073e 01D1     		bne	.L83
 479:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      debugpins_frame_toggle();
 1048              		.loc 1 479 0
 1049 0740 FFF7FEFF 		bl	debugpins_frame_toggle
 1050              	.L83:
 480:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 481:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 482:openstack/02a-MAClow/IEEE802154Ecsl.c ****        // if the previous slot took too long, we will not be in the right state
 483:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   if (ieee154e_vars.state!=S_SLEEP) {
 1051              		.loc 1 483 0
 1052 0744 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1053 0748 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1054 074c 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 1055 074e 002B     		cmp	r3, #0
 1056 0750 14D0     		beq	.L84
 484:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      // log the error
 485:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_STARTSLOT,
 486:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	                            (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_dbg.
 1057              		.loc 1 486 0
 1058 0752 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1059 0756 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1060 075a 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 485:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_STARTSLOT,
 1061              		.loc 1 485 0
 1062 075c 1A46     		mov	r2, r3
 1063              		.loc 1 486 0
 1064 075e 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 1065 0762 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 1066 0766 1B69     		ldr	r3, [r3, #16]
 485:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_STARTSLOT,
 1067              		.loc 1 485 0
 1068 0768 9BB2     		uxth	r3, r3
 1069 076a 4FF00900 		mov	r0, #9
 1070 076e 4FF01E01 		mov	r1, #30
 1071 0772 FFF7FEFF 		bl	openserial_printError
 487:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      // abort
 488:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      endOps();
 1072              		.loc 1 488 0
 1073 0776 FFF7FEFF 		bl	endOps
 1074 077a 62E0     		b	.L82
 1075              	.L84:
 489:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      return;
 490:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 491:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 492:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // advance the schedule
 493:openstack/02a-MAClow/IEEE802154Ecsl.c ****        schedule_advanceSlot();
 1076              		.loc 1 493 0
 1077 077c FFF7FEFF 		bl	schedule_advanceSlot
 494:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 495:openstack/02a-MAClow/IEEE802154Ecsl.c ****        // stop using serial
 496:openstack/02a-MAClow/IEEE802154Ecsl.c ****        openserial_stop();
 1078              		.loc 1 496 0
 1079 0780 FFF7FEFF 		bl	openserial_stop
 497:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 498:openstack/02a-MAClow/IEEE802154Ecsl.c ****        // check the schedule to see what type of slot this is
 499:openstack/02a-MAClow/IEEE802154Ecsl.c ****        cellType = schedule_getType();
 1080              		.loc 1 499 0
 1081 0784 FFF7FEFF 		bl	schedule_getType
 1082 0788 0346     		mov	r3, r0
 1083 078a FB75     		strb	r3, [r7, #23]
 500:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 501:openstack/02a-MAClow/IEEE802154Ecsl.c ****        // check whether we can send
 502:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   if (schedule_getOkToSend()) {
 1084              		.loc 1 502 0
 1085 078c FFF7FEFF 		bl	schedule_getOkToSend
 1086 0790 0346     		mov	r3, r0
 1087 0792 002B     		cmp	r3, #0
 1088 0794 10D0     		beq	.L86
 503:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       schedule_getNeighbor(&neighbor);
 1089              		.loc 1 503 0
 1090 0796 07F10403 		add	r3, r7, #4
 1091 079a 1846     		mov	r0, r3
 1092 079c FFF7FEFF 		bl	schedule_getNeighbor
 504:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       ieee154e_vars.dataToSend = openqueue_macGetDataPacket(&neighbor);
 1093              		.loc 1 504 0
 1094 07a0 07F10403 		add	r3, r7, #4
 1095 07a4 1846     		mov	r0, r3
 1096 07a6 FFF7FEFF 		bl	openqueue_macGetDataPacket
 1097 07aa 0246     		mov	r2, r0
 1098 07ac 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1099 07b0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1100 07b4 5A61     		str	r2, [r3, #20]
 1101 07b6 06E0     		b	.L87
 1102              	.L86:
 505:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   } else {
 506:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       ieee154e_vars.dataToSend = NULL;
 1103              		.loc 1 506 0
 1104 07b8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1105 07bc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1106 07c0 4FF00002 		mov	r2, #0
 1107 07c4 5A61     		str	r2, [r3, #20]
 1108              	.L87:
 507:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 508:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   if((ieee154e_vars.dataToSend!=NULL) && (cellType == CELLTYPE_TX)) {   // If I have a packet to 
 1109              		.loc 1 508 0
 1110 07c6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1111 07ca C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1112 07ce 5B69     		ldr	r3, [r3, #20]
 1113 07d0 002B     		cmp	r3, #0
 1114 07d2 2ED0     		beq	.L88
 1115              		.loc 1 508 0 is_stmt 0 discriminator 1
 1116 07d4 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 1117 07d6 022B     		cmp	r3, #2
 1118 07d8 2BD1     		bne	.L88
 509:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       // change state to start sending CSL preamble before send the data packet.
 510:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       changeState(S_CSLTXWAKEUPOFFSET);
 1119              		.loc 1 510 0 is_stmt 1
 1120 07da 4FF01A00 		mov	r0, #26
 1121 07de FFF7FEFF 		bl	changeState
 511:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       // Establecemos el tiempo de rendezvous que será necesario esperar. Como se trata de una T
 512:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       // no sincronizada, deberá ser un tiempo igual a macCSLMaxPeriod (por eso cuando venza
 513:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       // el timing DURATION_tt1, solo nos quedará el tiempo macCSLMaxPeriod.
 514:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       ieee154e_vars.rzTime = DURATION_tt1 + macCSLMaxPeriod;
 1122              		.loc 1 514 0
 1123 07e2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1124 07e6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1125 07ea 5B6A     		ldr	r3, [r3, #36]
 1126 07ec 9BB2     		uxth	r3, r3
 1127 07ee 03F5CE53 		add	r3, r3, #6592
 1128 07f2 03F11403 		add	r3, r3, #20
 1129 07f6 9AB2     		uxth	r2, r3
 1130 07f8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1131 07fc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1132 0800 A3F84820 		strh	r2, [r3, #72]	@ movhi
 515:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       // change owner
 516:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       //ieee154e_vars.dataToSend->owner = COMPONENT_IEEE802154E;
 517:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       // record that I will attempt to transmit this packet
 518:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       ieee154e_vars.dataToSend->l2_numTxAttempts++;
 1133              		.loc 1 518 0
 1134 0804 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1135 0808 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1136 080c 5B69     		ldr	r3, [r3, #20]
 1137 080e 93F84C20 		ldrb	r2, [r3, #76]	@ zero_extendqisi2
 1138 0812 02F10102 		add	r2, r2, #1
 1139 0816 D2B2     		uxtb	r2, r2
 1140 0818 83F84C20 		strb	r2, [r3, #76]
 519:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       // arm tt1
 520:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       radiotimer_schedule(DURATION_tt1);
 1141              		.loc 1 520 0
 1142 081c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1143 0820 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1144 0824 5B6A     		ldr	r3, [r3, #36]
 1145 0826 03F13A03 		add	r3, r3, #58
 1146 082a 1846     		mov	r0, r3
 1147 082c FFF7FEFF 		bl	radiotimer_schedule
 1148 0830 07E0     		b	.L82
 1149              	.L88:
 521:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   } else {
 522:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       // abort because slot is not TX or there is no data to send, so we reset TX Mode state
 523:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   ieee154e_vars.cslMode = CSL_SLEEP_MODE;
 1150              		.loc 1 523 0
 1151 0832 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1152 0836 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1153 083a 4FF00002 		mov	r2, #0
 1154 083e 83F84520 		strb	r2, [r3, #69]
 1155              	.L82:
 524:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 525:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1156              		.loc 1 525 0
 1157 0842 07F11807 		add	r7, r7, #24
 1158 0846 BD46     		mov	sp, r7
 1159 0848 80BD     		pop	{r7, pc}
 1160              		.cfi_endproc
 1161              	.LFE7:
 1163 084a 00BF     		.align	2
 1164              		.global	activity_csl_wakeup_ti2
 1165              		.thumb
 1166              		.thumb_func
 1168              	activity_csl_wakeup_ti2:
 1169              	.LFB8:
 526:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 527:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 528:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [wake-up ti2].
 529:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 530:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 531:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to prepare the radio for sending packets.
 532:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 533:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 534:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ti2() {
 1170              		.loc 1 534 0
 1171              		.cfi_startproc
 1172              		@ args = 0, pretend = 0, frame = 24
 1173              		@ frame_needed = 1, uses_anonymous_args = 0
 1174 084c 80B5     		push	{r7, lr}
 1175              	.LCFI20:
 1176              		.cfi_def_cfa_offset 8
 1177              		.cfi_offset 7, -8
 1178              		.cfi_offset 14, -4
 1179 084e 86B0     		sub	sp, sp, #24
 1180              	.LCFI21:
 1181              		.cfi_def_cfa_offset 32
 1182 0850 00AF     		add	r7, sp, #0
 1183              	.LCFI22:
 1184              		.cfi_def_cfa_register 7
 535:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 536:openstack/02a-MAClow/IEEE802154Ecsl.c ****    open_addr_t neighbor;
 537:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 538:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 539:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXWAKEUPPREPARE);
 1185              		.loc 1 539 0
 1186 0852 4FF01B00 		mov	r0, #27
 1187 0856 FFF7FEFF 		bl	changeState
 540:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 541:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Calculamos el valor del rz-time en cada trama wake-up de la secuencia dado que debe ir reduci
 542:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // al extemo remoto el tiempo restante hasta el envío de la trama de datos.
 543:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 544:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // El tiempo lastCapturedTime se ve incrementado tras el envio de cada trama wake-up por lo que 
 545:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // valor más proximo al rztime inicial (macCSLMaxPeriod).
 546:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 547:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.remainingRzTime = ieee154e_vars.rzTime - ieee154e_vars.lastCapturedTime;
 1188              		.loc 1 547 0
 1189 085a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1190 085e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1191 0862 B3F84820 		ldrh	r2, [r3, #72]
 1192 0866 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1193 086a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1194 086e 5B6A     		ldr	r3, [r3, #36]
 1195 0870 9BB2     		uxth	r3, r3
 1196 0872 D31A     		subs	r3, r2, r3
 1197 0874 9AB2     		uxth	r2, r3
 1198 0876 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1199 087a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1200 087e A3F84A20 		strh	r2, [r3, #74]	@ movhi
 548:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 549:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
 550:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Construimos el paquete Wake-Up con su valor RZTime asociado en caso de no existir ya.
 551:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
 552:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 553:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.wakeupToSend == NULL) { // first time
 1201              		.loc 1 553 0
 1202 0882 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1203 0886 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1204 088a DB6B     		ldr	r3, [r3, #60]
 1205 088c 002B     		cmp	r3, #0
 1206 088e 75D1     		bne	.L91
 554:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 555:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // obtenemos un buffer en el cual poder guardar los datos recibidos.
 556:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   ieee154e_vars.wakeupToSend = openqueue_getFreePacketBuffer(COMPONENT_IEEE802154E);
 1207              		.loc 1 556 0
 1208 0890 4FF00900 		mov	r0, #9
 1209 0894 FFF7FEFF 		bl	openqueue_getFreePacketBuffer
 1210 0898 0246     		mov	r2, r0
 1211 089a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1212 089e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1213 08a2 DA63     		str	r2, [r3, #60]
 557:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   if (ieee154e_vars.wakeupToSend==NULL) {
 1214              		.loc 1 557 0
 1215 08a4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1216 08a8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1217 08ac DB6B     		ldr	r3, [r3, #60]
 1218 08ae 002B     		cmp	r3, #0
 1219 08b0 0CD1     		bne	.L92
 558:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  // registro del error & fin de operaciones.
 559:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  openserial_printError(COMPONENT_IEEE802154E,ERR_NO_FREE_PACKET_BUFFER, (errorparameter_t)0, (er
 1220              		.loc 1 559 0
 1221 08b2 4FF00900 		mov	r0, #9
 1222 08b6 4FF02C01 		mov	r1, #44
 1223 08ba 4FF00002 		mov	r2, #0
 1224 08be 4FF00003 		mov	r3, #0
 1225 08c2 FFF7FEFF 		bl	openserial_printError
 560:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  endOps();
 1226              		.loc 1 560 0
 1227 08c6 FFF7FEFF 		bl	endOps
 1228 08ca 96E0     		b	.L90
 1229              	.L92:
 561:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  return;
 562:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 563:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 564:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // Declaración de propiedad sobre el paquete.
 565:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   ieee154e_vars.wakeupToSend->creator = COMPONENT_IEEE802154E;
 1230              		.loc 1 565 0
 1231 08cc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1232 08d0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1233 08d4 DB6B     		ldr	r3, [r3, #60]
 1234 08d6 4FF00902 		mov	r2, #9
 1235 08da 1A70     		strb	r2, [r3, #0]
 566:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   ieee154e_vars.wakeupToSend->owner   = COMPONENT_IEEE802154E;
 1236              		.loc 1 566 0
 1237 08dc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1238 08e0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1239 08e4 DB6B     		ldr	r3, [r3, #60]
 1240 08e6 4FF00902 		mov	r2, #9
 1241 08ea 5A70     		strb	r2, [r3, #1]
 567:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 568:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // El tipo de trama es Multipurpose.
 569:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   ieee154e_vars.wakeupToSend->l2_frameType = IEEE154_TYPE_MULTIPURPOSE;
 1242              		.loc 1 569 0
 1243 08ec 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1244 08f0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1245 08f4 DB6B     		ldr	r3, [r3, #60]
 1246 08f6 4FF00502 		mov	r2, #5
 1247 08fa 83F84920 		strb	r2, [r3, #73]
 570:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 571:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // El dsn del paquete lo obtenemos a partir del actual DSN incrementado en cada paquete de la s
 572:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   ieee154e_vars.wakeupToSend->l2_dsn = ieee154e_vars.cslDSN++;
 1248              		.loc 1 572 0
 1249 08fe 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1250 0902 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1251 0906 DA6B     		ldr	r2, [r3, #60]
 1252 0908 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1253 090c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1254 0910 93F84430 		ldrb	r3, [r3, #68]	@ zero_extendqisi2
 1255 0914 1946     		mov	r1, r3
 1256 0916 82F84A10 		strb	r1, [r2, #74]
 1257 091a 03F10103 		add	r3, r3, #1
 1258 091e DAB2     		uxtb	r2, r3
 1259 0920 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1260 0924 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1261 0928 83F84420 		strb	r2, [r3, #68]
 573:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 574:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // El destinatario es el mismo que el destinatario del mensaje de datos indicado en el schedule
 575:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   schedule_getNeighbor(&neighbor);
 1262              		.loc 1 575 0
 1263 092c 07F10403 		add	r3, r7, #4
 1264 0930 1846     		mov	r0, r3
 1265 0932 FFF7FEFF 		bl	schedule_getNeighbor
 576:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 577:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // Verificamos que se trata de una dirección corta (short address). En caso contrario generamo
 578:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   if(neighbor.type != ADDR_16B) {
 1266              		.loc 1 578 0
 1267 0936 3B79     		ldrb	r3, [r7, #4]	@ zero_extendqisi2
 1268 0938 012B     		cmp	r3, #1
 1269 093a 08D0     		beq	.L94
 579:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // CSL: This is an invalid address because address in wake-up frame must be short address.
 580:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // We do not finish operations but we will use later short address getting it from long addres
 581:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   openserial_printInfo(COMPONENT_IEEE802154,ERR_IEEE154_UNSUPPORTED, (errorparameter_t)1, (error
 1270              		.loc 1 581 0
 1271 093c 3B79     		ldrb	r3, [r7, #4]	@ zero_extendqisi2
 1272 093e 4FF00800 		mov	r0, #8
 1273 0942 4FF01901 		mov	r1, #25
 1274 0946 4FF00102 		mov	r2, #1
 1275 094a FFF7FEFF 		bl	openserial_printInfo
 1276              	.L94:
 582:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 583:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 584:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // create frame header.
 585:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   ieee802154_createWakeUpFrame(ieee154e_vars.wakeupToSend,
 1277              		.loc 1 585 0
 1278 094e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1279 0952 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1280 0956 D86B     		ldr	r0, [r3, #60]
 586:openstack/02a-MAClow/IEEE802154Ecsl.c **** 									ieee154e_vars.wakeupToSend->l2_dsn,
 1281              		.loc 1 586 0
 1282 0958 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1283 095c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1284 0960 DB6B     		ldr	r3, [r3, #60]
 585:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   ieee802154_createWakeUpFrame(ieee154e_vars.wakeupToSend,
 1285              		.loc 1 585 0
 1286 0962 93F84A10 		ldrb	r1, [r3, #74]	@ zero_extendqisi2
 1287 0966 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1288 096a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1289 096e B3F84A30 		ldrh	r3, [r3, #74]
 1290 0972 07F10402 		add	r2, r7, #4
 1291 0976 FFF7FEFF 		bl	ieee802154_createWakeUpFrame
 1292 097a 0EE0     		b	.L95
 1293              	.L91:
 587:openstack/02a-MAClow/IEEE802154Ecsl.c **** 									&neighbor,
 588:openstack/02a-MAClow/IEEE802154Ecsl.c **** 									ieee154e_vars.remainingRzTime);
 589:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 590:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 591:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // space for 2-byte CRC
 592:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   //packetfunctions_reserveFooterSize(ieee154e_vars.wakeupToSend,2);
 593:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 594:openstack/02a-MAClow/IEEE802154Ecsl.c ****    else {
 595:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // update rztime in header.
 596:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // Se posiciona 8 posiciones antes dado que estamos escribiendo el paquete de atras hacia delan
 597:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // - 1 byte FCF
 598:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // - 1 byte SEQ
 599:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // - 2 bytes PANID
 600:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // - 2 bytes DEST ADDR
 601:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // - 2 bytes RZTIME IE HEADER
 602:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // - 2 bytes RZTIME (el cual se sobrescribirá con el nuevo valor).
 603:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	    *((uint16_t*)(ieee154e_vars.wakeupToSend->payload+8)) = ieee154e_vars.remainingRzTime;
 1294              		.loc 1 603 0
 1295 097c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1296 0980 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1297 0984 DB6B     		ldr	r3, [r3, #60]
 1298 0986 5B68     		ldr	r3, [r3, #4]
 1299 0988 03F10802 		add	r2, r3, #8
 1300 098c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1301 0990 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1302 0994 B3F84A30 		ldrh	r3, [r3, #74]
 1303 0998 1380     		strh	r3, [r2, #0]	@ movhi
 1304              	.L95:
 604:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 605:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 606:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 607:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // load the packet in the radio's Tx buffer
 608:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_loadPacket(ieee154e_vars.wakeupToSend->payload, ieee154e_vars.wakeupToSend->length);
 1305              		.loc 1 608 0
 1306 099a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1307 099e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1308 09a2 DB6B     		ldr	r3, [r3, #60]
 1309 09a4 5A68     		ldr	r2, [r3, #4]
 1310 09a6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1311 09aa C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1312 09ae DB6B     		ldr	r3, [r3, #60]
 1313 09b0 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 1314 09b2 1046     		mov	r0, r2
 1315 09b4 1946     		mov	r1, r3
 1316 09b6 FFF7FEFF 		bl	radio_loadPacket
 609:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 610:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // enable the radio in Tx mode. This does not send the packet.
 611:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_txEnable();
 1317              		.loc 1 611 0
 1318 09ba FFF7FEFF 		bl	radio_txEnable
 612:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnInit=radio_getTimerValue();
 1319              		.loc 1 612 0
 1320 09be FFF7FEFF 		bl	radio_getTimerValue
 1321 09c2 0246     		mov	r2, r0
 1322 09c4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1323 09c8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1324 09cc 1A63     		str	r2, [r3, #48]
 613:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnThisSlot=TRUE;
 1325              		.loc 1 613 0
 1326 09ce 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1327 09d2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1328 09d6 4FF00102 		mov	r2, #1
 1329 09da 83F83820 		strb	r2, [r3, #56]
 614:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 615:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt2
 616:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt2);
 1330              		.loc 1 616 0
 1331 09de 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1332 09e2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1333 09e6 5B6A     		ldr	r3, [r3, #36]
 1334 09e8 03F17C03 		add	r3, r3, #124
 1335 09ec 1846     		mov	r0, r3
 1336 09ee FFF7FEFF 		bl	radiotimer_schedule
 617:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 618:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 619:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXWAKEUPREADY);
 1337              		.loc 1 619 0
 1338 09f2 4FF01C00 		mov	r0, #28
 1339 09f6 FFF7FEFF 		bl	changeState
 1340              	.L90:
 620:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1341              		.loc 1 620 0
 1342 09fa 07F11807 		add	r7, r7, #24
 1343 09fe BD46     		mov	sp, r7
 1344 0a00 80BD     		pop	{r7, pc}
 1345              		.cfi_endproc
 1346              	.LFE8:
 1348 0a02 00BF     		.align	2
 1349              		.global	activity_csl_wakeup_tie1
 1350              		.thumb
 1351              		.thumb_func
 1353              	activity_csl_wakeup_tie1:
 1354              	.LFB9:
 621:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 622:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 623:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [wake-up tie1].
 624:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 625:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #tt2 expiring, i.e. timer fires while state = S_CSLTXWAKEUPPREPARE. This is 
 626:openstack/02a-MAClow/IEEE802154Ecsl.c ****   did not have enough time to execute. Chances are to set maxTxDataPrepare too small. The implement
 627:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 628:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_tie1() {
 1355              		.loc 1 628 0
 1356              		.cfi_startproc
 1357              		@ args = 0, pretend = 0, frame = 0
 1358              		@ frame_needed = 1, uses_anonymous_args = 0
 1359 0a04 80B5     		push	{r7, lr}
 1360              	.LCFI23:
 1361              		.cfi_def_cfa_offset 8
 1362              		.cfi_offset 7, -8
 1363              		.cfi_offset 14, -4
 1364 0a06 00AF     		add	r7, sp, #0
 1365              	.LCFI24:
 1366              		.cfi_def_cfa_register 7
 629:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
 630:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXDATAPREPARE_OVERFLOW,
 631:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_vars.slo
 1367              		.loc 1 631 0
 1368 0a08 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1369 0a0c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1370 0a10 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 630:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXDATAPREPARE_OVERFLOW,
 1371              		.loc 1 630 0
 1372 0a12 1A46     		mov	r2, r3
 1373 0a14 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1374 0a18 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1375 0a1c DB88     		ldrh	r3, [r3, #6]
 1376 0a1e 4FF00900 		mov	r0, #9
 1377 0a22 4FF02201 		mov	r1, #34
 1378 0a26 FFF7FEFF 		bl	openserial_printError
 632:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 633:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
 634:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //endOps();
 635:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1379              		.loc 1 635 0
 1380 0a2a 80BD     		pop	{r7, pc}
 1381              		.cfi_endproc
 1382              	.LFE9:
 1384              		.align	2
 1385              		.global	activity_csl_wakeup_ti3
 1386              		.thumb
 1387              		.thumb_func
 1389              	activity_csl_wakeup_ti3:
 1390              	.LFB10:
 636:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 637:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 638:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [wake-up ti3].
 639:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 640:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 641:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The radio is configured and this interrupt gives it the "go" signal to start listening.
 642:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 643:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 644:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ti3() {
 1391              		.loc 1 644 0
 1392              		.cfi_startproc
 1393              		@ args = 0, pretend = 0, frame = 0
 1394              		@ frame_needed = 1, uses_anonymous_args = 0
 1395 0a2c 80B5     		push	{r7, lr}
 1396              	.LCFI25:
 1397              		.cfi_def_cfa_offset 8
 1398              		.cfi_offset 7, -8
 1399              		.cfi_offset 14, -4
 1400 0a2e 00AF     		add	r7, sp, #0
 1401              	.LCFI26:
 1402              		.cfi_def_cfa_register 7
 645:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 646:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXWAKEUPDELAY);
 1403              		.loc 1 646 0
 1404 0a30 4FF01D00 		mov	r0, #29
 1405 0a34 FFF7FEFF 		bl	changeState
 647:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 648:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt3
 649:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt3);
 1406              		.loc 1 649 0
 1407 0a38 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1408 0a3c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1409 0a40 5B6A     		ldr	r3, [r3, #36]
 1410 0a42 03F19D03 		add	r3, r3, #157
 1411 0a46 1846     		mov	r0, r3
 1412 0a48 FFF7FEFF 		bl	radiotimer_schedule
 650:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 651:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // give the 'go' to transmit
 652:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_txNow();
 1413              		.loc 1 652 0
 1414 0a4c FFF7FEFF 		bl	radio_txNow
 653:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1415              		.loc 1 653 0
 1416 0a50 80BD     		pop	{r7, pc}
 1417              		.cfi_endproc
 1418              	.LFE10:
 1420 0a52 00BF     		.align	2
 1421              		.global	activity_csl_wakeup_tie2
 1422              		.thumb
 1423              		.thumb_func
 1425              	activity_csl_wakeup_tie2:
 1426              	.LFB11:
 654:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 655:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 656:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [wakeup tie2].
 657:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 658:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #tt3 expiring, i.e. timer fires while state = S_CSLTXWAKEUPDELAY. If no pack
 659:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 660:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_tie2() {
 1427              		.loc 1 660 0
 1428              		.cfi_startproc
 1429              		@ args = 0, pretend = 0, frame = 0
 1430              		@ frame_needed = 1, uses_anonymous_args = 0
 1431 0a54 80B5     		push	{r7, lr}
 1432              	.LCFI27:
 1433              		.cfi_def_cfa_offset 8
 1434              		.cfi_offset 7, -8
 1435              		.cfi_offset 14, -4
 1436 0a56 00AF     		add	r7, sp, #0
 1437              	.LCFI28:
 1438              		.cfi_def_cfa_register 7
 661:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
 662:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIO_OVERFLOWS,
 663:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_vars.slo
 1439              		.loc 1 663 0
 1440 0a58 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1441 0a5c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1442 0a60 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 662:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIO_OVERFLOWS,
 1443              		.loc 1 662 0
 1444 0a62 1A46     		mov	r2, r3
 1445 0a64 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1446 0a68 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1447 0a6c DB88     		ldrh	r3, [r3, #6]
 1448 0a6e 4FF00900 		mov	r0, #9
 1449 0a72 4FF02701 		mov	r1, #39
 1450 0a76 FFF7FEFF 		bl	openserial_printError
 664:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
 665:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //endOps();
 666:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1451              		.loc 1 666 0
 1452 0a7a 80BD     		pop	{r7, pc}
 1453              		.cfi_endproc
 1454              	.LFE11:
 1456              		.align	2
 1457              		.global	activity_csl_wakeup_ti4
 1458              		.thumb
 1459              		.thumb_func
 1461              	activity_csl_wakeup_ti4:
 1462              	.LFB12:
 667:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 668:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 669:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [wake-up ti4].
 670:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 671:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_startOfFrame" function when a start of frame ev
 672:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to capture the time, cancel #tt3 and arm #tt4 (max time to send all the pack
 673:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 674:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ti4(PORT_RADIOTIMER_WIDTH capturedTime) {
 1463              		.loc 1 674 0
 1464              		.cfi_startproc
 1465              		@ args = 0, pretend = 0, frame = 8
 1466              		@ frame_needed = 1, uses_anonymous_args = 0
 1467 0a7c 80B5     		push	{r7, lr}
 1468              	.LCFI29:
 1469              		.cfi_def_cfa_offset 8
 1470              		.cfi_offset 7, -8
 1471              		.cfi_offset 14, -4
 1472 0a7e 82B0     		sub	sp, sp, #8
 1473              	.LCFI30:
 1474              		.cfi_def_cfa_offset 16
 1475 0a80 00AF     		add	r7, sp, #0
 1476              	.LCFI31:
 1477              		.cfi_def_cfa_register 7
 1478 0a82 7860     		str	r0, [r7, #4]
 675:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 676:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel tt3
 677:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 1479              		.loc 1 677 0
 1480 0a84 FFF7FEFF 		bl	radiotimer_cancel
 678:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 679:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
 680:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.lastCapturedTime = capturedTime;
 1481              		.loc 1 680 0
 1482 0a88 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1483 0a8c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1484 0a90 7A68     		ldr	r2, [r7, #4]
 1485 0a92 5A62     		str	r2, [r3, #36]
 681:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 682:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 683:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXWAKEUP);
 1486              		.loc 1 683 0
 1487 0a94 4FF01E00 		mov	r0, #30
 1488 0a98 FFF7FEFF 		bl	changeState
 684:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 685:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt4
 686:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt4);
 1489              		.loc 1 686 0
 1490 0a9c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1491 0aa0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1492 0aa4 5B6A     		ldr	r3, [r3, #36]
 1493 0aa6 03F1A403 		add	r3, r3, #164
 1494 0aaa 1846     		mov	r0, r3
 1495 0aac FFF7FEFF 		bl	radiotimer_schedule
 687:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1496              		.loc 1 687 0
 1497 0ab0 07F10807 		add	r7, r7, #8
 1498 0ab4 BD46     		mov	sp, r7
 1499 0ab6 80BD     		pop	{r7, pc}
 1500              		.cfi_endproc
 1501              	.LFE12:
 1503              		.align	2
 1504              		.global	activity_csl_wakeup_tie3
 1505              		.thumb
 1506              		.thumb_func
 1508              	activity_csl_wakeup_tie3:
 1509              	.LFB13:
 688:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 689:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 690:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [wake-up tie3].
 691:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 692:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #tt4 expiring, i.e. timer fires while state = S_CSLTXWAKEUP. This is an erro
 693:openstack/02a-MAClow/IEEE802154Ecsl.c ****   took too long to transmit the data packet. The implemented behaviour is to log the error and fini
 694:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 695:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_tie3() {
 1510              		.loc 1 695 0
 1511              		.cfi_startproc
 1512              		@ args = 0, pretend = 0, frame = 0
 1513              		@ frame_needed = 1, uses_anonymous_args = 0
 1514 0ab8 80B5     		push	{r7, lr}
 1515              	.LCFI32:
 1516              		.cfi_def_cfa_offset 8
 1517              		.cfi_offset 7, -8
 1518              		.cfi_offset 14, -4
 1519 0aba 00AF     		add	r7, sp, #0
 1520              	.LCFI33:
 1521              		.cfi_def_cfa_register 7
 696:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
 697:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
 698:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_vars.slo
 1522              		.loc 1 698 0
 1523 0abc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1524 0ac0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1525 0ac4 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 697:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
 1526              		.loc 1 697 0
 1527 0ac6 1A46     		mov	r2, r3
 1528 0ac8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1529 0acc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1530 0ad0 DB88     		ldrh	r3, [r3, #6]
 1531 0ad2 4FF00900 		mov	r0, #9
 1532 0ad6 4FF02601 		mov	r1, #38
 1533 0ada FFF7FEFF 		bl	openserial_printError
 699:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
 700:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //endOps();
 701:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1534              		.loc 1 701 0
 1535 0ade 80BD     		pop	{r7, pc}
 1536              		.cfi_endproc
 1537              	.LFE13:
 1539              		.align	2
 1540              		.global	activity_csl_wakeup_ti5
 1541              		.thumb
 1542              		.thumb_func
 1544              	activity_csl_wakeup_ti5:
 1545              	.LFB14:
 702:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 703:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 704:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 705:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [wake-up ri5].
 706:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 707:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_endOfFrame" function when a end of frame event 
 708:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change state, cancel #rt4, and start sending data frame and wait for ACK.
 709:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 710:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ti5(PORT_RADIOTIMER_WIDTH capturedTime) {
 1546              		.loc 1 710 0
 1547              		.cfi_startproc
 1548              		@ args = 0, pretend = 0, frame = 8
 1549              		@ frame_needed = 1, uses_anonymous_args = 0
 1550 0ae0 80B5     		push	{r7, lr}
 1551              	.LCFI34:
 1552              		.cfi_def_cfa_offset 8
 1553              		.cfi_offset 7, -8
 1554              		.cfi_offset 14, -4
 1555 0ae2 82B0     		sub	sp, sp, #8
 1556              	.LCFI35:
 1557              		.cfi_def_cfa_offset 16
 1558 0ae4 00AF     		add	r7, sp, #0
 1559              	.LCFI36:
 1560              		.cfi_def_cfa_register 7
 1561 0ae6 7860     		str	r0, [r7, #4]
 711:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 712:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// record the captured time
 713:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	ieee154e_vars.lastCapturedTime = capturedTime;
 1562              		.loc 1 713 0
 1563 0ae8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1564 0aec C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1565 0af0 7A68     		ldr	r2, [r7, #4]
 1566 0af2 5A62     		str	r2, [r3, #36]
 714:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 715:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// Mientras el tiempo capturado en el envío de la ultima trama wake-up de la trama wake-up sequen
 716:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// sea inferior al tiempo de la duración del rztime inicial, debemos seguir enviando tramas wake-
 717:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// En caso contrario, enviamos la trama de datos.
 718:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 719:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	if((ieee154e_vars.rzTime - ieee154e_vars.lastCapturedTime) < ieee154e_vars.remainingRzTime) {
 1567              		.loc 1 719 0
 1568 0af4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1569 0af8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1570 0afc B3F84830 		ldrh	r3, [r3, #72]
 1571 0b00 1A46     		mov	r2, r3
 1572 0b02 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1573 0b06 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1574 0b0a 5B6A     		ldr	r3, [r3, #36]
 1575 0b0c D21A     		subs	r2, r2, r3
 1576 0b0e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1577 0b12 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1578 0b16 B3F84A30 		ldrh	r3, [r3, #74]
 1579 0b1a 9A42     		cmp	r2, r3
 1580 0b1c 04D2     		bcs	.L102
 720:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   changeState(S_CSLTXWAKEUPOFFSET);
 1581              		.loc 1 720 0
 1582 0b1e 4FF01A00 		mov	r0, #26
 1583 0b22 FFF7FEFF 		bl	changeState
 1584 0b26 03E0     		b	.L103
 1585              	.L102:
 721:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	}
 722:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	else {
 723:openstack/02a-MAClow/IEEE802154Ecsl.c ****        changeState(S_CSLTXDATAOFFSET);
 1586              		.loc 1 723 0
 1587 0b28 4FF01F00 		mov	r0, #31
 1588 0b2c FFF7FEFF 		bl	changeState
 1589              	.L103:
 724:openstack/02a-MAClow/IEEE802154Ecsl.c ****     }
 725:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 726:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt1 (enviemos de nuevo una trama de wake-up o de datos, el tiempo será tt1).
 727:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt1);
 1590              		.loc 1 727 0
 1591 0b30 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1592 0b34 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1593 0b38 5B6A     		ldr	r3, [r3, #36]
 1594 0b3a 03F13A03 		add	r3, r3, #58
 1595 0b3e 1846     		mov	r0, r3
 1596 0b40 FFF7FEFF 		bl	radiotimer_schedule
 728:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1597              		.loc 1 728 0
 1598 0b44 07F10807 		add	r7, r7, #8
 1599 0b48 BD46     		mov	sp, r7
 1600 0b4a 80BD     		pop	{r7, pc}
 1601              		.cfi_endproc
 1602              	.LFE14:
 1604              		.align	2
 1605              		.global	activity_csl_data_ti2
 1606              		.thumb
 1607              		.thumb_func
 1609              	activity_csl_data_ti2:
 1610              	.LFB15:
 729:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 730:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 731:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 732:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti2].
 733:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 734:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 735:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to prepare the radio for sending packets.
 736:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 737:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti2() {
 1611              		.loc 1 737 0
 1612              		.cfi_startproc
 1613              		@ args = 0, pretend = 0, frame = 0
 1614              		@ frame_needed = 1, uses_anonymous_args = 0
 1615 0b4c 80B5     		push	{r7, lr}
 1616              	.LCFI37:
 1617              		.cfi_def_cfa_offset 8
 1618              		.cfi_offset 7, -8
 1619              		.cfi_offset 14, -4
 1620 0b4e 00AF     		add	r7, sp, #0
 1621              	.LCFI38:
 1622              		.cfi_def_cfa_register 7
 738:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 739:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXDATAPREPARE);
 1623              		.loc 1 739 0
 1624 0b50 4FF02000 		mov	r0, #32
 1625 0b54 FFF7FEFF 		bl	changeState
 740:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 741:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // load the packet in the radio's Tx buffer
 742:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_loadPacket(ieee154e_vars.dataToSend->payload,
 1626              		.loc 1 742 0
 1627 0b58 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1628 0b5c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1629 0b60 5B69     		ldr	r3, [r3, #20]
 1630 0b62 5A68     		ldr	r2, [r3, #4]
 743:openstack/02a-MAClow/IEEE802154Ecsl.c ****                     ieee154e_vars.dataToSend->length);
 1631              		.loc 1 743 0
 1632 0b64 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1633 0b68 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1634 0b6c 5B69     		ldr	r3, [r3, #20]
 742:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_loadPacket(ieee154e_vars.dataToSend->payload,
 1635              		.loc 1 742 0
 1636 0b6e 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 1637 0b70 1046     		mov	r0, r2
 1638 0b72 1946     		mov	r1, r3
 1639 0b74 FFF7FEFF 		bl	radio_loadPacket
 744:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 745:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // enable the radio in Tx mode. This does not send the packet.
 746:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_txEnable();
 1640              		.loc 1 746 0
 1641 0b78 FFF7FEFF 		bl	radio_txEnable
 747:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnInit=radio_getTimerValue();
 1642              		.loc 1 747 0
 1643 0b7c FFF7FEFF 		bl	radio_getTimerValue
 1644 0b80 0246     		mov	r2, r0
 1645 0b82 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1646 0b86 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1647 0b8a 1A63     		str	r2, [r3, #48]
 748:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnThisSlot=TRUE;
 1648              		.loc 1 748 0
 1649 0b8c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1650 0b90 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1651 0b94 4FF00102 		mov	r2, #1
 1652 0b98 83F83820 		strb	r2, [r3, #56]
 749:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 750:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt2
 751:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt2);
 1653              		.loc 1 751 0
 1654 0b9c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1655 0ba0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1656 0ba4 5B6A     		ldr	r3, [r3, #36]
 1657 0ba6 03F17C03 		add	r3, r3, #124
 1658 0baa 1846     		mov	r0, r3
 1659 0bac FFF7FEFF 		bl	radiotimer_schedule
 752:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 753:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 754:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXDATAREADY);
 1660              		.loc 1 754 0
 1661 0bb0 4FF02100 		mov	r0, #33
 1662 0bb4 FFF7FEFF 		bl	changeState
 755:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 756:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1663              		.loc 1 756 0
 1664 0bb8 80BD     		pop	{r7, pc}
 1665              		.cfi_endproc
 1666              	.LFE15:
 1668 0bba 00BF     		.align	2
 1669              		.global	activity_csl_data_tie1
 1670              		.thumb
 1671              		.thumb_func
 1673              	activity_csl_data_tie1:
 1674              	.LFB16:
 757:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 758:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 759:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data tie1].
 760:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 761:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #tt2 expiring, i.e. timer fires while state = S_CSLTXDATAPREPARE. This is re
 762:openstack/02a-MAClow/IEEE802154Ecsl.c ****   did not have enough time to execute. Chances are to set maxTxDataPrepare too small. The implement
 763:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 764:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_tie1() {
 1675              		.loc 1 764 0
 1676              		.cfi_startproc
 1677              		@ args = 0, pretend = 0, frame = 0
 1678              		@ frame_needed = 1, uses_anonymous_args = 0
 1679 0bbc 80B5     		push	{r7, lr}
 1680              	.LCFI39:
 1681              		.cfi_def_cfa_offset 8
 1682              		.cfi_offset 7, -8
 1683              		.cfi_offset 14, -4
 1684 0bbe 00AF     		add	r7, sp, #0
 1685              	.LCFI40:
 1686              		.cfi_def_cfa_register 7
 765:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
 766:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXDATAPREPARE_OVERFLOW,
 767:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_vars.slo
 1687              		.loc 1 767 0
 1688 0bc0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1689 0bc4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1690 0bc8 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 766:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXDATAPREPARE_OVERFLOW,
 1691              		.loc 1 766 0
 1692 0bca 1A46     		mov	r2, r3
 1693 0bcc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1694 0bd0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1695 0bd4 DB88     		ldrh	r3, [r3, #6]
 1696 0bd6 4FF00900 		mov	r0, #9
 1697 0bda 4FF02201 		mov	r1, #34
 1698 0bde FFF7FEFF 		bl	openserial_printError
 768:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
 769:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 1699              		.loc 1 769 0
 1700 0be2 FFF7FEFF 		bl	endOps
 770:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1701              		.loc 1 770 0
 1702 0be6 80BD     		pop	{r7, pc}
 1703              		.cfi_endproc
 1704              	.LFE16:
 1706              		.align	2
 1707              		.global	activity_csl_data_ti3
 1708              		.thumb
 1709              		.thumb_func
 1711              	activity_csl_data_ti3:
 1712              	.LFB17:
 771:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 772:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 773:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti3].
 774:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 775:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 776:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The radio is configured and this interrupt gives it the "go" signal to start listening.
 777:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 778:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti3() {
 1713              		.loc 1 778 0
 1714              		.cfi_startproc
 1715              		@ args = 0, pretend = 0, frame = 0
 1716              		@ frame_needed = 1, uses_anonymous_args = 0
 1717 0be8 80B5     		push	{r7, lr}
 1718              	.LCFI41:
 1719              		.cfi_def_cfa_offset 8
 1720              		.cfi_offset 7, -8
 1721              		.cfi_offset 14, -4
 1722 0bea 00AF     		add	r7, sp, #0
 1723              	.LCFI42:
 1724              		.cfi_def_cfa_register 7
 779:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 780:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXDATADELAY);
 1725              		.loc 1 780 0
 1726 0bec 4FF02200 		mov	r0, #34
 1727 0bf0 FFF7FEFF 		bl	changeState
 781:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 782:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt3
 783:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt3);
 1728              		.loc 1 783 0
 1729 0bf4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1730 0bf8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1731 0bfc 5B6A     		ldr	r3, [r3, #36]
 1732 0bfe 03F19D03 		add	r3, r3, #157
 1733 0c02 1846     		mov	r0, r3
 1734 0c04 FFF7FEFF 		bl	radiotimer_schedule
 784:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 785:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // give the 'go' to transmit
 786:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_txNow();
 1735              		.loc 1 786 0
 1736 0c08 FFF7FEFF 		bl	radio_txNow
 787:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1737              		.loc 1 787 0
 1738 0c0c 80BD     		pop	{r7, pc}
 1739              		.cfi_endproc
 1740              	.LFE17:
 1742 0c0e 00BF     		.align	2
 1743              		.global	activity_csl_data_tie2
 1744              		.thumb
 1745              		.thumb_func
 1747              	activity_csl_data_tie2:
 1748              	.LFB18:
 788:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 789:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 790:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 791:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX Sampling error [data tie2].
 792:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 793:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #tt3 expiring, i.e. timer fires while state = S_CSLTXDATADELAY. If no packet
 794:openstack/02a-MAClow/IEEE802154Ecsl.c ****   none will be sent and it is safe to switch off the radio. This timer is set such that the radio w
 795:openstack/02a-MAClow/IEEE802154Ecsl.c ****   duration (#TsLongGT).
 796:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 797:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_tie2() {
 1749              		.loc 1 797 0
 1750              		.cfi_startproc
 1751              		@ args = 0, pretend = 0, frame = 0
 1752              		@ frame_needed = 1, uses_anonymous_args = 0
 1753 0c10 80B5     		push	{r7, lr}
 1754              	.LCFI43:
 1755              		.cfi_def_cfa_offset 8
 1756              		.cfi_offset 7, -8
 1757              		.cfi_offset 14, -4
 1758 0c12 00AF     		add	r7, sp, #0
 1759              	.LCFI44:
 1760              		.cfi_def_cfa_register 7
 798:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
 799:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIO_OVERFLOWS,
 800:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_vars.slo
 1761              		.loc 1 800 0
 1762 0c14 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1763 0c18 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1764 0c1c 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 799:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIO_OVERFLOWS,
 1765              		.loc 1 799 0
 1766 0c1e 1A46     		mov	r2, r3
 1767 0c20 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1768 0c24 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1769 0c28 DB88     		ldrh	r3, [r3, #6]
 1770 0c2a 4FF00900 		mov	r0, #9
 1771 0c2e 4FF02701 		mov	r1, #39
 1772 0c32 FFF7FEFF 		bl	openserial_printError
 801:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 802:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
 803:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 1773              		.loc 1 803 0
 1774 0c36 FFF7FEFF 		bl	endOps
 804:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1775              		.loc 1 804 0
 1776 0c3a 80BD     		pop	{r7, pc}
 1777              		.cfi_endproc
 1778              	.LFE18:
 1780              		.align	2
 1781              		.global	activity_csl_data_ti4
 1782              		.thumb
 1783              		.thumb_func
 1785              	activity_csl_data_ti4:
 1786              	.LFB19:
 805:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 806:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 807:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 808:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti4].
 809:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 810:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_startOfFrame" function when a start of frame ev
 811:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change state, cancel #tt3 and arm #tt4 (max time to sent all the packet).
 812:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 813:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti4(PORT_RADIOTIMER_WIDTH capturedTime) {
 1787              		.loc 1 813 0
 1788              		.cfi_startproc
 1789              		@ args = 0, pretend = 0, frame = 8
 1790              		@ frame_needed = 1, uses_anonymous_args = 0
 1791 0c3c 80B5     		push	{r7, lr}
 1792              	.LCFI45:
 1793              		.cfi_def_cfa_offset 8
 1794              		.cfi_offset 7, -8
 1795              		.cfi_offset 14, -4
 1796 0c3e 82B0     		sub	sp, sp, #8
 1797              	.LCFI46:
 1798              		.cfi_def_cfa_offset 16
 1799 0c40 00AF     		add	r7, sp, #0
 1800              	.LCFI47:
 1801              		.cfi_def_cfa_register 7
 1802 0c42 7860     		str	r0, [r7, #4]
 814:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 815:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXDATA);
 1803              		.loc 1 815 0
 1804 0c44 4FF02300 		mov	r0, #35
 1805 0c48 FFF7FEFF 		bl	changeState
 816:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 817:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel tt3
 818:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 1806              		.loc 1 818 0
 1807 0c4c FFF7FEFF 		bl	radiotimer_cancel
 819:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 820:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
 821:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.lastCapturedTime = capturedTime;
 1808              		.loc 1 821 0
 1809 0c50 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1810 0c54 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1811 0c58 7A68     		ldr	r2, [r7, #4]
 1812 0c5a 5A62     		str	r2, [r3, #36]
 822:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 823:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt4
 824:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt4);
 1813              		.loc 1 824 0
 1814 0c5c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1815 0c60 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1816 0c64 5B6A     		ldr	r3, [r3, #36]
 1817 0c66 03F1A403 		add	r3, r3, #164
 1818 0c6a 1846     		mov	r0, r3
 1819 0c6c FFF7FEFF 		bl	radiotimer_schedule
 825:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1820              		.loc 1 825 0
 1821 0c70 07F10807 		add	r7, r7, #8
 1822 0c74 BD46     		mov	sp, r7
 1823 0c76 80BD     		pop	{r7, pc}
 1824              		.cfi_endproc
 1825              	.LFE19:
 1827              		.align	2
 1828              		.global	activity_csl_data_tie3
 1829              		.thumb
 1830              		.thumb_func
 1832              	activity_csl_data_tie3:
 1833              	.LFB20:
 826:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 827:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 828:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data tie3].
 829:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 830:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #tt4 expiring, i.e. timer fires while state = S_CSLTXDATA. This is an error 
 831:openstack/02a-MAClow/IEEE802154Ecsl.c ****   to transmit the data packet. The implemented behaviour is to log the error and finish.
 832:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 833:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_tie3() {
 1834              		.loc 1 833 0
 1835              		.cfi_startproc
 1836              		@ args = 0, pretend = 0, frame = 0
 1837              		@ frame_needed = 1, uses_anonymous_args = 0
 1838 0c78 80B5     		push	{r7, lr}
 1839              	.LCFI48:
 1840              		.cfi_def_cfa_offset 8
 1841              		.cfi_offset 7, -8
 1842              		.cfi_offset 14, -4
 1843 0c7a 00AF     		add	r7, sp, #0
 1844              	.LCFI49:
 1845              		.cfi_def_cfa_register 7
 834:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
 835:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
 836:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_vars.slo
 1846              		.loc 1 836 0
 1847 0c7c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1848 0c80 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1849 0c84 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 835:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
 1850              		.loc 1 835 0
 1851 0c86 1A46     		mov	r2, r3
 1852 0c88 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1853 0c8c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1854 0c90 DB88     		ldrh	r3, [r3, #6]
 1855 0c92 4FF00900 		mov	r0, #9
 1856 0c96 4FF02601 		mov	r1, #38
 1857 0c9a FFF7FEFF 		bl	openserial_printError
 837:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
 838:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 1858              		.loc 1 838 0
 1859 0c9e FFF7FEFF 		bl	endOps
 839:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1860              		.loc 1 839 0
 1861 0ca2 80BD     		pop	{r7, pc}
 1862              		.cfi_endproc
 1863              	.LFE20:
 1865              		.align	2
 1866              		.global	activity_csl_data_ti5
 1867              		.thumb
 1868              		.thumb_func
 1870              	activity_csl_data_ti5:
 1871              	.LFB21:
 840:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 841:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 842:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ri5].
 843:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 844:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_endOfFrame" function when a end of frame event 
 845:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change state, cancel #tt4, and notify upper layer and schedule about succ
 846:openstack/02a-MAClow/IEEE802154Ecsl.c ****   start process for receive ACK frame (arm #tt5).
 847:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 848:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti5(PORT_RADIOTIMER_WIDTH capturedTime) {
 1872              		.loc 1 848 0
 1873              		.cfi_startproc
 1874              		@ args = 0, pretend = 0, frame = 16
 1875              		@ frame_needed = 1, uses_anonymous_args = 0
 1876 0ca4 90B5     		push	{r4, r7, lr}
 1877              	.LCFI50:
 1878              		.cfi_def_cfa_offset 12
 1879              		.cfi_offset 4, -12
 1880              		.cfi_offset 7, -8
 1881              		.cfi_offset 14, -4
 1882 0ca6 85B0     		sub	sp, sp, #20
 1883              	.LCFI51:
 1884              		.cfi_def_cfa_offset 32
 1885 0ca8 00AF     		add	r7, sp, #0
 1886              	.LCFI52:
 1887              		.cfi_def_cfa_register 7
 1888 0caa 7860     		str	r0, [r7, #4]
 849:openstack/02a-MAClow/IEEE802154Ecsl.c ****    bool listenForAck;
 850:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 851:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 852:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXACKOFFSET);
 1889              		.loc 1 852 0
 1890 0cac 4FF02400 		mov	r0, #36
 1891 0cb0 FFF7FEFF 		bl	changeState
 853:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 854:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel tt4
 855:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 1892              		.loc 1 855 0
 1893 0cb4 FFF7FEFF 		bl	radiotimer_cancel
 856:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 857:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // turn off the radio
 858:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rfOff();
 1894              		.loc 1 858 0
 1895 0cb8 FFF7FEFF 		bl	radio_rfOff
 859:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnTics+=(radio_getTimerValue()-ieee154e_vars.radioOnInit);
 1896              		.loc 1 859 0
 1897 0cbc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1898 0cc0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1899 0cc4 5C6B     		ldr	r4, [r3, #52]
 1900 0cc6 FFF7FEFF 		bl	radio_getTimerValue
 1901 0cca 0246     		mov	r2, r0
 1902 0ccc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1903 0cd0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1904 0cd4 1B6B     		ldr	r3, [r3, #48]
 1905 0cd6 D31A     		subs	r3, r2, r3
 1906 0cd8 E218     		adds	r2, r4, r3
 1907 0cda 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1908 0cde C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1909 0ce2 5A63     		str	r2, [r3, #52]
 860:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 861:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
 862:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.lastCapturedTime = capturedTime;
 1910              		.loc 1 862 0
 1911 0ce4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1912 0ce8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1913 0cec 7A68     		ldr	r2, [r7, #4]
 1914 0cee 5A62     		str	r2, [r3, #36]
 863:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 864:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // decides whether to listen for an ACK
 865:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (packetfunctions_isBroadcastMulticast(&ieee154e_vars.dataToSend->l2_nextORpreviousHop)==TRUE)
 1915              		.loc 1 865 0
 1916 0cf0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1917 0cf4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1918 0cf8 5B69     		ldr	r3, [r3, #20]
 1919 0cfa 03F13803 		add	r3, r3, #56
 1920 0cfe 1846     		mov	r0, r3
 1921 0d00 FFF7FEFF 		bl	packetfunctions_isBroadcastMulticast
 1922 0d04 0346     		mov	r3, r0
 1923 0d06 002B     		cmp	r3, #0
 1924 0d08 03D0     		beq	.L111
 866:openstack/02a-MAClow/IEEE802154Ecsl.c ****       listenForAck = FALSE;
 1925              		.loc 1 866 0
 1926 0d0a 4FF00003 		mov	r3, #0
 1927 0d0e FB73     		strb	r3, [r7, #15]
 1928 0d10 02E0     		b	.L112
 1929              	.L111:
 867:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
 868:openstack/02a-MAClow/IEEE802154Ecsl.c ****       listenForAck = TRUE;
 1930              		.loc 1 868 0
 1931 0d12 4FF00103 		mov	r3, #1
 1932 0d16 FB73     		strb	r3, [r7, #15]
 1933              	.L112:
 869:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 870:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 871:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // CSL: TEST CODE
 872:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // toggle orange led to indicate TX.
 873:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if((ieee154e_vars.dataToSend->l2_frameType == IEEE154_TYPE_DATA) &&
 1934              		.loc 1 873 0
 1935 0d18 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1936 0d1c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1937 0d20 5B69     		ldr	r3, [r3, #20]
 1938 0d22 93F84930 		ldrb	r3, [r3, #73]	@ zero_extendqisi2
 1939 0d26 012B     		cmp	r3, #1
 1940 0d28 15D1     		bne	.L113
 874:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  (ieee154e_vars.dataToSend->owner == COMPONENT_SIXTOP_TO_IEEE802154E) &&
 1941              		.loc 1 874 0 discriminator 1
 1942 0d2a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1943 0d2e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1944 0d32 5B69     		ldr	r3, [r3, #20]
 1945 0d34 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 873:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if((ieee154e_vars.dataToSend->l2_frameType == IEEE154_TYPE_DATA) &&
 1946              		.loc 1 873 0 discriminator 1
 1947 0d36 0A2B     		cmp	r3, #10
 1948 0d38 0DD1     		bne	.L113
 875:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  (ieee154e_vars.dataToSend->cslFlag == 123)) {
 1949              		.loc 1 875 0
 1950 0d3a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1951 0d3e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1952 0d42 5B69     		ldr	r3, [r3, #20]
 1953 0d44 93F8ED30 		ldrb	r3, [r3, #237]	@ zero_extendqisi2
 874:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  (ieee154e_vars.dataToSend->owner == COMPONENT_SIXTOP_TO_IEEE802154E) &&
 1954              		.loc 1 874 0
 1955 0d48 7B2B     		cmp	r3, #123
 1956 0d4a 04D1     		bne	.L113
 876:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	 //leds_sync_toggle();
 877:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	 leds_sync_blink();
 1957              		.loc 1 877 0
 1958 0d4c FFF7FEFF 		bl	leds_sync_blink
 878:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	 listenForAck = FALSE;
 1959              		.loc 1 878 0
 1960 0d50 4FF00003 		mov	r3, #0
 1961 0d54 FB73     		strb	r3, [r7, #15]
 1962              	.L113:
 879:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 880:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // END TEST CODE
 881:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 882:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 883:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (listenForAck==TRUE) {
 1963              		.loc 1 883 0
 1964 0d56 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 1965 0d58 002B     		cmp	r3, #0
 1966 0d5a 0AD0     		beq	.L114
 884:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // arm tt5
 885:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radiotimer_schedule(DURATION_tt5);
 1967              		.loc 1 885 0
 1968 0d5c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1969 0d60 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1970 0d64 5B6A     		ldr	r3, [r3, #36]
 1971 0d66 03F17D03 		add	r3, r3, #125
 1972 0d6a 1846     		mov	r0, r3
 1973 0d6c FFF7FEFF 		bl	radiotimer_schedule
 1974 0d70 09E0     		b	.L110
 1975              	.L114:
 886:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
 887:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // indicate succesful Tx to schedule to keep statistics
 888:openstack/02a-MAClow/IEEE802154Ecsl.c ****       schedule_indicateTx(&ieee154e_vars.asn,TRUE);
 1976              		.loc 1 888 0
 1977 0d72 40F20000 		movw	r0, #:lower16:ieee154e_vars
 1978 0d76 C0F20000 		movt	r0, #:upper16:ieee154e_vars
 1979 0d7a 4FF00101 		mov	r1, #1
 1980 0d7e FFF7FEFF 		bl	schedule_indicateTx
 889:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 890:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // CSL TEST CODE (comment notification)
 891:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // indicate to upper later the packet was sent successfully
 892:openstack/02a-MAClow/IEEE802154Ecsl.c ****       //notif_sendDone(ieee154e_vars.dataToSend,E_SUCCESS);
 893:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 894:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset local variable
 895:openstack/02a-MAClow/IEEE802154Ecsl.c ****       //ieee154e_vars.dataToSend = NULL;
 896:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // END TEST CODE
 897:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 898:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // abort
 899:openstack/02a-MAClow/IEEE802154Ecsl.c ****       endOps();
 1981              		.loc 1 899 0
 1982 0d82 FFF7FEFF 		bl	endOps
 1983              	.L110:
 900:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 901:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1984              		.loc 1 901 0
 1985 0d86 07F11407 		add	r7, r7, #20
 1986 0d8a BD46     		mov	sp, r7
 1987 0d8c 90BD     		pop	{r4, r7, pc}
 1988              		.cfi_endproc
 1989              	.LFE21:
 1991 0d8e 00BF     		.align	2
 1992              		.global	activity_csl_data_ti6
 1993              		.thumb
 1994              		.thumb_func
 1996              	activity_csl_data_ti6:
 1997              	.LFB22:
 902:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 903:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 904:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti6].
 905:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 906:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 907:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The functionality is to prepare the radio for ACK reception.
 908:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 909:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti6() {
 1998              		.loc 1 909 0
 1999              		.cfi_startproc
 2000              		@ args = 0, pretend = 0, frame = 0
 2001              		@ frame_needed = 1, uses_anonymous_args = 0
 2002 0d90 80B5     		push	{r7, lr}
 2003              	.LCFI53:
 2004              		.cfi_def_cfa_offset 8
 2005              		.cfi_offset 7, -8
 2006              		.cfi_offset 14, -4
 2007 0d92 00AF     		add	r7, sp, #0
 2008              	.LCFI54:
 2009              		.cfi_def_cfa_register 7
 910:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 911:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXACKPREPARE);
 2010              		.loc 1 911 0
 2011 0d94 4FF02500 		mov	r0, #37
 2012 0d98 FFF7FEFF 		bl	changeState
 912:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 913:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // enable the radio in Rx mode. The radio is not actively listening yet.
 914:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rxEnable();
 2013              		.loc 1 914 0
 2014 0d9c FFF7FEFF 		bl	radio_rxEnable
 915:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 916:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //caputre init of radio for duty cycle calculation
 917:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnInit=radio_getTimerValue();
 2015              		.loc 1 917 0
 2016 0da0 FFF7FEFF 		bl	radio_getTimerValue
 2017 0da4 0246     		mov	r2, r0
 2018 0da6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2019 0daa C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2020 0dae 1A63     		str	r2, [r3, #48]
 918:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnThisSlot=TRUE;
 2021              		.loc 1 918 0
 2022 0db0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2023 0db4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2024 0db8 4FF00102 		mov	r2, #1
 2025 0dbc 83F83820 		strb	r2, [r3, #56]
 919:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 920:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt6
 921:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt6);
 2026              		.loc 1 921 0
 2027 0dc0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2028 0dc4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2029 0dc8 5B6A     		ldr	r3, [r3, #36]
 2030 0dca 03F18703 		add	r3, r3, #135
 2031 0dce 1846     		mov	r0, r3
 2032 0dd0 FFF7FEFF 		bl	radiotimer_schedule
 922:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 923:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 924:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXACKREADY);
 2033              		.loc 1 924 0
 2034 0dd4 4FF02600 		mov	r0, #38
 2035 0dd8 FFF7FEFF 		bl	changeState
 925:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2036              		.loc 1 925 0
 2037 0ddc 80BD     		pop	{r7, pc}
 2038              		.cfi_endproc
 2039              	.LFE22:
 2041 0dde 00BF     		.align	2
 2042              		.global	activity_csl_data_tie4
 2043              		.thumb
 2044              		.thumb_func
 2046              	activity_csl_data_tie4:
 2047              	.LFB23:
 926:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 927:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 928:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data tie4].
 929:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 930:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 931:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The functionality is to prepare the radio for ACK sending.
 932:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 933:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_tie4() {
 2048              		.loc 1 933 0
 2049              		.cfi_startproc
 2050              		@ args = 0, pretend = 0, frame = 0
 2051              		@ frame_needed = 1, uses_anonymous_args = 0
 2052 0de0 80B5     		push	{r7, lr}
 2053              	.LCFI55:
 2054              		.cfi_def_cfa_offset 8
 2055              		.cfi_offset 7, -8
 2056              		.cfi_offset 14, -4
 2057 0de2 00AF     		add	r7, sp, #0
 2058              	.LCFI56:
 2059              		.cfi_def_cfa_register 7
 934:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
 935:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXACKPREPARE_OVERFLOWS,
 936:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_vars.slo
 2060              		.loc 1 936 0
 2061 0de4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2062 0de8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2063 0dec 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 935:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXACKPREPARE_OVERFLOWS,
 2064              		.loc 1 935 0
 2065 0dee 1A46     		mov	r2, r3
 2066 0df0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2067 0df4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2068 0df8 DB88     		ldrh	r3, [r3, #6]
 2069 0dfa 4FF00900 		mov	r0, #9
 2070 0dfe 4FF02301 		mov	r1, #35
 2071 0e02 FFF7FEFF 		bl	openserial_printError
 937:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
 938:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 2072              		.loc 1 938 0
 2073 0e06 FFF7FEFF 		bl	endOps
 939:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2074              		.loc 1 939 0
 2075 0e0a 80BD     		pop	{r7, pc}
 2076              		.cfi_endproc
 2077              	.LFE23:
 2079              		.align	2
 2080              		.global	activity_csl_data_ti7
 2081              		.thumb
 2082              		.thumb_func
 2084              	activity_csl_data_ti7:
 2085              	.LFB24:
 940:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 941:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 942:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti7].
 943:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 944:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 945:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The radio is configured and this interrupt gives it the "go" signal to start listening.
 946:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 947:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti7() {
 2086              		.loc 1 947 0
 2087              		.cfi_startproc
 2088              		@ args = 0, pretend = 0, frame = 0
 2089              		@ frame_needed = 1, uses_anonymous_args = 0
 2090 0e0c 80B5     		push	{r7, lr}
 2091              	.LCFI57:
 2092              		.cfi_def_cfa_offset 8
 2093              		.cfi_offset 7, -8
 2094              		.cfi_offset 14, -4
 2095 0e0e 00AF     		add	r7, sp, #0
 2096              	.LCFI58:
 2097              		.cfi_def_cfa_register 7
 948:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 949:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXACKLISTEN);
 2098              		.loc 1 949 0
 2099 0e10 4FF02700 		mov	r0, #39
 2100 0e14 FFF7FEFF 		bl	changeState
 950:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 951:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // start listening
 952:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rxNow();
 2101              		.loc 1 952 0
 2102 0e18 FFF7FEFF 		bl	radio_rxNow
 953:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 954:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt7
 955:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt7);
 2103              		.loc 1 955 0
 2104 0e1c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2105 0e20 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2106 0e24 5B6A     		ldr	r3, [r3, #36]
 2107 0e26 03F1A703 		add	r3, r3, #167
 2108 0e2a 1846     		mov	r0, r3
 2109 0e2c FFF7FEFF 		bl	radiotimer_schedule
 956:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2110              		.loc 1 956 0
 2111 0e30 80BD     		pop	{r7, pc}
 2112              		.cfi_endproc
 2113              	.LFE24:
 2115 0e32 00BF     		.align	2
 2116              		.global	activity_csl_data_tie5
 2117              		.thumb
 2118              		.thumb_func
 2120              	activity_csl_data_tie5:
 2121              	.LFB25:
 957:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 958:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 959:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data tie5].
 960:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 961:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 962:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to notify upper level, updating the number of remaining retries of the packe
 963:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 964:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_tie5() {
 2122              		.loc 1 964 0
 2123              		.cfi_startproc
 2124              		@ args = 0, pretend = 0, frame = 0
 2125              		@ frame_needed = 1, uses_anonymous_args = 0
 2126 0e34 80B5     		push	{r7, lr}
 2127              	.LCFI59:
 2128              		.cfi_def_cfa_offset 8
 2129              		.cfi_offset 7, -8
 2130              		.cfi_offset 14, -4
 2131 0e36 00AF     		add	r7, sp, #0
 2132              	.LCFI60:
 2133              		.cfi_def_cfa_register 7
 965:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // indicate transmit failed to schedule to keep stats
 966:openstack/02a-MAClow/IEEE802154Ecsl.c ****    schedule_indicateTx(&ieee154e_vars.asn,FALSE);
 2134              		.loc 1 966 0
 2135 0e38 40F20000 		movw	r0, #:lower16:ieee154e_vars
 2136 0e3c C0F20000 		movt	r0, #:upper16:ieee154e_vars
 2137 0e40 4FF00001 		mov	r1, #0
 2138 0e44 FFF7FEFF 		bl	schedule_indicateTx
 967:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 968:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // decrement transmits left counter
 969:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.dataToSend->l2_retriesLeft--;
 2139              		.loc 1 969 0
 2140 0e48 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2141 0e4c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2142 0e50 5B69     		ldr	r3, [r3, #20]
 2143 0e52 93F84B20 		ldrb	r2, [r3, #75]	@ zero_extendqisi2
 2144 0e56 02F1FF32 		add	r2, r2, #-1
 2145 0e5a D2B2     		uxtb	r2, r2
 2146 0e5c 83F84B20 		strb	r2, [r3, #75]
 970:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 971:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.dataToSend->l2_retriesLeft==0) {
 2147              		.loc 1 971 0
 2148 0e60 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2149 0e64 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2150 0e68 5B69     		ldr	r3, [r3, #20]
 2151 0e6a 93F84B30 		ldrb	r3, [r3, #75]	@ zero_extendqisi2
 2152 0e6e 002B     		cmp	r3, #0
 2153 0e70 07D0     		beq	.L120
 972:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // indicate tx fail if no more retries left
 973:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // CSL testing commented
 974:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // notif_sendDone(ieee154e_vars.dataToSend,E_FAIL);
 975:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
 976:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // return packet to the virtual COMPONENT_SIXTOP_TO_IEEE802154E component
 977:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataToSend->owner = COMPONENT_SIXTOP_TO_IEEE802154E;
 2154              		.loc 1 977 0
 2155 0e72 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2156 0e76 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2157 0e7a 5B69     		ldr	r3, [r3, #20]
 2158 0e7c 4FF00A02 		mov	r2, #10
 2159 0e80 5A70     		strb	r2, [r3, #1]
 2160              	.L120:
 978:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 979:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 980:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // reset local variable
 981:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.dataToSend = NULL;
 2161              		.loc 1 981 0
 2162 0e82 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2163 0e86 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2164 0e8a 4FF00002 		mov	r2, #0
 2165 0e8e 5A61     		str	r2, [r3, #20]
 982:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 983:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
 984:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 2166              		.loc 1 984 0
 2167 0e90 FFF7FEFF 		bl	endOps
 985:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2168              		.loc 1 985 0
 2169 0e94 80BD     		pop	{r7, pc}
 2170              		.cfi_endproc
 2171              	.LFE25:
 2173 0e96 00BF     		.align	2
 2174              		.global	activity_csl_data_ti8
 2175              		.thumb
 2176              		.thumb_func
 2178              	activity_csl_data_ti8:
 2179              	.LFB26:
 986:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 987:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 988:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ri8].
 989:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 990:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_startOfFrame" function when a start of frame ev
 991:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change the state, cancel #tt7 and arm #tt8 (max time to receive the ack p
 992:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 993:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti8(PORT_RADIOTIMER_WIDTH capturedTime) {
 2180              		.loc 1 993 0
 2181              		.cfi_startproc
 2182              		@ args = 0, pretend = 0, frame = 8
 2183              		@ frame_needed = 1, uses_anonymous_args = 0
 2184 0e98 80B5     		push	{r7, lr}
 2185              	.LCFI61:
 2186              		.cfi_def_cfa_offset 8
 2187              		.cfi_offset 7, -8
 2188              		.cfi_offset 14, -4
 2189 0e9a 82B0     		sub	sp, sp, #8
 2190              	.LCFI62:
 2191              		.cfi_def_cfa_offset 16
 2192 0e9c 00AF     		add	r7, sp, #0
 2193              	.LCFI63:
 2194              		.cfi_def_cfa_register 7
 2195 0e9e 7860     		str	r0, [r7, #4]
 994:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 995:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXACK);
 2196              		.loc 1 995 0
 2197 0ea0 4FF02800 		mov	r0, #40
 2198 0ea4 FFF7FEFF 		bl	changeState
 996:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 997:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel tt7
 998:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 2199              		.loc 1 998 0
 2200 0ea8 FFF7FEFF 		bl	radiotimer_cancel
 999:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1000:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
1001:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.lastCapturedTime = capturedTime;
 2201              		.loc 1 1001 0
 2202 0eac 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2203 0eb0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2204 0eb4 7A68     		ldr	r2, [r7, #4]
 2205 0eb6 5A62     		str	r2, [r3, #36]
1002:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1003:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt8
1004:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt8);
 2206              		.loc 1 1004 0
 2207 0eb8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2208 0ebc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2209 0ec0 5B6A     		ldr	r3, [r3, #36]
 2210 0ec2 03F16203 		add	r3, r3, #98
 2211 0ec6 1846     		mov	r0, r3
 2212 0ec8 FFF7FEFF 		bl	radiotimer_schedule
1005:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2213              		.loc 1 1005 0
 2214 0ecc 07F10807 		add	r7, r7, #8
 2215 0ed0 BD46     		mov	sp, r7
 2216 0ed2 80BD     		pop	{r7, pc}
 2217              		.cfi_endproc
 2218              	.LFE26:
 2220              		.align	2
 2221              		.global	activity_csl_data_tie6
 2222              		.thumb
 2223              		.thumb_func
 2225              	activity_csl_data_tie6:
 2226              	.LFB27:
1006:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1007:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1008:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data tie6].
1009:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1010:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1011:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to finish and clean registers.
1012:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1013:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_tie6() {
 2227              		.loc 1 1013 0
 2228              		.cfi_startproc
 2229              		@ args = 0, pretend = 0, frame = 0
 2230              		@ frame_needed = 1, uses_anonymous_args = 0
 2231 0ed4 80B5     		push	{r7, lr}
 2232              	.LCFI64:
 2233              		.cfi_def_cfa_offset 8
 2234              		.cfi_offset 7, -8
 2235              		.cfi_offset 14, -4
 2236 0ed6 00AF     		add	r7, sp, #0
 2237              	.LCFI65:
 2238              		.cfi_def_cfa_register 7
1014:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1015:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 2239              		.loc 1 1015 0
 2240 0ed8 FFF7FEFF 		bl	endOps
1016:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2241              		.loc 1 1016 0
 2242 0edc 80BD     		pop	{r7, pc}
 2243              		.cfi_endproc
 2244              	.LFE27:
 2246 0ede 00BF     		.align	2
 2247              		.global	activity_csl_data_ti9
 2248              		.thumb
 2249              		.thumb_func
 2251              	activity_csl_data_ti9:
 2252              	.LFB28:
1017:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1018:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1019:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1020:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti9].
1021:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1022:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_endOfFrame" function when a end of frame event 
1023:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change the state, cancel #tt8, analyze ack packet and notify upper layer.
1024:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1025:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti9(PORT_RADIOTIMER_WIDTH capturedTime) {
 2253              		.loc 1 1025 0
 2254              		.cfi_startproc
 2255              		@ args = 0, pretend = 0, frame = 80
 2256              		@ frame_needed = 1, uses_anonymous_args = 0
 2257 0ee0 B0B5     		push	{r4, r5, r7, lr}
 2258              	.LCFI66:
 2259              		.cfi_def_cfa_offset 16
 2260              		.cfi_offset 4, -16
 2261              		.cfi_offset 5, -12
 2262              		.cfi_offset 7, -8
 2263              		.cfi_offset 14, -4
 2264 0ee2 96B0     		sub	sp, sp, #88
 2265              	.LCFI67:
 2266              		.cfi_def_cfa_offset 104
 2267 0ee4 02AF     		add	r7, sp, #8
 2268              	.LCFI68:
 2269              		.cfi_def_cfa 7, 96
 2270 0ee6 7860     		str	r0, [r7, #4]
1026:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802154_header_iht     ieee802514_header;
1027:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint16_t                  lenIE;
1028:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1029:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1030:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXPROC);
 2271              		.loc 1 1030 0
 2272 0ee8 4FF02900 		mov	r0, #41
 2273 0eec FFF7FEFF 		bl	changeState
1031:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1032:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel tt8
1033:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 2274              		.loc 1 1033 0
 2275 0ef0 FFF7FEFF 		bl	radiotimer_cancel
1034:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1035:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // turn off the radio
1036:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rfOff();
 2276              		.loc 1 1036 0
 2277 0ef4 FFF7FEFF 		bl	radio_rfOff
1037:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //compute tics radio on.
1038:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnTics+=(radio_getTimerValue()-ieee154e_vars.radioOnInit);
 2278              		.loc 1 1038 0
 2279 0ef8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2280 0efc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2281 0f00 5C6B     		ldr	r4, [r3, #52]
 2282 0f02 FFF7FEFF 		bl	radio_getTimerValue
 2283 0f06 0246     		mov	r2, r0
 2284 0f08 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2285 0f0c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2286 0f10 1B6B     		ldr	r3, [r3, #48]
 2287 0f12 D31A     		subs	r3, r2, r3
 2288 0f14 E218     		adds	r2, r4, r3
 2289 0f16 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2290 0f1a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2291 0f1e 5A63     		str	r2, [r3, #52]
1039:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1040:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
1041:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.lastCapturedTime = capturedTime;
 2292              		.loc 1 1041 0
 2293 0f20 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2294 0f24 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2295 0f28 7A68     		ldr	r2, [r7, #4]
 2296 0f2a 5A62     		str	r2, [r3, #36]
1042:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1043:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // get a buffer to put the (received) ACK in
1044:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackReceived = openqueue_getFreePacketBuffer(COMPONENT_IEEE802154E);
 2297              		.loc 1 1044 0
 2298 0f2c 4FF00900 		mov	r0, #9
 2299 0f30 FFF7FEFF 		bl	openqueue_getFreePacketBuffer
 2300 0f34 0246     		mov	r2, r0
 2301 0f36 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2302 0f3a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2303 0f3e 1A62     		str	r2, [r3, #32]
1045:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.ackReceived==NULL) {
 2304              		.loc 1 1045 0
 2305 0f40 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2306 0f44 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2307 0f48 1B6A     		ldr	r3, [r3, #32]
 2308 0f4a 002B     		cmp	r3, #0
 2309 0f4c 0CD1     		bne	.L124
1046:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // log the error
1047:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openserial_printError(COMPONENT_IEEE802154E,ERR_NO_FREE_PACKET_BUFFER,
 2310              		.loc 1 1047 0
 2311 0f4e 4FF00900 		mov	r0, #9
 2312 0f52 4FF02C01 		mov	r1, #44
 2313 0f56 4FF00002 		mov	r2, #0
 2314 0f5a 4FF00003 		mov	r3, #0
 2315 0f5e FFF7FEFF 		bl	openserial_printError
1048:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)0,
1049:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)0);
1050:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // abort
1051:openstack/02a-MAClow/IEEE802154Ecsl.c ****       endOps();
 2316              		.loc 1 1051 0
 2317 0f62 FFF7FEFF 		bl	endOps
 2318 0f66 15E1     		b	.L123
 2319              	.L124:
1052:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return;
1053:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
1054:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1055:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // declare ownership over that packet
1056:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackReceived->creator = COMPONENT_IEEE802154E;
 2320              		.loc 1 1056 0
 2321 0f68 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2322 0f6c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2323 0f70 1B6A     		ldr	r3, [r3, #32]
 2324 0f72 4FF00902 		mov	r2, #9
 2325 0f76 1A70     		strb	r2, [r3, #0]
1057:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackReceived->owner   = COMPONENT_IEEE802154E;
 2326              		.loc 1 1057 0
 2327 0f78 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2328 0f7c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2329 0f80 1B6A     		ldr	r3, [r3, #32]
 2330 0f82 4FF00902 		mov	r2, #9
 2331 0f86 5A70     		strb	r2, [r3, #1]
1058:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1059:openstack/02a-MAClow/IEEE802154Ecsl.c ****    /*
1060:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The do-while loop that follows is a little parsing trick.
1061:openstack/02a-MAClow/IEEE802154Ecsl.c ****    Because it contains a while(0) condition, it gets executed only once.
1062:openstack/02a-MAClow/IEEE802154Ecsl.c ****    Below the do-while loop is some code to cleans up the ack variable.
1063:openstack/02a-MAClow/IEEE802154Ecsl.c ****    Anywhere in the do-while loop, a break statement can be called to jump to
1064:openstack/02a-MAClow/IEEE802154Ecsl.c ****    the clean up code early. If the loop ends without a break, the received
1065:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packet was correct. If it got aborted early (through a break), the packet
1066:openstack/02a-MAClow/IEEE802154Ecsl.c ****    was faulty.
1067:openstack/02a-MAClow/IEEE802154Ecsl.c ****    */
1068:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1069:openstack/02a-MAClow/IEEE802154Ecsl.c ****    do { // this "loop" is only executed once
1070:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1071:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // retrieve the received ack frame from the radio's Rx buffer
1072:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.ackReceived->payload = &(ieee154e_vars.ackReceived->packet[FIRST_FRAME_BYTE]);
 2332              		.loc 1 1072 0
 2333 0f88 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2334 0f8c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2335 0f90 1A6A     		ldr	r2, [r3, #32]
 2336 0f92 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2337 0f96 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2338 0f9a 1B6A     		ldr	r3, [r3, #32]
 2339 0f9c 03F16C03 		add	r3, r3, #108
 2340 0fa0 5360     		str	r3, [r2, #4]
1073:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.ackReceived->payload,
 2341              		.loc 1 1073 0
 2342 0fa2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2343 0fa6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2344 0faa 1B6A     		ldr	r3, [r3, #32]
 2345 0fac 5968     		ldr	r1, [r3, #4]
1074:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.ackReceived->length,
 2346              		.loc 1 1074 0
 2347 0fae 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2348 0fb2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2349 0fb6 1B6A     		ldr	r3, [r3, #32]
1073:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.ackReceived->payload,
 2350              		.loc 1 1073 0
 2351 0fb8 03F10802 		add	r2, r3, #8
1075:openstack/02a-MAClow/IEEE802154Ecsl.c ****                              sizeof(ieee154e_vars.ackReceived->packet),
1076:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.ackReceived->l1_rssi,
 2352              		.loc 1 1076 0
 2353 0fbc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2354 0fc0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2355 0fc4 1B6A     		ldr	r3, [r3, #32]
1073:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.ackReceived->payload,
 2356              		.loc 1 1073 0
 2357 0fc6 03F16804 		add	r4, r3, #104
1077:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.ackReceived->l1_lqi,
 2358              		.loc 1 1077 0
 2359 0fca 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2360 0fce C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2361 0fd2 1B6A     		ldr	r3, [r3, #32]
1073:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.ackReceived->payload,
 2362              		.loc 1 1073 0
 2363 0fd4 03F16900 		add	r0, r3, #105
1078:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.ackReceived->l1_crc);
 2364              		.loc 1 1078 0
 2365 0fd8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2366 0fdc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2367 0fe0 1B6A     		ldr	r3, [r3, #32]
1073:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.ackReceived->payload,
 2368              		.loc 1 1073 0
 2369 0fe2 03F16A03 		add	r3, r3, #106
 2370 0fe6 0090     		str	r0, [sp, #0]
 2371 0fe8 0193     		str	r3, [sp, #4]
 2372 0fea 0846     		mov	r0, r1
 2373 0fec 1146     		mov	r1, r2
 2374 0fee 4FF08202 		mov	r2, #130
 2375 0ff2 2346     		mov	r3, r4
 2376 0ff4 FFF7FEFF 		bl	radio_getReceivedFrame
1079:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1080:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // break if wrong length
1081:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.ackReceived->length<LENGTH_CRC || ieee154e_vars.ackReceived->length>LENGTH_
 2377              		.loc 1 1081 0
 2378 0ff8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2379 0ffc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2380 1000 1B6A     		ldr	r3, [r3, #32]
 2381 1002 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 2382 1004 012B     		cmp	r3, #1
 2383 1006 07D9     		bls	.L126
 2384              		.loc 1 1081 0 is_stmt 0 discriminator 1
 2385 1008 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2386 100c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2387 1010 1B6A     		ldr	r3, [r3, #32]
 2388 1012 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 2389 1014 802B     		cmp	r3, #128
 2390 1016 0ED9     		bls	.L127
 2391              	.L126:
1082:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // break from the do-while loop and execute the clean-up code below
1083:openstack/02a-MAClow/IEEE802154Ecsl.c ****         openserial_printError(COMPONENT_IEEE802154E,ERR_INVALIDPACKETFROMRADIO,
1084:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)1,
1085:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             ieee154e_vars.ackReceived->length);
 2392              		.loc 1 1085 0 is_stmt 1
 2393 1018 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2394 101c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2395 1020 1B6A     		ldr	r3, [r3, #32]
 2396 1022 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
1083:openstack/02a-MAClow/IEEE802154Ecsl.c ****         openserial_printError(COMPONENT_IEEE802154E,ERR_INVALIDPACKETFROMRADIO,
 2397              		.loc 1 1083 0
 2398 1024 4FF00900 		mov	r0, #9
 2399 1028 4FF03701 		mov	r1, #55
 2400 102c 4FF00102 		mov	r2, #1
 2401 1030 FFF7FEFF 		bl	openserial_printError
1086:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1087:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 2402              		.loc 1 1087 0
 2403 1034 9DE0     		b	.L128
 2404              	.L127:
1088:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1089:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1090:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // toss CRC (2 last bytes)
1091:openstack/02a-MAClow/IEEE802154Ecsl.c ****       packetfunctions_tossFooter(   ieee154e_vars.ackReceived, LENGTH_CRC);
 2405              		.loc 1 1091 0
 2406 1036 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2407 103a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2408 103e 1B6A     		ldr	r3, [r3, #32]
 2409 1040 1846     		mov	r0, r3
 2410 1042 4FF00201 		mov	r1, #2
 2411 1046 FFF7FEFF 		bl	packetfunctions_tossFooter
1092:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1093:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // break if invalid CRC
1094:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.ackReceived->l1_crc==FALSE) {
 2412              		.loc 1 1094 0
 2413 104a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2414 104e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2415 1052 1B6A     		ldr	r3, [r3, #32]
 2416 1054 93F86A30 		ldrb	r3, [r3, #106]	@ zero_extendqisi2
 2417 1058 83F00103 		eor	r3, r3, #1
 2418 105c DBB2     		uxtb	r3, r3
 2419 105e 002B     		cmp	r3, #0
 2420 1060 7ED1     		bne	.L134
 2421              	.L129:
1095:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // break from the do-while loop and execute the clean-up code below
1096:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
1097:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1098:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1099:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // parse the IEEE802.15.4 header (RX ACK)
1100:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee802154_retrieveHeader(ieee154e_vars.ackReceived,&ieee802514_header);
 2422              		.loc 1 1100 0
 2423 1062 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2424 1066 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2425 106a 1A6A     		ldr	r2, [r3, #32]
 2426 106c 07F11003 		add	r3, r7, #16
 2427 1070 1046     		mov	r0, r2
 2428 1072 1946     		mov	r1, r3
 2429 1074 FFF7FEFF 		bl	ieee802154_retrieveHeader
1101:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1102:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // break if invalid IEEE802.15.4 header
1103:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee802514_header.valid==FALSE) {
 2430              		.loc 1 1103 0
 2431 1078 3B7C     		ldrb	r3, [r7, #16]	@ zero_extendqisi2
 2432 107a 83F00103 		eor	r3, r3, #1
 2433 107e DBB2     		uxtb	r3, r3
 2434 1080 002B     		cmp	r3, #0
 2435 1082 6FD1     		bne	.L135
 2436              	.L130:
1104:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // break from the do-while loop and execute the clean-up code below
1105:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
1106:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1107:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1108:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // store header details in packet buffer
1109:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.ackReceived->l2_frameType  = ieee802514_header.frameType;
 2437              		.loc 1 1109 0
 2438 1084 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2439 1088 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2440 108c 1B6A     		ldr	r3, [r3, #32]
 2441 108e BA7C     		ldrb	r2, [r7, #18]	@ zero_extendqisi2
 2442 1090 83F84920 		strb	r2, [r3, #73]
1110:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.ackReceived->l2_dsn        = ieee802514_header.dsn;
 2443              		.loc 1 1110 0
 2444 1094 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2445 1098 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2446 109c 1B6A     		ldr	r3, [r3, #32]
 2447 109e 7A7E     		ldrb	r2, [r7, #25]	@ zero_extendqisi2
 2448 10a0 83F84A20 		strb	r2, [r3, #74]
1111:openstack/02a-MAClow/IEEE802154Ecsl.c ****       memcpy(&(ieee154e_vars.ackReceived->l2_nextORpreviousHop),&(ieee802514_header.src),sizeof(ope
 2449              		.loc 1 1111 0
 2450 10a4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2451 10a8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2452 10ac 1B6A     		ldr	r3, [r3, #32]
 2453 10ae 03F13803 		add	r3, r3, #56
 2454 10b2 1D46     		mov	r5, r3
 2455 10b4 07F13C04 		add	r4, r7, #60
 2456 10b8 0FCC     		ldmia	r4!, {r0, r1, r2, r3}
 2457 10ba 2860     		str	r0, [r5, #0]	@ unaligned
 2458 10bc 6960     		str	r1, [r5, #4]	@ unaligned
 2459 10be AA60     		str	r2, [r5, #8]	@ unaligned
 2460 10c0 EB60     		str	r3, [r5, #12]	@ unaligned
 2461 10c2 2378     		ldrb	r3, [r4, #0]
 2462 10c4 2B74     		strb	r3, [r5, #16]
1112:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1113:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // toss the IEEE802.15.4 header
1114:openstack/02a-MAClow/IEEE802154Ecsl.c ****       packetfunctions_tossHeader(ieee154e_vars.ackReceived,ieee802514_header.headerLength);
 2463              		.loc 1 1114 0
 2464 10c6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2465 10ca C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2466 10ce 1A6A     		ldr	r2, [r3, #32]
 2467 10d0 7B7C     		ldrb	r3, [r7, #17]	@ zero_extendqisi2
 2468 10d2 1046     		mov	r0, r2
 2469 10d4 1946     		mov	r1, r3
 2470 10d6 FFF7FEFF 		bl	packetfunctions_tossHeader
1115:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1116:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // break if invalid ACK
1117:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (isValidAck(&ieee802514_header,ieee154e_vars.dataToSend)==FALSE) {
 2471              		.loc 1 1117 0
 2472 10da 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2473 10de C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2474 10e2 5B69     		ldr	r3, [r3, #20]
 2475 10e4 07F11002 		add	r2, r7, #16
 2476 10e8 1046     		mov	r0, r2
 2477 10ea 1946     		mov	r1, r3
 2478 10ec FFF7FEFF 		bl	isValidAck
 2479 10f0 0346     		mov	r3, r0
 2480 10f2 83F00103 		eor	r3, r3, #1
 2481 10f6 DBB2     		uxtb	r3, r3
 2482 10f8 002B     		cmp	r3, #0
 2483 10fa 35D1     		bne	.L136
 2484              	.L131:
1118:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // break from the do-while loop and execute the clean-up code below
1119:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
1120:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1121:openstack/02a-MAClow/IEEE802154Ecsl.c ****       //hanlde IEs --xv poipoi
1122:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee802514_header.ieListPresent==FALSE){
 2485              		.loc 1 1122 0
 2486 10fc FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 2487 10fe 83F00103 		eor	r3, r3, #1
 2488 1102 DBB2     		uxtb	r3, r3
 2489 1104 002B     		cmp	r3, #0
 2490 1106 31D1     		bne	.L137
 2491              	.L132:
1123:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break; //ack should contain IEs.
1124:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1125:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1126:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_processIEs(ieee154e_vars.ackReceived,&lenIE)==FALSE){
 2492              		.loc 1 1126 0
 2493 1108 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2494 110c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2495 1110 1A6A     		ldr	r2, [r3, #32]
 2496 1112 07F10E03 		add	r3, r7, #14
 2497 1116 1046     		mov	r0, r2
 2498 1118 1946     		mov	r1, r3
 2499 111a FFF7FEFF 		bl	ieee154e_processIEs
 2500 111e 0346     		mov	r3, r0
 2501 1120 83F00103 		eor	r3, r3, #1
 2502 1124 DBB2     		uxtb	r3, r3
 2503 1126 002B     		cmp	r3, #0
 2504 1128 22D1     		bne	.L138
 2505              	.L133:
1127:openstack/02a-MAClow/IEEE802154Ecsl.c ****         // invalid IEs in ACK
1128:openstack/02a-MAClow/IEEE802154Ecsl.c ****         break;
1129:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1130:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1131:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // toss the IEs
1132:openstack/02a-MAClow/IEEE802154Ecsl.c ****       packetfunctions_tossHeader(ieee154e_vars.ackReceived,lenIE);
 2506              		.loc 1 1132 0
 2507 112a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2508 112e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2509 1132 1A6A     		ldr	r2, [r3, #32]
 2510 1134 FB89     		ldrh	r3, [r7, #14]
 2511 1136 DBB2     		uxtb	r3, r3
 2512 1138 1046     		mov	r0, r2
 2513 113a 1946     		mov	r1, r3
 2514 113c FFF7FEFF 		bl	packetfunctions_tossHeader
1133:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1134:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // inform schedule of successful transmission
1135:openstack/02a-MAClow/IEEE802154Ecsl.c ****       schedule_indicateTx(&ieee154e_vars.asn,TRUE);
 2515              		.loc 1 1135 0
 2516 1140 40F20000 		movw	r0, #:lower16:ieee154e_vars
 2517 1144 C0F20000 		movt	r0, #:upper16:ieee154e_vars
 2518 1148 4FF00101 		mov	r1, #1
 2519 114c FFF7FEFF 		bl	schedule_indicateTx
1136:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1137:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // inform upper layer
1138:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // CSL testing commented
1139:openstack/02a-MAClow/IEEE802154Ecsl.c ****       //notif_sendDone(ieee154e_vars.dataToSend,E_SUCCESS);
1140:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataToSend = NULL;
 2520              		.loc 1 1140 0
 2521 1150 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2522 1154 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2523 1158 4FF00002 		mov	r2, #0
 2524 115c 5A61     		str	r2, [r3, #20]
 2525 115e 08E0     		b	.L128
 2526              	.L134:
1096:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 2527              		.loc 1 1096 0
 2528 1160 00BF     		nop
 2529 1162 06E0     		b	.L128
 2530              	.L135:
1105:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 2531              		.loc 1 1105 0
 2532 1164 00BF     		nop
 2533 1166 04E0     		b	.L128
 2534              	.L136:
1119:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 2535              		.loc 1 1119 0
 2536 1168 00BF     		nop
 2537 116a 02E0     		b	.L128
 2538              	.L137:
1123:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break; //ack should contain IEs.
 2539              		.loc 1 1123 0
 2540 116c 00BF     		nop
 2541 116e 00E0     		b	.L128
 2542              	.L138:
1128:openstack/02a-MAClow/IEEE802154Ecsl.c ****         break;
 2543              		.loc 1 1128 0
 2544 1170 00BF     		nop
 2545              	.L128:
1141:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1142:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // in any case, execute the clean-up code below (processing of ACK done)
1143:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } while (0);
1144:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1145:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // free the received ack so corresponding RAM memory can be recycled
1146:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openqueue_freePacketBuffer(ieee154e_vars.ackReceived);
 2546              		.loc 1 1146 0
 2547 1172 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2548 1176 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2549 117a 1B6A     		ldr	r3, [r3, #32]
 2550 117c 1846     		mov	r0, r3
 2551 117e FFF7FEFF 		bl	openqueue_freePacketBuffer
1147:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1148:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clear local variable
1149:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackReceived = NULL;
 2552              		.loc 1 1149 0
 2553 1182 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2554 1186 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2555 118a 4FF00002 		mov	r2, #0
 2556 118e 1A62     		str	r2, [r3, #32]
1150:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1151:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // official end of Tx
1152:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 2557              		.loc 1 1152 0
 2558 1190 FFF7FEFF 		bl	endOps
 2559              	.L123:
1153:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2560              		.loc 1 1153 0
 2561 1194 07F15007 		add	r7, r7, #80
 2562 1198 BD46     		mov	sp, r7
 2563 119a B0BD     		pop	{r4, r5, r7, pc}
 2564              		.cfi_endproc
 2565              	.LFE28:
 2567              		.align	2
 2568              		.global	activity_csl_wakeup_ri1
 2569              		.thumb
 2570              		.thumb_func
 2572              	activity_csl_wakeup_ri1:
 2573              	.LFB29:
1154:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1155:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
1156:openstack/02a-MAClow/IEEE802154Ecsl.c **** //========================== CSL RX MODE ===============================
1157:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
1158:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1159:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1160:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1161:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [wake-up ri1].
1162:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1163:openstack/02a-MAClow/IEEE802154Ecsl.c ****  This method is invoked in ISR-mode from "isr_ieee154ecsl_newChannelSample" function when a new CSL
1164:openstack/02a-MAClow/IEEE802154Ecsl.c ****  
1165:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \note The FSM state should be S_SLEEP (initial state), raising an error in otherwise.
1166:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1167:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ri1() { // Activity for stage [ri1] on CSL RX Sampling.
 2574              		.loc 1 1167 0
 2575              		.cfi_startproc
 2576              		@ args = 0, pretend = 0, frame = 0
 2577              		@ frame_needed = 1, uses_anonymous_args = 0
 2578 119c 80B5     		push	{r7, lr}
 2579              	.LCFI69:
 2580              		.cfi_def_cfa_offset 8
 2581              		.cfi_offset 7, -8
 2582              		.cfi_offset 14, -4
 2583 119e 00AF     		add	r7, sp, #0
 2584              	.LCFI70:
 2585              		.cfi_def_cfa_register 7
1168:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1169:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // if the previous sample took too long or the state is incorrect, we will not be in the right 
1170:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // we register an error indicating the number of CSL sample where the problem have been detecte
1171:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   if (ieee154e_vars.state!=S_SLEEP) {
 2586              		.loc 1 1171 0
 2587 11a0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2588 11a4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2589 11a8 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 2590 11aa 002B     		cmp	r3, #0
 2591 11ac 14D0     		beq	.L140
1172:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  // log the error
1173:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_START_CSL_SAMPLING,
1174:openstack/02a-MAClow/IEEE802154Ecsl.c **** 								(errorparameter_t)ieee154e_vars.state,
 2592              		.loc 1 1174 0
 2593 11ae 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2594 11b2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2595 11b6 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1173:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_START_CSL_SAMPLING,
 2596              		.loc 1 1173 0
 2597 11b8 1A46     		mov	r2, r3
1175:openstack/02a-MAClow/IEEE802154Ecsl.c **** 								(errorparameter_t)ieee154e_dbg.num_cslSamples);
 2598              		.loc 1 1175 0
 2599 11ba 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 2600 11be C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 2601 11c2 1B69     		ldr	r3, [r3, #16]
1173:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_START_CSL_SAMPLING,
 2602              		.loc 1 1173 0
 2603 11c4 9BB2     		uxth	r3, r3
 2604 11c6 4FF00900 		mov	r0, #9
 2605 11ca 4FF03A01 		mov	r1, #58
 2606 11ce FFF7FEFF 		bl	openserial_printError
1176:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1177:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  // Abort in case of error. The signature of the function has been changed (instead of endSlot()
1178:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  // functionality. However, this function is equal for CSL and not-CSL.
1179:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  endOps();
 2607              		.loc 1 1179 0
 2608 11d2 FFF7FEFF 		bl	endOps
1180:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  return;
 2609              		.loc 1 1180 0
 2610 11d6 17E0     		b	.L139
 2611              	.L140:
1181:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
1182:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1183:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // stop using serial
1184:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   openserial_stop();
 2612              		.loc 1 1184 0
 2613 11d8 FFF7FEFF 		bl	openserial_stop
1185:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1186:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // change state --> Next State will be S_CSLRXWAKEUPOFFSET in order to prepare for CSL Rx wake-
1187:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   changeState(S_CSLRXWAKEUPOFFSET);
 2614              		.loc 1 1187 0
 2615 11dc 4FF02A00 		mov	r0, #42
 2616 11e0 FFF7FEFF 		bl	changeState
1188:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1189:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // update CSL Mode to RX in order to avoid problems in FSM.
1190:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   ieee154e_vars.cslMode = CSL_RX_MODE;
 2617              		.loc 1 1190 0
 2618 11e4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2619 11e8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2620 11ec 4FF00102 		mov	r2, #1
 2621 11f0 83F84520 		strb	r2, [r3, #69]
1191:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1192:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // arm rt1
1193:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   radiotimer_schedule(DURATION_rt1);
 2622              		.loc 1 1193 0
 2623 11f4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2624 11f8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2625 11fc 5B6A     		ldr	r3, [r3, #36]
 2626 11fe 03F13703 		add	r3, r3, #55
 2627 1202 1846     		mov	r0, r3
 2628 1204 FFF7FEFF 		bl	radiotimer_schedule
 2629              	.L139:
1194:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1195:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2630              		.loc 1 1195 0
 2631 1208 80BD     		pop	{r7, pc}
 2632              		.cfi_endproc
 2633              	.LFE29:
 2635 120a 00BF     		.align	2
 2636              		.global	activity_csl_wakeup_ri2
 2637              		.thumb
 2638              		.thumb_func
 2640              	activity_csl_wakeup_ri2:
 2641              	.LFB30:
1196:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1197:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1198:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1199:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [wake-up ri2].
1200:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1201:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1202:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to prepare the radio for receiving packets.
1203:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1204:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ri2() { // Activity for stage [ri2] on CSL RX Sampling.
 2642              		.loc 1 1204 0
 2643              		.cfi_startproc
 2644              		@ args = 0, pretend = 0, frame = 0
 2645              		@ frame_needed = 1, uses_anonymous_args = 0
 2646 120c 80B5     		push	{r7, lr}
 2647              	.LCFI71:
 2648              		.cfi_def_cfa_offset 8
 2649              		.cfi_offset 7, -8
 2650              		.cfi_offset 14, -4
 2651 120e 00AF     		add	r7, sp, #0
 2652              	.LCFI72:
 2653              		.cfi_def_cfa_register 7
1205:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1206:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXWAKEUPPREPARE);
 2654              		.loc 1 1206 0
 2655 1210 4FF02B00 		mov	r0, #43
 2656 1214 FFF7FEFF 		bl	changeState
1207:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1208:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // We use always the same frequency so it is not necessary to change it on radio.
1209:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Enable the radio in Rx mode. The radio does not actively listen yet.
1210:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rxEnable();
 2657              		.loc 1 1210 0
 2658 1218 FFF7FEFF 		bl	radio_rxEnable
1211:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnInit=radio_getTimerValue();
 2659              		.loc 1 1211 0
 2660 121c FFF7FEFF 		bl	radio_getTimerValue
 2661 1220 0246     		mov	r2, r0
 2662 1222 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2663 1226 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2664 122a 1A63     		str	r2, [r3, #48]
1212:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnThisSlot=TRUE;
 2665              		.loc 1 1212 0
 2666 122c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2667 1230 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2668 1234 4FF00102 		mov	r2, #1
 2669 1238 83F83820 		strb	r2, [r3, #56]
1213:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1214:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt2
1215:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt2);
 2670              		.loc 1 1215 0
 2671 123c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2672 1240 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2673 1244 5B6A     		ldr	r3, [r3, #36]
 2674 1246 03F15803 		add	r3, r3, #88
 2675 124a 1846     		mov	r0, r3
 2676 124c FFF7FEFF 		bl	radiotimer_schedule
1216:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1217:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Change state.
1218:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // If this action is not performed before rt2 has expired, we need to manage the error in activi
1219:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // prepare has exceeded the maximum allowed time (duration_rt2).
1220:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXWAKEUPREADY);
 2677              		.loc 1 1220 0
 2678 1250 4FF02C00 		mov	r0, #44
 2679 1254 FFF7FEFF 		bl	changeState
1221:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2680              		.loc 1 1221 0
 2681 1258 80BD     		pop	{r7, pc}
 2682              		.cfi_endproc
 2683              	.LFE30:
 2685 125a 00BF     		.align	2
 2686              		.global	activity_csl_wakeup_rie1
 2687              		.thumb
 2688              		.thumb_func
 2690              	activity_csl_wakeup_rie1:
 2691              	.LFB31:
1222:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1223:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1224:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1225:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling error [wake-up rie1].
1226:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1227:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #rt2 expiring, i.e. timer fires while state = S_CSLRXWAKEUPPREPARE. This is 
1228:openstack/02a-MAClow/IEEE802154Ecsl.c ****   did not have enough time to execute. Chances are to set maxRxDataPrepare too small. The implement
1229:openstack/02a-MAClow/IEEE802154Ecsl.c ****   next CSL sample.
1230:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1231:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_rie1() {  // Activity for error event [rie1] on CSL RX Samplin
 2692              		.loc 1 1231 0
 2693              		.cfi_startproc
 2694              		@ args = 0, pretend = 0, frame = 0
 2695              		@ frame_needed = 1, uses_anonymous_args = 0
 2696 125c 80B5     		push	{r7, lr}
 2697              	.LCFI73:
 2698              		.cfi_def_cfa_offset 8
 2699              		.cfi_offset 7, -8
 2700              		.cfi_offset 14, -4
 2701 125e 00AF     		add	r7, sp, #0
 2702              	.LCFI74:
 2703              		.cfi_def_cfa_register 7
1232:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
1233:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXWAKEUPPREPARE_OVERFLOWS,
1234:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state,
 2704              		.loc 1 1234 0
 2705 1260 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2706 1264 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2707 1268 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1233:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXWAKEUPPREPARE_OVERFLOWS,
 2708              		.loc 1 1233 0
 2709 126a 1A46     		mov	r2, r3
1235:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_dbg.num_cslSamples);
 2710              		.loc 1 1235 0
 2711 126c 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 2712 1270 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 2713 1274 1B69     		ldr	r3, [r3, #16]
1233:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXWAKEUPPREPARE_OVERFLOWS,
 2714              		.loc 1 1233 0
 2715 1276 9BB2     		uxth	r3, r3
 2716 1278 4FF00900 		mov	r0, #9
 2717 127c 4FF03C01 		mov	r1, #60
 2718 1280 FFF7FEFF 		bl	openserial_printError
1236:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1237:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1238:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 2719              		.loc 1 1238 0
 2720 1284 FFF7FEFF 		bl	endOps
1239:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2721              		.loc 1 1239 0
 2722 1288 80BD     		pop	{r7, pc}
 2723              		.cfi_endproc
 2724              	.LFE31:
 2726 128a 00BF     		.align	2
 2727              		.global	activity_csl_wakeup_ri3
 2728              		.thumb
 2729              		.thumb_func
 2731              	activity_csl_wakeup_ri3:
 2732              	.LFB32:
1240:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1241:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1242:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1243:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [wake-up ri3].
1244:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1245:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1246:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The radio is configured and this interrupt gives it the "go" signal to start listening.
1247:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1248:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ri3() { // Activity for stage [ri3] on CSL RX Sampling.
 2733              		.loc 1 1248 0
 2734              		.cfi_startproc
 2735              		@ args = 0, pretend = 0, frame = 0
 2736              		@ frame_needed = 1, uses_anonymous_args = 0
 2737 128c 80B5     		push	{r7, lr}
 2738              	.LCFI75:
 2739              		.cfi_def_cfa_offset 8
 2740              		.cfi_offset 7, -8
 2741              		.cfi_offset 14, -4
 2742 128e 00AF     		add	r7, sp, #0
 2743              	.LCFI76:
 2744              		.cfi_def_cfa_register 7
1249:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1250:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXWAKEUPLISTEN);
 2745              		.loc 1 1250 0
 2746 1290 4FF02D00 		mov	r0, #45
 2747 1294 FFF7FEFF 		bl	changeState
1251:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1252:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // give the 'go' to receive
1253:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rxNow();
 2748              		.loc 1 1253 0
 2749 1298 FFF7FEFF 		bl	radio_rxNow
1254:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1255:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt3
1256:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt3);
 2750              		.loc 1 1256 0
 2751 129c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2752 12a0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2753 12a4 5B6A     		ldr	r3, [r3, #36]
 2754 12a6 03F1AE03 		add	r3, r3, #174
 2755 12aa 1846     		mov	r0, r3
 2756 12ac FFF7FEFF 		bl	radiotimer_schedule
1257:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2757              		.loc 1 1257 0
 2758 12b0 80BD     		pop	{r7, pc}
 2759              		.cfi_endproc
 2760              	.LFE32:
 2762 12b2 00BF     		.align	2
 2763              		.global	activity_csl_wakeup_rie2
 2764              		.thumb
 2765              		.thumb_func
 2767              	activity_csl_wakeup_rie2:
 2768              	.LFB33:
1258:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1259:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1260:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1261:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling error [wake-up rie2].
1262:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1263:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #rt3 expiring, i.e. timer fires while state = S_CSLRXWAKEUPLISTEN. If no pac
1264:openstack/02a-MAClow/IEEE802154Ecsl.c ****   none will be received ever and it is safe to switch of the radio. This timer is set such that the
1265:openstack/02a-MAClow/IEEE802154Ecsl.c ****   duration (#TsLongGT).
1266:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1267:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_rie2() { // Activity for error event [rie2] on CSL RX Sampling
 2769              		.loc 1 1267 0
 2770              		.cfi_startproc
 2771              		@ args = 0, pretend = 0, frame = 0
 2772              		@ frame_needed = 1, uses_anonymous_args = 0
 2773 12b4 80B5     		push	{r7, lr}
 2774              	.LCFI77:
 2775              		.cfi_def_cfa_offset 8
 2776              		.cfi_offset 7, -8
 2777              		.cfi_offset 14, -4
 2778 12b6 00AF     		add	r7, sp, #0
 2779              	.LCFI78:
 2780              		.cfi_def_cfa_register 7
1268:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1269:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 2781              		.loc 1 1269 0
 2782 12b8 FFF7FEFF 		bl	endOps
1270:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2783              		.loc 1 1270 0
 2784 12bc 80BD     		pop	{r7, pc}
 2785              		.cfi_endproc
 2786              	.LFE33:
 2788 12be 00BF     		.align	2
 2789              		.global	activity_csl_wakeup_ri4
 2790              		.thumb
 2791              		.thumb_func
 2793              	activity_csl_wakeup_ri4:
 2794              	.LFB34:
1271:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1272:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1273:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1274:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [wake-up ri4].
1275:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1276:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_startOfFrame" function when a start of frame ev
1277:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to capture the time, cancel #rt3 and arm #rt4 (max time to receive all the p
1278:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1279:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ri4(PORT_RADIOTIMER_WIDTH capturedTime) {  // Activity for sta
 2795              		.loc 1 1279 0
 2796              		.cfi_startproc
 2797              		@ args = 0, pretend = 0, frame = 8
 2798              		@ frame_needed = 1, uses_anonymous_args = 0
 2799 12c0 80B5     		push	{r7, lr}
 2800              	.LCFI79:
 2801              		.cfi_def_cfa_offset 8
 2802              		.cfi_offset 7, -8
 2803              		.cfi_offset 14, -4
 2804 12c2 82B0     		sub	sp, sp, #8
 2805              	.LCFI80:
 2806              		.cfi_def_cfa_offset 16
 2807 12c4 00AF     		add	r7, sp, #0
 2808              	.LCFI81:
 2809              		.cfi_def_cfa_register 7
 2810 12c6 7860     		str	r0, [r7, #4]
1280:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1281:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1282:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXWAKEUP);
 2811              		.loc 1 1282 0
 2812 12c8 4FF02E00 		mov	r0, #46
 2813 12cc FFF7FEFF 		bl	changeState
1283:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1284:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel rt3
1285:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 2814              		.loc 1 1285 0
 2815 12d0 FFF7FEFF 		bl	radiotimer_cancel
1286:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1287:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
1288:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.lastCapturedTime = capturedTime;
 2816              		.loc 1 1288 0
 2817 12d4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2818 12d8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2819 12dc 7A68     		ldr	r2, [r7, #4]
 2820 12de 5A62     		str	r2, [r3, #36]
1289:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1290:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time to sync
1291:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.syncCapturedTime = capturedTime;
 2821              		.loc 1 1291 0
 2822 12e0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2823 12e4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2824 12e8 7A68     		ldr	r2, [r7, #4]
 2825 12ea 9A62     		str	r2, [r3, #40]
1292:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1293:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt4);
 2826              		.loc 1 1293 0
 2827 12ec 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2828 12f0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2829 12f4 5B6A     		ldr	r3, [r3, #36]
 2830 12f6 03F1A403 		add	r3, r3, #164
 2831 12fa 1846     		mov	r0, r3
 2832 12fc FFF7FEFF 		bl	radiotimer_schedule
1294:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2833              		.loc 1 1294 0
 2834 1300 07F10807 		add	r7, r7, #8
 2835 1304 BD46     		mov	sp, r7
 2836 1306 80BD     		pop	{r7, pc}
 2837              		.cfi_endproc
 2838              	.LFE34:
 2840              		.align	2
 2841              		.global	activity_csl_wakeup_rie3
 2842              		.thumb
 2843              		.thumb_func
 2845              	activity_csl_wakeup_rie3:
 2846              	.LFB35:
1295:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1296:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1297:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1298:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling error [wake-up rie3].
1299:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1300:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #rt4 expiring, i.e. timer fires while state = S_CSLRXWAKEUP. This is an erro
1301:openstack/02a-MAClow/IEEE802154Ecsl.c ****   transmit the data packet. The implemented behaviour is to log the error and move on the next CSL 
1302:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1303:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_rie3() {
 2847              		.loc 1 1303 0
 2848              		.cfi_startproc
 2849              		@ args = 0, pretend = 0, frame = 0
 2850              		@ frame_needed = 1, uses_anonymous_args = 0
 2851 1308 80B5     		push	{r7, lr}
 2852              	.LCFI82:
 2853              		.cfi_def_cfa_offset 8
 2854              		.cfi_offset 7, -8
 2855              		.cfi_offset 14, -4
 2856 130a 00AF     		add	r7, sp, #0
 2857              	.LCFI83:
 2858              		.cfi_def_cfa_register 7
1304:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1305:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
1306:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDWAKEUPDURATION_OVERFLOWS,
1307:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state,
 2859              		.loc 1 1307 0
 2860 130c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2861 1310 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2862 1314 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1306:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDWAKEUPDURATION_OVERFLOWS,
 2863              		.loc 1 1306 0
 2864 1316 1A46     		mov	r2, r3
1308:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_dbg.num_cslSamples);
 2865              		.loc 1 1308 0
 2866 1318 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 2867 131c C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 2868 1320 1B69     		ldr	r3, [r3, #16]
1306:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDWAKEUPDURATION_OVERFLOWS,
 2869              		.loc 1 1306 0
 2870 1322 9BB2     		uxth	r3, r3
 2871 1324 4FF00900 		mov	r0, #9
 2872 1328 4FF03D01 		mov	r1, #61
 2873 132c FFF7FEFF 		bl	openserial_printError
1309:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1310:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1311:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 2874              		.loc 1 1311 0
 2875 1330 FFF7FEFF 		bl	endOps
1312:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2876              		.loc 1 1312 0
 2877 1334 80BD     		pop	{r7, pc}
 2878              		.cfi_endproc
 2879              	.LFE35:
 2881 1336 00BF     		.align	2
 2882              		.global	activity_csl_wakeup_rie4
 2883              		.thumb
 2884              		.thumb_func
 2886              	activity_csl_wakeup_rie4:
 2887              	.LFB36:
1313:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1314:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1315:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling error [wake-up rie4].
1316:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1317:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by rztime+TsSlotDuration expiring, i.e. timer fires while state = S_CSLRXWAKEUP
1318:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The behaviour is to free mem used and restart CSL sampling.
1319:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1320:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_rie4() {
 2888              		.loc 1 1320 0
 2889              		.cfi_startproc
 2890              		@ args = 0, pretend = 0, frame = 0
 2891              		@ frame_needed = 1, uses_anonymous_args = 0
 2892 1338 80B5     		push	{r7, lr}
 2893              	.LCFI84:
 2894              		.cfi_def_cfa_offset 8
 2895              		.cfi_offset 7, -8
 2896              		.cfi_offset 14, -4
 2897 133a 00AF     		add	r7, sp, #0
 2898              	.LCFI85:
 2899              		.cfi_def_cfa_register 7
1321:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1322:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // free memory
1323:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openqueue_freePacketBuffer(ieee154e_vars.dataReceived);
 2900              		.loc 1 1323 0
 2901 133c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2902 1340 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2903 1344 9B69     		ldr	r3, [r3, #24]
 2904 1346 1846     		mov	r0, r3
 2905 1348 FFF7FEFF 		bl	openqueue_freePacketBuffer
1324:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1325:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clear local variable
1326:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.dataReceived = NULL;
 2906              		.loc 1 1326 0
 2907 134c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2908 1350 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2909 1354 4FF00002 		mov	r2, #0
 2910 1358 9A61     		str	r2, [r3, #24]
1327:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1328:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1329:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 2911              		.loc 1 1329 0
 2912 135a FFF7FEFF 		bl	endOps
1330:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2913              		.loc 1 1330 0
 2914 135e 80BD     		pop	{r7, pc}
 2915              		.cfi_endproc
 2916              	.LFE36:
 2918              		.align	2
 2919              		.global	activity_csl_wakeup_ri5
 2920              		.thumb
 2921              		.thumb_func
 2923              	activity_csl_wakeup_ri5:
 2924              	.LFB37:
1331:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1332:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1333:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1334:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [wake-up ri5].
1335:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1336:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_endOfFrame" function when a end of frame event 
1337:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change state, cancel #rt4, validate wake-up frame and destination, and ar
1338:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1339:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ri5(PORT_RADIOTIMER_WIDTH capturedTime) {
 2925              		.loc 1 1339 0
 2926              		.cfi_startproc
 2927              		@ args = 0, pretend = 0, frame = 96
 2928              		@ frame_needed = 1, uses_anonymous_args = 0
 2929 1360 90B5     		push	{r4, r7, lr}
 2930              	.LCFI86:
 2931              		.cfi_def_cfa_offset 12
 2932              		.cfi_offset 4, -12
 2933              		.cfi_offset 7, -8
 2934              		.cfi_offset 14, -4
 2935 1362 9BB0     		sub	sp, sp, #108
 2936              	.LCFI87:
 2937              		.cfi_def_cfa_offset 120
 2938 1364 02AF     		add	r7, sp, #8
 2939              	.LCFI88:
 2940              		.cfi_def_cfa 7, 112
 2941 1366 7860     		str	r0, [r7, #4]
1340:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1341:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// Only for CSL Testing due to we are hard-coding destination (neighbor) address on schedule, pack
1342:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	open_addr_t myID;
1343:openstack/02a-MAClow/IEEE802154Ecsl.c ****     myID.addr_64b[0]=0x00;
 2942              		.loc 1 1343 0
 2943 1368 4FF00003 		mov	r3, #0
 2944 136c 87F84D30 		strb	r3, [r7, #77]
1344:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.addr_64b[1]=0x11;
 2945              		.loc 1 1344 0
 2946 1370 4FF01103 		mov	r3, #17
 2947 1374 87F84E30 		strb	r3, [r7, #78]
1345:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.addr_64b[2]=0x22;
 2948              		.loc 1 1345 0
 2949 1378 4FF02203 		mov	r3, #34
 2950 137c 87F84F30 		strb	r3, [r7, #79]
1346:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.addr_64b[3]=0x33;
 2951              		.loc 1 1346 0
 2952 1380 4FF03303 		mov	r3, #51
 2953 1384 87F85030 		strb	r3, [r7, #80]
1347:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.addr_64b[4]=0x44;
 2954              		.loc 1 1347 0
 2955 1388 4FF04403 		mov	r3, #68
 2956 138c 87F85130 		strb	r3, [r7, #81]
1348:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.addr_64b[5]=0x55;
 2957              		.loc 1 1348 0
 2958 1390 4FF05503 		mov	r3, #85
 2959 1394 87F85230 		strb	r3, [r7, #82]
1349:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.addr_64b[6]=0x66;
 2960              		.loc 1 1349 0
 2961 1398 4FF06603 		mov	r3, #102
 2962 139c 87F85330 		strb	r3, [r7, #83]
1350:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.addr_64b[7]=0x77;
 2963              		.loc 1 1350 0
 2964 13a0 4FF07703 		mov	r3, #119
 2965 13a4 87F85430 		strb	r3, [r7, #84]
1351:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1352:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.type=ADDR_64B;
 2966              		.loc 1 1352 0
 2967 13a8 4FF00203 		mov	r3, #2
 2968 13ac 87F84C30 		strb	r3, [r7, #76]
1353:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1354:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// En este punto ya hemos recibido la trama por lo que hay que hacer las siguientes validaciones:
1355:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   1.- Cambiar el estado a S_CSLRXWAKEUPVALIDATE y cancelar el temporizador rt4.
1356:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   2.- Apagar la radio.
1357:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   3.- Analizar el mensaje recibido y parsear su cabecera.
1358:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   4.- Verificar que se trata de una trama de tipo wake-up.
1359:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   5.- Comprobar que el destinatario soy yo mismo.
1360:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//
1361:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// En caso afirmativo, utilizamos el Rendezvous time recibido para saber cuánto tiempo hay que do
1362:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// En caso negativo, desactivamos la radio e iniciamos de nuevo el proceso de channel sampling.
1363:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1364:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	ieee802154_header_iht ieee802514_header;
1365:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	uint16_t rztime;
1366:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1367:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // actualizamos el estado.
1368:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXWAKEUPVALIDATE);
 2969              		.loc 1 1368 0
 2970 13b0 4FF02F00 		mov	r0, #47
 2971 13b4 FFF7FEFF 		bl	changeState
1369:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1370:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancelamos el timer #rt4
1371:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 2972              		.loc 1 1371 0
 2973 13b8 FFF7FEFF 		bl	radiotimer_cancel
1372:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1373:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // apagamos la radio
1374:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rfOff();
 2974              		.loc 1 1374 0
 2975 13bc FFF7FEFF 		bl	radio_rfOff
1375:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1376:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // obtenemos un buffer en el cual poder guardar los datos recibidos.
1377:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.wakeupReceived = openqueue_getFreePacketBuffer(COMPONENT_IEEE802154E);
 2976              		.loc 1 1377 0
 2977 13c0 4FF00900 		mov	r0, #9
 2978 13c4 FFF7FEFF 		bl	openqueue_getFreePacketBuffer
 2979 13c8 0246     		mov	r2, r0
 2980 13ca 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2981 13ce C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2982 13d2 1A64     		str	r2, [r3, #64]
1378:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.wakeupReceived==NULL) {
 2983              		.loc 1 1378 0
 2984 13d4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2985 13d8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2986 13dc 1B6C     		ldr	r3, [r3, #64]
 2987 13de 002B     		cmp	r3, #0
 2988 13e0 0CD1     		bne	.L150
1379:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // registro del error & fin de operaciones.
1380:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openserial_printError(COMPONENT_IEEE802154E,ERR_NO_FREE_PACKET_BUFFER, (errorparameter_t)0, (
 2989              		.loc 1 1380 0
 2990 13e2 4FF00900 		mov	r0, #9
 2991 13e6 4FF02C01 		mov	r1, #44
 2992 13ea 4FF00002 		mov	r2, #0
 2993 13ee 4FF00003 		mov	r3, #0
 2994 13f2 FFF7FEFF 		bl	openserial_printError
1381:openstack/02a-MAClow/IEEE802154Ecsl.c ****       endOps();
 2995              		.loc 1 1381 0
 2996 13f6 FFF7FEFF 		bl	endOps
 2997 13fa 14E1     		b	.L149
 2998              	.L150:
1382:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return;
1383:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
1384:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1385:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Declaración de propiedad sobre el paquete.
1386:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.wakeupReceived->creator = COMPONENT_IEEE802154E;
 2999              		.loc 1 1386 0
 3000 13fc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3001 1400 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3002 1404 1B6C     		ldr	r3, [r3, #64]
 3003 1406 4FF00902 		mov	r2, #9
 3004 140a 1A70     		strb	r2, [r3, #0]
1387:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.wakeupReceived->owner   = COMPONENT_IEEE802154E;
 3005              		.loc 1 1387 0
 3006 140c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3007 1410 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3008 1414 1B6C     		ldr	r3, [r3, #64]
 3009 1416 4FF00902 		mov	r2, #9
 3010 141a 5A70     		strb	r2, [r3, #1]
1388:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1389:openstack/02a-MAClow/IEEE802154Ecsl.c ****    /*
1390:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The do-while loop that follows is a little parsing trick.
1391:openstack/02a-MAClow/IEEE802154Ecsl.c ****    Because it contains a while(0) condition, it gets executed only once.
1392:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The behavior is:
1393:openstack/02a-MAClow/IEEE802154Ecsl.c ****    - if a break occurs inside the do{} body, the error code below the loop gets executed. This indi
1394:openstack/02a-MAClow/IEEE802154Ecsl.c ****    - if a return occurs inside the do{} body, the error code below the loop does not get executed. 
1395:openstack/02a-MAClow/IEEE802154Ecsl.c ****    */
1396:openstack/02a-MAClow/IEEE802154Ecsl.c ****    do { // Este "loop" es ejecutado sólo en una ocasión.
1397:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1398:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Obtenemos la trama con los datos recibidos desde el buffer de recepción de la radio.
1399:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.wakeupReceived->payload = &(ieee154e_vars.wakeupReceived->packet[FIRST_FRAME_BY
 3011              		.loc 1 1399 0
 3012 141c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3013 1420 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3014 1424 1A6C     		ldr	r2, [r3, #64]
 3015 1426 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3016 142a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3017 142e 1B6C     		ldr	r3, [r3, #64]
 3018 1430 03F16C03 		add	r3, r3, #108
 3019 1434 5360     		str	r3, [r2, #4]
1400:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(      ieee154e_vars.wakeupReceived->payload,
 3020              		.loc 1 1400 0
 3021 1436 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3022 143a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3023 143e 1B6C     		ldr	r3, [r3, #64]
 3024 1440 5968     		ldr	r1, [r3, #4]
1401:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.wakeupReceived->length,
 3025              		.loc 1 1401 0
 3026 1442 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3027 1446 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3028 144a 1B6C     		ldr	r3, [r3, #64]
1400:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(      ieee154e_vars.wakeupReceived->payload,
 3029              		.loc 1 1400 0
 3030 144c 03F10802 		add	r2, r3, #8
1402:openstack/02a-MAClow/IEEE802154Ecsl.c ****                              sizeof(ieee154e_vars.wakeupReceived->packet),
1403:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.wakeupReceived->l1_rssi,
 3031              		.loc 1 1403 0
 3032 1450 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3033 1454 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3034 1458 1B6C     		ldr	r3, [r3, #64]
1400:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(      ieee154e_vars.wakeupReceived->payload,
 3035              		.loc 1 1400 0
 3036 145a 03F16804 		add	r4, r3, #104
1404:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.wakeupReceived->l1_lqi,
 3037              		.loc 1 1404 0
 3038 145e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3039 1462 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3040 1466 1B6C     		ldr	r3, [r3, #64]
1400:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(      ieee154e_vars.wakeupReceived->payload,
 3041              		.loc 1 1400 0
 3042 1468 03F16900 		add	r0, r3, #105
1405:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.wakeupReceived->l1_crc);
 3043              		.loc 1 1405 0
 3044 146c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3045 1470 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3046 1474 1B6C     		ldr	r3, [r3, #64]
1400:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(      ieee154e_vars.wakeupReceived->payload,
 3047              		.loc 1 1400 0
 3048 1476 03F16A03 		add	r3, r3, #106
 3049 147a 0090     		str	r0, [sp, #0]
 3050 147c 0193     		str	r3, [sp, #4]
 3051 147e 0846     		mov	r0, r1
 3052 1480 1146     		mov	r1, r2
 3053 1482 4FF08202 		mov	r2, #130
 3054 1486 2346     		mov	r3, r4
 3055 1488 FFF7FEFF 		bl	radio_getReceivedFrame
1406:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1407:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Finalizamos si la longitud no es correcta.
1408:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.wakeupReceived->length<LENGTH_CRC || ieee154e_vars.wakeupReceived->length>L
 3056              		.loc 1 1408 0
 3057 148c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3058 1490 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3059 1494 1B6C     		ldr	r3, [r3, #64]
 3060 1496 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 3061 1498 012B     		cmp	r3, #1
 3062 149a 07D9     		bls	.L152
 3063              		.loc 1 1408 0 is_stmt 0 discriminator 1
 3064 149c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3065 14a0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3066 14a4 1B6C     		ldr	r3, [r3, #64]
 3067 14a6 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 3068 14a8 802B     		cmp	r3, #128
 3069 14aa 0ED9     		bls	.L153
 3070              	.L152:
1409:openstack/02a-MAClow/IEEE802154Ecsl.c ****         openserial_printError(COMPONENT_IEEE802154E,ERR_INVALIDPACKETFROMRADIO, (errorparameter_t)2
 3071              		.loc 1 1409 0 is_stmt 1
 3072 14ac 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3073 14b0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3074 14b4 1B6C     		ldr	r3, [r3, #64]
 3075 14b6 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 3076 14b8 4FF00900 		mov	r0, #9
 3077 14bc 4FF03701 		mov	r1, #55
 3078 14c0 4FF00202 		mov	r2, #2
 3079 14c4 FFF7FEFF 		bl	openserial_printError
1410:openstack/02a-MAClow/IEEE802154Ecsl.c ****         break;
 3080              		.loc 1 1410 0
 3081 14c8 9CE0     		b	.L154
 3082              	.L153:
1411:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1412:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1413:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // toss CRC (2 últimos bytes)
1414:openstack/02a-MAClow/IEEE802154Ecsl.c ****       packetfunctions_tossFooter(ieee154e_vars.wakeupReceived, LENGTH_CRC);
 3083              		.loc 1 1414 0
 3084 14ca 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3085 14ce C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3086 14d2 1B6C     		ldr	r3, [r3, #64]
 3087 14d4 1846     		mov	r0, r3
 3088 14d6 4FF00201 		mov	r1, #2
 3089 14da FFF7FEFF 		bl	packetfunctions_tossFooter
1415:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1416:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // si CRC no es válido, finalizamos el proceso.
1417:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.wakeupReceived->l1_crc==FALSE) { break; }
 3090              		.loc 1 1417 0
 3091 14de 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3092 14e2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3093 14e6 1B6C     		ldr	r3, [r3, #64]
 3094 14e8 93F86A30 		ldrb	r3, [r3, #106]	@ zero_extendqisi2
 3095 14ec 83F00103 		eor	r3, r3, #1
 3096 14f0 DBB2     		uxtb	r3, r3
 3097 14f2 002B     		cmp	r3, #0
 3098 14f4 40F08380 		bne	.L161
 3099              	.L155:
1418:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1419:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // parseamos la trama IEEE802.15.4 WAKE-UP y su cabecera.
1420:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee802154_retrieveWakeUpFrame(ieee154e_vars.wakeupReceived,&ieee802514_header,&rztime);
 3100              		.loc 1 1420 0
 3101 14f8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3102 14fc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3103 1500 196C     		ldr	r1, [r3, #64]
 3104 1502 07F10C02 		add	r2, r7, #12
 3105 1506 07F10A03 		add	r3, r7, #10
 3106 150a 0846     		mov	r0, r1
 3107 150c 1146     		mov	r1, r2
 3108 150e 1A46     		mov	r2, r3
 3109 1510 FFF7FEFF 		bl	ieee802154_retrieveWakeUpFrame
1421:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1422:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // En el caso de que no sea una cabecera IEEE802.15.4 válida, finalizamos el proceso.
1423:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee802514_header.valid==FALSE) { break; }
 3110              		.loc 1 1423 0
 3111 1514 3B7B     		ldrb	r3, [r7, #12]	@ zero_extendqisi2
 3112 1516 83F00103 		eor	r3, r3, #1
 3113 151a DBB2     		uxtb	r3, r3
 3114 151c 002B     		cmp	r3, #0
 3115 151e 70D1     		bne	.L162
 3116              	.L156:
1424:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1425:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Verificamos que se trata de una trama WAKE-UP, perteneciente a la misma PAN ID, y dirigida
1426:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if(ieee802514_header.frameType==IEEE154_TYPE_MULTIPURPOSE) {
 3117              		.loc 1 1426 0
 3118 1520 BB7B     		ldrb	r3, [r7, #14]	@ zero_extendqisi2
 3119 1522 052B     		cmp	r3, #5
 3120 1524 6ED1     		bne	.L154
1427:openstack/02a-MAClow/IEEE802154Ecsl.c ****      	  //if(packetfunctions_sameAddress(&ieee802514_header.dest,idmanager_getMyID(ADDR_16B)) && --
1428:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	  if(packetfunctions_sameAddress(&ieee802514_header.dest, &myID) &&
 3121              		.loc 1 1428 0
 3122 1526 07F10C03 		add	r3, r7, #12
 3123 152a 03F11B02 		add	r2, r3, #27
 3124 152e 07F14C03 		add	r3, r7, #76
 3125 1532 1046     		mov	r0, r2
 3126 1534 1946     		mov	r1, r3
 3127 1536 FFF7FEFF 		bl	packetfunctions_sameAddress
 3128 153a 0346     		mov	r3, r0
 3129 153c 002B     		cmp	r3, #0
 3130 153e 34D0     		beq	.L157
1429:openstack/02a-MAClow/IEEE802154Ecsl.c ****    		    packetfunctions_sameAddress(&ieee802514_header.panid,idmanager_getMyID(ADDR_PANID))) {
 3131              		.loc 1 1429 0 discriminator 1
 3132 1540 4FF00400 		mov	r0, #4
 3133 1544 FFF7FEFF 		bl	idmanager_getMyID
 3134 1548 0346     		mov	r3, r0
 3135 154a 07F10C02 		add	r2, r7, #12
 3136 154e 02F10A02 		add	r2, r2, #10
 3137 1552 1046     		mov	r0, r2
 3138 1554 1946     		mov	r1, r3
 3139 1556 FFF7FEFF 		bl	packetfunctions_sameAddress
 3140 155a 0346     		mov	r3, r0
1428:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	  if(packetfunctions_sameAddress(&ieee802514_header.dest, &myID) &&
 3141              		.loc 1 1428 0 discriminator 1
 3142 155c 002B     		cmp	r3, #0
 3143 155e 24D0     		beq	.L157
1430:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1431:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	   // En este caso, debemos dormir el tiempo indicado por RZ Time, estableciendo el estado a S
1432:openstack/02a-MAClow/IEEE802154Ecsl.c ****  	       changeState(S_CSLRXDATAOFFSET);
 3144              		.loc 1 1432 0
 3145 1560 4FF03000 		mov	r0, #48
 3146 1564 FFF7FEFF 		bl	changeState
1433:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1434:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	   // Tratamos el caso en el cual rztime_ie.time sea cero, es decir, sea la ultima trama wake-
1435:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	   if (rztime == 0) {
 3147              		.loc 1 1435 0
 3148 1568 7B89     		ldrh	r3, [r7, #10]
 3149 156a 002B     		cmp	r3, #0
 3150 156c 0AD1     		bne	.L158
1436:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     // Establecemos el timer rt1 (consideramos el mismo tiempo de offset para la recepción d
1437:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     radiotimer_schedule(DURATION_rt1);
 3151              		.loc 1 1437 0
 3152 156e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3153 1572 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3154 1576 5B6A     		ldr	r3, [r3, #36]
 3155 1578 03F13703 		add	r3, r3, #55
 3156 157c 1846     		mov	r0, r3
 3157 157e FFF7FEFF 		bl	radiotimer_schedule
 3158 1582 0BE0     		b	.L159
 3159              	.L158:
1438:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	   } else {
1439:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     // Establecemos el timer al valor rt1 pero desplazado el tiempo indicado desde el rendezv
1440:openstack/02a-MAClow/IEEE802154Ecsl.c ****         	 radiotimer_schedule(DURATION_rt1 + rztime);
 3160              		.loc 1 1440 0
 3161 1584 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3162 1588 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3163 158c 5A6A     		ldr	r2, [r3, #36]
 3164 158e 7B89     		ldrh	r3, [r7, #10]
 3165 1590 D318     		adds	r3, r2, r3
 3166 1592 03F13703 		add	r3, r3, #55
 3167 1596 1846     		mov	r0, r3
 3168 1598 FFF7FEFF 		bl	radiotimer_schedule
 3169              	.L159:
1441:openstack/02a-MAClow/IEEE802154Ecsl.c ****            }
1442:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1443:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	   // registro del tiempo de captura
1444:openstack/02a-MAClow/IEEE802154Ecsl.c ****            ieee154e_vars.lastCapturedTime = capturedTime;
 3170              		.loc 1 1444 0
 3171 159c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3172 15a0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3173 15a4 7A68     		ldr	r2, [r7, #4]
 3174 15a6 5A62     		str	r2, [r3, #36]
 3175 15a8 3DE0     		b	.L149
 3176              	.L157:
1445:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1446:openstack/02a-MAClow/IEEE802154Ecsl.c ****            // si hemos llegado aquí, retornamos para no ejecutar el codigo inferior.
1447:openstack/02a-MAClow/IEEE802154Ecsl.c ****            return;
1448:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 }
1449:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 // En el caso que sea una trama dentro de mi PANID pero no dirigida a mi, entonces dormimos u
1450:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 //   - RZ time + Maximum length payload frame + secure ack frame (consideraremos un tiempo ig
1451:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 // dado que TsSlotDuration es el tiempo utilizado en OpenWSN-TSCH para enviar y recibir una t
1452:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 else if( ! packetfunctions_sameAddress(&ieee802514_header.dest,idmanager_getMyID(ADDR_16B)) &
 3177              		.loc 1 1452 0
 3178 15aa 4FF00100 		mov	r0, #1
 3179 15ae FFF7FEFF 		bl	idmanager_getMyID
 3180 15b2 0346     		mov	r3, r0
 3181 15b4 07F10C02 		add	r2, r7, #12
 3182 15b8 02F11B02 		add	r2, r2, #27
 3183 15bc 1046     		mov	r0, r2
 3184 15be 1946     		mov	r1, r3
 3185 15c0 FFF7FEFF 		bl	packetfunctions_sameAddress
 3186 15c4 0346     		mov	r3, r0
 3187 15c6 83F00103 		eor	r3, r3, #1
 3188 15ca DBB2     		uxtb	r3, r3
 3189 15cc 002B     		cmp	r3, #0
 3190 15ce 19D0     		beq	.L154
1453:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	   		    packetfunctions_sameAddress(&ieee802514_header.panid,idmanager_getMyID(ADDR_PANID))) 
 3191              		.loc 1 1453 0 discriminator 1
 3192 15d0 4FF00400 		mov	r0, #4
 3193 15d4 FFF7FEFF 		bl	idmanager_getMyID
 3194 15d8 0346     		mov	r3, r0
 3195 15da 07F10C02 		add	r2, r7, #12
 3196 15de 02F10A02 		add	r2, r2, #10
 3197 15e2 1046     		mov	r0, r2
 3198 15e4 1946     		mov	r1, r3
 3199 15e6 FFF7FEFF 		bl	packetfunctions_sameAddress
 3200 15ea 0346     		mov	r3, r0
1452:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 else if( ! packetfunctions_sameAddress(&ieee802514_header.dest,idmanager_getMyID(ADDR_16B)) &
 3201              		.loc 1 1452 0 discriminator 1
 3202 15ec 002B     		cmp	r3, #0
 3203 15ee 09D0     		beq	.L154
1454:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1455:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     // La limpieza del paquete y los datos recibidos será realizada en el metodo activity_cs
1456:openstack/02a-MAClow/IEEE802154Ecsl.c ****     		 radiotimer_schedule(rztime + TsSlotDuration);
 3204              		.loc 1 1456 0
 3205 15f0 7B89     		ldrh	r3, [r7, #10]
 3206 15f2 03F5F673 		add	r3, r3, #492
 3207 15f6 1846     		mov	r0, r3
 3208 15f8 FFF7FEFF 		bl	radiotimer_schedule
 3209 15fc 13E0     		b	.L149
 3210              	.L161:
1417:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.wakeupReceived->l1_crc==FALSE) { break; }
 3211              		.loc 1 1417 0
 3212 15fe 00BF     		nop
 3213 1600 00E0     		b	.L154
 3214              	.L162:
1423:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee802514_header.valid==FALSE) { break; }
 3215              		.loc 1 1423 0
 3216 1602 00BF     		nop
 3217              	.L154:
1457:openstack/02a-MAClow/IEEE802154Ecsl.c ****     		 return;
1458:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 }
1459:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1460:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1461:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } while(0);
1462:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1463:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // En cualquier otro caso, descartamos el paquete e iniciamos de nuevo el proceso de channel sam
1464:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1465:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openqueue_freePacketBuffer(ieee154e_vars.wakeupReceived);
 3218              		.loc 1 1465 0
 3219 1604 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3220 1608 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3221 160c 1B6C     		ldr	r3, [r3, #64]
 3222 160e 1846     		mov	r0, r3
 3223 1610 FFF7FEFF 		bl	openqueue_freePacketBuffer
1466:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1467:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clear local variable
1468:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.wakeupReceived = NULL;
 3224              		.loc 1 1468 0
 3225 1614 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3226 1618 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3227 161c 4FF00002 		mov	r2, #0
 3228 1620 1A64     		str	r2, [r3, #64]
1469:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1470:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1471:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 3229              		.loc 1 1471 0
 3230 1622 FFF7FEFF 		bl	endOps
 3231              	.L149:
1472:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3232              		.loc 1 1472 0
 3233 1626 07F16407 		add	r7, r7, #100
 3234 162a BD46     		mov	sp, r7
 3235 162c 90BD     		pop	{r4, r7, pc}
 3236              		.cfi_endproc
 3237              	.LFE37:
 3239 162e 00BF     		.align	2
 3240              		.global	activity_csl_data_ri2
 3241              		.thumb
 3242              		.thumb_func
 3244              	activity_csl_data_ri2:
 3245              	.LFB38:
1473:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1474:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1475:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1476:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri2].
1477:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1478:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1479:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to prepare the radio for receiving packets.
1480:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1481:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1482:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri2() {
 3246              		.loc 1 1482 0
 3247              		.cfi_startproc
 3248              		@ args = 0, pretend = 0, frame = 0
 3249              		@ frame_needed = 1, uses_anonymous_args = 0
 3250 1630 80B5     		push	{r7, lr}
 3251              	.LCFI89:
 3252              		.cfi_def_cfa_offset 8
 3253              		.cfi_offset 7, -8
 3254              		.cfi_offset 14, -4
 3255 1632 00AF     		add	r7, sp, #0
 3256              	.LCFI90:
 3257              		.cfi_def_cfa_register 7
1483:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1484:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXDATAPREPARE);
 3258              		.loc 1 1484 0
 3259 1634 4FF03100 		mov	r0, #49
 3260 1638 FFF7FEFF 		bl	changeState
1485:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1486:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // We use always the same frequency so it is not necessary to change it on radio.
1487:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Enable the radio in Rx mode. The radio does not actively listen yet.
1488:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rxEnable();
 3261              		.loc 1 1488 0
 3262 163c FFF7FEFF 		bl	radio_rxEnable
1489:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnInit=radio_getTimerValue();
 3263              		.loc 1 1489 0
 3264 1640 FFF7FEFF 		bl	radio_getTimerValue
 3265 1644 0246     		mov	r2, r0
 3266 1646 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3267 164a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3268 164e 1A63     		str	r2, [r3, #48]
1490:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnThisSlot=TRUE;
 3269              		.loc 1 1490 0
 3270 1650 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3271 1654 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3272 1658 4FF00102 		mov	r2, #1
 3273 165c 83F83820 		strb	r2, [r3, #56]
1491:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1492:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt2
1493:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt2);
 3274              		.loc 1 1493 0
 3275 1660 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3276 1664 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3277 1668 5B6A     		ldr	r3, [r3, #36]
 3278 166a 03F15803 		add	r3, r3, #88
 3279 166e 1846     		mov	r0, r3
 3280 1670 FFF7FEFF 		bl	radiotimer_schedule
1494:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1495:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1496:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // If this action is not performed before rt2 has expired, we need to manage the error in activi
1497:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // prepare has exceeded the maximum allowed time (duration_rt2).
1498:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXDATAREADY);
 3281              		.loc 1 1498 0
 3282 1674 4FF03200 		mov	r0, #50
 3283 1678 FFF7FEFF 		bl	changeState
1499:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3284              		.loc 1 1499 0
 3285 167c 80BD     		pop	{r7, pc}
 3286              		.cfi_endproc
 3287              	.LFE38:
 3289 167e 00BF     		.align	2
 3290              		.global	activity_csl_data_rie1
 3291              		.thumb
 3292              		.thumb_func
 3294              	activity_csl_data_rie1:
 3295              	.LFB39:
1500:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1501:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1502:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1503:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling error [data_rie1].
1504:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1505:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #rt2 expiring, i.e. timer fires while state = S_CSLRXDATAPREPARE. This is re
1506:openstack/02a-MAClow/IEEE802154Ecsl.c ****   did not have enough time to execute. Chances are to set maxRxDataPrepare too small. The implement
1507:openstack/02a-MAClow/IEEE802154Ecsl.c ****   next CSL sample.
1508:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1509:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_rie1() {  // Activity for error event [rie1] on CSL RX Sampling.
 3296              		.loc 1 1509 0
 3297              		.cfi_startproc
 3298              		@ args = 0, pretend = 0, frame = 0
 3299              		@ frame_needed = 1, uses_anonymous_args = 0
 3300 1680 80B5     		push	{r7, lr}
 3301              	.LCFI91:
 3302              		.cfi_def_cfa_offset 8
 3303              		.cfi_offset 7, -8
 3304              		.cfi_offset 14, -4
 3305 1682 00AF     		add	r7, sp, #0
 3306              	.LCFI92:
 3307              		.cfi_def_cfa_register 7
1510:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
1511:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXDATAPREPARE_OVERFLOWS,
1512:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state,
 3308              		.loc 1 1512 0
 3309 1684 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3310 1688 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3311 168c 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1511:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXDATAPREPARE_OVERFLOWS,
 3312              		.loc 1 1511 0
 3313 168e 1A46     		mov	r2, r3
1513:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_dbg.num_cslSamples);
 3314              		.loc 1 1513 0
 3315 1690 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 3316 1694 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 3317 1698 1B69     		ldr	r3, [r3, #16]
1511:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXDATAPREPARE_OVERFLOWS,
 3318              		.loc 1 1511 0
 3319 169a 9BB2     		uxth	r3, r3
 3320 169c 4FF00900 		mov	r0, #9
 3321 16a0 4FF02401 		mov	r1, #36
 3322 16a4 FFF7FEFF 		bl	openserial_printError
1514:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1515:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 3323              		.loc 1 1515 0
 3324 16a8 FFF7FEFF 		bl	endOps
1516:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3325              		.loc 1 1516 0
 3326 16ac 80BD     		pop	{r7, pc}
 3327              		.cfi_endproc
 3328              	.LFE39:
 3330 16ae 00BF     		.align	2
 3331              		.global	activity_csl_data_ri3
 3332              		.thumb
 3333              		.thumb_func
 3335              	activity_csl_data_ri3:
 3336              	.LFB40:
1517:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1518:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1519:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1520:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri3].
1521:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1522:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1523:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The radio is configured and this interrupt gives it the "go" signal to start listening.
1524:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1525:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri3() { // Activity for stage [data ri3] on CSL RX Sampling.
 3337              		.loc 1 1525 0
 3338              		.cfi_startproc
 3339              		@ args = 0, pretend = 0, frame = 0
 3340              		@ frame_needed = 1, uses_anonymous_args = 0
 3341 16b0 80B5     		push	{r7, lr}
 3342              	.LCFI93:
 3343              		.cfi_def_cfa_offset 8
 3344              		.cfi_offset 7, -8
 3345              		.cfi_offset 14, -4
 3346 16b2 00AF     		add	r7, sp, #0
 3347              	.LCFI94:
 3348              		.cfi_def_cfa_register 7
1526:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1527:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXDATALISTEN);
 3349              		.loc 1 1527 0
 3350 16b4 4FF03300 		mov	r0, #51
 3351 16b8 FFF7FEFF 		bl	changeState
1528:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1529:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // give the 'go' to receive
1530:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rxNow();
 3352              		.loc 1 1530 0
 3353 16bc FFF7FEFF 		bl	radio_rxNow
1531:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1532:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt3
1533:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt3);
 3354              		.loc 1 1533 0
 3355 16c0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3356 16c4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3357 16c8 5B6A     		ldr	r3, [r3, #36]
 3358 16ca 03F1AE03 		add	r3, r3, #174
 3359 16ce 1846     		mov	r0, r3
 3360 16d0 FFF7FEFF 		bl	radiotimer_schedule
1534:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3361              		.loc 1 1534 0
 3362 16d4 80BD     		pop	{r7, pc}
 3363              		.cfi_endproc
 3364              	.LFE40:
 3366 16d6 00BF     		.align	2
 3367              		.global	activity_csl_data_rie2
 3368              		.thumb
 3369              		.thumb_func
 3371              	activity_csl_data_rie2:
 3372              	.LFB41:
1535:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1536:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1537:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1538:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling error [data rie2].
1539:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1540:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #rt3 expiring, i.e. timer fires while state = S_CSLRXDATALISTEN. If no packe
1541:openstack/02a-MAClow/IEEE802154Ecsl.c ****   none will be received ever and it is safe to switch of the radio. This timer is set such that the
1542:openstack/02a-MAClow/IEEE802154Ecsl.c ****   duration (#TsLongGT).
1543:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1544:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_rie2() { // Activity for error event [data rie2] on CSL RX Sampl
 3373              		.loc 1 1544 0
 3374              		.cfi_startproc
 3375              		@ args = 0, pretend = 0, frame = 0
 3376              		@ frame_needed = 1, uses_anonymous_args = 0
 3377 16d8 80B5     		push	{r7, lr}
 3378              	.LCFI95:
 3379              		.cfi_def_cfa_offset 8
 3380              		.cfi_offset 7, -8
 3381              		.cfi_offset 14, -4
 3382 16da 00AF     		add	r7, sp, #0
 3383              	.LCFI96:
 3384              		.cfi_def_cfa_register 7
1545:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1546:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 3385              		.loc 1 1546 0
 3386 16dc FFF7FEFF 		bl	endOps
1547:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3387              		.loc 1 1547 0
 3388 16e0 80BD     		pop	{r7, pc}
 3389              		.cfi_endproc
 3390              	.LFE41:
 3392 16e2 00BF     		.align	2
 3393              		.global	activity_csl_data_ri4
 3394              		.thumb
 3395              		.thumb_func
 3397              	activity_csl_data_ri4:
 3398              	.LFB42:
1548:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1549:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1550:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri4].
1551:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1552:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_startOfFrame" function when a start of frame ev
1553:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to capture the time, cancel #rt3 and arm #rt4 (max time to receive all the p
1554:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1555:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri4(PORT_RADIOTIMER_WIDTH capturedTime) {  // Activity for stage
 3399              		.loc 1 1555 0
 3400              		.cfi_startproc
 3401              		@ args = 0, pretend = 0, frame = 8
 3402              		@ frame_needed = 1, uses_anonymous_args = 0
 3403 16e4 80B5     		push	{r7, lr}
 3404              	.LCFI97:
 3405              		.cfi_def_cfa_offset 8
 3406              		.cfi_offset 7, -8
 3407              		.cfi_offset 14, -4
 3408 16e6 82B0     		sub	sp, sp, #8
 3409              	.LCFI98:
 3410              		.cfi_def_cfa_offset 16
 3411 16e8 00AF     		add	r7, sp, #0
 3412              	.LCFI99:
 3413              		.cfi_def_cfa_register 7
 3414 16ea 7860     		str	r0, [r7, #4]
1556:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1557:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1558:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXDATA);
 3415              		.loc 1 1558 0
 3416 16ec 4FF03400 		mov	r0, #52
 3417 16f0 FFF7FEFF 		bl	changeState
1559:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1560:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel rt3
1561:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 3418              		.loc 1 1561 0
 3419 16f4 FFF7FEFF 		bl	radiotimer_cancel
1562:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1563:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
1564:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.lastCapturedTime = capturedTime;
 3420              		.loc 1 1564 0
 3421 16f8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3422 16fc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3423 1700 7A68     		ldr	r2, [r7, #4]
 3424 1702 5A62     		str	r2, [r3, #36]
1565:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1566:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time to sync
1567:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.syncCapturedTime = capturedTime;
 3425              		.loc 1 1567 0
 3426 1704 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3427 1708 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3428 170c 7A68     		ldr	r2, [r7, #4]
 3429 170e 9A62     		str	r2, [r3, #40]
1568:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1569:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt4);
 3430              		.loc 1 1569 0
 3431 1710 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3432 1714 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3433 1718 5B6A     		ldr	r3, [r3, #36]
 3434 171a 03F1A403 		add	r3, r3, #164
 3435 171e 1846     		mov	r0, r3
 3436 1720 FFF7FEFF 		bl	radiotimer_schedule
1570:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3437              		.loc 1 1570 0
 3438 1724 07F10807 		add	r7, r7, #8
 3439 1728 BD46     		mov	sp, r7
 3440 172a 80BD     		pop	{r7, pc}
 3441              		.cfi_endproc
 3442              	.LFE42:
 3444              		.align	2
 3445              		.global	activity_csl_data_rie3
 3446              		.thumb
 3447              		.thumb_func
 3449              	activity_csl_data_rie3:
 3450              	.LFB43:
1571:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1572:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1573:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1574:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling error [data rie3].
1575:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1576:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #rt4 expiring, i.e. timer fires while state = S_CSLRXDATA. This is an error 
1577:openstack/02a-MAClow/IEEE802154Ecsl.c ****   transmit the data packet. The implemented behaviour is to log the error and move on the next CSL 
1578:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1579:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_rie3() {
 3451              		.loc 1 1579 0
 3452              		.cfi_startproc
 3453              		@ args = 0, pretend = 0, frame = 0
 3454              		@ frame_needed = 1, uses_anonymous_args = 0
 3455 172c 80B5     		push	{r7, lr}
 3456              	.LCFI100:
 3457              		.cfi_def_cfa_offset 8
 3458              		.cfi_offset 7, -8
 3459              		.cfi_offset 14, -4
 3460 172e 00AF     		add	r7, sp, #0
 3461              	.LCFI101:
 3462              		.cfi_def_cfa_register 7
1580:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1581:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
1582:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
1583:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state,
 3463              		.loc 1 1583 0
 3464 1730 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3465 1734 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3466 1738 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1582:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
 3467              		.loc 1 1582 0
 3468 173a 1A46     		mov	r2, r3
1584:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_dbg.num_cslSamples);
 3469              		.loc 1 1584 0
 3470 173c 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 3471 1740 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 3472 1744 1B69     		ldr	r3, [r3, #16]
1582:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
 3473              		.loc 1 1582 0
 3474 1746 9BB2     		uxth	r3, r3
 3475 1748 4FF00900 		mov	r0, #9
 3476 174c 4FF02601 		mov	r1, #38
 3477 1750 FFF7FEFF 		bl	openserial_printError
1585:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1586:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1587:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 3478              		.loc 1 1587 0
 3479 1754 FFF7FEFF 		bl	endOps
1588:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3480              		.loc 1 1588 0
 3481 1758 80BD     		pop	{r7, pc}
 3482              		.cfi_endproc
 3483              	.LFE43:
 3485 175a 00BF     		.align	2
 3486              		.global	activity_csl_data_ri5
 3487              		.thumb
 3488              		.thumb_func
 3490              	activity_csl_data_ri5:
 3491              	.LFB44:
1589:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1590:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1591:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri5].
1592:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1593:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_endOfFrame" function when a end of frame event 
1594:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change state, cancel #rt4, validate data frame, and transmit ACK.
1595:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1596:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri5(PORT_RADIOTIMER_WIDTH capturedTime) {
 3492              		.loc 1 1596 0
 3493              		.cfi_startproc
 3494              		@ args = 0, pretend = 0, frame = 80
 3495              		@ frame_needed = 1, uses_anonymous_args = 0
 3496 175c B0B5     		push	{r4, r5, r7, lr}
 3497              	.LCFI102:
 3498              		.cfi_def_cfa_offset 16
 3499              		.cfi_offset 4, -16
 3500              		.cfi_offset 5, -12
 3501              		.cfi_offset 7, -8
 3502              		.cfi_offset 14, -4
 3503 175e 96B0     		sub	sp, sp, #88
 3504              	.LCFI103:
 3505              		.cfi_def_cfa_offset 104
 3506 1760 02AF     		add	r7, sp, #8
 3507              	.LCFI104:
 3508              		.cfi_def_cfa 7, 96
 3509 1762 7860     		str	r0, [r7, #4]
1597:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802154_header_iht ieee802514_header;
1598:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint16_t lenIE=0;
 3510              		.loc 1 1598 0
 3511 1764 4FF00003 		mov	r3, #0
 3512 1768 FB81     		strh	r3, [r7, #14]	@ movhi
1599:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1600:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1601:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXACKOFFSET);
 3513              		.loc 1 1601 0
 3514 176a 4FF03500 		mov	r0, #53
 3515 176e FFF7FEFF 		bl	changeState
1602:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1603:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel rt4
1604:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 3516              		.loc 1 1604 0
 3517 1772 FFF7FEFF 		bl	radiotimer_cancel
1605:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1606:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // turn off the radio
1607:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rfOff();
 3518              		.loc 1 1607 0
 3519 1776 FFF7FEFF 		bl	radio_rfOff
1608:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnTics+=radio_getTimerValue()-ieee154e_vars.radioOnInit;
 3520              		.loc 1 1608 0
 3521 177a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3522 177e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3523 1782 5C6B     		ldr	r4, [r3, #52]
 3524 1784 FFF7FEFF 		bl	radio_getTimerValue
 3525 1788 0246     		mov	r2, r0
 3526 178a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3527 178e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3528 1792 1B6B     		ldr	r3, [r3, #48]
 3529 1794 D31A     		subs	r3, r2, r3
 3530 1796 E218     		adds	r2, r4, r3
 3531 1798 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3532 179c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3533 17a0 5A63     		str	r2, [r3, #52]
1609:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // get a buffer to put the (received) data in
1610:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.dataReceived = openqueue_getFreePacketBuffer(COMPONENT_IEEE802154E);
 3534              		.loc 1 1610 0
 3535 17a2 4FF00900 		mov	r0, #9
 3536 17a6 FFF7FEFF 		bl	openqueue_getFreePacketBuffer
 3537 17aa 0246     		mov	r2, r0
 3538 17ac 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3539 17b0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3540 17b4 9A61     		str	r2, [r3, #24]
1611:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.dataReceived==NULL) {
 3541              		.loc 1 1611 0
 3542 17b6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3543 17ba C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3544 17be 9B69     		ldr	r3, [r3, #24]
 3545 17c0 002B     		cmp	r3, #0
 3546 17c2 0CD1     		bne	.L170
1612:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // log the error
1613:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openserial_printError(COMPONENT_IEEE802154E,ERR_NO_FREE_PACKET_BUFFER,
 3547              		.loc 1 1613 0
 3548 17c4 4FF00900 		mov	r0, #9
 3549 17c8 4FF02C01 		mov	r1, #44
 3550 17cc 4FF00002 		mov	r2, #0
 3551 17d0 4FF00003 		mov	r3, #0
 3552 17d4 FFF7FEFF 		bl	openserial_printError
1614:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)0,
1615:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)0);
1616:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // abort
1617:openstack/02a-MAClow/IEEE802154Ecsl.c ****       endOps();
 3553              		.loc 1 1617 0
 3554 17d8 FFF7FEFF 		bl	endOps
 3555 17dc 3CE1     		b	.L169
 3556              	.L170:
1618:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return;
1619:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
1620:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1621:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // declare ownership over that packet
1622:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.dataReceived->creator = COMPONENT_IEEE802154E;
 3557              		.loc 1 1622 0
 3558 17de 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3559 17e2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3560 17e6 9B69     		ldr	r3, [r3, #24]
 3561 17e8 4FF00902 		mov	r2, #9
 3562 17ec 1A70     		strb	r2, [r3, #0]
1623:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.dataReceived->owner   = COMPONENT_IEEE802154E;
 3563              		.loc 1 1623 0
 3564 17ee 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3565 17f2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3566 17f6 9B69     		ldr	r3, [r3, #24]
 3567 17f8 4FF00902 		mov	r2, #9
 3568 17fc 5A70     		strb	r2, [r3, #1]
1624:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1625:openstack/02a-MAClow/IEEE802154Ecsl.c ****    /*
1626:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The do-while loop that follows is a little parsing trick.
1627:openstack/02a-MAClow/IEEE802154Ecsl.c ****    Because it contains a while(0) condition, it gets executed only once.
1628:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The behavior is:
1629:openstack/02a-MAClow/IEEE802154Ecsl.c ****    - if a break occurs inside the do{} body, the error code below the loop
1630:openstack/02a-MAClow/IEEE802154Ecsl.c ****      gets executed. This indicates something is wrong with the packet being
1631:openstack/02a-MAClow/IEEE802154Ecsl.c ****      parsed.
1632:openstack/02a-MAClow/IEEE802154Ecsl.c ****    - if a return occurs inside the do{} body, the error code below the loop
1633:openstack/02a-MAClow/IEEE802154Ecsl.c ****      does not get executed. This indicates the received packet is correct.
1634:openstack/02a-MAClow/IEEE802154Ecsl.c ****    */
1635:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1636:openstack/02a-MAClow/IEEE802154Ecsl.c ****    do { // this "loop" is only executed once
1637:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1638:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // retrieve the received data frame from the radio's Rx buffer
1639:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataReceived->payload = &(ieee154e_vars.dataReceived->packet[FIRST_FRAME_BYTE])
 3569              		.loc 1 1639 0
 3570 17fe 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3571 1802 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3572 1806 9A69     		ldr	r2, [r3, #24]
 3573 1808 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3574 180c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3575 1810 9B69     		ldr	r3, [r3, #24]
 3576 1812 03F16C03 		add	r3, r3, #108
 3577 1816 5360     		str	r3, [r2, #4]
1640:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.dataReceived->payload,
 3578              		.loc 1 1640 0
 3579 1818 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3580 181c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3581 1820 9B69     		ldr	r3, [r3, #24]
 3582 1822 5968     		ldr	r1, [r3, #4]
1641:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.dataReceived->length,
 3583              		.loc 1 1641 0
 3584 1824 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3585 1828 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3586 182c 9B69     		ldr	r3, [r3, #24]
1640:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.dataReceived->payload,
 3587              		.loc 1 1640 0
 3588 182e 03F10802 		add	r2, r3, #8
1642:openstack/02a-MAClow/IEEE802154Ecsl.c ****                              sizeof(ieee154e_vars.dataReceived->packet),
1643:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.dataReceived->l1_rssi,
 3589              		.loc 1 1643 0
 3590 1832 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3591 1836 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3592 183a 9B69     		ldr	r3, [r3, #24]
1640:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.dataReceived->payload,
 3593              		.loc 1 1640 0
 3594 183c 03F16804 		add	r4, r3, #104
1644:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.dataReceived->l1_lqi,
 3595              		.loc 1 1644 0
 3596 1840 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3597 1844 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3598 1848 9B69     		ldr	r3, [r3, #24]
1640:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.dataReceived->payload,
 3599              		.loc 1 1640 0
 3600 184a 03F16900 		add	r0, r3, #105
1645:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.dataReceived->l1_crc);
 3601              		.loc 1 1645 0
 3602 184e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3603 1852 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3604 1856 9B69     		ldr	r3, [r3, #24]
1640:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.dataReceived->payload,
 3605              		.loc 1 1640 0
 3606 1858 03F16A03 		add	r3, r3, #106
 3607 185c 0090     		str	r0, [sp, #0]
 3608 185e 0193     		str	r3, [sp, #4]
 3609 1860 0846     		mov	r0, r1
 3610 1862 1146     		mov	r1, r2
 3611 1864 4FF08202 		mov	r2, #130
 3612 1868 2346     		mov	r3, r4
 3613 186a FFF7FEFF 		bl	radio_getReceivedFrame
1646:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1647:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // break if wrong length
1648:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.dataReceived->length<LENGTH_CRC || ieee154e_vars.dataReceived->length>LENGT
 3614              		.loc 1 1648 0
 3615 186e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3616 1872 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3617 1876 9B69     		ldr	r3, [r3, #24]
 3618 1878 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 3619 187a 012B     		cmp	r3, #1
 3620 187c 07D9     		bls	.L172
 3621              		.loc 1 1648 0 is_stmt 0 discriminator 1
 3622 187e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3623 1882 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3624 1886 9B69     		ldr	r3, [r3, #24]
 3625 1888 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 3626 188a 802B     		cmp	r3, #128
 3627 188c 0ED9     		bls	.L173
 3628              	.L172:
1649:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // jump to the error code below this do-while loop
1650:openstack/02a-MAClow/IEEE802154Ecsl.c ****         openserial_printError(COMPONENT_IEEE802154E,ERR_INVALIDPACKETFROMRADIO,
1651:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)2,
1652:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             ieee154e_vars.dataReceived->length);
 3629              		.loc 1 1652 0 is_stmt 1
 3630 188e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3631 1892 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3632 1896 9B69     		ldr	r3, [r3, #24]
 3633 1898 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
1650:openstack/02a-MAClow/IEEE802154Ecsl.c ****         openserial_printError(COMPONENT_IEEE802154E,ERR_INVALIDPACKETFROMRADIO,
 3634              		.loc 1 1650 0
 3635 189a 4FF00900 		mov	r0, #9
 3636 189e 4FF03701 		mov	r1, #55
 3637 18a2 4FF00202 		mov	r2, #2
 3638 18a6 FFF7FEFF 		bl	openserial_printError
1653:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 3639              		.loc 1 1653 0
 3640 18aa C4E0     		b	.L174
 3641              	.L173:
1654:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1655:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1656:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // toss CRC (2 last bytes)
1657:openstack/02a-MAClow/IEEE802154Ecsl.c ****       packetfunctions_tossFooter(   ieee154e_vars.dataReceived, LENGTH_CRC);
 3642              		.loc 1 1657 0
 3643 18ac 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3644 18b0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3645 18b4 9B69     		ldr	r3, [r3, #24]
 3646 18b6 1846     		mov	r0, r3
 3647 18b8 4FF00201 		mov	r1, #2
 3648 18bc FFF7FEFF 		bl	packetfunctions_tossFooter
1658:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1659:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // if CRC doesn't check, stop
1660:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.dataReceived->l1_crc==FALSE) {
 3649              		.loc 1 1660 0
 3650 18c0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3651 18c4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3652 18c8 9B69     		ldr	r3, [r3, #24]
 3653 18ca 93F86A30 		ldrb	r3, [r3, #106]	@ zero_extendqisi2
 3654 18ce 83F00103 		eor	r3, r3, #1
 3655 18d2 DBB2     		uxtb	r3, r3
 3656 18d4 002B     		cmp	r3, #0
 3657 18d6 40F0A980 		bne	.L182
 3658              	.L175:
1661:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // jump to the error code below this do-while loop
1662:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
1663:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1664:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1665:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // parse the IEEE802.15.4 header (RX DATA)
1666:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee802154_retrieveHeader(ieee154e_vars.dataReceived,&ieee802514_header);
 3659              		.loc 1 1666 0
 3660 18da 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3661 18de C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3662 18e2 9A69     		ldr	r2, [r3, #24]
 3663 18e4 07F11003 		add	r3, r7, #16
 3664 18e8 1046     		mov	r0, r2
 3665 18ea 1946     		mov	r1, r3
 3666 18ec FFF7FEFF 		bl	ieee802154_retrieveHeader
1667:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1668:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // break if invalid IEEE802.15.4 header
1669:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee802514_header.valid==FALSE) {
 3667              		.loc 1 1669 0
 3668 18f0 3B7C     		ldrb	r3, [r7, #16]	@ zero_extendqisi2
 3669 18f2 83F00103 		eor	r3, r3, #1
 3670 18f6 DBB2     		uxtb	r3, r3
 3671 18f8 002B     		cmp	r3, #0
 3672 18fa 40F09980 		bne	.L183
 3673              	.L176:
1670:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // break from the do-while loop and execute the clean-up code below
1671:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
1672:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1673:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1674:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // store header details in packet buffer
1675:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataReceived->l2_frameType      = ieee802514_header.frameType;
 3674              		.loc 1 1675 0
 3675 18fe 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3676 1902 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3677 1906 9B69     		ldr	r3, [r3, #24]
 3678 1908 BA7C     		ldrb	r2, [r7, #18]	@ zero_extendqisi2
 3679 190a 83F84920 		strb	r2, [r3, #73]
1676:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataReceived->l2_dsn            = ieee802514_header.dsn;
 3680              		.loc 1 1676 0
 3681 190e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3682 1912 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3683 1916 9B69     		ldr	r3, [r3, #24]
 3684 1918 7A7E     		ldrb	r2, [r7, #25]	@ zero_extendqisi2
 3685 191a 83F84A20 		strb	r2, [r3, #74]
1677:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataReceived->l2_IEListPresent  = ieee802514_header.ieListPresent;
 3686              		.loc 1 1677 0
 3687 191e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3688 1922 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3689 1926 9B69     		ldr	r3, [r3, #24]
 3690 1928 FA7D     		ldrb	r2, [r7, #23]	@ zero_extendqisi2
 3691 192a 83F86520 		strb	r2, [r3, #101]
1678:openstack/02a-MAClow/IEEE802154Ecsl.c ****       memcpy(&(ieee154e_vars.dataReceived->l2_nextORpreviousHop),&(ieee802514_header.src),sizeof(op
 3692              		.loc 1 1678 0
 3693 192e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3694 1932 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3695 1936 9B69     		ldr	r3, [r3, #24]
 3696 1938 03F13803 		add	r3, r3, #56
 3697 193c 1D46     		mov	r5, r3
 3698 193e 07F13C04 		add	r4, r7, #60
 3699 1942 0FCC     		ldmia	r4!, {r0, r1, r2, r3}
 3700 1944 2860     		str	r0, [r5, #0]	@ unaligned
 3701 1946 6960     		str	r1, [r5, #4]	@ unaligned
 3702 1948 AA60     		str	r2, [r5, #8]	@ unaligned
 3703 194a EB60     		str	r3, [r5, #12]	@ unaligned
 3704 194c 2378     		ldrb	r3, [r4, #0]
 3705 194e 2B74     		strb	r3, [r5, #16]
1679:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1680:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // toss the IEEE802.15.4 header
1681:openstack/02a-MAClow/IEEE802154Ecsl.c ****       packetfunctions_tossHeader(ieee154e_vars.dataReceived,ieee802514_header.headerLength);
 3706              		.loc 1 1681 0
 3707 1950 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3708 1954 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3709 1958 9A69     		ldr	r2, [r3, #24]
 3710 195a 7B7C     		ldrb	r3, [r7, #17]	@ zero_extendqisi2
 3711 195c 1046     		mov	r0, r2
 3712 195e 1946     		mov	r1, r3
 3713 1960 FFF7FEFF 		bl	packetfunctions_tossHeader
1682:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1683:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // handle IEs xv poipoi
1684:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset join priority
1685:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // retrieve IE in sixtop
1686:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if ((ieee802514_header.valid==TRUE &&
 3714              		.loc 1 1686 0
 3715 1964 3B7C     		ldrb	r3, [r7, #16]	@ zero_extendqisi2
1687:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header.ieListPresent==TRUE &&
1688:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header.frameType==IEEE154_TYPE_BEACON && // if it is not a beacon and have ie,
1689:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header.panid,idmanager_getMyID(ADDR_PANID)) &&
 3716              		.loc 1 1689 0
 3717 1966 002B     		cmp	r3, #0
 3718 1968 22D0     		beq	.L178
1687:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header.ieListPresent==TRUE &&
 3719              		.loc 1 1687 0
 3720 196a FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
1686:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if ((ieee802514_header.valid==TRUE &&
 3721              		.loc 1 1686 0
 3722 196c 002B     		cmp	r3, #0
 3723 196e 1FD0     		beq	.L178
1688:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header.frameType==IEEE154_TYPE_BEACON && // if it is not a beacon and have ie,
 3724              		.loc 1 1688 0
 3725 1970 BB7C     		ldrb	r3, [r7, #18]	@ zero_extendqisi2
1687:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header.ieListPresent==TRUE &&
 3726              		.loc 1 1687 0
 3727 1972 002B     		cmp	r3, #0
 3728 1974 1CD1     		bne	.L178
 3729              		.loc 1 1689 0
 3730 1976 4FF00400 		mov	r0, #4
 3731 197a FFF7FEFF 		bl	idmanager_getMyID
 3732 197e 0346     		mov	r3, r0
 3733 1980 07F11002 		add	r2, r7, #16
 3734 1984 02F10A02 		add	r2, r2, #10
 3735 1988 1046     		mov	r0, r2
 3736 198a 1946     		mov	r1, r3
 3737 198c FFF7FEFF 		bl	packetfunctions_sameAddress
 3738 1990 0346     		mov	r3, r0
1688:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header.frameType==IEEE154_TYPE_BEACON && // if it is not a beacon and have ie,
 3739              		.loc 1 1688 0
 3740 1992 002B     		cmp	r3, #0
 3741 1994 0CD0     		beq	.L178
1690:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee154e_processIEs(ieee154e_vars.dataReceived,&lenIE))==FALSE) {
 3742              		.loc 1 1690 0
 3743 1996 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3744 199a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3745 199e 9A69     		ldr	r2, [r3, #24]
 3746 19a0 07F10E03 		add	r3, r7, #14
 3747 19a4 1046     		mov	r0, r2
 3748 19a6 1946     		mov	r1, r3
 3749 19a8 FFF7FEFF 		bl	ieee154e_processIEs
 3750 19ac 0346     		mov	r3, r0
1689:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header.panid,idmanager_getMyID(ADDR_PANID)) &&
 3751              		.loc 1 1689 0
 3752 19ae 002B     		cmp	r3, #0
 3753              	.L178:
1691:openstack/02a-MAClow/IEEE802154Ecsl.c ****           //log  that the packet is not carrying IEs
1692:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1693:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1694:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // toss the IEs including Synch
1695:openstack/02a-MAClow/IEEE802154Ecsl.c ****       packetfunctions_tossHeader(ieee154e_vars.dataReceived,lenIE);
 3754              		.loc 1 1695 0
 3755 19b0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3756 19b4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3757 19b8 9A69     		ldr	r2, [r3, #24]
 3758 19ba FB89     		ldrh	r3, [r7, #14]
 3759 19bc DBB2     		uxtb	r3, r3
 3760 19be 1046     		mov	r0, r2
 3761 19c0 1946     		mov	r1, r3
 3762 19c2 FFF7FEFF 		bl	packetfunctions_tossHeader
1696:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1697:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // record the captured time
1698:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.lastCapturedTime = capturedTime;
 3763              		.loc 1 1698 0
 3764 19c6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3765 19ca C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3766 19ce 7A68     		ldr	r2, [r7, #4]
 3767 19d0 5A62     		str	r2, [r3, #36]
1699:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1700:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // if I just received an invalid frame, stop
1701:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (isValidRxFrame(&ieee802514_header)==FALSE) {
 3768              		.loc 1 1701 0
 3769 19d2 07F11003 		add	r3, r7, #16
 3770 19d6 1846     		mov	r0, r3
 3771 19d8 FFF7FEFF 		bl	isValidRxFrame
 3772 19dc 0346     		mov	r3, r0
 3773 19de 83F00103 		eor	r3, r3, #1
 3774 19e2 DBB2     		uxtb	r3, r3
 3775 19e4 002B     		cmp	r3, #0
 3776 19e6 25D1     		bne	.L184
 3777              	.L179:
1702:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // jump to the error code below this do-while loop
1703:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
1704:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1705:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1706:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // check if ack requested
1707:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee802514_header.ackRequested==1) {
 3778              		.loc 1 1707 0
 3779 19e8 7B7D     		ldrb	r3, [r7, #21]	@ zero_extendqisi2
 3780 19ea 002B     		cmp	r3, #0
 3781 19ec 0AD0     		beq	.L180
1708:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // arm rt5
1709:openstack/02a-MAClow/IEEE802154Ecsl.c ****          radiotimer_schedule(DURATION_rt5);
 3782              		.loc 1 1709 0
 3783 19ee 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3784 19f2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3785 19f6 5B6A     		ldr	r3, [r3, #36]
 3786 19f8 03F17A03 		add	r3, r3, #122
 3787 19fc 1846     		mov	r0, r3
 3788 19fe FFF7FEFF 		bl	radiotimer_schedule
 3789 1a02 29E0     		b	.L169
 3790              	.L180:
1710:openstack/02a-MAClow/IEEE802154Ecsl.c ****       } else {
1711:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // synchronize to the received packet if I'm not a DAGroot and this is my preferred parent
1712:openstack/02a-MAClow/IEEE802154Ecsl.c ****          //if (idmanager_getIsDAGroot()==FALSE && neighbors_isPreferredParent(&(ieee154e_vars.dataR
1713:openstack/02a-MAClow/IEEE802154Ecsl.c ****          //   synchronizePacket(ieee154e_vars.syncCapturedTime);
1714:openstack/02a-MAClow/IEEE802154Ecsl.c ****          //}
1715:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // indicate reception to upper layer (no ACK asked)
1716:openstack/02a-MAClow/IEEE802154Ecsl.c ****          notif_receive(ieee154e_vars.dataReceived, 1);
 3791              		.loc 1 1716 0
 3792 1a04 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3793 1a08 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3794 1a0c 9B69     		ldr	r3, [r3, #24]
 3795 1a0e 1846     		mov	r0, r3
 3796 1a10 4FF00101 		mov	r1, #1
 3797 1a14 FFF7FEFF 		bl	notif_receive
1717:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // reset local variable
1718:openstack/02a-MAClow/IEEE802154Ecsl.c ****          ieee154e_vars.dataReceived = NULL;
 3798              		.loc 1 1718 0
 3799 1a18 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3800 1a1c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3801 1a20 4FF00002 		mov	r2, #0
 3802 1a24 9A61     		str	r2, [r3, #24]
1719:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // abort
1720:openstack/02a-MAClow/IEEE802154Ecsl.c ****          endOps();
 3803              		.loc 1 1720 0
 3804 1a26 FFF7FEFF 		bl	endOps
 3805 1a2a 15E0     		b	.L169
 3806              	.L182:
1662:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 3807              		.loc 1 1662 0
 3808 1a2c 00BF     		nop
 3809 1a2e 02E0     		b	.L174
 3810              	.L183:
1671:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 3811              		.loc 1 1671 0
 3812 1a30 00BF     		nop
 3813 1a32 00E0     		b	.L174
 3814              	.L184:
1703:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 3815              		.loc 1 1703 0
 3816 1a34 00BF     		nop
 3817              	.L174:
1721:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1722:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1723:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // everything went well, return here not to execute the error code below
1724:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return;
1725:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1726:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } while(0);
1727:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1728:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // free the (invalid) received data so RAM memory can be recycled
1729:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openqueue_freePacketBuffer(ieee154e_vars.dataReceived);
 3818              		.loc 1 1729 0
 3819 1a36 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3820 1a3a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3821 1a3e 9B69     		ldr	r3, [r3, #24]
 3822 1a40 1846     		mov	r0, r3
 3823 1a42 FFF7FEFF 		bl	openqueue_freePacketBuffer
1730:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1731:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clear local variable
1732:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.dataReceived = NULL;
 3824              		.loc 1 1732 0
 3825 1a46 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3826 1a4a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3827 1a4e 4FF00002 		mov	r2, #0
 3828 1a52 9A61     		str	r2, [r3, #24]
1733:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1734:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1735:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 3829              		.loc 1 1735 0
 3830 1a54 FFF7FEFF 		bl	endOps
 3831              	.L169:
1736:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3832              		.loc 1 1736 0
 3833 1a58 07F15007 		add	r7, r7, #80
 3834 1a5c BD46     		mov	sp, r7
 3835 1a5e B0BD     		pop	{r4, r5, r7, pc}
 3836              		.cfi_endproc
 3837              	.LFE44:
 3839              		.align	2
 3840              		.global	activity_csl_data_ri6
 3841              		.thumb
 3842              		.thumb_func
 3844              	activity_csl_data_ri6:
 3845              	.LFB45:
1737:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1738:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1739:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri6].
1740:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1741:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1742:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The functionality is to prepare the radio for ACK sending.
1743:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1744:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri6() {
 3846              		.loc 1 1744 0
 3847              		.cfi_startproc
 3848              		@ args = 0, pretend = 0, frame = 8
 3849              		@ frame_needed = 1, uses_anonymous_args = 0
 3850 1a60 90B5     		push	{r4, r7, lr}
 3851              	.LCFI105:
 3852              		.cfi_def_cfa_offset 12
 3853              		.cfi_offset 4, -12
 3854              		.cfi_offset 7, -8
 3855              		.cfi_offset 14, -4
 3856 1a62 87B0     		sub	sp, sp, #28
 3857              	.LCFI106:
 3858              		.cfi_def_cfa_offset 40
 3859 1a64 04AF     		add	r7, sp, #16
 3860              	.LCFI107:
 3861              		.cfi_def_cfa 7, 24
1745:openstack/02a-MAClow/IEEE802154Ecsl.c ****    PORT_SIGNED_INT_WIDTH timeCorrection;
1746:openstack/02a-MAClow/IEEE802154Ecsl.c ****    header_IE_ht header_desc;
1747:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1748:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1749:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXACKPREPARE);
 3862              		.loc 1 1749 0
 3863 1a66 4FF03600 		mov	r0, #54
 3864 1a6a FFF7FEFF 		bl	changeState
1750:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1751:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // get a buffer to put the ack to send in
1752:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend = openqueue_getFreePacketBuffer(COMPONENT_IEEE802154E);
 3865              		.loc 1 1752 0
 3866 1a6e 4FF00900 		mov	r0, #9
 3867 1a72 FFF7FEFF 		bl	openqueue_getFreePacketBuffer
 3868 1a76 0246     		mov	r2, r0
 3869 1a78 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3870 1a7c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3871 1a80 DA61     		str	r2, [r3, #28]
1753:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.ackToSend==NULL) {
 3872              		.loc 1 1753 0
 3873 1a82 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3874 1a86 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3875 1a8a DB69     		ldr	r3, [r3, #28]
 3876 1a8c 002B     		cmp	r3, #0
 3877 1a8e 1DD1     		bne	.L186
1754:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // log the error
1755:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openserial_printError(COMPONENT_IEEE802154E,ERR_NO_FREE_PACKET_BUFFER, (errorparameter_t)0, (
 3878              		.loc 1 1755 0
 3879 1a90 4FF00900 		mov	r0, #9
 3880 1a94 4FF02C01 		mov	r1, #44
 3881 1a98 4FF00002 		mov	r2, #0
 3882 1a9c 4FF00003 		mov	r3, #0
 3883 1aa0 FFF7FEFF 		bl	openserial_printError
1756:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // indicate we received a packet anyway (we don't want to loose any)
1757:openstack/02a-MAClow/IEEE802154Ecsl.c ****       notif_receive(ieee154e_vars.dataReceived,2);
 3884              		.loc 1 1757 0
 3885 1aa4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3886 1aa8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3887 1aac 9B69     		ldr	r3, [r3, #24]
 3888 1aae 1846     		mov	r0, r3
 3889 1ab0 4FF00201 		mov	r1, #2
 3890 1ab4 FFF7FEFF 		bl	notif_receive
1758:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // free local variable
1759:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataReceived = NULL;
 3891              		.loc 1 1759 0
 3892 1ab8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3893 1abc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3894 1ac0 4FF00002 		mov	r2, #0
 3895 1ac4 9A61     		str	r2, [r3, #24]
1760:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // abort
1761:openstack/02a-MAClow/IEEE802154Ecsl.c ****       endOps();
 3896              		.loc 1 1761 0
 3897 1ac6 FFF7FEFF 		bl	endOps
 3898 1aca D3E0     		b	.L185
 3899              	.L186:
1762:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return;
1763:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
1764:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1765:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // declare ownership over that packet
1766:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend->creator = COMPONENT_IEEE802154E;
 3900              		.loc 1 1766 0
 3901 1acc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3902 1ad0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3903 1ad4 DB69     		ldr	r3, [r3, #28]
 3904 1ad6 4FF00902 		mov	r2, #9
 3905 1ada 1A70     		strb	r2, [r3, #0]
1767:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend->owner   = COMPONENT_IEEE802154E;
 3906              		.loc 1 1767 0
 3907 1adc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3908 1ae0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3909 1ae4 DB69     		ldr	r3, [r3, #28]
 3910 1ae6 4FF00902 		mov	r2, #9
 3911 1aea 5A70     		strb	r2, [r3, #1]
1768:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1769:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // calculate the time timeCorrection (this is the time when the packet arrive w.r.t the time it 
1770:openstack/02a-MAClow/IEEE802154Ecsl.c ****    timeCorrection = (PORT_SIGNED_INT_WIDTH)((PORT_SIGNED_INT_WIDTH)ieee154e_vars.syncCapturedTime-(
 3912              		.loc 1 1770 0
 3913 1aec 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3914 1af0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3915 1af4 9B6A     		ldr	r3, [r3, #40]
 3916 1af6 A3F18303 		sub	r3, r3, #131
 3917 1afa 7B60     		str	r3, [r7, #4]
1771:openstack/02a-MAClow/IEEE802154Ecsl.c ****     
1772:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // add the payload to the ACK (i.e. the timeCorrection)
1773:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packetfunctions_reserveHeaderSize(ieee154e_vars.ackToSend,sizeof(timecorrection_IE_ht));
 3918              		.loc 1 1773 0
 3919 1afc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3920 1b00 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3921 1b04 DB69     		ldr	r3, [r3, #28]
 3922 1b06 1846     		mov	r0, r3
 3923 1b08 4FF00201 		mov	r1, #2
 3924 1b0c FFF7FEFF 		bl	packetfunctions_reserveHeaderSize
1774:openstack/02a-MAClow/IEEE802154Ecsl.c ****    timeCorrection  = -timeCorrection;
 3925              		.loc 1 1774 0
 3926 1b10 7B68     		ldr	r3, [r7, #4]
 3927 1b12 C3F10003 		rsb	r3, r3, #0
 3928 1b16 7B60     		str	r3, [r7, #4]
1775:openstack/02a-MAClow/IEEE802154Ecsl.c ****    timeCorrection *= US_PER_TICK;
 3929              		.loc 1 1775 0
 3930 1b18 7A68     		ldr	r2, [r7, #4]
 3931 1b1a 1346     		mov	r3, r2
 3932 1b1c 4FEA0313 		lsl	r3, r3, #4
 3933 1b20 9B1A     		subs	r3, r3, r2
 3934 1b22 4FEA4303 		lsl	r3, r3, #1
 3935 1b26 7B60     		str	r3, [r7, #4]
1776:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend->payload[0] = (uint8_t)((((uint16_t)timeCorrection)   ) & 0xff);
 3936              		.loc 1 1776 0
 3937 1b28 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3938 1b2c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3939 1b30 DB69     		ldr	r3, [r3, #28]
 3940 1b32 5B68     		ldr	r3, [r3, #4]
 3941 1b34 7A68     		ldr	r2, [r7, #4]
 3942 1b36 D2B2     		uxtb	r2, r2
 3943 1b38 1A70     		strb	r2, [r3, #0]
1777:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend->payload[1] = (uint8_t)((((uint16_t)timeCorrection)>>8) & 0xff);
 3944              		.loc 1 1777 0
 3945 1b3a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3946 1b3e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3947 1b42 DB69     		ldr	r3, [r3, #28]
 3948 1b44 5B68     		ldr	r3, [r3, #4]
 3949 1b46 03F10103 		add	r3, r3, #1
 3950 1b4a 7A68     		ldr	r2, [r7, #4]
 3951 1b4c 92B2     		uxth	r2, r2
 3952 1b4e 4FEA1222 		lsr	r2, r2, #8
 3953 1b52 92B2     		uxth	r2, r2
 3954 1b54 D2B2     		uxtb	r2, r2
 3955 1b56 1A70     		strb	r2, [r3, #0]
1778:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1779:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // add header IE header -- xv poipoi -- pkt is filled in reverse order..
1780:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packetfunctions_reserveHeaderSize(ieee154e_vars.ackToSend,sizeof(header_IE_ht));
 3956              		.loc 1 1780 0
 3957 1b58 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3958 1b5c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3959 1b60 DB69     		ldr	r3, [r3, #28]
 3960 1b62 1846     		mov	r0, r3
 3961 1b64 4FF00201 		mov	r1, #2
 3962 1b68 FFF7FEFF 		bl	packetfunctions_reserveHeaderSize
1781:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //create the header for ack IE
1782:openstack/02a-MAClow/IEEE802154Ecsl.c ****    header_desc.length_elementid_type=(sizeof(timecorrection_IE_ht)<< IEEE802154E_DESC_LEN_HEADER_IE
 3963              		.loc 1 1782 0
 3964 1b6c 40F23C43 		movw	r3, #1084
 3965 1b70 3B80     		strh	r3, [r7, #0]	@ movhi
1783:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                      (IEEE802154E_ACK_NACK_TIMECORRECTION_ELEMENTID << IEEE802154E_
1784:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                      IEEE802154E_DESC_TYPE_SHORT; 
1785:openstack/02a-MAClow/IEEE802154Ecsl.c ****    memcpy(ieee154e_vars.ackToSend->payload,&header_desc,sizeof(header_IE_ht));
 3966              		.loc 1 1785 0
 3967 1b72 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3968 1b76 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3969 1b7a DB69     		ldr	r3, [r3, #28]
 3970 1b7c 5B68     		ldr	r3, [r3, #4]
 3971 1b7e 3A46     		mov	r2, r7
 3972 1b80 1288     		ldrh	r2, [r2, #0]	@ unaligned
 3973 1b82 1A80     		strh	r2, [r3, #0]	@ unaligned
1786:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1787:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // prepend the IEEE802.15.4 header to the ACK
1788:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend->l2_frameType = IEEE154_TYPE_ACK;
 3974              		.loc 1 1788 0
 3975 1b84 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3976 1b88 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3977 1b8c DB69     		ldr	r3, [r3, #28]
 3978 1b8e 4FF00202 		mov	r2, #2
 3979 1b92 83F84920 		strb	r2, [r3, #73]
1789:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend->l2_dsn       = ieee154e_vars.dataReceived->l2_dsn;
 3980              		.loc 1 1789 0
 3981 1b96 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3982 1b9a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3983 1b9e DA69     		ldr	r2, [r3, #28]
 3984 1ba0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3985 1ba4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3986 1ba8 9B69     		ldr	r3, [r3, #24]
 3987 1baa 93F84A30 		ldrb	r3, [r3, #74]	@ zero_extendqisi2
 3988 1bae 82F84A30 		strb	r3, [r2, #74]
1790:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802154_prependHeader(ieee154e_vars.ackToSend,
 3989              		.loc 1 1790 0
 3990 1bb2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3991 1bb6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3992 1bba D969     		ldr	r1, [r3, #28]
1791:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             ieee154e_vars.ackToSend->l2_frameType,
 3993              		.loc 1 1791 0
 3994 1bbc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3995 1bc0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3996 1bc4 DB69     		ldr	r3, [r3, #28]
1790:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802154_prependHeader(ieee154e_vars.ackToSend,
 3997              		.loc 1 1790 0
 3998 1bc6 93F84920 		ldrb	r2, [r3, #73]	@ zero_extendqisi2
1792:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             IEEE154_IELIST_YES,//ie in ack
1793:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             IEEE154_FRAMEVERSION,//enhanced ack
1794:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             IEEE154_SEC_NO_SECURITY,
1795:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             ieee154e_vars.dataReceived->l2_dsn,
 3999              		.loc 1 1795 0
 4000 1bca 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4001 1bce C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4002 1bd2 9B69     		ldr	r3, [r3, #24]
1790:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802154_prependHeader(ieee154e_vars.ackToSend,
 4003              		.loc 1 1790 0
 4004 1bd4 93F84A00 		ldrb	r0, [r3, #74]	@ zero_extendqisi2
1796:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             &(ieee154e_vars.dataReceived->l2_nextORpreviousHop)
 4005              		.loc 1 1796 0
 4006 1bd8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4007 1bdc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4008 1be0 9B69     		ldr	r3, [r3, #24]
1790:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802154_prependHeader(ieee154e_vars.ackToSend,
 4009              		.loc 1 1790 0
 4010 1be2 03F13803 		add	r3, r3, #56
 4011 1be6 4FF00004 		mov	r4, #0
 4012 1bea 0094     		str	r4, [sp, #0]
 4013 1bec 0190     		str	r0, [sp, #4]
 4014 1bee 0293     		str	r3, [sp, #8]
 4015 1bf0 0846     		mov	r0, r1
 4016 1bf2 1146     		mov	r1, r2
 4017 1bf4 4FF00102 		mov	r2, #1
 4018 1bf8 4FF00203 		mov	r3, #2
 4019 1bfc FFF7FEFF 		bl	ieee802154_prependHeader
1797:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             );
1798:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1799:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // space for 2-byte CRC
1800:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packetfunctions_reserveFooterSize(ieee154e_vars.ackToSend,2);
 4020              		.loc 1 1800 0
 4021 1c00 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4022 1c04 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4023 1c08 DB69     		ldr	r3, [r3, #28]
 4024 1c0a 1846     		mov	r0, r3
 4025 1c0c 4FF00201 		mov	r1, #2
 4026 1c10 FFF7FEFF 		bl	packetfunctions_reserveFooterSize
1801:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1802:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // load the packet in the radio's Tx buffer
1803:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_loadPacket(ieee154e_vars.ackToSend->payload,
 4027              		.loc 1 1803 0
 4028 1c14 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4029 1c18 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4030 1c1c DB69     		ldr	r3, [r3, #28]
 4031 1c1e 5A68     		ldr	r2, [r3, #4]
1804:openstack/02a-MAClow/IEEE802154Ecsl.c ****                     ieee154e_vars.ackToSend->length);
 4032              		.loc 1 1804 0
 4033 1c20 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4034 1c24 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4035 1c28 DB69     		ldr	r3, [r3, #28]
1803:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_loadPacket(ieee154e_vars.ackToSend->payload,
 4036              		.loc 1 1803 0
 4037 1c2a 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4038 1c2c 1046     		mov	r0, r2
 4039 1c2e 1946     		mov	r1, r3
 4040 1c30 FFF7FEFF 		bl	radio_loadPacket
1805:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1806:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // enable the radio in Tx mode. This does not send that packet.
1807:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_txEnable();
 4041              		.loc 1 1807 0
 4042 1c34 FFF7FEFF 		bl	radio_txEnable
1808:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnInit=radio_getTimerValue();
 4043              		.loc 1 1808 0
 4044 1c38 FFF7FEFF 		bl	radio_getTimerValue
 4045 1c3c 0246     		mov	r2, r0
 4046 1c3e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4047 1c42 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4048 1c46 1A63     		str	r2, [r3, #48]
1809:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnThisSlot=TRUE;
 4049              		.loc 1 1809 0
 4050 1c48 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4051 1c4c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4052 1c50 4FF00102 		mov	r2, #1
 4053 1c54 83F83820 		strb	r2, [r3, #56]
1810:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt6
1811:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt6);
 4054              		.loc 1 1811 0
 4055 1c58 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4056 1c5c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4057 1c60 5B6A     		ldr	r3, [r3, #36]
 4058 1c62 03F19003 		add	r3, r3, #144
 4059 1c66 1846     		mov	r0, r3
 4060 1c68 FFF7FEFF 		bl	radiotimer_schedule
1812:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1813:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1814:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXACKREADY);
 4061              		.loc 1 1814 0
 4062 1c6c 4FF03700 		mov	r0, #55
 4063 1c70 FFF7FEFF 		bl	changeState
 4064              	.L185:
1815:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4065              		.loc 1 1815 0
 4066 1c74 07F10C07 		add	r7, r7, #12
 4067 1c78 BD46     		mov	sp, r7
 4068 1c7a 90BD     		pop	{r4, r7, pc}
 4069              		.cfi_endproc
 4070              	.LFE45:
 4072              		.align	2
 4073              		.global	activity_csl_data_rie4
 4074              		.thumb
 4075              		.thumb_func
 4077              	activity_csl_data_rie4:
 4078              	.LFB46:
1816:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1817:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1818:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data rie4].
1819:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1820:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1821:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The functionality is to prepare the radio for ACK sending.
1822:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1823:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_rie4() {
 4079              		.loc 1 1823 0
 4080              		.cfi_startproc
 4081              		@ args = 0, pretend = 0, frame = 0
 4082              		@ frame_needed = 1, uses_anonymous_args = 0
 4083 1c7c 80B5     		push	{r7, lr}
 4084              	.LCFI108:
 4085              		.cfi_def_cfa_offset 8
 4086              		.cfi_offset 7, -8
 4087              		.cfi_offset 14, -4
 4088 1c7e 00AF     		add	r7, sp, #0
 4089              	.LCFI109:
 4090              		.cfi_def_cfa_register 7
1824:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
1825:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXACKPREPARE_OVERFLOWS,
1826:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		                 (errorparameter_t)ieee154e_vars.state,
 4091              		.loc 1 1826 0
 4092 1c80 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4093 1c84 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4094 1c88 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1825:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXACKPREPARE_OVERFLOWS,
 4095              		.loc 1 1825 0
 4096 1c8a 1A46     		mov	r2, r3
1827:openstack/02a-MAClow/IEEE802154Ecsl.c **** 						 (errorparameter_t)ieee154e_dbg.num_cslSamples);
 4097              		.loc 1 1827 0
 4098 1c8c 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 4099 1c90 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 4100 1c94 1B69     		ldr	r3, [r3, #16]
1825:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXACKPREPARE_OVERFLOWS,
 4101              		.loc 1 1825 0
 4102 1c96 9BB2     		uxth	r3, r3
 4103 1c98 4FF00900 		mov	r0, #9
 4104 1c9c 4FF02501 		mov	r1, #37
 4105 1ca0 FFF7FEFF 		bl	openserial_printError
1828:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1829:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1830:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 4106              		.loc 1 1830 0
 4107 1ca4 FFF7FEFF 		bl	endOps
1831:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4108              		.loc 1 1831 0
 4109 1ca8 80BD     		pop	{r7, pc}
 4110              		.cfi_endproc
 4111              	.LFE46:
 4113 1caa 00BF     		.align	2
 4114              		.global	activity_csl_data_ri7
 4115              		.thumb
 4116              		.thumb_func
 4118              	activity_csl_data_ri7:
 4119              	.LFB47:
1832:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1833:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1834:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri7].
1835:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1836:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1837:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The radio is configured and this interrupt gives it the "go" signal to start listening.
1838:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1839:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri7() {
 4120              		.loc 1 1839 0
 4121              		.cfi_startproc
 4122              		@ args = 0, pretend = 0, frame = 0
 4123              		@ frame_needed = 1, uses_anonymous_args = 0
 4124 1cac 80B5     		push	{r7, lr}
 4125              	.LCFI110:
 4126              		.cfi_def_cfa_offset 8
 4127              		.cfi_offset 7, -8
 4128              		.cfi_offset 14, -4
 4129 1cae 00AF     		add	r7, sp, #0
 4130              	.LCFI111:
 4131              		.cfi_def_cfa_register 7
1840:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1841:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXACKDELAY);
 4132              		.loc 1 1841 0
 4133 1cb0 4FF03800 		mov	r0, #56
 4134 1cb4 FFF7FEFF 		bl	changeState
1842:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1843:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt7
1844:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt7);
 4135              		.loc 1 1844 0
 4136 1cb8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4137 1cbc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4138 1cc0 5B6A     		ldr	r3, [r3, #36]
 4139 1cc2 03F1B103 		add	r3, r3, #177
 4140 1cc6 1846     		mov	r0, r3
 4141 1cc8 FFF7FEFF 		bl	radiotimer_schedule
1845:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1846:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // give the 'go' to transmit
1847:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_txNow(); 
 4142              		.loc 1 1847 0
 4143 1ccc FFF7FEFF 		bl	radio_txNow
1848:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4144              		.loc 1 1848 0
 4145 1cd0 80BD     		pop	{r7, pc}
 4146              		.cfi_endproc
 4147              	.LFE47:
 4149 1cd2 00BF     		.align	2
 4150              		.global	activity_csl_data_rie5
 4151              		.thumb
 4152              		.thumb_func
 4154              	activity_csl_data_rie5:
 4155              	.LFB48:
1849:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1850:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1851:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data rie5].
1852:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1853:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1854:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The functionality is to prepare the radio for ACK sending.
1855:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1856:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_rie5() {
 4156              		.loc 1 1856 0
 4157              		.cfi_startproc
 4158              		@ args = 0, pretend = 0, frame = 0
 4159              		@ frame_needed = 1, uses_anonymous_args = 0
 4160 1cd4 80B5     		push	{r7, lr}
 4161              	.LCFI112:
 4162              		.cfi_def_cfa_offset 8
 4163              		.cfi_offset 7, -8
 4164              		.cfi_offset 14, -4
 4165 1cd6 00AF     		add	r7, sp, #0
 4166              	.LCFI113:
 4167              		.cfi_def_cfa_register 7
1857:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
1858:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIOTX_OVERFLOWS,
1859:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state,
 4168              		.loc 1 1859 0
 4169 1cd8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4170 1cdc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4171 1ce0 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1858:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIOTX_OVERFLOWS,
 4172              		.loc 1 1858 0
 4173 1ce2 1A46     		mov	r2, r3
1860:openstack/02a-MAClow/IEEE802154Ecsl.c **** 						 (errorparameter_t)ieee154e_dbg.num_cslSamples);
 4174              		.loc 1 1860 0
 4175 1ce4 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 4176 1ce8 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 4177 1cec 1B69     		ldr	r3, [r3, #16]
1858:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIOTX_OVERFLOWS,
 4178              		.loc 1 1858 0
 4179 1cee 9BB2     		uxth	r3, r3
 4180 1cf0 4FF00900 		mov	r0, #9
 4181 1cf4 4FF02801 		mov	r1, #40
 4182 1cf8 FFF7FEFF 		bl	openserial_printError
1861:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1862:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 4183              		.loc 1 1862 0
 4184 1cfc FFF7FEFF 		bl	endOps
1863:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4185              		.loc 1 1863 0
 4186 1d00 80BD     		pop	{r7, pc}
 4187              		.cfi_endproc
 4188              	.LFE48:
 4190 1d02 00BF     		.align	2
 4191              		.global	activity_csl_data_ri8
 4192              		.thumb
 4193              		.thumb_func
 4195              	activity_csl_data_ri8:
 4196              	.LFB49:
1864:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1865:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1866:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri8].
1867:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1868:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_startOfFrame" function when a start of frame ev
1869:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change the state to set transmission, cancel #rt7 and arm #rt8 (max time 
1870:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1871:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri8(PORT_RADIOTIMER_WIDTH capturedTime) {
 4197              		.loc 1 1871 0
 4198              		.cfi_startproc
 4199              		@ args = 0, pretend = 0, frame = 8
 4200              		@ frame_needed = 1, uses_anonymous_args = 0
 4201 1d04 80B5     		push	{r7, lr}
 4202              	.LCFI114:
 4203              		.cfi_def_cfa_offset 8
 4204              		.cfi_offset 7, -8
 4205              		.cfi_offset 14, -4
 4206 1d06 82B0     		sub	sp, sp, #8
 4207              	.LCFI115:
 4208              		.cfi_def_cfa_offset 16
 4209 1d08 00AF     		add	r7, sp, #0
 4210              	.LCFI116:
 4211              		.cfi_def_cfa_register 7
 4212 1d0a 7860     		str	r0, [r7, #4]
1872:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1873:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXACK);
 4213              		.loc 1 1873 0
 4214 1d0c 4FF03900 		mov	r0, #57
 4215 1d10 FFF7FEFF 		bl	changeState
1874:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1875:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel rt7
1876:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 4216              		.loc 1 1876 0
 4217 1d14 FFF7FEFF 		bl	radiotimer_cancel
1877:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1878:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
1879:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.lastCapturedTime = capturedTime;
 4218              		.loc 1 1879 0
 4219 1d18 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4220 1d1c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4221 1d20 7A68     		ldr	r2, [r7, #4]
 4222 1d22 5A62     		str	r2, [r3, #36]
1880:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1881:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt8
1882:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt8);
 4223              		.loc 1 1882 0
 4224 1d24 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4225 1d28 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4226 1d2c 5B6A     		ldr	r3, [r3, #36]
 4227 1d2e 03F16203 		add	r3, r3, #98
 4228 1d32 1846     		mov	r0, r3
 4229 1d34 FFF7FEFF 		bl	radiotimer_schedule
1883:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4230              		.loc 1 1883 0
 4231 1d38 07F10807 		add	r7, r7, #8
 4232 1d3c BD46     		mov	sp, r7
 4233 1d3e 80BD     		pop	{r7, pc}
 4234              		.cfi_endproc
 4235              	.LFE49:
 4237              		.align	2
 4238              		.global	activity_csl_data_rie6
 4239              		.thumb
 4240              		.thumb_func
 4242              	activity_csl_data_rie6:
 4243              	.LFB50:
1884:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1885:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1886:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data rie6].
1887:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1888:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1889:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to register an error when timer for sent ACK has expired.
1890:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1891:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_rie6() {
 4244              		.loc 1 1891 0
 4245              		.cfi_startproc
 4246              		@ args = 0, pretend = 0, frame = 0
 4247              		@ frame_needed = 1, uses_anonymous_args = 0
 4248 1d40 80B5     		push	{r7, lr}
 4249              	.LCFI117:
 4250              		.cfi_def_cfa_offset 8
 4251              		.cfi_offset 7, -8
 4252              		.cfi_offset 14, -4
 4253 1d42 00AF     		add	r7, sp, #0
 4254              	.LCFI118:
 4255              		.cfi_def_cfa_register 7
1892:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
1893:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDACKDURATION_OVERFLOWS,
1894:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state,
 4256              		.loc 1 1894 0
 4257 1d44 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4258 1d48 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4259 1d4c 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1893:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDACKDURATION_OVERFLOWS,
 4260              		.loc 1 1893 0
 4261 1d4e 1A46     		mov	r2, r3
1895:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_dbg.num_cslSamples);
 4262              		.loc 1 1895 0
 4263 1d50 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 4264 1d54 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 4265 1d58 1B69     		ldr	r3, [r3, #16]
1893:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDACKDURATION_OVERFLOWS,
 4266              		.loc 1 1893 0
 4267 1d5a 9BB2     		uxth	r3, r3
 4268 1d5c 4FF00900 		mov	r0, #9
 4269 1d60 4FF02901 		mov	r1, #41
 4270 1d64 FFF7FEFF 		bl	openserial_printError
1896:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1897:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 4271              		.loc 1 1897 0
 4272 1d68 FFF7FEFF 		bl	endOps
1898:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4273              		.loc 1 1898 0
 4274 1d6c 80BD     		pop	{r7, pc}
 4275              		.cfi_endproc
 4276              	.LFE50:
 4278 1d6e 00BF     		.align	2
 4279              		.global	activity_csl_data_ri9
 4280              		.thumb
 4281              		.thumb_func
 4283              	activity_csl_data_ri9:
 4284              	.LFB51:
1899:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1900:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1901:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri9].
1902:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1903:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_endOfFrame" function when a end of frame event 
1904:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change the state, cancel #rt8, free ack packet and notify upper layer.
1905:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1906:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri9(PORT_RADIOTIMER_WIDTH capturedTime) {
 4285              		.loc 1 1906 0
 4286              		.cfi_startproc
 4287              		@ args = 0, pretend = 0, frame = 8
 4288              		@ frame_needed = 1, uses_anonymous_args = 0
 4289 1d70 80B5     		push	{r7, lr}
 4290              	.LCFI119:
 4291              		.cfi_def_cfa_offset 8
 4292              		.cfi_offset 7, -8
 4293              		.cfi_offset 14, -4
 4294 1d72 82B0     		sub	sp, sp, #8
 4295              	.LCFI120:
 4296              		.cfi_def_cfa_offset 16
 4297 1d74 00AF     		add	r7, sp, #0
 4298              	.LCFI121:
 4299              		.cfi_def_cfa_register 7
 4300 1d76 7860     		str	r0, [r7, #4]
1907:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1908:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXPROC);
 4301              		.loc 1 1908 0
 4302 1d78 4FF03A00 		mov	r0, #58
 4303 1d7c FFF7FEFF 		bl	changeState
1909:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1910:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel rt8
1911:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 4304              		.loc 1 1911 0
 4305 1d80 FFF7FEFF 		bl	radiotimer_cancel
1912:openstack/02a-MAClow/IEEE802154Ecsl.c ****   
1913:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
1914:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.lastCapturedTime = capturedTime;
 4306              		.loc 1 1914 0
 4307 1d84 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4308 1d88 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4309 1d8c 7A68     		ldr	r2, [r7, #4]
 4310 1d8e 5A62     		str	r2, [r3, #36]
1915:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1916:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // free the ack we just sent so corresponding RAM memory can be recycled
1917:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openqueue_freePacketBuffer(ieee154e_vars.ackToSend);
 4311              		.loc 1 1917 0
 4312 1d90 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4313 1d94 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4314 1d98 DB69     		ldr	r3, [r3, #28]
 4315 1d9a 1846     		mov	r0, r3
 4316 1d9c FFF7FEFF 		bl	openqueue_freePacketBuffer
1918:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1919:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clear local variable
1920:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend = NULL;
 4317              		.loc 1 1920 0
 4318 1da0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4319 1da4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4320 1da8 4FF00002 		mov	r2, #0
 4321 1dac DA61     		str	r2, [r3, #28]
1921:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1922:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // synchronize to the received packet
1923:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //if (idmanager_getIsDAGroot()==FALSE && neighbors_isPreferredParent(&(ieee154e_vars.dataReceive
1924:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   synchronizePacket(ieee154e_vars.syncCapturedTime);
1925:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //}
1926:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1927:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // inform upper layer of reception (after ACK sent)
1928:openstack/02a-MAClow/IEEE802154Ecsl.c ****    notif_receive(ieee154e_vars.dataReceived,3);
 4322              		.loc 1 1928 0
 4323 1dae 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4324 1db2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4325 1db6 9B69     		ldr	r3, [r3, #24]
 4326 1db8 1846     		mov	r0, r3
 4327 1dba 4FF00301 		mov	r1, #3
 4328 1dbe FFF7FEFF 		bl	notif_receive
1929:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1930:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clear local variable
1931:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.dataReceived = NULL;
 4329              		.loc 1 1931 0
 4330 1dc2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4331 1dc6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4332 1dca 4FF00002 		mov	r2, #0
 4333 1dce 9A61     		str	r2, [r3, #24]
1932:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1933:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // official end of Rx slot
1934:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 4334              		.loc 1 1934 0
 4335 1dd0 FFF7FEFF 		bl	endOps
1935:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4336              		.loc 1 1935 0
 4337 1dd4 07F10807 		add	r7, r7, #8
 4338 1dd8 BD46     		mov	sp, r7
 4339 1dda 80BD     		pop	{r7, pc}
 4340              		.cfi_endproc
 4341              	.LFE51:
 4343              		.align	2
 4344              		.global	ieee802154_createWakeUpFrame
 4345              		.thumb
 4346              		.thumb_func
 4348              	ieee802154_createWakeUpFrame:
 4349              	.LFB52:
1936:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1937:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1938:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
1939:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================= WAKE-UP FRAMES ===============================
1940:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
1941:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1942:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1943:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Prepend the IEEE802.15.4 MAC Wake-Up header to a (to be transmitted) packet.
1944:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1945:openstack/02a-MAClow/IEEE802154Ecsl.c **** Note that we are writing the field from the end of the header to the beginning.
1946:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1947:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in,out] msg              The message to append the header to.
1948:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in]     sequenceNumber   Sequence number of this frame.
1949:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in]     nextHop          Address of the next hop
1950:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in]     rztime           Rendezvoud time
1951:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1952:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1953:openstack/02a-MAClow/IEEE802154Ecsl.c **** void ieee802154_createWakeUpFrame(OpenQueueEntry_t*		msg,
1954:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                   uint8_t           	sequenceNumber,
1955:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                   open_addr_t*        	nextHop,
1956:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							      uint16_t				rztime) {
 4350              		.loc 1 1956 0
 4351              		.cfi_startproc
 4352              		@ args = 0, pretend = 0, frame = 40
 4353              		@ frame_needed = 1, uses_anonymous_args = 0
 4354 1ddc 80B5     		push	{r7, lr}
 4355              	.LCFI122:
 4356              		.cfi_def_cfa_offset 8
 4357              		.cfi_offset 7, -8
 4358              		.cfi_offset 14, -4
 4359 1dde 8AB0     		sub	sp, sp, #40
 4360              	.LCFI123:
 4361              		.cfi_def_cfa_offset 48
 4362 1de0 00AF     		add	r7, sp, #0
 4363              	.LCFI124:
 4364              		.cfi_def_cfa_register 7
 4365 1de2 F860     		str	r0, [r7, #12]
 4366 1de4 7A60     		str	r2, [r7, #4]
 4367 1de6 0A46     		mov	r2, r1
 4368 1de8 FA72     		strb	r2, [r7, #11]
 4369 1dea 3B81     		strh	r3, [r7, #8]	@ movhi
1957:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1958:openstack/02a-MAClow/IEEE802154Ecsl.c ****     open_addr_t	nextHop16b;
1959:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1960:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// La estructura de una trama Wake-Up es la siguiente:
1961:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//
1962:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   - FRAME CONTROL: 1 byte
1963:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   - SEQ NUMBER (macDSN): 1 byte
1964:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   - PAN ID: 2 bytes
1965:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   - DEST ADDR: 2 bytes
1966:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   - RZ TIME IE: 2 bytes
1967:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   - IE LIST TERMINATOR: 2 bytes
1968:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//
1969:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//  | FRAME   |  SEQ   | PAN | DEST | RZ TIME  | IE LIST    |
1970:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//  | CONTROL | NUMBER |  ID | ADDR |  HDR IE  | TERMINATOR |
1971:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//
1972:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1973:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// Empezamos a escribir el payload de la trama wake-up empezando del final hacia adelante.
1974:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1975:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// IE LIST TERMINATOR
1976:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	packetfunctions_reserveHeaderSize(msg,sizeof(uint8_t));
 4370              		.loc 1 1976 0
 4371 1dec F868     		ldr	r0, [r7, #12]
 4372 1dee 4FF00101 		mov	r1, #1
 4373 1df2 FFF7FEFF 		bl	packetfunctions_reserveHeaderSize
1977:openstack/02a-MAClow/IEEE802154Ecsl.c ****  	*((uint8_t*)(msg->payload)) = 0x7e;
 4374              		.loc 1 1977 0
 4375 1df6 FB68     		ldr	r3, [r7, #12]
 4376 1df8 5B68     		ldr	r3, [r3, #4]
 4377 1dfa 4FF07E02 		mov	r2, #126
 4378 1dfe 1A70     		strb	r2, [r3, #0]
1978:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1979:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// RZ TIME IE, formado por 4 bytes con la siguiente estructura (0x0E82)
1980:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  - b0-b6 (Length) = 2
1981:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  - b7-b14 (Element ID) = 0x1D
1982:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  - b15 (Type) = 0
1983:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  - b16-b31 (IE Content) = time (2 bytes)
1984:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //
1985:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  b15 | b14 | b13 | b12 | b11 | b10 | b9 | b8 | b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 |
1986:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //   0  |  0  |  0  |  0  |  1  |  1  |  1 |  0 |  1 |  0 |  0 |  0 |  0 |  0 |  1 |  0 |
1987:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1988:openstack/02a-MAClow/IEEE802154Ecsl.c ****  	// rz time ie body (time)
1989:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	packetfunctions_reserveHeaderSize(msg,sizeof(uint16_t));
 4379              		.loc 1 1989 0
 4380 1e00 F868     		ldr	r0, [r7, #12]
 4381 1e02 4FF00201 		mov	r1, #2
 4382 1e06 FFF7FEFF 		bl	packetfunctions_reserveHeaderSize
1990:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	*((uint16_t*)(msg->payload)) = rztime;
 4383              		.loc 1 1990 0
 4384 1e0a FB68     		ldr	r3, [r7, #12]
 4385 1e0c 5B68     		ldr	r3, [r3, #4]
 4386 1e0e 3A89     		ldrh	r2, [r7, #8]	@ movhi
 4387 1e10 1A80     		strh	r2, [r3, #0]	@ movhi
1991:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1992:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// rz time ie header
1993:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	packetfunctions_reserveHeaderSize(msg,sizeof(uint16_t));
 4388              		.loc 1 1993 0
 4389 1e12 F868     		ldr	r0, [r7, #12]
 4390 1e14 4FF00201 		mov	r1, #2
 4391 1e18 FFF7FEFF 		bl	packetfunctions_reserveHeaderSize
1994:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	*((uint16_t*)(msg->payload)) = 0x0E82;
 4392              		.loc 1 1994 0
 4393 1e1c FB68     		ldr	r3, [r7, #12]
 4394 1e1e 5B68     		ldr	r3, [r3, #4]
 4395 1e20 40F68262 		movw	r2, #3714
 4396 1e24 1A80     		strh	r2, [r3, #0]	@ movhi
1995:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1996:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// DEST ADDR
1997:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	if (nextHop->type == ADDR_16B) {
 4397              		.loc 1 1997 0
 4398 1e26 7B68     		ldr	r3, [r7, #4]
 4399 1e28 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 4400 1e2a 012B     		cmp	r3, #1
 4401 1e2c 06D1     		bne	.L195
1998:openstack/02a-MAClow/IEEE802154Ecsl.c ****   	   packetfunctions_writeAddress(msg,nextHop,OW_LITTLE_ENDIAN);
 4402              		.loc 1 1998 0
 4403 1e2e F868     		ldr	r0, [r7, #12]
 4404 1e30 7968     		ldr	r1, [r7, #4]
 4405 1e32 4FF00102 		mov	r2, #1
 4406 1e36 FFF7FEFF 		bl	packetfunctions_writeAddress
 4407 1e3a 11E0     		b	.L196
 4408              	.L195:
1999:openstack/02a-MAClow/IEEE802154Ecsl.c ****     } else if (nextHop->type == ADDR_64B) {
 4409              		.loc 1 1999 0
 4410 1e3c 7B68     		ldr	r3, [r7, #4]
 4411 1e3e 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 4412 1e40 022B     		cmp	r3, #2
 4413 1e42 0DD1     		bne	.L196
2000:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   packetfunctions_mac64bToMac16b(nextHop, &nextHop16b);
 4414              		.loc 1 2000 0
 4415 1e44 07F11403 		add	r3, r7, #20
 4416 1e48 7868     		ldr	r0, [r7, #4]
 4417 1e4a 1946     		mov	r1, r3
 4418 1e4c FFF7FEFF 		bl	packetfunctions_mac64bToMac16b
2001:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   packetfunctions_writeAddress(msg,&nextHop16b,OW_LITTLE_ENDIAN);
 4419              		.loc 1 2001 0
 4420 1e50 07F11403 		add	r3, r7, #20
 4421 1e54 F868     		ldr	r0, [r7, #12]
 4422 1e56 1946     		mov	r1, r3
 4423 1e58 4FF00102 		mov	r2, #1
 4424 1e5c FFF7FEFF 		bl	packetfunctions_writeAddress
 4425              	.L196:
2002:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	}
2003:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// PAN ID
2004:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	packetfunctions_writeAddress(msg,idmanager_getMyID(ADDR_PANID),OW_LITTLE_ENDIAN);
 4426              		.loc 1 2004 0
 4427 1e60 4FF00400 		mov	r0, #4
 4428 1e64 FFF7FEFF 		bl	idmanager_getMyID
 4429 1e68 0346     		mov	r3, r0
 4430 1e6a F868     		ldr	r0, [r7, #12]
 4431 1e6c 1946     		mov	r1, r3
 4432 1e6e 4FF00102 		mov	r2, #1
 4433 1e72 FFF7FEFF 		bl	packetfunctions_writeAddress
2005:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2006:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// SEQ NUMBER
2007:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	packetfunctions_reserveHeaderSize(msg,sizeof(uint8_t));
 4434              		.loc 1 2007 0
 4435 1e76 F868     		ldr	r0, [r7, #12]
 4436 1e78 4FF00101 		mov	r1, #1
 4437 1e7c FFF7FEFF 		bl	packetfunctions_reserveHeaderSize
2008:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	*((uint8_t*)(msg->payload)) = sequenceNumber;
 4438              		.loc 1 2008 0
 4439 1e80 FB68     		ldr	r3, [r7, #12]
 4440 1e82 5B68     		ldr	r3, [r3, #4]
 4441 1e84 FA7A     		ldrb	r2, [r7, #11]
 4442 1e86 1A70     		strb	r2, [r3, #0]
2009:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2010:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// La estructura del FCF en la trama de wake-up es 0x55 = 01010101b:
2011:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// b0-b2 -- Frame Type (debe ser 101 para trama wake-up)
2012:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// b3 ----- Long Frame Control (debe ser 0 para indicar que se trata de un FCF de 1 byte como es e
2013:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// b4-b5 -- Dest Addr Mode (en este caso, short address por lo que tiene que valer 10).
2014:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// b6-b7 -- Src Addr Mode (en este caso, short address por lo que tiene que valer 10).
2015:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2016:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//  b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 |
2017:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   0 |  1 |  0 |  1 |  0 |  1 |  0 |  1 |
2018:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2019:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// FCF
2020:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	packetfunctions_reserveHeaderSize(msg,sizeof(uint8_t));
 4443              		.loc 1 2020 0
 4444 1e88 F868     		ldr	r0, [r7, #12]
 4445 1e8a 4FF00101 		mov	r1, #1
 4446 1e8e FFF7FEFF 		bl	packetfunctions_reserveHeaderSize
2021:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	*((uint8_t*)(msg->payload)) = 0x55;
 4447              		.loc 1 2021 0
 4448 1e92 FB68     		ldr	r3, [r7, #12]
 4449 1e94 5B68     		ldr	r3, [r3, #4]
 4450 1e96 4FF05502 		mov	r2, #85
 4451 1e9a 1A70     		strb	r2, [r3, #0]
2022:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2023:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4452              		.loc 1 2023 0
 4453 1e9c 07F12807 		add	r7, r7, #40
 4454 1ea0 BD46     		mov	sp, r7
 4455 1ea2 80BD     		pop	{r7, pc}
 4456              		.cfi_endproc
 4457              	.LFE52:
 4459              		.align	2
 4460              		.global	ieee802154_retrieveWakeUpFrame
 4461              		.thumb
 4462              		.thumb_func
 4464              	ieee802154_retrieveWakeUpFrame:
 4465              	.LFB53:
2024:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2025:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2026:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Retrieve the IEEE802.15.4 MAC Wake-Up Frame header from a (just received) packet.
2027:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2028:openstack/02a-MAClow/IEEE802154Ecsl.c **** Note We are writing the fields from the beginning of the header to the end.
2029:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2030:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in,out] msg            The message just received.
2031:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[out] ieee802514_header The internal header to write the data to.
2032:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[out] rztime  		  Rendezvous time to wait for data packet.
2033:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2034:openstack/02a-MAClow/IEEE802154Ecsl.c **** void ieee802154_retrieveWakeUpFrame(OpenQueueEntry_t*      msg,
2035:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                     ieee802154_header_iht* ieee802514_header,
2036:openstack/02a-MAClow/IEEE802154Ecsl.c **** 									uint16_t* rztime) {
 4466              		.loc 1 2036 0
 4467              		.cfi_startproc
 4468              		@ args = 0, pretend = 0, frame = 24
 4469              		@ frame_needed = 1, uses_anonymous_args = 0
 4470 1ea4 80B5     		push	{r7, lr}
 4471              	.LCFI125:
 4472              		.cfi_def_cfa_offset 8
 4473              		.cfi_offset 7, -8
 4474              		.cfi_offset 14, -4
 4475 1ea6 86B0     		sub	sp, sp, #24
 4476              	.LCFI126:
 4477              		.cfi_def_cfa_offset 32
 4478 1ea8 00AF     		add	r7, sp, #0
 4479              	.LCFI127:
 4480              		.cfi_def_cfa_register 7
 4481 1eaa F860     		str	r0, [r7, #12]
 4482 1eac B960     		str	r1, [r7, #8]
 4483 1eae 7A60     		str	r2, [r7, #4]
2037:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t temp_8b;
2038:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t src_addr_mode, dst_addr_mode;
2039:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint16_t temp_16b;
2040:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2041:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2042:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // La estructura de una trama Wake-Up es la siguiente
2043:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2044:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - FRAME CONTROL: 1 byte
2045:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - SEQ NUMBER (macDSN): 1 byte
2046:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - PAN ID: 2 bytes
2047:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - DEST ADDR: 2 bytes
2048:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - RZ TIME IE: 2 bytes
2049:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - IE LIST TERMINATOR: 2 bytes
2050:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2051:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  | FRAME   |  SEQ   | PAN | DEST | RZ TIME  | IE LIST    |
2052:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  | CONTROL | NUMBER |  ID | ADDR |  HDR IE  | TERMINATOR |
2053:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2054:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2055:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Por defecto, se asume que la cabecera no es válida en el caso de
2056:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abandonar la función al ser el paquete más corto que la cabecera.
2057:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->valid=FALSE;
 4484              		.loc 1 2057 0
 4485 1eb0 BB68     		ldr	r3, [r7, #8]
 4486 1eb2 4FF00002 		mov	r2, #0
 4487 1eb6 1A70     		strb	r2, [r3, #0]
2058:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength = 0;
 4488              		.loc 1 2058 0
 4489 1eb8 BB68     		ldr	r3, [r7, #8]
 4490 1eba 4FF00002 		mov	r2, #0
 4491 1ebe 5A70     		strb	r2, [r3, #1]
2059:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2060:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Validamos que hay datos que leer.
2061:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; }
 4492              		.loc 1 2061 0
 4493 1ec0 BB68     		ldr	r3, [r7, #8]
 4494 1ec2 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 4495 1ec4 FB68     		ldr	r3, [r7, #12]
 4496 1ec6 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4497 1ec8 9A42     		cmp	r2, r3
 4498 1eca 00F22081 		bhi	.L220
 4499              	.L198:
2062:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2063:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Frame Control Field (1 byte)
2064:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_8b = *((uint8_t*)(msg->payload)+ieee802514_header->headerLength);
 4500              		.loc 1 2064 0
 4501 1ece FB68     		ldr	r3, [r7, #12]
 4502 1ed0 5A68     		ldr	r2, [r3, #4]
 4503 1ed2 BB68     		ldr	r3, [r7, #8]
 4504 1ed4 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4505 1ed6 D318     		adds	r3, r2, r3
 4506 1ed8 1B78     		ldrb	r3, [r3, #0]
 4507 1eda FB75     		strb	r3, [r7, #23]
2065:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2066:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // La estructura del FCF en la trama de wake-up es 0x55 = 01010101b:
2067:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // b0-b2 -- Frame Type (debe ser 101 para trama wake-up)
2068:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // b3 ----- Long Frame Control (debe ser 0 para indicar que se trata de un FCF de 1 byte como es
2069:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // b4-b5 -- Dest Addr Mode (en este caso, short address por lo que tiene que valer 10).
2070:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // b6-b7 -- Src Addr Mode (en este caso, short address por lo que tiene que valer 10).
2071:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2072:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 |
2073:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   0 |  1 |  0 |  1 |  0 |  1 |  0 |  1 |
2074:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2075:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->frameType = (temp_8b >> IEEE154_FCF_FRAME_TYPE) & 0x07;//3b
 4508              		.loc 1 2075 0
 4509 1edc FB7D     		ldrb	r3, [r7, #23]
 4510 1ede 03F00703 		and	r3, r3, #7
 4511 1ee2 DAB2     		uxtb	r2, r3
 4512 1ee4 BB68     		ldr	r3, [r7, #8]
 4513 1ee6 9A70     		strb	r2, [r3, #2]
2076:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2077:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Comprobamos que efectivamente se trata de una trama de tipo MULTIPURPOSE.
2078:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->frameType != IEEE154_TYPE_MULTIPURPOSE) {return; }
 4514              		.loc 1 2078 0
 4515 1ee8 BB68     		ldr	r3, [r7, #8]
 4516 1eea 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 4517 1eec 052B     		cmp	r3, #5
 4518 1eee 40F01081 		bne	.L221
 4519              	.L200:
2079:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2080:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Verificamos que efectivamente el campo Long Frame Control tiene valor cero para indicar que e
2081:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_8b >> 3) & 0x01) { return; }
 4520              		.loc 1 2081 0
 4521 1ef2 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 4522 1ef4 4FEAD303 		lsr	r3, r3, #3
 4523 1ef8 DBB2     		uxtb	r3, r3
 4524 1efa 03F00103 		and	r3, r3, #1
 4525 1efe 002B     		cmp	r3, #0
 4526 1f00 40F00981 		bne	.L222
 4527              	.L201:
2082:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2083:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Recuperamos los Destination y Source Address Mode
2084:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2085:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Destination Address Mode
2086:openstack/02a-MAClow/IEEE802154Ecsl.c ****    dst_addr_mode = (temp_8b >> 4) & 0x03;
 4528              		.loc 1 2086 0
 4529 1f04 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 4530 1f06 4FEA1313 		lsr	r3, r3, #4
 4531 1f0a DBB2     		uxtb	r3, r3
 4532 1f0c 03F00303 		and	r3, r3, #3
 4533 1f10 BB75     		strb	r3, [r7, #22]
2087:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if(dst_addr_mode == 1) { // 01 en binario en bits b5-b4
 4534              		.loc 1 2087 0
 4535 1f12 BB7D     		ldrb	r3, [r7, #22]	@ zero_extendqisi2
 4536 1f14 012B     		cmp	r3, #1
 4537 1f16 0BD1     		bne	.L202
2088:openstack/02a-MAClow/IEEE802154Ecsl.c ****      // Debería ser siempre este caso en las tramas wake-up por lo que se trata como error cualqui
2089:openstack/02a-MAClow/IEEE802154Ecsl.c ****      ieee802514_header->dest.type = ADDR_16B;
 4538              		.loc 1 2089 0
 4539 1f18 BB68     		ldr	r3, [r7, #8]
 4540 1f1a 4FF00102 		mov	r2, #1
 4541 1f1e DA76     		strb	r2, [r3, #27]
2090:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2091:openstack/02a-MAClow/IEEE802154Ecsl.c ****    else {
2092:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	 openserial_printError(COMPONENT_IEEE802154,ERR_IEEE154_UNSUPPORTED, (errorparameter_t)1, (errorpa
2093:openstack/02a-MAClow/IEEE802154Ecsl.c ****      return; // this is an invalid packet, return
2094:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2095:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2096:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Source Address Mode
2097:openstack/02a-MAClow/IEEE802154Ecsl.c ****    src_addr_mode = (temp_8b >> 6) & 0x03;
 4542              		.loc 1 2097 0
 4543 1f20 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 4544 1f22 4FEA9313 		lsr	r3, r3, #6
 4545 1f26 7B75     		strb	r3, [r7, #21]
2098:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if(src_addr_mode == 1) { // 01 en binario en bits b7-b6
 4546              		.loc 1 2098 0
 4547 1f28 7B7D     		ldrb	r3, [r7, #21]	@ zero_extendqisi2
 4548 1f2a 012B     		cmp	r3, #1
 4549 1f2c 0BD0     		beq	.L203
 4550 1f2e 25E0     		b	.L218
 4551              	.L202:
2092:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	 openserial_printError(COMPONENT_IEEE802154,ERR_IEEE154_UNSUPPORTED, (errorparameter_t)1, (errorpa
 4552              		.loc 1 2092 0
 4553 1f30 BB7D     		ldrb	r3, [r7, #22]	@ zero_extendqisi2
 4554 1f32 9BB2     		uxth	r3, r3
 4555 1f34 4FF00800 		mov	r0, #8
 4556 1f38 4FF01901 		mov	r1, #25
 4557 1f3c 4FF00102 		mov	r2, #1
 4558 1f40 FFF7FEFF 		bl	openserial_printError
2093:openstack/02a-MAClow/IEEE802154Ecsl.c ****      return; // this is an invalid packet, return
 4559              		.loc 1 2093 0
 4560 1f44 00E1     		b	.L197
 4561              	.L203:
2099:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Debería ser siempre este caso en las tramas wake-up por lo que se trata como error cualqu
2100:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee802514_header->src.type = ADDR_16B;
 4562              		.loc 1 2100 0
 4563 1f46 BB68     		ldr	r3, [r7, #8]
 4564 1f48 4FF00102 		mov	r2, #1
 4565 1f4c 83F82C20 		strb	r2, [r3, #44]
2101:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2102:openstack/02a-MAClow/IEEE802154Ecsl.c ****    else {
2103:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printError(COMPONENT_IEEE802154,ERR_IEEE154_UNSUPPORTED, (errorparameter_t)2, (errorp
2104:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return; // this is an invalid packet, return
2105:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2106:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2107:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2108:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // En este punto ya hemos analizado el contenido del primer byte de la cabecera correspondiente 
2109:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2110:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2111:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // A partir de este punto, la estructura del paquete es la siguiente:
2112:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - SEQ NUMBER (macDSN): 1 byte
2113:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - PAN ID: 2 bytes
2114:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - DEST ADDR: 2 bytes
2115:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - RZ TIME IE: 2 bytes
2116:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - IE LIST TERMINATOR: 2 bytes
2117:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2118:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2119:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2120:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Avanzamos 1 byte en el procesamiento de la cabecera.
2121:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 1;
 4566              		.loc 1 2121 0
 4567 1f50 BB68     		ldr	r3, [r7, #8]
 4568 1f52 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4569 1f54 03F10103 		add	r3, r3, #1
 4570 1f58 DAB2     		uxtb	r2, r3
 4571 1f5a BB68     		ldr	r3, [r7, #8]
 4572 1f5c 5A70     		strb	r2, [r3, #1]
2122:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2123:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Posicionamos dentro del paquete para leer el resto de elementos.
2124:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_8b = *((uint8_t*)(msg->payload)+ieee802514_header->headerLength);
 4573              		.loc 1 2124 0
 4574 1f5e FB68     		ldr	r3, [r7, #12]
 4575 1f60 5A68     		ldr	r2, [r3, #4]
 4576 1f62 BB68     		ldr	r3, [r7, #8]
 4577 1f64 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4578 1f66 D318     		adds	r3, r2, r3
 4579 1f68 1B78     		ldrb	r3, [r3, #0]
 4580 1f6a FB75     		strb	r3, [r7, #23]
2125:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2126:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // 1.- SequenceNumber
2127:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4581              		.loc 1 2127 0
 4582 1f6c BB68     		ldr	r3, [r7, #8]
 4583 1f6e 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 4584 1f70 FB68     		ldr	r3, [r7, #12]
 4585 1f72 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4586 1f74 9A42     		cmp	r2, r3
 4587 1f76 00F2D080 		bhi	.L223
 4588 1f7a 0AE0     		b	.L219
 4589              	.L218:
2103:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printError(COMPONENT_IEEE802154,ERR_IEEE154_UNSUPPORTED, (errorparameter_t)2, (errorp
 4590              		.loc 1 2103 0
 4591 1f7c 7B7D     		ldrb	r3, [r7, #21]	@ zero_extendqisi2
 4592 1f7e 9BB2     		uxth	r3, r3
 4593 1f80 4FF00800 		mov	r0, #8
 4594 1f84 4FF01901 		mov	r1, #25
 4595 1f88 4FF00202 		mov	r2, #2
 4596 1f8c FFF7FEFF 		bl	openserial_printError
2104:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return; // this is an invalid packet, return
 4597              		.loc 1 2104 0
 4598 1f90 DAE0     		b	.L197
 4599              	.L219:
2128:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->dsn  = *((uint8_t*)(msg->payload)+ieee802514_header->headerLength);
 4600              		.loc 1 2128 0
 4601 1f92 FB68     		ldr	r3, [r7, #12]
 4602 1f94 5A68     		ldr	r2, [r3, #4]
 4603 1f96 BB68     		ldr	r3, [r7, #8]
 4604 1f98 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4605 1f9a D318     		adds	r3, r2, r3
 4606 1f9c 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 4607 1f9e BB68     		ldr	r3, [r7, #8]
 4608 1fa0 5A72     		strb	r2, [r3, #9]
2129:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 1;
 4609              		.loc 1 2129 0
 4610 1fa2 BB68     		ldr	r3, [r7, #8]
 4611 1fa4 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4612 1fa6 03F10103 		add	r3, r3, #1
 4613 1faa DAB2     		uxtb	r2, r3
 4614 1fac BB68     		ldr	r3, [r7, #8]
 4615 1fae 5A70     		strb	r2, [r3, #1]
2130:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2131:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // 2.- panID
2132:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4616              		.loc 1 2132 0
 4617 1fb0 BB68     		ldr	r3, [r7, #8]
 4618 1fb2 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 4619 1fb4 FB68     		ldr	r3, [r7, #12]
 4620 1fb6 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4621 1fb8 9A42     		cmp	r2, r3
 4622 1fba 00F2B080 		bhi	.L224
 4623              	.L207:
2133:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packetfunctions_readAddress(((uint8_t*)(msg->payload)+ieee802514_header->headerLength), ADDR_PAN
 4624              		.loc 1 2133 0
 4625 1fbe FB68     		ldr	r3, [r7, #12]
 4626 1fc0 5A68     		ldr	r2, [r3, #4]
 4627 1fc2 BB68     		ldr	r3, [r7, #8]
 4628 1fc4 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4629 1fc6 D218     		adds	r2, r2, r3
 4630 1fc8 BB68     		ldr	r3, [r7, #8]
 4631 1fca 03F10A03 		add	r3, r3, #10
 4632 1fce 1046     		mov	r0, r2
 4633 1fd0 4FF00401 		mov	r1, #4
 4634 1fd4 1A46     		mov	r2, r3
 4635 1fd6 4FF00103 		mov	r3, #1
 4636 1fda FFF7FEFF 		bl	packetfunctions_readAddress
2134:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 2;
 4637              		.loc 1 2134 0
 4638 1fde BB68     		ldr	r3, [r7, #8]
 4639 1fe0 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4640 1fe2 03F10203 		add	r3, r3, #2
 4641 1fe6 DAB2     		uxtb	r2, r3
 4642 1fe8 BB68     		ldr	r3, [r7, #8]
 4643 1fea 5A70     		strb	r2, [r3, #1]
2135:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2136:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // 3.- Dest Addr
2137:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4644              		.loc 1 2137 0
 4645 1fec BB68     		ldr	r3, [r7, #8]
 4646 1fee 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 4647 1ff0 FB68     		ldr	r3, [r7, #12]
 4648 1ff2 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4649 1ff4 9A42     		cmp	r2, r3
 4650 1ff6 00F29480 		bhi	.L225
 4651              	.L208:
2138:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2139:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // En este punto ya sabemos que el tipo de dirección tiene que ser ADDR_16B dado que cualquier 
2140:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // en la lectura del frame control field por lo que leemos los 2 bytes de la dirección del dest
2141:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packetfunctions_readAddress(((uint8_t*)(msg->payload)+ieee802514_header->headerLength), ADDR_16B
 4652              		.loc 1 2141 0
 4653 1ffa FB68     		ldr	r3, [r7, #12]
 4654 1ffc 5A68     		ldr	r2, [r3, #4]
 4655 1ffe BB68     		ldr	r3, [r7, #8]
 4656 2000 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4657 2002 D218     		adds	r2, r2, r3
 4658 2004 BB68     		ldr	r3, [r7, #8]
 4659 2006 03F11B03 		add	r3, r3, #27
 4660 200a 1046     		mov	r0, r2
 4661 200c 4FF00101 		mov	r1, #1
 4662 2010 1A46     		mov	r2, r3
 4663 2012 4FF00103 		mov	r3, #1
 4664 2016 FFF7FEFF 		bl	packetfunctions_readAddress
2142:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 2;
 4665              		.loc 1 2142 0
 4666 201a BB68     		ldr	r3, [r7, #8]
 4667 201c 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4668 201e 03F10203 		add	r3, r3, #2
 4669 2022 DAB2     		uxtb	r2, r3
 4670 2024 BB68     		ldr	r3, [r7, #8]
 4671 2026 5A70     		strb	r2, [r3, #1]
2143:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2144:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // 4.- RZ Time Header IE, formado por 4 bytes con la siguiente estructura (0x0E82)
2145:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  - b0-b6 (Length) = 2
2146:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  - b7-b14 (Element ID) = 0x1D
2147:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  - b15 (Type) = 0
2148:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  - b16-b31 (IE Content) = time (2 bytes)
2149:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2150:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  b15 | b14 | b13 | b12 | b11 | b10 | b9 | b8 | b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 |
2151:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   0  |  0  |  0  |  0  |  1  |  1  |  1 |  0 |  1 |  0 |  0 |  0 |  0 |  0 |  1 |  0 |
2152:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2153:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) {  return; } // no more to read!
 4672              		.loc 1 2153 0
 4673 2028 BB68     		ldr	r3, [r7, #8]
 4674 202a 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 4675 202c FB68     		ldr	r3, [r7, #12]
 4676 202e 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4677 2030 9A42     		cmp	r2, r3
 4678 2032 78D8     		bhi	.L226
 4679              	.L209:
2154:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2155:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Verificamos longitud a valor 2 y el elementID a valor 0x1D. Lo hacemos leyendo los primeros 2
2156:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_16b = *((uint16_t*)(msg->payload)+ieee802514_header->headerLength);
 4680              		.loc 1 2156 0
 4681 2034 FB68     		ldr	r3, [r7, #12]
 4682 2036 5A68     		ldr	r2, [r3, #4]
 4683 2038 BB68     		ldr	r3, [r7, #8]
 4684 203a 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4685 203c 4FEA4303 		lsl	r3, r3, #1
 4686 2040 D318     		adds	r3, r2, r3
 4687 2042 1B88     		ldrh	r3, [r3, #0]	@ movhi
 4688 2044 7B82     		strh	r3, [r7, #18]	@ movhi
2157:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2158:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Comprobación de longitud a valor 2.
2159:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2160:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b & 0x007f)  == 2) { return; }
 4689              		.loc 1 2160 0
 4690 2046 7B8A     		ldrh	r3, [r7, #18]
 4691 2048 03F07F03 		and	r3, r3, #127
 4692 204c 022B     		cmp	r3, #2
 4693 204e 6CD0     		beq	.L227
 4694              	.L210:
2161:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2162:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Comprobación de element ID = 0x1D.
2163:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2164:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (((temp_16b >> 7) & 0x001d) == 0) { return; }
 4695              		.loc 1 2164 0
 4696 2050 7B8A     		ldrh	r3, [r7, #18]
 4697 2052 4FEAD313 		lsr	r3, r3, #7
 4698 2056 9BB2     		uxth	r3, r3
 4699 2058 03F01D03 		and	r3, r3, #29
 4700 205c 002B     		cmp	r3, #0
 4701 205e 66D0     		beq	.L228
 4702              	.L211:
2165:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2166:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Comprobación del type = 0.
2167:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2168:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b >> 15) & 0x0001) { return; }
 4703              		.loc 1 2168 0
 4704 2060 7B8A     		ldrh	r3, [r7, #18]
 4705 2062 4FEAD333 		lsr	r3, r3, #15
 4706 2066 9BB2     		uxth	r3, r3
 4707 2068 03F00103 		and	r3, r3, #1
 4708 206c 002B     		cmp	r3, #0
 4709 206e 60D1     		bne	.L229
 4710              	.L212:
2169:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2170:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Obtención del IE Content (rztime).
2171:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 2;
 4711              		.loc 1 2171 0
 4712 2070 BB68     		ldr	r3, [r7, #8]
 4713 2072 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4714 2074 03F10203 		add	r3, r3, #2
 4715 2078 DAB2     		uxtb	r2, r3
 4716 207a BB68     		ldr	r3, [r7, #8]
 4717 207c 5A70     		strb	r2, [r3, #1]
2172:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4718              		.loc 1 2172 0
 4719 207e BB68     		ldr	r3, [r7, #8]
 4720 2080 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 4721 2082 FB68     		ldr	r3, [r7, #12]
 4722 2084 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4723 2086 9A42     		cmp	r2, r3
 4724 2088 55D8     		bhi	.L230
 4725              	.L213:
2173:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2174:openstack/02a-MAClow/IEEE802154Ecsl.c ****    (*rztime) = *((uint16_t*)(msg->payload)+ieee802514_header->headerLength);
 4726              		.loc 1 2174 0
 4727 208a FB68     		ldr	r3, [r7, #12]
 4728 208c 5A68     		ldr	r2, [r3, #4]
 4729 208e BB68     		ldr	r3, [r7, #8]
 4730 2090 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4731 2092 4FEA4303 		lsl	r3, r3, #1
 4732 2096 D318     		adds	r3, r2, r3
 4733 2098 1A88     		ldrh	r2, [r3, #0]
 4734 209a 7B68     		ldr	r3, [r7, #4]
 4735 209c 1A80     		strh	r2, [r3, #0]	@ movhi
2175:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2176:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // 5.- IE List Terminator, formado por 2 bytes con la siguiente estructura:
2177:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  - b0-b6 (Length) = 0
2178:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  - b7-b14 (Element ID) = 0x7e o 0x7f
2179:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  - b15 (Type) = 0
2180:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2181:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  b15 | b14 | b13 | b12 | b11 | b10 | b9 | b8 | b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 |
2182:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   0  |  1  |  1  |  1 |  1  |  1  |  1 |  1 |  1 |  0 |  0 |  0 |  0 |  0 |  0 |  0 |
2183:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2184:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 2;
 4736              		.loc 1 2184 0
 4737 209e BB68     		ldr	r3, [r7, #8]
 4738 20a0 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4739 20a2 03F10203 		add	r3, r3, #2
 4740 20a6 DAB2     		uxtb	r2, r3
 4741 20a8 BB68     		ldr	r3, [r7, #8]
 4742 20aa 5A70     		strb	r2, [r3, #1]
2185:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4743              		.loc 1 2185 0
 4744 20ac BB68     		ldr	r3, [r7, #8]
 4745 20ae 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 4746 20b0 FB68     		ldr	r3, [r7, #12]
 4747 20b2 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4748 20b4 9A42     		cmp	r2, r3
 4749 20b6 40D8     		bhi	.L231
 4750              	.L214:
2186:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2187:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Verificamos longitud a valor 0 y el elementID a valor 0x7E o 0x7F. Lo hacemos leyendo los 2 b
2188:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_16b = *((uint16_t*)(msg->payload)+ieee802514_header->headerLength);
 4751              		.loc 1 2188 0
 4752 20b8 FB68     		ldr	r3, [r7, #12]
 4753 20ba 5A68     		ldr	r2, [r3, #4]
 4754 20bc BB68     		ldr	r3, [r7, #8]
 4755 20be 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4756 20c0 4FEA4303 		lsl	r3, r3, #1
 4757 20c4 D318     		adds	r3, r2, r3
 4758 20c6 1B88     		ldrh	r3, [r3, #0]	@ movhi
 4759 20c8 7B82     		strh	r3, [r7, #18]	@ movhi
2189:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2190:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Comprobación de longitud a valor 0.
2191:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2192:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (temp_16b & 0x007f) { return; }
 4760              		.loc 1 2192 0
 4761 20ca 7B8A     		ldrh	r3, [r7, #18]
 4762 20cc 03F07F03 		and	r3, r3, #127
 4763 20d0 002B     		cmp	r3, #0
 4764 20d2 34D1     		bne	.L232
 4765              	.L215:
2193:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2194:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Comprobación de element ID = 0x7E o 0x7F.
2195:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2196:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((((temp_16b >> 7) & 0x007e) != 0x7e) &&
 4766              		.loc 1 2196 0
 4767 20d4 7B8A     		ldrh	r3, [r7, #18]
 4768 20d6 4FEAD313 		lsr	r3, r3, #7
 4769 20da 9BB2     		uxth	r3, r3
 4770 20dc 03F07E03 		and	r3, r3, #126
 4771 20e0 7E2B     		cmp	r3, #126
 4772 20e2 07D0     		beq	.L216
2197:openstack/02a-MAClow/IEEE802154Ecsl.c ****        (((temp_16b >> 7) & 0x007f) != 0x7f)
 4773              		.loc 1 2197 0 discriminator 1
 4774 20e4 7B8A     		ldrh	r3, [r7, #18]
 4775 20e6 4FEAD313 		lsr	r3, r3, #7
 4776 20ea 9BB2     		uxth	r3, r3
 4777 20ec 03F07F03 		and	r3, r3, #127
2196:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((((temp_16b >> 7) & 0x007e) != 0x7e) &&
 4778              		.loc 1 2196 0 discriminator 1
 4779 20f0 7F2B     		cmp	r3, #127
 4780 20f2 26D1     		bne	.L233
 4781              	.L216:
2198:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  ){ return; }
2199:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2200:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Comprobación del type = 0.
2201:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2202:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b >> 15) & 0x0001) { return; }
 4782              		.loc 1 2202 0
 4783 20f4 7B8A     		ldrh	r3, [r7, #18]
 4784 20f6 4FEAD333 		lsr	r3, r3, #15
 4785 20fa 9BB2     		uxth	r3, r3
 4786 20fc 03F00103 		and	r3, r3, #1
 4787 2100 002B     		cmp	r3, #0
 4788 2102 20D1     		bne	.L234
 4789              	.L217:
2203:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2204:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Por ultimo y en el caso de haber llegado aquí, consideramos la cabecera como válida.
2205:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->valid=TRUE;
 4790              		.loc 1 2205 0
 4791 2104 BB68     		ldr	r3, [r7, #8]
 4792 2106 4FF00102 		mov	r2, #1
 4793 210a 1A70     		strb	r2, [r3, #0]
 4794 210c 1CE0     		b	.L197
 4795              	.L220:
2061:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; }
 4796              		.loc 1 2061 0
 4797 210e 00BF     		nop
 4798 2110 1AE0     		b	.L197
 4799              	.L221:
2078:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->frameType != IEEE154_TYPE_MULTIPURPOSE) {return; }
 4800              		.loc 1 2078 0
 4801 2112 00BF     		nop
 4802 2114 18E0     		b	.L197
 4803              	.L222:
2081:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_8b >> 3) & 0x01) { return; }
 4804              		.loc 1 2081 0
 4805 2116 00BF     		nop
 4806 2118 16E0     		b	.L197
 4807              	.L223:
2127:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4808              		.loc 1 2127 0
 4809 211a 00BF     		nop
 4810 211c 14E0     		b	.L197
 4811              	.L224:
2132:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4812              		.loc 1 2132 0
 4813 211e 00BF     		nop
 4814 2120 12E0     		b	.L197
 4815              	.L225:
2137:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4816              		.loc 1 2137 0
 4817 2122 00BF     		nop
 4818 2124 10E0     		b	.L197
 4819              	.L226:
2153:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) {  return; } // no more to read!
 4820              		.loc 1 2153 0
 4821 2126 00BF     		nop
 4822 2128 0EE0     		b	.L197
 4823              	.L227:
2160:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b & 0x007f)  == 2) { return; }
 4824              		.loc 1 2160 0
 4825 212a 00BF     		nop
 4826 212c 0CE0     		b	.L197
 4827              	.L228:
2164:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (((temp_16b >> 7) & 0x001d) == 0) { return; }
 4828              		.loc 1 2164 0
 4829 212e 00BF     		nop
 4830 2130 0AE0     		b	.L197
 4831              	.L229:
2168:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b >> 15) & 0x0001) { return; }
 4832              		.loc 1 2168 0
 4833 2132 00BF     		nop
 4834 2134 08E0     		b	.L197
 4835              	.L230:
2172:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4836              		.loc 1 2172 0
 4837 2136 00BF     		nop
 4838 2138 06E0     		b	.L197
 4839              	.L231:
2185:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4840              		.loc 1 2185 0
 4841 213a 00BF     		nop
 4842 213c 04E0     		b	.L197
 4843              	.L232:
2192:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (temp_16b & 0x007f) { return; }
 4844              		.loc 1 2192 0
 4845 213e 00BF     		nop
 4846 2140 02E0     		b	.L197
 4847              	.L233:
2198:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  ){ return; }
 4848              		.loc 1 2198 0
 4849 2142 00BF     		nop
 4850 2144 00E0     		b	.L197
 4851              	.L234:
2202:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b >> 15) & 0x0001) { return; }
 4852              		.loc 1 2202 0
 4853 2146 00BF     		nop
 4854              	.L197:
2206:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4855              		.loc 1 2206 0
 4856 2148 07F11807 		add	r7, r7, #24
 4857 214c BD46     		mov	sp, r7
 4858 214e 80BD     		pop	{r7, pc}
 4859              		.cfi_endproc
 4860              	.LFE53:
 4862              		.align	2
 4863              		.global	isValidRxFrame
 4864              		.thumb
 4865              		.thumb_func
 4867              	isValidRxFrame:
 4868              	.LFB54:
2207:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2208:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2209:openstack/02a-MAClow/IEEE802154Ecsl.c **** //====================  FRAME VALIDITY CHECK ===========================
2210:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2211:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2212:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2213:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Decides whether the packet I just received is valid received frame.
2214:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2215:openstack/02a-MAClow/IEEE802154Ecsl.c **** A valid Rx frame satisfies the following constraints:
2216:openstack/02a-MAClow/IEEE802154Ecsl.c **** - its IEEE802.15.4 header is well formatted
2217:openstack/02a-MAClow/IEEE802154Ecsl.c **** - it's a DATA of BEACON frame (i.e. not ACK and not COMMAND)
2218:openstack/02a-MAClow/IEEE802154Ecsl.c **** - it's sent on the same PANid as mine
2219:openstack/02a-MAClow/IEEE802154Ecsl.c **** - it's for me (unicast or broadcast)
2220:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2221:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in] ieee802514_header IEEE802.15.4 header of the packet I just received
2222:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2223:openstack/02a-MAClow/IEEE802154Ecsl.c **** \returns TRUE if packet is valid received frame, FALSE otherwise
2224:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2225:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE bool isValidRxFrame(ieee802154_header_iht* ieee802514_header) {
 4869              		.loc 1 2225 0
 4870              		.cfi_startproc
 4871              		@ args = 0, pretend = 0, frame = 8
 4872              		@ frame_needed = 1, uses_anonymous_args = 0
 4873 2150 90B5     		push	{r4, r7, lr}
 4874              	.LCFI128:
 4875              		.cfi_def_cfa_offset 12
 4876              		.cfi_offset 4, -12
 4877              		.cfi_offset 7, -8
 4878              		.cfi_offset 14, -4
 4879 2152 83B0     		sub	sp, sp, #12
 4880              	.LCFI129:
 4881              		.cfi_def_cfa_offset 24
 4882 2154 00AF     		add	r7, sp, #0
 4883              	.LCFI130:
 4884              		.cfi_def_cfa_register 7
 4885 2156 7860     		str	r0, [r7, #4]
2226:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee802514_header->valid==TRUE                                                           
 4886              		.loc 1 2226 0
 4887 2158 7B68     		ldr	r3, [r7, #4]
 4888 215a 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
2227:openstack/02a-MAClow/IEEE802154Ecsl.c ****           (
2228:openstack/02a-MAClow/IEEE802154Ecsl.c ****              ieee802514_header->frameType==IEEE154_TYPE_DATA                   ||
2229:openstack/02a-MAClow/IEEE802154Ecsl.c ****              ieee802514_header->frameType==IEEE154_TYPE_BEACON
2230:openstack/02a-MAClow/IEEE802154Ecsl.c ****           )                                                                                        
2231:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
 4889              		.loc 1 2231 0
 4890 215c 002B     		cmp	r3, #0
 4891 215e 2BD0     		beq	.L236
2228:openstack/02a-MAClow/IEEE802154Ecsl.c ****              ieee802514_header->frameType==IEEE154_TYPE_DATA                   ||
 4892              		.loc 1 2228 0
 4893 2160 7B68     		ldr	r3, [r7, #4]
 4894 2162 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
2226:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee802514_header->valid==TRUE                                                           
 4895              		.loc 1 2226 0
 4896 2164 012B     		cmp	r3, #1
 4897 2166 03D0     		beq	.L237
2229:openstack/02a-MAClow/IEEE802154Ecsl.c ****              ieee802514_header->frameType==IEEE154_TYPE_BEACON
 4898              		.loc 1 2229 0
 4899 2168 7B68     		ldr	r3, [r7, #4]
 4900 216a 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
2228:openstack/02a-MAClow/IEEE802154Ecsl.c ****              ieee802514_header->frameType==IEEE154_TYPE_DATA                   ||
 4901              		.loc 1 2228 0
 4902 216c 002B     		cmp	r3, #0
 4903 216e 23D1     		bne	.L236
 4904              	.L237:
 4905              		.loc 1 2231 0
 4906 2170 7B68     		ldr	r3, [r7, #4]
 4907 2172 03F10A04 		add	r4, r3, #10
 4908 2176 4FF00400 		mov	r0, #4
 4909 217a FFF7FEFF 		bl	idmanager_getMyID
 4910 217e 0346     		mov	r3, r0
 4911 2180 2046     		mov	r0, r4
 4912 2182 1946     		mov	r1, r3
 4913 2184 FFF7FEFF 		bl	packetfunctions_sameAddress
 4914 2188 0346     		mov	r3, r0
2230:openstack/02a-MAClow/IEEE802154Ecsl.c ****           )                                                                                        
 4915              		.loc 1 2230 0
 4916 218a 002B     		cmp	r3, #0
 4917 218c 14D0     		beq	.L236
2232:openstack/02a-MAClow/IEEE802154Ecsl.c ****           (
2233:openstack/02a-MAClow/IEEE802154Ecsl.c ****              idmanager_isMyAddress(&ieee802514_header->dest)                   ||
 4918              		.loc 1 2233 0
 4919 218e 7B68     		ldr	r3, [r7, #4]
 4920 2190 03F11B03 		add	r3, r3, #27
 4921 2194 1846     		mov	r0, r3
 4922 2196 FFF7FEFF 		bl	idmanager_isMyAddress
 4923 219a 0346     		mov	r3, r0
2231:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
 4924              		.loc 1 2231 0
 4925 219c 002B     		cmp	r3, #0
 4926 219e 08D1     		bne	.L238
2234:openstack/02a-MAClow/IEEE802154Ecsl.c ****              packetfunctions_isBroadcastMulticast(&ieee802514_header->dest)
 4927              		.loc 1 2234 0
 4928 21a0 7B68     		ldr	r3, [r7, #4]
 4929 21a2 03F11B03 		add	r3, r3, #27
 4930 21a6 1846     		mov	r0, r3
 4931 21a8 FFF7FEFF 		bl	packetfunctions_isBroadcastMulticast
 4932 21ac 0346     		mov	r3, r0
2233:openstack/02a-MAClow/IEEE802154Ecsl.c ****              idmanager_isMyAddress(&ieee802514_header->dest)                   ||
 4933              		.loc 1 2233 0
 4934 21ae 002B     		cmp	r3, #0
 4935 21b0 02D0     		beq	.L236
 4936              	.L238:
2231:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
 4937              		.loc 1 2231 0 discriminator 2
 4938 21b2 4FF00103 		mov	r3, #1
 4939 21b6 01E0     		b	.L239
 4940              	.L236:
2231:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
 4941              		.loc 1 2231 0 is_stmt 0 discriminator 1
 4942 21b8 4FF00003 		mov	r3, #0
 4943              	.L239:
2226:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee802514_header->valid==TRUE                                                           
 4944              		.loc 1 2226 0 is_stmt 1
 4945 21bc 03F00103 		and	r3, r3, #1
 4946 21c0 DBB2     		uxtb	r3, r3
2235:openstack/02a-MAClow/IEEE802154Ecsl.c ****           );
2236:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4947              		.loc 1 2236 0
 4948 21c2 1846     		mov	r0, r3
 4949 21c4 07F10C07 		add	r7, r7, #12
 4950 21c8 BD46     		mov	sp, r7
 4951 21ca 90BD     		pop	{r4, r7, pc}
 4952              		.cfi_endproc
 4953              	.LFE54:
 4955              		.align	2
 4956              		.global	isValidAck
 4957              		.thumb
 4958              		.thumb_func
 4960              	isValidAck:
 4961              	.LFB55:
2237:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2238:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2239:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Decides whether the packet I just received is a valid ACK.
2240:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2241:openstack/02a-MAClow/IEEE802154Ecsl.c **** A packet is a valid ACK if it satisfies the following conditions:
2242:openstack/02a-MAClow/IEEE802154Ecsl.c **** - the IEEE802.15.4 header is valid
2243:openstack/02a-MAClow/IEEE802154Ecsl.c **** - the frame type is 'ACK'
2244:openstack/02a-MAClow/IEEE802154Ecsl.c **** - the sequence number in the ACK matches the sequence number of the packet sent
2245:openstack/02a-MAClow/IEEE802154Ecsl.c **** - the ACK contains my PANid
2246:openstack/02a-MAClow/IEEE802154Ecsl.c **** - the packet is unicast to me
2247:openstack/02a-MAClow/IEEE802154Ecsl.c **** - the packet comes from the neighbor I sent the data to
2248:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2249:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in] ieee802514_header IEEE802.15.4 header of the packet I just received
2250:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in] packetSent points to the packet I just sent
2251:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2252:openstack/02a-MAClow/IEEE802154Ecsl.c **** \returns TRUE if packet is a valid ACK, FALSE otherwise.
2253:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2254:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE bool isValidAck(ieee802154_header_iht* ieee802514_header, OpenQueueEntry_t* packetSent)
 4962              		.loc 1 2254 0
 4963              		.cfi_startproc
 4964              		@ args = 0, pretend = 0, frame = 8
 4965              		@ frame_needed = 1, uses_anonymous_args = 0
 4966 21cc 90B5     		push	{r4, r7, lr}
 4967              	.LCFI131:
 4968              		.cfi_def_cfa_offset 12
 4969              		.cfi_offset 4, -12
 4970              		.cfi_offset 7, -8
 4971              		.cfi_offset 14, -4
 4972 21ce 83B0     		sub	sp, sp, #12
 4973              	.LCFI132:
 4974              		.cfi_def_cfa_offset 24
 4975 21d0 00AF     		add	r7, sp, #0
 4976              	.LCFI133:
 4977              		.cfi_def_cfa_register 7
 4978 21d2 7860     		str	r0, [r7, #4]
 4979 21d4 3960     		str	r1, [r7, #0]
2255:openstack/02a-MAClow/IEEE802154Ecsl.c ****    /*
2256:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee802514_header->valid==TRUE                                                           
2257:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header->frameType==IEEE154_TYPE_ACK                                           
2258:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header->dsn==packetSent->l2_dsn                                               
2259:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
2260:openstack/02a-MAClow/IEEE802154Ecsl.c ****           idmanager_isMyAddress(&ieee802514_header->dest)                                          
2261:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->src,&packetSent->l2_nextORpreviousHop);
2262:openstack/02a-MAClow/IEEE802154Ecsl.c ****    */
2263:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // poipoi don't check for seq num
2264:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee802514_header->valid==TRUE                                                           
 4980              		.loc 1 2264 0
 4981 21d6 7B68     		ldr	r3, [r7, #4]
 4982 21d8 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
2265:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header->frameType==IEEE154_TYPE_ACK                                           
2266:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
2267:openstack/02a-MAClow/IEEE802154Ecsl.c ****           idmanager_isMyAddress(&ieee802514_header->dest)                                          
 4983              		.loc 1 2267 0
 4984 21da 002B     		cmp	r3, #0
 4985 21dc 2BD0     		beq	.L242
2265:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header->frameType==IEEE154_TYPE_ACK                                           
 4986              		.loc 1 2265 0
 4987 21de 7B68     		ldr	r3, [r7, #4]
 4988 21e0 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
2264:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee802514_header->valid==TRUE                                                           
 4989              		.loc 1 2264 0
 4990 21e2 022B     		cmp	r3, #2
 4991 21e4 27D1     		bne	.L242
2266:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
 4992              		.loc 1 2266 0
 4993 21e6 7B68     		ldr	r3, [r7, #4]
 4994 21e8 03F10A04 		add	r4, r3, #10
 4995 21ec 4FF00400 		mov	r0, #4
 4996 21f0 FFF7FEFF 		bl	idmanager_getMyID
 4997 21f4 0346     		mov	r3, r0
 4998 21f6 2046     		mov	r0, r4
 4999 21f8 1946     		mov	r1, r3
 5000 21fa FFF7FEFF 		bl	packetfunctions_sameAddress
 5001 21fe 0346     		mov	r3, r0
2265:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header->frameType==IEEE154_TYPE_ACK                                           
 5002              		.loc 1 2265 0
 5003 2200 002B     		cmp	r3, #0
 5004 2202 18D0     		beq	.L242
 5005              		.loc 1 2267 0
 5006 2204 7B68     		ldr	r3, [r7, #4]
 5007 2206 03F11B03 		add	r3, r3, #27
 5008 220a 1846     		mov	r0, r3
 5009 220c FFF7FEFF 		bl	idmanager_isMyAddress
 5010 2210 0346     		mov	r3, r0
2266:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
 5011              		.loc 1 2266 0
 5012 2212 002B     		cmp	r3, #0
 5013 2214 0FD0     		beq	.L242
2268:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->src,&packetSent->l2_nextORpreviousHop);
 5014              		.loc 1 2268 0
 5015 2216 7B68     		ldr	r3, [r7, #4]
 5016 2218 03F12C02 		add	r2, r3, #44
 5017 221c 3B68     		ldr	r3, [r7, #0]
 5018 221e 03F13803 		add	r3, r3, #56
 5019 2222 1046     		mov	r0, r2
 5020 2224 1946     		mov	r1, r3
 5021 2226 FFF7FEFF 		bl	packetfunctions_sameAddress
 5022 222a 0346     		mov	r3, r0
2267:openstack/02a-MAClow/IEEE802154Ecsl.c ****           idmanager_isMyAddress(&ieee802514_header->dest)                                          
 5023              		.loc 1 2267 0
 5024 222c 002B     		cmp	r3, #0
 5025 222e 02D0     		beq	.L242
2267:openstack/02a-MAClow/IEEE802154Ecsl.c ****           idmanager_isMyAddress(&ieee802514_header->dest)                                          
 5026              		.loc 1 2267 0 is_stmt 0 discriminator 2
 5027 2230 4FF00103 		mov	r3, #1
 5028 2234 01E0     		b	.L243
 5029              	.L242:
2267:openstack/02a-MAClow/IEEE802154Ecsl.c ****           idmanager_isMyAddress(&ieee802514_header->dest)                                          
 5030              		.loc 1 2267 0 discriminator 1
 5031 2236 4FF00003 		mov	r3, #0
 5032              	.L243:
2264:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee802514_header->valid==TRUE                                                           
 5033              		.loc 1 2264 0 is_stmt 1
 5034 223a 03F00103 		and	r3, r3, #1
 5035 223e DBB2     		uxtb	r3, r3
2269:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5036              		.loc 1 2269 0
 5037 2240 1846     		mov	r0, r3
 5038 2242 07F10C07 		add	r7, r7, #12
 5039 2246 BD46     		mov	sp, r7
 5040 2248 90BD     		pop	{r4, r7, pc}
 5041              		.cfi_endproc
 5042              	.LFE55:
 5044 224a 00BF     		.align	2
 5045              		.global	incrementAsnOffset
 5046              		.thumb
 5047              		.thumb_func
 5049              	incrementAsnOffset:
 5050              	.LFB56:
2270:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2271:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2272:openstack/02a-MAClow/IEEE802154Ecsl.c **** //========================  ASN HANDLING ===============================
2273:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2274:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2275:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void incrementAsnOffset() {
 5051              		.loc 1 2275 0
 5052              		.cfi_startproc
 5053              		@ args = 0, pretend = 0, frame = 0
 5054              		@ frame_needed = 1, uses_anonymous_args = 0
 5055 224c 98B5     		push	{r3, r4, r7, lr}
 5056              	.LCFI134:
 5057              		.cfi_def_cfa_offset 16
 5058              		.cfi_offset 3, -16
 5059              		.cfi_offset 4, -12
 5060              		.cfi_offset 7, -8
 5061              		.cfi_offset 14, -4
 5062 224e 00AF     		add	r7, sp, #0
 5063              	.LCFI135:
 5064              		.cfi_def_cfa_register 7
2276:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // increment the asn
2277:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asn.bytes0and1++;
 5065              		.loc 1 2277 0
 5066 2250 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5067 2254 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5068 2258 B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 5069 225c 9BB2     		uxth	r3, r3
 5070 225e 03F10103 		add	r3, r3, #1
 5071 2262 9AB2     		uxth	r2, r3
 5072 2264 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5073 2268 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5074 226c A3F80320 		strh	r2, [r3, #3]	@ unaligned
2278:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.asn.bytes0and1==0) {
 5075              		.loc 1 2278 0
 5076 2270 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5077 2274 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5078 2278 B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 5079 227c 9BB2     		uxth	r3, r3
 5080 227e 002B     		cmp	r3, #0
 5081 2280 25D1     		bne	.L246
2279:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.asn.bytes2and3++;
 5082              		.loc 1 2279 0
 5083 2282 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5084 2286 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5085 228a B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 5086 228e 9BB2     		uxth	r3, r3
 5087 2290 03F10103 		add	r3, r3, #1
 5088 2294 9AB2     		uxth	r2, r3
 5089 2296 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5090 229a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5091 229e A3F80120 		strh	r2, [r3, #1]	@ unaligned
2280:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.asn.bytes2and3==0) {
 5092              		.loc 1 2280 0
 5093 22a2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5094 22a6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5095 22aa B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 5096 22ae 9BB2     		uxth	r3, r3
 5097 22b0 002B     		cmp	r3, #0
 5098 22b2 0CD1     		bne	.L246
2281:openstack/02a-MAClow/IEEE802154Ecsl.c ****          ieee154e_vars.asn.byte4++;
 5099              		.loc 1 2281 0
 5100 22b4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5101 22b8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5102 22bc 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 5103 22be 03F10103 		add	r3, r3, #1
 5104 22c2 DAB2     		uxtb	r2, r3
 5105 22c4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5106 22c8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5107 22cc 1A70     		strb	r2, [r3, #0]
 5108              	.L246:
2282:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
2283:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2284:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // increment the offsets: Comment slot offset update.
2285:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.slotOffset  = (ieee154e_vars.slotOffset+1)%schedule_getFrameLength();
 5109              		.loc 1 2285 0
 5110 22ce 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5111 22d2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5112 22d6 DB88     		ldrh	r3, [r3, #6]
 5113 22d8 03F10104 		add	r4, r3, #1
 5114 22dc FFF7FEFF 		bl	schedule_getFrameLength
 5115 22e0 0346     		mov	r3, r0
 5116 22e2 94FBF3F2 		sdiv	r2, r4, r3
 5117 22e6 03FB02F3 		mul	r3, r3, r2
 5118 22ea E31A     		subs	r3, r4, r3
 5119 22ec 9AB2     		uxth	r2, r3
 5120 22ee 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5121 22f2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5122 22f6 DA80     		strh	r2, [r3, #6]	@ movhi
2286:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asnOffset   = (ieee154e_vars.asnOffset+1)%16;
 5123              		.loc 1 2286 0
 5124 22f8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5125 22fc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5126 2300 93F82D30 		ldrb	r3, [r3, #45]	@ zero_extendqisi2
 5127 2304 03F10102 		add	r2, r3, #1
 5128 2308 4FF00F03 		mov	r3, #15
 5129 230c C8F20003 		movt	r3, 32768
 5130 2310 1340     		ands	r3, r3, r2
 5131 2312 002B     		cmp	r3, #0
 5132 2314 05DA     		bge	.L247
 5133 2316 03F1FF33 		add	r3, r3, #-1
 5134 231a 63F00F03 		orn	r3, r3, #15
 5135 231e 03F10103 		add	r3, r3, #1
 5136              	.L247:
 5137 2322 DAB2     		uxtb	r2, r3
 5138 2324 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5139 2328 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5140 232c 83F82D20 		strb	r2, [r3, #45]
2287:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5141              		.loc 1 2287 0
 5142 2330 98BD     		pop	{r3, r4, r7, pc}
 5143              		.cfi_endproc
 5144              	.LFE56:
 5146 2332 00BF     		.align	2
 5147              		.global	ieee154e_getAsn
 5148              		.thumb
 5149              		.thumb_func
 5151              	ieee154e_getAsn:
 5152              	.LFB57:
2288:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2289:openstack/02a-MAClow/IEEE802154Ecsl.c **** //from upper layer that want to send the ASN to compute timing or latency
2290:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void ieee154e_getAsn(uint8_t* array) {
 5153              		.loc 1 2290 0
 5154              		.cfi_startproc
 5155              		@ args = 0, pretend = 0, frame = 8
 5156              		@ frame_needed = 1, uses_anonymous_args = 0
 5157              		@ link register save eliminated.
 5158 2334 80B4     		push	{r7}
 5159              	.LCFI136:
 5160              		.cfi_def_cfa_offset 4
 5161              		.cfi_offset 7, -4
 5162 2336 83B0     		sub	sp, sp, #12
 5163              	.LCFI137:
 5164              		.cfi_def_cfa_offset 16
 5165 2338 00AF     		add	r7, sp, #0
 5166              	.LCFI138:
 5167              		.cfi_def_cfa_register 7
 5168 233a 7860     		str	r0, [r7, #4]
2291:openstack/02a-MAClow/IEEE802154Ecsl.c ****    array[0]         = (ieee154e_vars.asn.bytes0and1     & 0xff);
 5169              		.loc 1 2291 0
 5170 233c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5171 2340 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5172 2344 B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 5173 2348 9BB2     		uxth	r3, r3
 5174 234a DAB2     		uxtb	r2, r3
 5175 234c 7B68     		ldr	r3, [r7, #4]
 5176 234e 1A70     		strb	r2, [r3, #0]
2292:openstack/02a-MAClow/IEEE802154Ecsl.c ****    array[1]         = (ieee154e_vars.asn.bytes0and1/256 & 0xff);
 5177              		.loc 1 2292 0
 5178 2350 7B68     		ldr	r3, [r7, #4]
 5179 2352 03F10102 		add	r2, r3, #1
 5180 2356 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5181 235a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5182 235e B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 5183 2362 9BB2     		uxth	r3, r3
 5184 2364 4FEA1323 		lsr	r3, r3, #8
 5185 2368 9BB2     		uxth	r3, r3
 5186 236a DBB2     		uxtb	r3, r3
 5187 236c 1370     		strb	r3, [r2, #0]
2293:openstack/02a-MAClow/IEEE802154Ecsl.c ****    array[2]         = (ieee154e_vars.asn.bytes2and3     & 0xff);
 5188              		.loc 1 2293 0
 5189 236e 7B68     		ldr	r3, [r7, #4]
 5190 2370 03F10202 		add	r2, r3, #2
 5191 2374 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5192 2378 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5193 237c B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 5194 2380 9BB2     		uxth	r3, r3
 5195 2382 DBB2     		uxtb	r3, r3
 5196 2384 1370     		strb	r3, [r2, #0]
2294:openstack/02a-MAClow/IEEE802154Ecsl.c ****    array[3]         = (ieee154e_vars.asn.bytes2and3/256 & 0xff);
 5197              		.loc 1 2294 0
 5198 2386 7B68     		ldr	r3, [r7, #4]
 5199 2388 03F10302 		add	r2, r3, #3
 5200 238c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5201 2390 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5202 2394 B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 5203 2398 9BB2     		uxth	r3, r3
 5204 239a 4FEA1323 		lsr	r3, r3, #8
 5205 239e 9BB2     		uxth	r3, r3
 5206 23a0 DBB2     		uxtb	r3, r3
 5207 23a2 1370     		strb	r3, [r2, #0]
2295:openstack/02a-MAClow/IEEE802154Ecsl.c ****    array[4]         =  ieee154e_vars.asn.byte4;
 5208              		.loc 1 2295 0
 5209 23a4 7B68     		ldr	r3, [r7, #4]
 5210 23a6 03F10402 		add	r2, r3, #4
 5211 23aa 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5212 23ae C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5213 23b2 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 5214 23b4 1370     		strb	r3, [r2, #0]
2296:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5215              		.loc 1 2296 0
 5216 23b6 07F10C07 		add	r7, r7, #12
 5217 23ba BD46     		mov	sp, r7
 5218 23bc 80BC     		pop	{r7}
 5219 23be 7047     		bx	lr
 5220              		.cfi_endproc
 5221              	.LFE57:
 5223              		.align	2
 5224              		.global	synchronizeAck
 5225              		.thumb
 5226              		.thumb_func
 5228              	synchronizeAck:
 5229              	.LFB58:
2297:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2298:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2299:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================  SYNCHRONIZATION ==============================
2300:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2301:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2302:openstack/02a-MAClow/IEEE802154Ecsl.c **** void synchronizeAck(PORT_SIGNED_INT_WIDTH timeCorrection) {
 5230              		.loc 1 2302 0
 5231              		.cfi_startproc
 5232              		@ args = 0, pretend = 0, frame = 16
 5233              		@ frame_needed = 1, uses_anonymous_args = 0
 5234 23c0 90B5     		push	{r4, r7, lr}
 5235              	.LCFI139:
 5236              		.cfi_def_cfa_offset 12
 5237              		.cfi_offset 4, -12
 5238              		.cfi_offset 7, -8
 5239              		.cfi_offset 14, -4
 5240 23c2 87B0     		sub	sp, sp, #28
 5241              	.LCFI140:
 5242              		.cfi_def_cfa_offset 40
 5243 23c4 02AF     		add	r7, sp, #8
 5244              	.LCFI141:
 5245              		.cfi_def_cfa 7, 32
 5246 23c6 7860     		str	r0, [r7, #4]
2303:openstack/02a-MAClow/IEEE802154Ecsl.c ****    PORT_RADIOTIMER_WIDTH newPeriod;
2304:openstack/02a-MAClow/IEEE802154Ecsl.c ****    PORT_RADIOTIMER_WIDTH currentPeriod;
2305:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
2306:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // calculate new period
2307:openstack/02a-MAClow/IEEE802154Ecsl.c ****    currentPeriod                  =  radio_getTimerPeriod();
 5247              		.loc 1 2307 0
 5248 23c8 FFF7FEFF 		bl	radio_getTimerPeriod
 5249 23cc F860     		str	r0, [r7, #12]
2308:openstack/02a-MAClow/IEEE802154Ecsl.c ****    newPeriod                      =  (PORT_RADIOTIMER_WIDTH)((PORT_SIGNED_INT_WIDTH)currentPeriod-t
 5250              		.loc 1 2308 0
 5251 23ce FA68     		ldr	r2, [r7, #12]
 5252 23d0 7B68     		ldr	r3, [r7, #4]
 5253 23d2 D31A     		subs	r3, r2, r3
 5254 23d4 BB60     		str	r3, [r7, #8]
2309:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2310:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // resynchronize by applying the new period
2311:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_setTimerPeriod(newPeriod);
 5255              		.loc 1 2311 0
 5256 23d6 B868     		ldr	r0, [r7, #8]
 5257 23d8 FFF7FEFF 		bl	radio_setTimerPeriod
2312:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
2313:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // reset the de-synchronization timeout
2314:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.deSyncTimeout    = DESYNCTIMEOUT;
 5258              		.loc 1 2314 0
 5259 23dc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5260 23e0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5261 23e4 40F61D12 		movw	r2, #2333
 5262 23e8 DA60     		str	r2, [r3, #12]
2315:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
2316:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // indicate time correction to adaptive sync module
2317:openstack/02a-MAClow/IEEE802154Ecsl.c ****    adaptive_sync_indicateTimeCorrection((-timeCorrection),ieee154e_vars.ackReceived->l2_nextORprevi
 5263              		.loc 1 2317 0
 5264 23ea 7B68     		ldr	r3, [r7, #4]
 5265 23ec 9BB2     		uxth	r3, r3
 5266 23ee C3F10003 		rsb	r3, r3, #0
 5267 23f2 9BB2     		uxth	r3, r3
 5268 23f4 99B2     		uxth	r1, r3
 5269 23f6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5270 23fa C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5271 23fe 1A6A     		ldr	r2, [r3, #32]
 5272 2400 0CB2     		sxth	r4, r1
 5273 2402 6B46     		mov	r3, sp
 5274 2404 02F14401 		add	r1, r2, #68
 5275 2408 03C9     		ldmia	r1, {r0, r1}
 5276 240a 1860     		str	r0, [r3, #0]
 5277 240c 03F10403 		add	r3, r3, #4
 5278 2410 1970     		strb	r1, [r3, #0]
 5279 2412 02F13803 		add	r3, r2, #56
 5280 2416 0ECB     		ldmia	r3, {r1, r2, r3}
 5281 2418 2046     		mov	r0, r4
 5282 241a FFF7FEFF 		bl	adaptive_sync_indicateTimeCorrection
2318:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
2319:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log a large timeCorrection
2320:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (
2321:openstack/02a-MAClow/IEEE802154Ecsl.c ****          ieee154e_vars.isSync==TRUE &&
 5283              		.loc 1 2321 0
 5284 241e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5285 2422 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5286 2426 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
2320:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (
 5287              		.loc 1 2320 0
 5288 2428 002B     		cmp	r3, #0
 5289 242a 11D0     		beq	.L250
 5290              		.loc 1 2321 0
 5291 242c 7B68     		ldr	r3, [r7, #4]
 5292 242e 13F1050F 		cmn	r3, #5
 5293 2432 02DB     		blt	.L251
2322:openstack/02a-MAClow/IEEE802154Ecsl.c ****          (
2323:openstack/02a-MAClow/IEEE802154Ecsl.c ****             timeCorrection<-LIMITLARGETIMECORRECTION ||
 5294              		.loc 1 2323 0
 5295 2434 7B68     		ldr	r3, [r7, #4]
 5296 2436 052B     		cmp	r3, #5
 5297 2438 0ADD     		ble	.L250
 5298              	.L251:
2324:openstack/02a-MAClow/IEEE802154Ecsl.c ****             timeCorrection> LIMITLARGETIMECORRECTION
2325:openstack/02a-MAClow/IEEE802154Ecsl.c ****          )
2326:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ) {
2327:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openserial_printError(COMPONENT_IEEE802154E,ERR_LARGE_TIMECORRECTION,
 5299              		.loc 1 2327 0
 5300 243a 7B68     		ldr	r3, [r7, #4]
 5301 243c 9BB2     		uxth	r3, r3
 5302 243e 4FF00900 		mov	r0, #9
 5303 2442 4FF01C01 		mov	r1, #28
 5304 2446 1A46     		mov	r2, r3
 5305 2448 4FF00103 		mov	r3, #1
 5306 244c FFF7FEFF 		bl	openserial_printError
 5307              	.L250:
2328:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)timeCorrection,
2329:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)1);
2330:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2331:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // update the stats
2332:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.numSyncAck++;
 5308              		.loc 1 2332 0
 5309 2450 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5310 2454 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5311 2458 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 5312 245a 03F10103 		add	r3, r3, #1
 5313 245e DAB2     		uxtb	r2, r3
 5314 2460 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5315 2464 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5316 2468 5A70     		strb	r2, [r3, #1]
2333:openstack/02a-MAClow/IEEE802154Ecsl.c ****    updateStats(timeCorrection);
 5317              		.loc 1 2333 0
 5318 246a 7868     		ldr	r0, [r7, #4]
 5319 246c FFF7FEFF 		bl	updateStats
2334:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
2335:openstack/02a-MAClow/IEEE802154Ecsl.c **** #ifdef OPENSIM
2336:openstack/02a-MAClow/IEEE802154Ecsl.c ****    debugpins_syncAck_set();
2337:openstack/02a-MAClow/IEEE802154Ecsl.c ****    debugpins_syncAck_clr();
2338:openstack/02a-MAClow/IEEE802154Ecsl.c **** #endif
2339:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5320              		.loc 1 2339 0
 5321 2470 07F11407 		add	r7, r7, #20
 5322 2474 BD46     		mov	sp, r7
 5323 2476 90BD     		pop	{r4, r7, pc}
 5324              		.cfi_endproc
 5325              	.LFE58:
 5327              		.align	2
 5328              		.global	changeIsSync
 5329              		.thumb
 5330              		.thumb_func
 5332              	changeIsSync:
 5333              	.LFB59:
2340:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2341:openstack/02a-MAClow/IEEE802154Ecsl.c **** void changeIsSync(bool newIsSync) {
 5334              		.loc 1 2341 0
 5335              		.cfi_startproc
 5336              		@ args = 0, pretend = 0, frame = 8
 5337              		@ frame_needed = 1, uses_anonymous_args = 0
 5338 2478 80B5     		push	{r7, lr}
 5339              	.LCFI142:
 5340              		.cfi_def_cfa_offset 8
 5341              		.cfi_offset 7, -8
 5342              		.cfi_offset 14, -4
 5343 247a 82B0     		sub	sp, sp, #8
 5344              	.LCFI143:
 5345              		.cfi_def_cfa_offset 16
 5346 247c 00AF     		add	r7, sp, #0
 5347              	.LCFI144:
 5348              		.cfi_def_cfa_register 7
 5349 247e 0346     		mov	r3, r0
 5350 2480 FB71     		strb	r3, [r7, #7]
2342:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.isSync = newIsSync;
 5351              		.loc 1 2342 0
 5352 2482 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5353 2486 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5354 248a FA79     		ldrb	r2, [r7, #7]
 5355 248c 1A74     		strb	r2, [r3, #16]
2343:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
2344:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.isSync==TRUE) {
 5356              		.loc 1 2344 0
 5357 248e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5358 2492 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5359 2496 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
 5360 2498 002B     		cmp	r3, #0
 5361 249a 04D0     		beq	.L253
2345:openstack/02a-MAClow/IEEE802154Ecsl.c ****       leds_sync_on();
 5362              		.loc 1 2345 0
 5363 249c FFF7FEFF 		bl	leds_sync_on
2346:openstack/02a-MAClow/IEEE802154Ecsl.c ****       resetStats();
 5364              		.loc 1 2346 0
 5365 24a0 FFF7FEFF 		bl	resetStats
 5366 24a4 03E0     		b	.L252
 5367              	.L253:
2347:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
2348:openstack/02a-MAClow/IEEE802154Ecsl.c ****       leds_sync_off();
 5368              		.loc 1 2348 0
 5369 24a6 FFF7FEFF 		bl	leds_sync_off
2349:openstack/02a-MAClow/IEEE802154Ecsl.c ****       schedule_resetBackoff();
 5370              		.loc 1 2349 0
 5371 24aa FFF7FEFF 		bl	schedule_resetBackoff
 5372              	.L252:
2350:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2351:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5373              		.loc 1 2351 0
 5374 24ae 07F10807 		add	r7, r7, #8
 5375 24b2 BD46     		mov	sp, r7
 5376 24b4 80BD     		pop	{r7, pc}
 5377              		.cfi_endproc
 5378              	.LFE59:
 5380 24b6 00BF     		.align	2
 5381              		.global	notif_sendDone
 5382              		.thumb
 5383              		.thumb_func
 5385              	notif_sendDone:
 5386              	.LFB60:
2352:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2353:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2354:openstack/02a-MAClow/IEEE802154Ecsl.c **** //=====================  NOTIFY UPPER LAYER  ===========================
2355:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2356:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2357:openstack/02a-MAClow/IEEE802154Ecsl.c **** void notif_sendDone(OpenQueueEntry_t* packetSent, owerror_t error) {
 5387              		.loc 1 2357 0
 5388              		.cfi_startproc
 5389              		@ args = 0, pretend = 0, frame = 8
 5390              		@ frame_needed = 1, uses_anonymous_args = 0
 5391 24b8 80B5     		push	{r7, lr}
 5392              	.LCFI145:
 5393              		.cfi_def_cfa_offset 8
 5394              		.cfi_offset 7, -8
 5395              		.cfi_offset 14, -4
 5396 24ba 82B0     		sub	sp, sp, #8
 5397              	.LCFI146:
 5398              		.cfi_def_cfa_offset 16
 5399 24bc 00AF     		add	r7, sp, #0
 5400              	.LCFI147:
 5401              		.cfi_def_cfa_register 7
 5402 24be 7860     		str	r0, [r7, #4]
 5403 24c0 0B46     		mov	r3, r1
 5404 24c2 FB70     		strb	r3, [r7, #3]
2358:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the outcome of the trasmission attempt
2359:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packetSent->l2_sendDoneError   = error;
 5405              		.loc 1 2359 0
 5406 24c4 7B68     		ldr	r3, [r7, #4]
 5407 24c6 FA78     		ldrb	r2, [r7, #3]
 5408 24c8 83F83720 		strb	r2, [r3, #55]
2360:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the current ASN
2361:openstack/02a-MAClow/IEEE802154Ecsl.c ****    memcpy(&packetSent->l2_asn,&ieee154e_vars.asn,sizeof(asn_t));
 5409              		.loc 1 2361 0
 5410 24cc 7B68     		ldr	r3, [r7, #4]
 5411 24ce 03F14D02 		add	r2, r3, #77
 5412 24d2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5413 24d6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5414 24da 1868     		ldr	r0, [r3, #0]	@ unaligned
 5415 24dc 1060     		str	r0, [r2, #0]	@ unaligned
 5416 24de 1B79     		ldrb	r3, [r3, #4]
 5417 24e0 1371     		strb	r3, [r2, #4]
2362:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // associate this packet with the virtual component
2363:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // COMPONENT_IEEE802154E_TO_RES so RES can knows it's for it
2364:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packetSent->owner              = COMPONENT_IEEE802154E_TO_SIXTOP;
 5418              		.loc 1 2364 0
 5419 24e2 7B68     		ldr	r3, [r7, #4]
 5420 24e4 4FF00B02 		mov	r2, #11
 5421 24e8 5A70     		strb	r2, [r3, #1]
2365:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // post RES's sendDone task
2366:openstack/02a-MAClow/IEEE802154Ecsl.c ****    scheduler_push_task(task_sixtopNotifSendDone,TASKPRIO_SIXTOP_NOTIF_TXDONE);
 5422              		.loc 1 2366 0
 5423 24ea 40F20000 		movw	r0, #:lower16:task_sixtopNotifSendDone
 5424 24ee C0F20000 		movt	r0, #:upper16:task_sixtopNotifSendDone
 5425 24f2 4FF00201 		mov	r1, #2
 5426 24f6 FFF7FEFF 		bl	scheduler_push_task
2367:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // wake up the scheduler
2368:openstack/02a-MAClow/IEEE802154Ecsl.c ****    SCHEDULER_WAKEUP();
2369:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5427              		.loc 1 2369 0
 5428 24fa 07F10807 		add	r7, r7, #8
 5429 24fe BD46     		mov	sp, r7
 5430 2500 80BD     		pop	{r7, pc}
 5431              		.cfi_endproc
 5432              	.LFE60:
 5434 2502 00BF     		.align	2
 5435              		.global	notif_receive
 5436              		.thumb
 5437              		.thumb_func
 5439              	notif_receive:
 5440              	.LFB61:
2370:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2371:openstack/02a-MAClow/IEEE802154Ecsl.c **** // Modified notif_receive signature to add action for CSL testing purposes.
2372:openstack/02a-MAClow/IEEE802154Ecsl.c **** // Packet is removed on endOps in order to not fill all the slots on queue due
2373:openstack/02a-MAClow/IEEE802154Ecsl.c **** // to no sixtop action is defined for receive and process incoming packets.
2374:openstack/02a-MAClow/IEEE802154Ecsl.c **** // Then, we comment this actions here and add remove packet on endOps method.
2375:openstack/02a-MAClow/IEEE802154Ecsl.c **** void notif_receive(OpenQueueEntry_t* packetReceived, uint8_t action) {
 5441              		.loc 1 2375 0
 5442              		.cfi_startproc
 5443              		@ args = 0, pretend = 0, frame = 8
 5444              		@ frame_needed = 1, uses_anonymous_args = 0
 5445 2504 80B5     		push	{r7, lr}
 5446              	.LCFI148:
 5447              		.cfi_def_cfa_offset 8
 5448              		.cfi_offset 7, -8
 5449              		.cfi_offset 14, -4
 5450 2506 82B0     		sub	sp, sp, #8
 5451              	.LCFI149:
 5452              		.cfi_def_cfa_offset 16
 5453 2508 00AF     		add	r7, sp, #0
 5454              	.LCFI150:
 5455              		.cfi_def_cfa_register 7
 5456 250a 7860     		str	r0, [r7, #4]
 5457 250c 0B46     		mov	r3, r1
 5458 250e FB70     		strb	r3, [r7, #3]
2376:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the current ASN
2377:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //memcpy(&packetReceived->l2_asn, &ieee154e_vars.asn, sizeof(asn_t));
2378:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2379:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // indicate reception to the schedule, to keep statistics
2380:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //schedule_indicateRx(&packetReceived->l2_asn);
2381:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2382:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // associate this packet with the virtual component
2383:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // COMPONENT_IEEE802154E_TO_SIXTOP so sixtop can knows it's for it
2384:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //packetReceived->owner          = COMPONENT_IEEE802154E_TO_SIXTOP;
2385:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2386:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // post RES's Receive task
2387:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //scheduler_push_task(task_sixtopNotifReceive,TASKPRIO_SIXTOP_NOTIF_RX);
2388:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2389:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // CSL Testing purposes
2390:openstack/02a-MAClow/IEEE802154Ecsl.c ****    switch(action) {
 5459              		.loc 1 2390 0
 5460 2510 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 5461 2512 03F1FF33 		add	r3, r3, #-1
 5462 2516 032B     		cmp	r3, #3
 5463 2518 13D8     		bhi	.L257
 5464 251a 01A2     		adr	r2, .L261
 5465 251c 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 5466              		.align	2
 5467              	.L261:
 5468 2520 31250000 		.word	.L258+1
 5469 2524 37250000 		.word	.L259+1
 5470 2528 31250000 		.word	.L258+1
 5471 252c 3D250000 		.word	.L260+1
 5472              	.L258:
2391:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // OK. verde toggle
2392:openstack/02a-MAClow/IEEE802154Ecsl.c ****    case 1:
2393:openstack/02a-MAClow/IEEE802154Ecsl.c ****    case 3: leds_radio_toggle(); break;
 5473              		.loc 1 2393 0
 5474 2530 FFF7FEFF 		bl	leds_radio_toggle
 5475 2534 07E0     		b	.L256
 5476              	.L259:
2394:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Error ACK. naranja toggle
2395:openstack/02a-MAClow/IEEE802154Ecsl.c ****    case 2: leds_sync_toggle();  break;
 5477              		.loc 1 2395 0
 5478 2536 FFF7FEFF 		bl	leds_sync_toggle
 5479 253a 04E0     		b	.L256
 5480              	.L260:
2396:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Error EndOps
2397:openstack/02a-MAClow/IEEE802154Ecsl.c ****    case 4: leds_error_toggle(); break;
 5481              		.loc 1 2397 0
 5482 253c FFF7FEFF 		bl	leds_error_toggle
 5483 2540 01E0     		b	.L256
 5484              	.L257:
2398:openstack/02a-MAClow/IEEE802154Ecsl.c ****    default: leds_all_off();
 5485              		.loc 1 2398 0
 5486 2542 FFF7FEFF 		bl	leds_all_off
 5487              	.L256:
2399:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2400:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2401:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // wake up the scheduler
2402:openstack/02a-MAClow/IEEE802154Ecsl.c ****    SCHEDULER_WAKEUP();
2403:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5488              		.loc 1 2403 0
 5489 2546 07F10807 		add	r7, r7, #8
 5490 254a BD46     		mov	sp, r7
 5491 254c 80BD     		pop	{r7, pc}
 5492              		.cfi_endproc
 5493              	.LFE61:
 5495 254e 00BF     		.align	2
 5496              		.global	resetStats
 5497              		.thumb
 5498              		.thumb_func
 5500              	resetStats:
 5501              	.LFB62:
2404:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2405:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2406:openstack/02a-MAClow/IEEE802154Ecsl.c **** //============================== STATS =================================
2407:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2408:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2409:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void resetStats() {
 5502              		.loc 1 2409 0
 5503              		.cfi_startproc
 5504              		@ args = 0, pretend = 0, frame = 0
 5505              		@ frame_needed = 1, uses_anonymous_args = 0
 5506              		@ link register save eliminated.
 5507 2550 80B4     		push	{r7}
 5508              	.LCFI151:
 5509              		.cfi_def_cfa_offset 4
 5510              		.cfi_offset 7, -4
 5511 2552 00AF     		add	r7, sp, #0
 5512              	.LCFI152:
 5513              		.cfi_def_cfa_register 7
2410:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.numSyncPkt      =    0;
 5514              		.loc 1 2410 0
 5515 2554 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5516 2558 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5517 255c 4FF00002 		mov	r2, #0
 5518 2560 1A70     		strb	r2, [r3, #0]
2411:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.numSyncAck      =    0;
 5519              		.loc 1 2411 0
 5520 2562 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5521 2566 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5522 256a 4FF00002 		mov	r2, #0
 5523 256e 5A70     		strb	r2, [r3, #1]
2412:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.minCorrection   =  127;
 5524              		.loc 1 2412 0
 5525 2570 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5526 2574 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5527 2578 4FF07F02 		mov	r2, #127
 5528 257c 5A80     		strh	r2, [r3, #2]	@ movhi
2413:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.maxCorrection   = -127;
 5529              		.loc 1 2413 0
 5530 257e 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5531 2582 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5532 2586 4FF68172 		movw	r2, #65409
 5533 258a 9A80     		strh	r2, [r3, #4]	@ movhi
2414:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.numTicsOn       =    0;
 5534              		.loc 1 2414 0
 5535 258c 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5536 2590 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5537 2594 4FF00002 		mov	r2, #0
 5538 2598 DA71     		strb	r2, [r3, #7]
 5539 259a 9A68     		ldr	r2, [r3, #8]
 5540 259c 02F07F42 		and	r2, r2, #-16777216
 5541 25a0 9A60     		str	r2, [r3, #8]
2415:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.numTicsTotal    =    0;
 5542              		.loc 1 2415 0
 5543 25a2 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5544 25a6 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5545 25aa 4FF00002 		mov	r2, #0
 5546 25ae DA72     		strb	r2, [r3, #11]
 5547 25b0 DA68     		ldr	r2, [r3, #12]
 5548 25b2 02F07F42 		and	r2, r2, #-16777216
 5549 25b6 DA60     		str	r2, [r3, #12]
2416:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // do not reset the number of de-synchronizations
2417:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5550              		.loc 1 2417 0
 5551 25b8 BD46     		mov	sp, r7
 5552 25ba 80BC     		pop	{r7}
 5553 25bc 7047     		bx	lr
 5554              		.cfi_endproc
 5555              	.LFE62:
 5557 25be 00BF     		.align	2
 5558              		.global	updateStats
 5559              		.thumb
 5560              		.thumb_func
 5562              	updateStats:
 5563              	.LFB63:
2418:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2419:openstack/02a-MAClow/IEEE802154Ecsl.c **** void updateStats(PORT_SIGNED_INT_WIDTH timeCorrection) {
 5564              		.loc 1 2419 0
 5565              		.cfi_startproc
 5566              		@ args = 0, pretend = 0, frame = 8
 5567              		@ frame_needed = 1, uses_anonymous_args = 0
 5568              		@ link register save eliminated.
 5569 25c0 80B4     		push	{r7}
 5570              	.LCFI153:
 5571              		.cfi_def_cfa_offset 4
 5572              		.cfi_offset 7, -4
 5573 25c2 83B0     		sub	sp, sp, #12
 5574              	.LCFI154:
 5575              		.cfi_def_cfa_offset 16
 5576 25c4 00AF     		add	r7, sp, #0
 5577              	.LCFI155:
 5578              		.cfi_def_cfa_register 7
 5579 25c6 7860     		str	r0, [r7, #4]
2420:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // update minCorrection
2421:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (timeCorrection<ieee154e_stats.minCorrection) {
 5580              		.loc 1 2421 0
 5581 25c8 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5582 25cc C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5583 25d0 5B88     		ldrh	r3, [r3, #2]
 5584 25d2 1AB2     		sxth	r2, r3
 5585 25d4 7B68     		ldr	r3, [r7, #4]
 5586 25d6 9A42     		cmp	r2, r3
 5587 25d8 06DD     		ble	.L265
2422:openstack/02a-MAClow/IEEE802154Ecsl.c ****      ieee154e_stats.minCorrection = timeCorrection;
 5588              		.loc 1 2422 0
 5589 25da 7B68     		ldr	r3, [r7, #4]
 5590 25dc 9AB2     		uxth	r2, r3
 5591 25de 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5592 25e2 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5593 25e6 5A80     		strh	r2, [r3, #2]	@ movhi
 5594              	.L265:
2423:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2424:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // update maxConnection
2425:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if(timeCorrection>ieee154e_stats.maxCorrection) {
 5595              		.loc 1 2425 0
 5596 25e8 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5597 25ec C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5598 25f0 9B88     		ldrh	r3, [r3, #4]
 5599 25f2 1AB2     		sxth	r2, r3
 5600 25f4 7B68     		ldr	r3, [r7, #4]
 5601 25f6 9A42     		cmp	r2, r3
 5602 25f8 06DA     		bge	.L264
2426:openstack/02a-MAClow/IEEE802154Ecsl.c ****      ieee154e_stats.maxCorrection = timeCorrection;
 5603              		.loc 1 2426 0
 5604 25fa 7B68     		ldr	r3, [r7, #4]
 5605 25fc 9AB2     		uxth	r2, r3
 5606 25fe 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5607 2602 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5608 2606 9A80     		strh	r2, [r3, #4]	@ movhi
 5609              	.L264:
2427:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2428:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5610              		.loc 1 2428 0
 5611 2608 07F10C07 		add	r7, r7, #12
 5612 260c BD46     		mov	sp, r7
 5613 260e 80BC     		pop	{r7}
 5614 2610 7047     		bx	lr
 5615              		.cfi_endproc
 5616              	.LFE63:
 5618 2612 00BF     		.align	2
 5619              		.global	changeState
 5620              		.thumb
 5621              		.thumb_func
 5623              	changeState:
 5624              	.LFB64:
2429:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2430:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2431:openstack/02a-MAClow/IEEE802154Ecsl.c **** //============================== MISC ==================================
2432:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2433:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2434:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2435:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Changes the state of the IEEE802.15.4e FSM.
2436:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2437:openstack/02a-MAClow/IEEE802154Ecsl.c **** Besides simply updating the state global variable,
2438:openstack/02a-MAClow/IEEE802154Ecsl.c **** this function toggles the FSM debug pin.
2439:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2440:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in] newstate The state the IEEE802.15.4e FSM is now in.
2441:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2442:openstack/02a-MAClow/IEEE802154Ecsl.c **** void changeState(ieee154e_state_t newstate) {
 5625              		.loc 1 2442 0
 5626              		.cfi_startproc
 5627              		@ args = 0, pretend = 0, frame = 8
 5628              		@ frame_needed = 1, uses_anonymous_args = 0
 5629 2614 80B5     		push	{r7, lr}
 5630              	.LCFI156:
 5631              		.cfi_def_cfa_offset 8
 5632              		.cfi_offset 7, -8
 5633              		.cfi_offset 14, -4
 5634 2616 82B0     		sub	sp, sp, #8
 5635              	.LCFI157:
 5636              		.cfi_def_cfa_offset 16
 5637 2618 00AF     		add	r7, sp, #0
 5638              	.LCFI158:
 5639              		.cfi_def_cfa_register 7
 5640 261a 0346     		mov	r3, r0
 5641 261c FB71     		strb	r3, [r7, #7]
2443:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // update the state
2444:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.state = newstate;
 5642              		.loc 1 2444 0
 5643 261e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5644 2622 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5645 2626 FA79     		ldrb	r2, [r7, #7]
 5646 2628 5A74     		strb	r2, [r3, #17]
2445:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // wiggle the FSM debug pin
2446:openstack/02a-MAClow/IEEE802154Ecsl.c ****    switch (ieee154e_vars.state) {
 5647              		.loc 1 2446 0
 5648 262a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5649 262e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5650 2632 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 5651 2634 3A2B     		cmp	r3, #58
 5652 2636 00F28280 		bhi	.L267
 5653 263a 01A2     		adr	r2, .L272
 5654 263c 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 5655              		.align	2
 5656              	.L272:
 5657 2640 33270000 		.word	.L269+1
 5658 2644 3F270000 		.word	.L267+1
 5659 2648 3F270000 		.word	.L267+1
 5660 264c 3F270000 		.word	.L267+1
 5661 2650 3F270000 		.word	.L267+1
 5662 2654 3F270000 		.word	.L267+1
 5663 2658 3F270000 		.word	.L267+1
 5664 265c 3F270000 		.word	.L267+1
 5665 2660 3F270000 		.word	.L267+1
 5666 2664 3F270000 		.word	.L267+1
 5667 2668 3F270000 		.word	.L267+1
 5668 266c 3F270000 		.word	.L267+1
 5669 2670 3F270000 		.word	.L267+1
 5670 2674 3F270000 		.word	.L267+1
 5671 2678 3F270000 		.word	.L267+1
 5672 267c 3F270000 		.word	.L267+1
 5673 2680 3F270000 		.word	.L267+1
 5674 2684 3F270000 		.word	.L267+1
 5675 2688 3F270000 		.word	.L267+1
 5676 268c 3F270000 		.word	.L267+1
 5677 2690 3F270000 		.word	.L267+1
 5678 2694 3F270000 		.word	.L267+1
 5679 2698 3F270000 		.word	.L267+1
 5680 269c 3F270000 		.word	.L267+1
 5681 26a0 3F270000 		.word	.L267+1
 5682 26a4 3F270000 		.word	.L267+1
 5683 26a8 2D270000 		.word	.L270+1
 5684 26ac 39270000 		.word	.L271+1
 5685 26b0 39270000 		.word	.L271+1
 5686 26b4 39270000 		.word	.L271+1
 5687 26b8 39270000 		.word	.L271+1
 5688 26bc 2D270000 		.word	.L270+1
 5689 26c0 39270000 		.word	.L271+1
 5690 26c4 39270000 		.word	.L271+1
 5691 26c8 39270000 		.word	.L271+1
 5692 26cc 39270000 		.word	.L271+1
 5693 26d0 39270000 		.word	.L271+1
 5694 26d4 39270000 		.word	.L271+1
 5695 26d8 39270000 		.word	.L271+1
 5696 26dc 39270000 		.word	.L271+1
 5697 26e0 39270000 		.word	.L271+1
 5698 26e4 39270000 		.word	.L271+1
 5699 26e8 33270000 		.word	.L269+1
 5700 26ec 39270000 		.word	.L271+1
 5701 26f0 39270000 		.word	.L271+1
 5702 26f4 39270000 		.word	.L271+1
 5703 26f8 39270000 		.word	.L271+1
 5704 26fc 39270000 		.word	.L271+1
 5705 2700 33270000 		.word	.L269+1
 5706 2704 39270000 		.word	.L271+1
 5707 2708 39270000 		.word	.L271+1
 5708 270c 39270000 		.word	.L271+1
 5709 2710 39270000 		.word	.L271+1
 5710 2714 39270000 		.word	.L271+1
 5711 2718 39270000 		.word	.L271+1
 5712 271c 39270000 		.word	.L271+1
 5713 2720 39270000 		.word	.L271+1
 5714 2724 39270000 		.word	.L271+1
 5715 2728 39270000 		.word	.L271+1
 5716              	.L270:
2447:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXWAKEUPOFFSET:
2448:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXDATAOFFSET:
2449:openstack/02a-MAClow/IEEE802154Ecsl.c ****          debugpins_fsm_set();
 5717              		.loc 1 2449 0
 5718 272c FFF7FEFF 		bl	debugpins_fsm_set
2450:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 5719              		.loc 1 2450 0
 5720 2730 05E0     		b	.L267
 5721              	.L269:
2451:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_SLEEP:
2452:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXDATAOFFSET:
2453:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXWAKEUPOFFSET:
2454:openstack/02a-MAClow/IEEE802154Ecsl.c ****          debugpins_fsm_clr();
 5722              		.loc 1 2454 0
 5723 2732 FFF7FEFF 		bl	debugpins_fsm_clr
2455:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 5724              		.loc 1 2455 0
 5725 2736 02E0     		b	.L267
 5726              	.L271:
2456:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2457:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // ------- TX STATES -------
2458:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2459:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Estados usados para la transmisión de tramas WAKE-UP previas a la trama de datos (Wake-Up
2460:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXWAKEUPPREPARE:
2461:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXWAKEUPREADY:
2462:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXWAKEUPDELAY:
2463:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXWAKEUP:
2464:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2465:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Estados usados para la transmisión del paquete de datos y la recepción del ACK.
2466:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXDATAPREPARE:
2467:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXDATAREADY:
2468:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXDATADELAY:
2469:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXDATA:
2470:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2471:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXACKOFFSET:
2472:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXACKPREPARE:
2473:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXACKREADY:
2474:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXACKLISTEN:
2475:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXACK:
2476:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXPROC:
2477:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2478:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // ------- RX STATES -------
2479:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2480:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Estados usados para la recepción y tratamiento de la trama de WAKE-UP.
2481:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXWAKEUPPREPARE:
2482:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXWAKEUPREADY:
2483:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXWAKEUPLISTEN:
2484:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXWAKEUP:
2485:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXWAKEUPVALIDATE:
2486:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2487:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Estados usados para la recepción del paquete de datos y la transmisión del ACK.
2488:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXDATAPREPARE:
2489:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXDATAREADY:
2490:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXDATALISTEN:
2491:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXDATA:
2492:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2493:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXACKOFFSET:
2494:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXACKPREPARE:
2495:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXACKREADY:
2496:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXACKDELAY:
2497:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXACK:
2498:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXPROC:
2499:openstack/02a-MAClow/IEEE802154Ecsl.c ****          debugpins_fsm_toggle();
 5727              		.loc 1 2499 0
 5728 2738 FFF7FEFF 		bl	debugpins_fsm_toggle
2500:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 5729              		.loc 1 2500 0
 5730 273c 00BF     		nop
 5731              	.L267:
2501:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2502:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5732              		.loc 1 2502 0
 5733 273e 07F10807 		add	r7, r7, #8
 5734 2742 BD46     		mov	sp, r7
 5735 2744 80BD     		pop	{r7, pc}
 5736              		.cfi_endproc
 5737              	.LFE64:
 5739 2746 00BF     		.align	2
 5740              		.global	debugPrint_asn
 5741              		.thumb
 5742              		.thumb_func
 5744              	debugPrint_asn:
 5745              	.LFB65:
2503:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2504:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2505:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Trigger this module to print status information, over serial.
2506:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2507:openstack/02a-MAClow/IEEE802154Ecsl.c **** debugPrint_* functions are used by the openserial module to continuously print
2508:openstack/02a-MAClow/IEEE802154Ecsl.c **** status information about several modules in the OpenWSN stack.
2509:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2510:openstack/02a-MAClow/IEEE802154Ecsl.c **** \returns TRUE if this function printed something, FALSE otherwise.
2511:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2512:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool debugPrint_asn() {
 5746              		.loc 1 2512 0
 5747              		.cfi_startproc
 5748              		@ args = 0, pretend = 0, frame = 8
 5749              		@ frame_needed = 1, uses_anonymous_args = 0
 5750 2748 80B5     		push	{r7, lr}
 5751              	.LCFI159:
 5752              		.cfi_def_cfa_offset 8
 5753              		.cfi_offset 7, -8
 5754              		.cfi_offset 14, -4
 5755 274a 82B0     		sub	sp, sp, #8
 5756              	.LCFI160:
 5757              		.cfi_def_cfa_offset 16
 5758 274c 00AF     		add	r7, sp, #0
 5759              	.LCFI161:
 5760              		.cfi_def_cfa_register 7
2513:openstack/02a-MAClow/IEEE802154Ecsl.c ****    asn_t output;
2514:openstack/02a-MAClow/IEEE802154Ecsl.c ****    output.byte4         =  ieee154e_vars.asn.byte4;
 5761              		.loc 1 2514 0
 5762 274e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5763 2752 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5764 2756 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 5765 2758 3B70     		strb	r3, [r7, #0]
2515:openstack/02a-MAClow/IEEE802154Ecsl.c ****    output.bytes2and3    =  ieee154e_vars.asn.bytes2and3;
 5766              		.loc 1 2515 0
 5767 275a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5768 275e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5769 2762 B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 5770 2766 9BB2     		uxth	r3, r3
 5771 2768 A7F80130 		strh	r3, [r7, #1]	@ unaligned
2516:openstack/02a-MAClow/IEEE802154Ecsl.c ****    output.bytes0and1    =  ieee154e_vars.asn.bytes0and1;
 5772              		.loc 1 2516 0
 5773 276c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5774 2770 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5775 2774 B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 5776 2778 9BB2     		uxth	r3, r3
 5777 277a A7F80330 		strh	r3, [r7, #3]	@ unaligned
2517:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printStatus(STATUS_ASN,(uint8_t*)&output,sizeof(output));
 5778              		.loc 1 2517 0
 5779 277e 3B46     		mov	r3, r7
 5780 2780 4FF00400 		mov	r0, #4
 5781 2784 1946     		mov	r1, r3
 5782 2786 4FF00502 		mov	r2, #5
 5783 278a FFF7FEFF 		bl	openserial_printStatus
2518:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return TRUE;
 5784              		.loc 1 2518 0
 5785 278e 4FF00103 		mov	r3, #1
2519:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5786              		.loc 1 2519 0
 5787 2792 1846     		mov	r0, r3
 5788 2794 07F10807 		add	r7, r7, #8
 5789 2798 BD46     		mov	sp, r7
 5790 279a 80BD     		pop	{r7, pc}
 5791              		.cfi_endproc
 5792              	.LFE65:
 5794              		.align	2
 5795              		.global	debugPrint_isSync
 5796              		.thumb
 5797              		.thumb_func
 5799              	debugPrint_isSync:
 5800              	.LFB66:
2520:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2521:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2522:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Trigger this module to print status information, over serial.
2523:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2524:openstack/02a-MAClow/IEEE802154Ecsl.c **** debugPrint_* functions are used by the openserial module to continuously print
2525:openstack/02a-MAClow/IEEE802154Ecsl.c **** status information about several modules in the OpenWSN stack.
2526:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2527:openstack/02a-MAClow/IEEE802154Ecsl.c **** \returns TRUE if this function printed something, FALSE otherwise.
2528:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2529:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool debugPrint_isSync() {
 5801              		.loc 1 2529 0
 5802              		.cfi_startproc
 5803              		@ args = 0, pretend = 0, frame = 8
 5804              		@ frame_needed = 1, uses_anonymous_args = 0
 5805 279c 80B5     		push	{r7, lr}
 5806              	.LCFI162:
 5807              		.cfi_def_cfa_offset 8
 5808              		.cfi_offset 7, -8
 5809              		.cfi_offset 14, -4
 5810 279e 82B0     		sub	sp, sp, #8
 5811              	.LCFI163:
 5812              		.cfi_def_cfa_offset 16
 5813 27a0 00AF     		add	r7, sp, #0
 5814              	.LCFI164:
 5815              		.cfi_def_cfa_register 7
2530:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t output=0;
 5816              		.loc 1 2530 0
 5817 27a2 4FF00003 		mov	r3, #0
 5818 27a6 FB71     		strb	r3, [r7, #7]
2531:openstack/02a-MAClow/IEEE802154Ecsl.c ****    output = ieee154e_vars.isSync;
 5819              		.loc 1 2531 0
 5820 27a8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5821 27ac C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5822 27b0 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
 5823 27b2 FB71     		strb	r3, [r7, #7]
2532:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printStatus(STATUS_ISSYNC,(uint8_t*)&output,sizeof(uint8_t));
 5824              		.loc 1 2532 0
 5825 27b4 07F10703 		add	r3, r7, #7
 5826 27b8 4FF00000 		mov	r0, #0
 5827 27bc 1946     		mov	r1, r3
 5828 27be 4FF00102 		mov	r2, #1
 5829 27c2 FFF7FEFF 		bl	openserial_printStatus
2533:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return TRUE;
 5830              		.loc 1 2533 0
 5831 27c6 4FF00103 		mov	r3, #1
2534:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5832              		.loc 1 2534 0
 5833 27ca 1846     		mov	r0, r3
 5834 27cc 07F10807 		add	r7, r7, #8
 5835 27d0 BD46     		mov	sp, r7
 5836 27d2 80BD     		pop	{r7, pc}
 5837              		.cfi_endproc
 5838              	.LFE66:
 5840              		.align	2
 5841              		.global	debugPrint_macStats
 5842              		.thumb
 5843              		.thumb_func
 5845              	debugPrint_macStats:
 5846              	.LFB67:
2535:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2536:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2537:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Trigger this module to print status information, over serial.
2538:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2539:openstack/02a-MAClow/IEEE802154Ecsl.c **** debugPrint_* functions are used by the openserial module to continuously print
2540:openstack/02a-MAClow/IEEE802154Ecsl.c **** status information about several modules in the OpenWSN stack.
2541:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2542:openstack/02a-MAClow/IEEE802154Ecsl.c **** \returns TRUE if this function printed something, FALSE otherwise.
2543:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2544:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool debugPrint_macStats() {
 5847              		.loc 1 2544 0
 5848              		.cfi_startproc
 5849              		@ args = 0, pretend = 0, frame = 0
 5850              		@ frame_needed = 1, uses_anonymous_args = 0
 5851 27d4 80B5     		push	{r7, lr}
 5852              	.LCFI165:
 5853              		.cfi_def_cfa_offset 8
 5854              		.cfi_offset 7, -8
 5855              		.cfi_offset 14, -4
 5856 27d6 00AF     		add	r7, sp, #0
 5857              	.LCFI166:
 5858              		.cfi_def_cfa_register 7
2545:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // send current stats over serial
2546:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printStatus(STATUS_MACSTATS,(uint8_t*)&ieee154e_stats,sizeof(ieee154e_stats_t));
 5859              		.loc 1 2546 0
 5860 27d8 4FF00500 		mov	r0, #5
 5861 27dc 40F20001 		movw	r1, #:lower16:ieee154e_stats
 5862 27e0 C0F20001 		movt	r1, #:upper16:ieee154e_stats
 5863 27e4 4FF00F02 		mov	r2, #15
 5864 27e8 FFF7FEFF 		bl	openserial_printStatus
2547:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return TRUE;
 5865              		.loc 1 2547 0
 5866 27ec 4FF00103 		mov	r3, #1
2548:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5867              		.loc 1 2548 0
 5868 27f0 1846     		mov	r0, r3
 5869 27f2 80BD     		pop	{r7, pc}
 5870              		.cfi_endproc
 5871              	.LFE67:
 5873              		.align	2
 5874              		.global	endOps
 5875              		.thumb
 5876              		.thumb_func
 5878              	endOps:
 5879              	.LFB68:
2549:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2550:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2551:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2552:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Housekeeping tasks to do at the end of each slot.
2553:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2554:openstack/02a-MAClow/IEEE802154Ecsl.c **** This functions is called once in each slot, when there is nothing more
2555:openstack/02a-MAClow/IEEE802154Ecsl.c **** to do. This might be when an error occured, or when everything went well.
2556:openstack/02a-MAClow/IEEE802154Ecsl.c **** This function resets the state of the FSM so it is ready for the next slot.
2557:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2558:openstack/02a-MAClow/IEEE802154Ecsl.c **** Note that by the time this function is called, any received packet should already
2559:openstack/02a-MAClow/IEEE802154Ecsl.c **** have been sent to the upper layer. Similarly, in a Tx slot, the sendDone
2560:openstack/02a-MAClow/IEEE802154Ecsl.c **** function should already have been done. If this is not the case, this function
2561:openstack/02a-MAClow/IEEE802154Ecsl.c **** will do that for you, but assume that something went wrong.
2562:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2563:openstack/02a-MAClow/IEEE802154Ecsl.c **** void endOps() {
 5880              		.loc 1 2563 0
 5881              		.cfi_startproc
 5882              		@ args = 0, pretend = 0, frame = 0
 5883              		@ frame_needed = 1, uses_anonymous_args = 0
 5884 27f4 80B5     		push	{r7, lr}
 5885              	.LCFI167:
 5886              		.cfi_def_cfa_offset 8
 5887              		.cfi_offset 7, -8
 5888              		.cfi_offset 14, -4
 5889 27f6 00AF     		add	r7, sp, #0
 5890              	.LCFI168:
 5891              		.cfi_def_cfa_register 7
2564:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2565:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // turn off the radio
2566:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rfOff();
 5892              		.loc 1 2566 0
 5893 27f8 FFF7FEFF 		bl	radio_rfOff
2567:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2568:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clear any pending timer
2569:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 5894              		.loc 1 2569 0
 5895 27fc FFF7FEFF 		bl	radiotimer_cancel
2570:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2571:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // reset capturedTimes
2572:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.lastCapturedTime = 0;
 5896              		.loc 1 2572 0
 5897 2800 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5898 2804 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5899 2808 4FF00002 		mov	r2, #0
 5900 280c 5A62     		str	r2, [r3, #36]
2573:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.syncCapturedTime = 0;
 5901              		.loc 1 2573 0
 5902 280e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5903 2812 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5904 2816 4FF00002 		mov	r2, #0
 5905 281a 9A62     		str	r2, [r3, #40]
2574:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2575:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //clear vars for duty cycle on this slot
2576:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnTics=0;
 5906              		.loc 1 2576 0
 5907 281c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5908 2820 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5909 2824 4FF00002 		mov	r2, #0
 5910 2828 5A63     		str	r2, [r3, #52]
2577:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnThisSlot=FALSE;
 5911              		.loc 1 2577 0
 5912 282a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5913 282e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5914 2832 4FF00002 		mov	r2, #0
 5915 2836 83F83820 		strb	r2, [r3, #56]
2578:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2579:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clean up dataToSend
2580:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.dataToSend!=NULL) {
 5916              		.loc 1 2580 0
 5917 283a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5918 283e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5919 2842 5B69     		ldr	r3, [r3, #20]
 5920 2844 002B     		cmp	r3, #0
 5921 2846 33D0     		beq	.L280
2581:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // if everything went well, dataToSend was set to NULL in ti9
2582:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // getting here means transmit failed
2583:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2584:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // indicate Tx fail to schedule to update stats
2585:openstack/02a-MAClow/IEEE802154Ecsl.c ****       schedule_indicateTx(&ieee154e_vars.asn,FALSE);
 5922              		.loc 1 2585 0
 5923 2848 40F20000 		movw	r0, #:lower16:ieee154e_vars
 5924 284c C0F20000 		movt	r0, #:upper16:ieee154e_vars
 5925 2850 4FF00001 		mov	r1, #0
 5926 2854 FFF7FEFF 		bl	schedule_indicateTx
2586:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2587:openstack/02a-MAClow/IEEE802154Ecsl.c ****       //decrement transmits left counter
2588:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataToSend->l2_retriesLeft--;
 5927              		.loc 1 2588 0
 5928 2858 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5929 285c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5930 2860 5B69     		ldr	r3, [r3, #20]
 5931 2862 93F84B20 		ldrb	r2, [r3, #75]	@ zero_extendqisi2
 5932 2866 02F1FF32 		add	r2, r2, #-1
 5933 286a D2B2     		uxtb	r2, r2
 5934 286c 83F84B20 		strb	r2, [r3, #75]
2589:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2590:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.dataToSend->l2_retriesLeft==0) {
 5935              		.loc 1 2590 0
 5936 2870 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5937 2874 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5938 2878 5B69     		ldr	r3, [r3, #20]
 5939 287a 93F84B30 		ldrb	r3, [r3, #75]	@ zero_extendqisi2
 5940 287e 002B     		cmp	r3, #0
 5941 2880 07D0     		beq	.L281
2591:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 // CSL TEST CODE (comment)
2592:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // indicate tx fail if no more retries left
2593:openstack/02a-MAClow/IEEE802154Ecsl.c ****          //notif_sendDone(ieee154e_vars.dataToSend,E_FAIL);
2594:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 // END TEST CODE
2595:openstack/02a-MAClow/IEEE802154Ecsl.c ****       } else {
2596:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // return packet to the virtual COMPONENT_SIXTOP_TO_IEEE802154E component
2597:openstack/02a-MAClow/IEEE802154Ecsl.c ****          ieee154e_vars.dataToSend->owner = COMPONENT_SIXTOP_TO_IEEE802154E;
 5942              		.loc 1 2597 0
 5943 2882 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5944 2886 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5945 288a 5B69     		ldr	r3, [r3, #20]
 5946 288c 4FF00A02 		mov	r2, #10
 5947 2890 5A70     		strb	r2, [r3, #1]
 5948              	.L281:
2598:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
2599:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2600:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // CSL - Remove packet for testing because no high entity for packet processing.
2601:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openqueue_freePacketBuffer(ieee154e_vars.dataToSend);
 5949              		.loc 1 2601 0
 5950 2892 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5951 2896 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5952 289a 5B69     		ldr	r3, [r3, #20]
 5953 289c 1846     		mov	r0, r3
 5954 289e FFF7FEFF 		bl	openqueue_freePacketBuffer
2602:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2603:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset local variable
2604:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataToSend = NULL;
 5955              		.loc 1 2604 0
 5956 28a2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5957 28a6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5958 28aa 4FF00002 		mov	r2, #0
 5959 28ae 5A61     		str	r2, [r3, #20]
 5960              	.L280:
2605:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2606:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2607:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clean up dataReceived
2608:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.dataReceived!=NULL) {
 5961              		.loc 1 2608 0
 5962 28b0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5963 28b4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5964 28b8 9B69     		ldr	r3, [r3, #24]
 5965 28ba 002B     		cmp	r3, #0
 5966 28bc 18D0     		beq	.L282
2609:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // assume something went wrong. If everything went well, dataReceived
2610:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // would have been set to NULL in ri9.
2611:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // indicate  "received packet" to upper layer since we don't want to loose packets
2612:openstack/02a-MAClow/IEEE802154Ecsl.c ****       notif_receive(ieee154e_vars.dataReceived,4);
 5967              		.loc 1 2612 0
 5968 28be 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5969 28c2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5970 28c6 9B69     		ldr	r3, [r3, #24]
 5971 28c8 1846     		mov	r0, r3
 5972 28ca 4FF00401 		mov	r1, #4
 5973 28ce FFF7FEFF 		bl	notif_receive
2613:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2614:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // CSL - Remove packet for testing because no high entity for packet processing.
2615:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openqueue_freePacketBuffer(ieee154e_vars.dataReceived);
 5974              		.loc 1 2615 0
 5975 28d2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5976 28d6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5977 28da 9B69     		ldr	r3, [r3, #24]
 5978 28dc 1846     		mov	r0, r3
 5979 28de FFF7FEFF 		bl	openqueue_freePacketBuffer
2616:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2617:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset local variable
2618:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataReceived = NULL;
 5980              		.loc 1 2618 0
 5981 28e2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5982 28e6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5983 28ea 4FF00002 		mov	r2, #0
 5984 28ee 9A61     		str	r2, [r3, #24]
 5985              	.L282:
2619:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2620:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2621:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clean up ackToSend
2622:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.ackToSend!=NULL) {
 5986              		.loc 1 2622 0
 5987 28f0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5988 28f4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5989 28f8 DB69     		ldr	r3, [r3, #28]
 5990 28fa 002B     		cmp	r3, #0
 5991 28fc 0ED0     		beq	.L283
2623:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // free ackToSend so corresponding RAM memory can be recycled
2624:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openqueue_freePacketBuffer(ieee154e_vars.ackToSend);
 5992              		.loc 1 2624 0
 5993 28fe 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5994 2902 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5995 2906 DB69     		ldr	r3, [r3, #28]
 5996 2908 1846     		mov	r0, r3
 5997 290a FFF7FEFF 		bl	openqueue_freePacketBuffer
2625:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset local variable
2626:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.ackToSend = NULL;
 5998              		.loc 1 2626 0
 5999 290e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6000 2912 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6001 2916 4FF00002 		mov	r2, #0
 6002 291a DA61     		str	r2, [r3, #28]
 6003              	.L283:
2627:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2628:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2629:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clean up ackReceived
2630:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.ackReceived!=NULL) {
 6004              		.loc 1 2630 0
 6005 291c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6006 2920 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6007 2924 1B6A     		ldr	r3, [r3, #32]
 6008 2926 002B     		cmp	r3, #0
 6009 2928 0ED0     		beq	.L284
2631:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // free ackReceived so corresponding RAM memory can be recycled
2632:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openqueue_freePacketBuffer(ieee154e_vars.ackReceived);
 6010              		.loc 1 2632 0
 6011 292a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6012 292e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6013 2932 1B6A     		ldr	r3, [r3, #32]
 6014 2934 1846     		mov	r0, r3
 6015 2936 FFF7FEFF 		bl	openqueue_freePacketBuffer
2633:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset local variable
2634:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.ackReceived = NULL;
 6016              		.loc 1 2634 0
 6017 293a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6018 293e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6019 2942 4FF00002 		mov	r2, #0
 6020 2946 1A62     		str	r2, [r3, #32]
 6021              	.L284:
2635:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2636:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2637:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clean up wakeupSend
2638:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.wakeupToSend!=NULL) {
 6022              		.loc 1 2638 0
 6023 2948 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6024 294c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6025 2950 DB6B     		ldr	r3, [r3, #60]
 6026 2952 002B     		cmp	r3, #0
 6027 2954 0ED0     		beq	.L285
2639:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // free wakeupToSend so corresponding RAM memory can be recycled
2640:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openqueue_freePacketBuffer(ieee154e_vars.wakeupToSend);
 6028              		.loc 1 2640 0
 6029 2956 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6030 295a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6031 295e DB6B     		ldr	r3, [r3, #60]
 6032 2960 1846     		mov	r0, r3
 6033 2962 FFF7FEFF 		bl	openqueue_freePacketBuffer
2641:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset local variable
2642:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.wakeupToSend = NULL;
 6034              		.loc 1 2642 0
 6035 2966 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6036 296a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6037 296e 4FF00002 		mov	r2, #0
 6038 2972 DA63     		str	r2, [r3, #60]
 6039              	.L285:
2643:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2644:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2645:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clean up wakeupReceived
2646:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.wakeupReceived !=NULL) {
 6040              		.loc 1 2646 0
 6041 2974 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6042 2978 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6043 297c 1B6C     		ldr	r3, [r3, #64]
 6044 297e 002B     		cmp	r3, #0
 6045 2980 0ED0     		beq	.L286
2647:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // free wakeupReceived so corresponding RAM memory can be recycled
2648:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openqueue_freePacketBuffer(ieee154e_vars.wakeupReceived);
 6046              		.loc 1 2648 0
 6047 2982 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6048 2986 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6049 298a 1B6C     		ldr	r3, [r3, #64]
 6050 298c 1846     		mov	r0, r3
 6051 298e FFF7FEFF 		bl	openqueue_freePacketBuffer
2649:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset local variable
2650:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.wakeupReceived = NULL;
 6052              		.loc 1 2650 0
 6053 2992 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6054 2996 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6055 299a 4FF00002 		mov	r2, #0
 6056 299e 1A64     		str	r2, [r3, #64]
 6057              	.L286:
2651:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2652:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2653:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
2654:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_SLEEP);
 6058              		.loc 1 2654 0
 6059 29a0 4FF00000 		mov	r0, #0
 6060 29a4 FFF7FEFF 		bl	changeState
2655:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2656:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // update CSL Mode to SLEEP in order to allow new TX or RX.
2657:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.cslMode = CSL_SLEEP_MODE;
 6061              		.loc 1 2657 0
 6062 29a8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6063 29ac C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6064 29b0 4FF00002 		mov	r2, #0
 6065 29b4 83F84520 		strb	r2, [r3, #69]
2658:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2659:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 6066              		.loc 1 2659 0
 6067 29b8 80BD     		pop	{r7, pc}
 6068              		.cfi_endproc
 6069              	.LFE68:
 6071 29ba 00BF     		.align	2
 6072              		.global	ieee154e_isSynch
 6073              		.thumb
 6074              		.thumb_func
 6076              	ieee154e_isSynch:
 6077              	.LFB69:
2660:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2661:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool ieee154e_isSynch(){
 6078              		.loc 1 2661 0
 6079              		.cfi_startproc
 6080              		@ args = 0, pretend = 0, frame = 0
 6081              		@ frame_needed = 1, uses_anonymous_args = 0
 6082              		@ link register save eliminated.
 6083 29bc 80B4     		push	{r7}
 6084              	.LCFI169:
 6085              		.cfi_def_cfa_offset 4
 6086              		.cfi_offset 7, -4
 6087 29be 00AF     		add	r7, sp, #0
 6088              	.LCFI170:
 6089              		.cfi_def_cfa_register 7
2662:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee154e_vars.isSync;
 6090              		.loc 1 2662 0
 6091 29c0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6092 29c4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6093 29c8 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
2663:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 6094              		.loc 1 2663 0
 6095 29ca 1846     		mov	r0, r3
 6096 29cc BD46     		mov	sp, r7
 6097 29ce 80BC     		pop	{r7}
 6098 29d0 7047     		bx	lr
 6099              		.cfi_endproc
 6100              	.LFE69:
 6102 29d2 00BF     		.align	2
 6103              		.global	ieee154e_processIEs
 6104              		.thumb
 6105              		.thumb_func
 6107              	ieee154e_processIEs:
 6108              	.LFB70:
2664:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2665:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE bool ieee154e_processIEs(OpenQueueEntry_t* pkt, uint16_t* lenIE) {
 6109              		.loc 1 2665 0
 6110              		.cfi_startproc
 6111              		@ args = 0, pretend = 0, frame = 32
 6112              		@ frame_needed = 1, uses_anonymous_args = 0
 6113 29d4 80B5     		push	{r7, lr}
 6114              	.LCFI171:
 6115              		.cfi_def_cfa_offset 8
 6116              		.cfi_offset 7, -8
 6117              		.cfi_offset 14, -4
 6118 29d6 88B0     		sub	sp, sp, #32
 6119              	.LCFI172:
 6120              		.cfi_def_cfa_offset 40
 6121 29d8 00AF     		add	r7, sp, #0
 6122              	.LCFI173:
 6123              		.cfi_def_cfa_register 7
 6124 29da 7860     		str	r0, [r7, #4]
 6125 29dc 3960     		str	r1, [r7, #0]
2666:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t               ptr;
2667:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t               byte0;
2668:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t               byte1;
2669:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t               temp_8b;
2670:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t               gr_elem_id;
2671:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t               subid;
2672:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint16_t              temp_16b;
2673:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint16_t              len;
2674:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint16_t              sublen;
2675:openstack/02a-MAClow/IEEE802154Ecsl.c ****    PORT_SIGNED_INT_WIDTH timeCorrection;
2676:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2677:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ptr=0;
 6126              		.loc 1 2677 0
 6127 29de 4FF00003 		mov	r3, #0
 6128 29e2 FB73     		strb	r3, [r7, #15]
2678:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2679:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //===== header or payload IE header
2680:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2681:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //candidate IE header  if type ==0 header IE if type==1 payload IE
2682:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_8b    = *((uint8_t*)(pkt->payload)+ptr);
 6129              		.loc 1 2682 0
 6130 29e4 7B68     		ldr	r3, [r7, #4]
 6131 29e6 5A68     		ldr	r2, [r3, #4]
 6132 29e8 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6133 29ea D318     		adds	r3, r2, r3
 6134 29ec 1B78     		ldrb	r3, [r3, #0]
 6135 29ee 7B76     		strb	r3, [r7, #25]
2683:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ptr++;
 6136              		.loc 1 2683 0
 6137 29f0 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6138 29f2 03F10103 		add	r3, r3, #1
 6139 29f6 DBB2     		uxtb	r3, r3
 6140 29f8 FB73     		strb	r3, [r7, #15]
2684:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2685:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_16b   = temp_8b + ((*((uint8_t*)(pkt->payload)+ptr))<< 8);
 6141              		.loc 1 2685 0
 6142 29fa 7B7E     		ldrb	r3, [r7, #25]	@ zero_extendqisi2
 6143 29fc 9AB2     		uxth	r2, r3
 6144 29fe 7B68     		ldr	r3, [r7, #4]
 6145 2a00 5968     		ldr	r1, [r3, #4]
 6146 2a02 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6147 2a04 CB18     		adds	r3, r1, r3
 6148 2a06 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 6149 2a08 4FEA0323 		lsl	r3, r3, #8
 6150 2a0c 9BB2     		uxth	r3, r3
 6151 2a0e D318     		adds	r3, r2, r3
 6152 2a10 FB82     		strh	r3, [r7, #22]	@ movhi
2686:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ptr++;
 6153              		.loc 1 2686 0
 6154 2a12 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6155 2a14 03F10103 		add	r3, r3, #1
 6156 2a18 DBB2     		uxtb	r3, r3
 6157 2a1a FB73     		strb	r3, [r7, #15]
2687:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2688:openstack/02a-MAClow/IEEE802154Ecsl.c ****    *lenIE     = ptr;
 6158              		.loc 1 2688 0
 6159 2a1c FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6160 2a1e 1A46     		mov	r2, r3
 6161 2a20 3B68     		ldr	r3, [r7, #0]
 6162 2a22 1A80     		strh	r2, [r3, #0]	@ movhi
2689:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2690:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b & IEEE802154E_DESC_TYPE_PAYLOAD_IE) == IEEE802154E_DESC_TYPE_PAYLOAD_IE){
 6163              		.loc 1 2690 0
 6164 2a24 FB8A     		ldrh	r3, [r7, #22]
 6165 2a26 03F00103 		and	r3, r3, #1
 6166 2a2a 002B     		cmp	r3, #0
 6167 2a2c 0AD0     		beq	.L290
2691:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // payload IE
2692:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2693:openstack/02a-MAClow/IEEE802154Ecsl.c ****       len          = (temp_16b & IEEE802154E_DESC_LEN_PAYLOAD_IE_MASK)>>IEEE802154E_DESC_LEN_PAYLOA
 6168              		.loc 1 2693 0
 6169 2a2e FB8A     		ldrh	r3, [r7, #22]
 6170 2a30 4FEA5313 		lsr	r3, r3, #5
 6171 2a34 BB83     		strh	r3, [r7, #28]	@ movhi
2694:openstack/02a-MAClow/IEEE802154Ecsl.c ****       gr_elem_id   = (temp_16b & IEEE802154E_DESC_GROUPID_PAYLOAD_IE_MASK)>>IEEE802154E_DESC_GROUPI
 6172              		.loc 1 2694 0
 6173 2a36 FB8A     		ldrh	r3, [r7, #22]
 6174 2a38 03F01E03 		and	r3, r3, #30
 6175 2a3c 4FEA6303 		asr	r3, r3, #1
 6176 2a40 FB77     		strb	r3, [r7, #31]
 6177 2a42 09E0     		b	.L291
 6178              	.L290:
2695:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
2696:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // header IE
2697:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2698:openstack/02a-MAClow/IEEE802154Ecsl.c ****       len          = (temp_16b & IEEE802154E_DESC_LEN_HEADER_IE_MASK)>>IEEE802154E_DESC_LEN_HEADER_
 6179              		.loc 1 2698 0
 6180 2a44 FB8A     		ldrh	r3, [r7, #22]
 6181 2a46 4FEA5323 		lsr	r3, r3, #9
 6182 2a4a BB83     		strh	r3, [r7, #28]	@ movhi
2699:openstack/02a-MAClow/IEEE802154Ecsl.c ****       gr_elem_id   = (temp_16b & IEEE802154E_DESC_ELEMENTID_HEADER_IE_MASK)>>IEEE802154E_DESC_ELEME
 6183              		.loc 1 2699 0
 6184 2a4c FB8A     		ldrh	r3, [r7, #22]
 6185 2a4e 03F4FF73 		and	r3, r3, #510
 6186 2a52 4FEA6303 		asr	r3, r3, #1
 6187 2a56 FB77     		strb	r3, [r7, #31]
 6188              	.L291:
2700:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2701:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2702:openstack/02a-MAClow/IEEE802154Ecsl.c ****    *lenIE         += len;
 6189              		.loc 1 2702 0
 6190 2a58 3B68     		ldr	r3, [r7, #0]
 6191 2a5a 1A88     		ldrh	r2, [r3, #0]
 6192 2a5c BB8B     		ldrh	r3, [r7, #28]	@ movhi
 6193 2a5e D318     		adds	r3, r2, r3
 6194 2a60 9AB2     		uxth	r2, r3
 6195 2a62 3B68     		ldr	r3, [r7, #0]
 6196 2a64 1A80     		strh	r2, [r3, #0]	@ movhi
2703:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2704:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //===== sub-elements
2705:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2706:openstack/02a-MAClow/IEEE802154Ecsl.c ****    switch(gr_elem_id){
 6197              		.loc 1 2706 0
 6198 2a66 FB7F     		ldrb	r3, [r7, #31]	@ zero_extendqisi2
 6199 2a68 012B     		cmp	r3, #1
 6200 2a6a 02D0     		beq	.L293
 6201 2a6c 1E2B     		cmp	r3, #30
 6202 2a6e 78D0     		beq	.L294
 6203 2a70 BEE0     		b	.L308
 6204              	.L293:
2707:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2708:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case IEEE802154E_MLME_IE_GROUPID:
2709:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // MLME IE
2710:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2711:openstack/02a-MAClow/IEEE802154Ecsl.c ****          do {
2712:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2713:openstack/02a-MAClow/IEEE802154Ecsl.c ****             //read sub IE header
2714:openstack/02a-MAClow/IEEE802154Ecsl.c ****             temp_8b     = *((uint8_t*)(pkt->payload)+ptr);
 6205              		.loc 1 2714 0
 6206 2a72 7B68     		ldr	r3, [r7, #4]
 6207 2a74 5A68     		ldr	r2, [r3, #4]
 6208 2a76 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6209 2a78 D318     		adds	r3, r2, r3
 6210 2a7a 1B78     		ldrb	r3, [r3, #0]
 6211 2a7c 7B76     		strb	r3, [r7, #25]
2715:openstack/02a-MAClow/IEEE802154Ecsl.c ****             ptr         = ptr + 1;
 6212              		.loc 1 2715 0
 6213 2a7e FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6214 2a80 03F10103 		add	r3, r3, #1
 6215 2a84 DBB2     		uxtb	r3, r3
 6216 2a86 FB73     		strb	r3, [r7, #15]
2716:openstack/02a-MAClow/IEEE802154Ecsl.c ****             temp_16b    = temp_8b  +(*((uint8_t*)(pkt->payload)+ptr) << 8);
 6217              		.loc 1 2716 0
 6218 2a88 7B7E     		ldrb	r3, [r7, #25]	@ zero_extendqisi2
 6219 2a8a 9AB2     		uxth	r2, r3
 6220 2a8c 7B68     		ldr	r3, [r7, #4]
 6221 2a8e 5968     		ldr	r1, [r3, #4]
 6222 2a90 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6223 2a92 CB18     		adds	r3, r1, r3
 6224 2a94 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 6225 2a96 4FEA0323 		lsl	r3, r3, #8
 6226 2a9a 9BB2     		uxth	r3, r3
 6227 2a9c D318     		adds	r3, r2, r3
 6228 2a9e FB82     		strh	r3, [r7, #22]	@ movhi
2717:openstack/02a-MAClow/IEEE802154Ecsl.c ****             ptr         = ptr + 1;
 6229              		.loc 1 2717 0
 6230 2aa0 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6231 2aa2 03F10103 		add	r3, r3, #1
 6232 2aa6 DBB2     		uxtb	r3, r3
 6233 2aa8 FB73     		strb	r3, [r7, #15]
2718:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2719:openstack/02a-MAClow/IEEE802154Ecsl.c ****             len         = len - 2; //remove header fields len
 6234              		.loc 1 2719 0
 6235 2aaa BB8B     		ldrh	r3, [r7, #28]	@ movhi
 6236 2aac A3F10203 		sub	r3, r3, #2
 6237 2ab0 BB83     		strh	r3, [r7, #28]	@ movhi
2720:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2721:openstack/02a-MAClow/IEEE802154Ecsl.c ****             if ((temp_16b & IEEE802154E_DESC_TYPE_LONG) == IEEE802154E_DESC_TYPE_LONG){
 6238              		.loc 1 2721 0
 6239 2ab2 FB8A     		ldrh	r3, [r7, #22]
 6240 2ab4 03F00103 		and	r3, r3, #1
 6241 2ab8 002B     		cmp	r3, #0
 6242 2aba 0AD0     		beq	.L295
2722:openstack/02a-MAClow/IEEE802154Ecsl.c ****                // long sub-IE
2723:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2724:openstack/02a-MAClow/IEEE802154Ecsl.c ****                sublen   = (temp_16b & IEEE802154E_DESC_LEN_LONG_MLME_IE_MASK)>>IEEE802154E_DESC_LEN
 6243              		.loc 1 2724 0
 6244 2abc FB8A     		ldrh	r3, [r7, #22]
 6245 2abe 4FEA5313 		lsr	r3, r3, #5
 6246 2ac2 7B83     		strh	r3, [r7, #26]	@ movhi
2725:openstack/02a-MAClow/IEEE802154Ecsl.c ****                subid    = (temp_16b & IEEE802154E_DESC_SUBID_LONG_MLME_IE_MASK)>>IEEE802154E_DESC_S
 6247              		.loc 1 2725 0
 6248 2ac4 FB8A     		ldrh	r3, [r7, #22]
 6249 2ac6 03F01E03 		and	r3, r3, #30
 6250 2aca 4FEA6303 		asr	r3, r3, #1
 6251 2ace BB77     		strb	r3, [r7, #30]
 6252 2ad0 09E0     		b	.L296
 6253              	.L295:
2726:openstack/02a-MAClow/IEEE802154Ecsl.c ****             } else {
2727:openstack/02a-MAClow/IEEE802154Ecsl.c ****                // short sub-IE
2728:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2729:openstack/02a-MAClow/IEEE802154Ecsl.c ****                sublen   = (temp_16b & IEEE802154E_DESC_LEN_SHORT_MLME_IE_MASK)>>IEEE802154E_DESC_LE
 6254              		.loc 1 2729 0
 6255 2ad2 FB8A     		ldrh	r3, [r7, #22]
 6256 2ad4 4FEA1323 		lsr	r3, r3, #8
 6257 2ad8 7B83     		strh	r3, [r7, #26]	@ movhi
2730:openstack/02a-MAClow/IEEE802154Ecsl.c ****                subid    = (temp_16b & IEEE802154E_DESC_SUBID_SHORT_MLME_IE_MASK)>>IEEE802154E_DESC_
 6258              		.loc 1 2730 0
 6259 2ada FB8A     		ldrh	r3, [r7, #22]
 6260 2adc 03F0FE03 		and	r3, r3, #254
 6261 2ae0 4FEA6303 		asr	r3, r3, #1
 6262 2ae4 BB77     		strb	r3, [r7, #30]
 6263              	.L296:
2731:openstack/02a-MAClow/IEEE802154Ecsl.c ****             }
2732:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2733:openstack/02a-MAClow/IEEE802154Ecsl.c ****             switch(subid){
 6264              		.loc 1 2733 0
 6265 2ae6 BB7F     		ldrb	r3, [r7, #30]	@ zero_extendqisi2
 6266 2ae8 1B2B     		cmp	r3, #27
 6267 2aea 25D0     		beq	.L299
 6268 2aec 1C2B     		cmp	r3, #28
 6269 2aee 2DD0     		beq	.L310
 6270 2af0 1A2B     		cmp	r3, #26
 6271 2af2 28D1     		bne	.L309
 6272              	.L298:
2734:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2735:openstack/02a-MAClow/IEEE802154Ecsl.c ****                case IEEE802154E_MLME_SYNC_IE_SUBID:
2736:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   // Sync IE: ASN and Join Priority
2737:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2738:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   if (idmanager_getIsDAGroot()==FALSE) {
 6273              		.loc 1 2738 0
 6274 2af4 FFF7FEFF 		bl	idmanager_getIsDAGroot
 6275 2af8 0346     		mov	r3, r0
 6276 2afa 83F00103 		eor	r3, r3, #1
 6277 2afe DBB2     		uxtb	r3, r3
 6278 2b00 002B     		cmp	r3, #0
 6279 2b02 25D0     		beq	.L311
2739:openstack/02a-MAClow/IEEE802154Ecsl.c ****                      // ASN
2740:openstack/02a-MAClow/IEEE802154Ecsl.c ****                      asnStoreFromAdv((uint8_t*)(pkt->payload)+ptr);
 6280              		.loc 1 2740 0
 6281 2b04 7B68     		ldr	r3, [r7, #4]
 6282 2b06 5A68     		ldr	r2, [r3, #4]
 6283 2b08 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6284 2b0a D318     		adds	r3, r2, r3
 6285 2b0c 1846     		mov	r0, r3
 6286 2b0e FFF7FEFF 		bl	asnStoreFromAdv
2741:openstack/02a-MAClow/IEEE802154Ecsl.c ****                      ptr = ptr + 5;
 6287              		.loc 1 2741 0
 6288 2b12 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6289 2b14 03F10503 		add	r3, r3, #5
 6290 2b18 DBB2     		uxtb	r3, r3
 6291 2b1a FB73     		strb	r3, [r7, #15]
2742:openstack/02a-MAClow/IEEE802154Ecsl.c ****                      // join priority
2743:openstack/02a-MAClow/IEEE802154Ecsl.c ****                      joinPriorityStoreFromAdv(*((uint8_t*)(pkt->payload)+ptr));
 6292              		.loc 1 2743 0
 6293 2b1c 7B68     		ldr	r3, [r7, #4]
 6294 2b1e 5A68     		ldr	r2, [r3, #4]
 6295 2b20 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6296 2b22 D318     		adds	r3, r2, r3
 6297 2b24 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 6298 2b26 1846     		mov	r0, r3
 6299 2b28 FFF7FEFF 		bl	joinPriorityStoreFromAdv
2744:openstack/02a-MAClow/IEEE802154Ecsl.c ****                      ptr = ptr + 1;
 6300              		.loc 1 2744 0
 6301 2b2c FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6302 2b2e 03F10103 		add	r3, r3, #1
 6303 2b32 DBB2     		uxtb	r3, r3
 6304 2b34 FB73     		strb	r3, [r7, #15]
2745:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   }
2746:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   break;
 6305              		.loc 1 2746 0
 6306 2b36 0BE0     		b	.L311
 6307              	.L299:
2747:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2748:openstack/02a-MAClow/IEEE802154Ecsl.c ****                case IEEE802154E_MLME_SLOTFRAME_LINK_IE_SUBID:
2749:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   processIE_retrieveSlotframeLinkIE(pkt,&ptr);
 6308              		.loc 1 2749 0
 6309 2b38 07F10F03 		add	r3, r7, #15
 6310 2b3c 7868     		ldr	r0, [r7, #4]
 6311 2b3e 1946     		mov	r1, r3
 6312 2b40 FFF7FEFF 		bl	processIE_retrieveSlotframeLinkIE
2750:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   break;
 6313              		.loc 1 2750 0
 6314 2b44 05E0     		b	.L302
 6315              	.L309:
2751:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2752:openstack/02a-MAClow/IEEE802154Ecsl.c ****                case IEEE802154E_MLME_TIMESLOT_IE_SUBID:
2753:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   // to do
2754:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   break;
2755:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2756:openstack/02a-MAClow/IEEE802154Ecsl.c ****                default:
2757:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   return FALSE;
 6316              		.loc 1 2757 0
 6317 2b46 4FF00003 		mov	r3, #0
 6318 2b4a 6AE0     		b	.L307
 6319              	.L310:
2754:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   break;
 6320              		.loc 1 2754 0
 6321 2b4c 00BF     		nop
 6322 2b4e 00E0     		b	.L302
 6323              	.L311:
2746:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   break;
 6324              		.loc 1 2746 0
 6325 2b50 00BF     		nop
 6326              	.L302:
2758:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   break;
2759:openstack/02a-MAClow/IEEE802154Ecsl.c ****             }
2760:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2761:openstack/02a-MAClow/IEEE802154Ecsl.c ****             len = len - sublen;
 6327              		.loc 1 2761 0
 6328 2b52 BA8B     		ldrh	r2, [r7, #28]	@ movhi
 6329 2b54 7B8B     		ldrh	r3, [r7, #26]	@ movhi
 6330 2b56 D31A     		subs	r3, r2, r3
 6331 2b58 BB83     		strh	r3, [r7, #28]	@ movhi
2762:openstack/02a-MAClow/IEEE802154Ecsl.c ****          } while(len>0);
 6332              		.loc 1 2762 0
 6333 2b5a BB8B     		ldrh	r3, [r7, #28]
 6334 2b5c 002B     		cmp	r3, #0
 6335 2b5e 88D1     		bne	.L293
2763:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2764:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 6336              		.loc 1 2764 0
 6337 2b60 4EE0     		b	.L304
 6338              	.L294:
2765:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2766:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case IEEE802154E_ACK_NACK_TIMECORRECTION_ELEMENTID:
2767:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // timecorrection IE
2768:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2769:openstack/02a-MAClow/IEEE802154Ecsl.c ****          if (
2770:openstack/02a-MAClow/IEEE802154Ecsl.c ****                idmanager_getIsDAGroot()==FALSE &&
 6339              		.loc 1 2770 0
 6340 2b62 FFF7FEFF 		bl	idmanager_getIsDAGroot
 6341 2b66 0346     		mov	r3, r0
 6342 2b68 83F00103 		eor	r3, r3, #1
 6343 2b6c DBB2     		uxtb	r3, r3
2769:openstack/02a-MAClow/IEEE802154Ecsl.c ****          if (
 6344              		.loc 1 2769 0
 6345 2b6e 002B     		cmp	r3, #0
 6346 2b70 45D0     		beq	.L312
2771:openstack/02a-MAClow/IEEE802154Ecsl.c ****                neighbors_isPreferredParent(&(pkt->l2_nextORpreviousHop))
 6347              		.loc 1 2771 0
 6348 2b72 7B68     		ldr	r3, [r7, #4]
 6349 2b74 03F13803 		add	r3, r3, #56
 6350 2b78 1846     		mov	r0, r3
 6351 2b7a FFF7FEFF 		bl	neighbors_isPreferredParent
 6352 2b7e 0346     		mov	r3, r0
2770:openstack/02a-MAClow/IEEE802154Ecsl.c ****                idmanager_getIsDAGroot()==FALSE &&
 6353              		.loc 1 2770 0
 6354 2b80 002B     		cmp	r3, #0
 6355 2b82 3CD0     		beq	.L312
2772:openstack/02a-MAClow/IEEE802154Ecsl.c ****             ) {
2773:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2774:openstack/02a-MAClow/IEEE802154Ecsl.c ****             byte0 = *((uint8_t*)(pkt->payload)+ptr);
 6356              		.loc 1 2774 0
 6357 2b84 7B68     		ldr	r3, [r7, #4]
 6358 2b86 5A68     		ldr	r2, [r3, #4]
 6359 2b88 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6360 2b8a D318     		adds	r3, r2, r3
 6361 2b8c 1B78     		ldrb	r3, [r3, #0]
 6362 2b8e 7B75     		strb	r3, [r7, #21]
2775:openstack/02a-MAClow/IEEE802154Ecsl.c ****             ptr++;
 6363              		.loc 1 2775 0
 6364 2b90 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6365 2b92 03F10103 		add	r3, r3, #1
 6366 2b96 DBB2     		uxtb	r3, r3
 6367 2b98 FB73     		strb	r3, [r7, #15]
2776:openstack/02a-MAClow/IEEE802154Ecsl.c ****             byte1 = *((uint8_t*)(pkt->payload)+ptr);
 6368              		.loc 1 2776 0
 6369 2b9a 7B68     		ldr	r3, [r7, #4]
 6370 2b9c 5A68     		ldr	r2, [r3, #4]
 6371 2b9e FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6372 2ba0 D318     		adds	r3, r2, r3
 6373 2ba2 1B78     		ldrb	r3, [r3, #0]
 6374 2ba4 3B75     		strb	r3, [r7, #20]
2777:openstack/02a-MAClow/IEEE802154Ecsl.c ****             ptr++;
 6375              		.loc 1 2777 0
 6376 2ba6 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6377 2ba8 03F10103 		add	r3, r3, #1
 6378 2bac DBB2     		uxtb	r3, r3
 6379 2bae FB73     		strb	r3, [r7, #15]
2778:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2779:openstack/02a-MAClow/IEEE802154Ecsl.c ****             timeCorrection  = (int16_t)((uint16_t)byte1<<8 | (uint16_t)byte0);
 6380              		.loc 1 2779 0
 6381 2bb0 3B7D     		ldrb	r3, [r7, #20]	@ zero_extendqisi2
 6382 2bb2 4FEA0323 		lsl	r3, r3, #8
 6383 2bb6 9AB2     		uxth	r2, r3
 6384 2bb8 7B7D     		ldrb	r3, [r7, #21]	@ zero_extendqisi2
 6385 2bba 9BB2     		uxth	r3, r3
 6386 2bbc 1343     		orrs	r3, r3, r2
 6387 2bbe 9BB2     		uxth	r3, r3
 6388 2bc0 1BB2     		sxth	r3, r3
 6389 2bc2 3B61     		str	r3, [r7, #16]
2780:openstack/02a-MAClow/IEEE802154Ecsl.c ****             timeCorrection  = (timeCorrection / (PORT_SIGNED_INT_WIDTH)US_PER_TICK);
 6390              		.loc 1 2780 0
 6391 2bc4 3B69     		ldr	r3, [r7, #16]
 6392 2bc6 48F68902 		movw	r2, #34953
 6393 2bca C8F68802 		movt	r2, 34952
 6394 2bce 82FB0312 		smull	r1, r2, r2, r3
 6395 2bd2 D218     		adds	r2, r2, r3
 6396 2bd4 4FEA2212 		asr	r2, r2, #4
 6397 2bd8 4FEAE373 		asr	r3, r3, #31
 6398 2bdc D31A     		subs	r3, r2, r3
 6399 2bde 3B61     		str	r3, [r7, #16]
2781:openstack/02a-MAClow/IEEE802154Ecsl.c ****             timeCorrection  = -timeCorrection;
 6400              		.loc 1 2781 0
 6401 2be0 3B69     		ldr	r3, [r7, #16]
 6402 2be2 C3F10003 		rsb	r3, r3, #0
 6403 2be6 3B61     		str	r3, [r7, #16]
2782:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2783:openstack/02a-MAClow/IEEE802154Ecsl.c ****             synchronizeAck(timeCorrection);
 6404              		.loc 1 2783 0
 6405 2be8 3869     		ldr	r0, [r7, #16]
 6406 2bea FFF7FEFF 		bl	synchronizeAck
2784:openstack/02a-MAClow/IEEE802154Ecsl.c ****          }
2785:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 6407              		.loc 1 2785 0
 6408 2bee 06E0     		b	.L312
 6409              	.L308:
2786:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2787:openstack/02a-MAClow/IEEE802154Ecsl.c ****       default:
2788:openstack/02a-MAClow/IEEE802154Ecsl.c ****          *lenIE = 0; //no header or not recognized.
 6410              		.loc 1 2788 0
 6411 2bf0 3B68     		ldr	r3, [r7, #0]
 6412 2bf2 4FF00002 		mov	r2, #0
 6413 2bf6 1A80     		strh	r2, [r3, #0]	@ movhi
2789:openstack/02a-MAClow/IEEE802154Ecsl.c ****          return FALSE;
 6414              		.loc 1 2789 0
 6415 2bf8 4FF00003 		mov	r3, #0
 6416 2bfc 11E0     		b	.L307
 6417              	.L312:
2785:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 6418              		.loc 1 2785 0
 6419 2bfe 00BF     		nop
 6420              	.L304:
2790:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2791:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2792:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if(*lenIE>127) {
 6421              		.loc 1 2792 0
 6422 2c00 3B68     		ldr	r3, [r7, #0]
 6423 2c02 1B88     		ldrh	r3, [r3, #0]
 6424 2c04 7F2B     		cmp	r3, #127
 6425 2c06 0AD9     		bls	.L306
2793:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // log the error
2794:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openserial_printError(
 6426              		.loc 1 2794 0
 6427 2c08 3B68     		ldr	r3, [r7, #0]
 6428 2c0a 1B88     		ldrh	r3, [r3, #0]
 6429 2c0c 4FF00900 		mov	r0, #9
 6430 2c10 4FF03301 		mov	r1, #51
 6431 2c14 1A46     		mov	r2, r3
 6432 2c16 4FF00103 		mov	r3, #1
 6433 2c1a FFF7FEFF 		bl	openserial_printError
 6434              	.L306:
2795:openstack/02a-MAClow/IEEE802154Ecsl.c ****          COMPONENT_IEEE802154E,
2796:openstack/02a-MAClow/IEEE802154Ecsl.c ****          ERR_HEADER_TOO_LONG,
2797:openstack/02a-MAClow/IEEE802154Ecsl.c ****          (errorparameter_t)*lenIE,
2798:openstack/02a-MAClow/IEEE802154Ecsl.c ****          (errorparameter_t)1
2799:openstack/02a-MAClow/IEEE802154Ecsl.c ****       );
2800:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2801:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return TRUE;
 6435              		.loc 1 2801 0
 6436 2c1e 4FF00103 		mov	r3, #1
 6437              	.L307:
2802:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 6438              		.loc 1 2802 0
 6439 2c22 1846     		mov	r0, r3
 6440 2c24 07F12007 		add	r7, r7, #32
 6441 2c28 BD46     		mov	sp, r7
 6442 2c2a 80BD     		pop	{r7, pc}
 6443              		.cfi_endproc
 6444              	.LFE70:
 6446              		.align	2
 6447              		.global	joinPriorityStoreFromAdv
 6448              		.thumb
 6449              		.thumb_func
 6451              	joinPriorityStoreFromAdv:
 6452              	.LFB71:
2803:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2804:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void joinPriorityStoreFromAdv(uint8_t jp){
 6453              		.loc 1 2804 0
 6454              		.cfi_startproc
 6455              		@ args = 0, pretend = 0, frame = 8
 6456              		@ frame_needed = 1, uses_anonymous_args = 0
 6457              		@ link register save eliminated.
 6458 2c2c 80B4     		push	{r7}
 6459              	.LCFI174:
 6460              		.cfi_def_cfa_offset 4
 6461              		.cfi_offset 7, -4
 6462 2c2e 83B0     		sub	sp, sp, #12
 6463              	.LCFI175:
 6464              		.cfi_def_cfa_offset 16
 6465 2c30 00AF     		add	r7, sp, #0
 6466              	.LCFI176:
 6467              		.cfi_def_cfa_register 7
 6468 2c32 0346     		mov	r3, r0
 6469 2c34 FB71     		strb	r3, [r7, #7]
2805:openstack/02a-MAClow/IEEE802154Ecsl.c ****   ieee154e_vars.dataReceived->l2_joinPriority = jp;
 6470              		.loc 1 2805 0
 6471 2c36 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6472 2c3a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6473 2c3e 9B69     		ldr	r3, [r3, #24]
 6474 2c40 FA79     		ldrb	r2, [r7, #7]
 6475 2c42 83F86420 		strb	r2, [r3, #100]
2806:openstack/02a-MAClow/IEEE802154Ecsl.c ****   ieee154e_vars.dataReceived->l2_joinPriorityPresent = TRUE;
 6476              		.loc 1 2806 0
 6477 2c46 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6478 2c4a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6479 2c4e 9B69     		ldr	r3, [r3, #24]
 6480 2c50 4FF00102 		mov	r2, #1
 6481 2c54 83F86620 		strb	r2, [r3, #102]
2807:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 6482              		.loc 1 2807 0
 6483 2c58 07F10C07 		add	r7, r7, #12
 6484 2c5c BD46     		mov	sp, r7
 6485 2c5e 80BC     		pop	{r7}
 6486 2c60 7047     		bx	lr
 6487              		.cfi_endproc
 6488              	.LFE71:
 6490 2c62 00BF     		.align	2
 6491              		.global	asnStoreFromAdv
 6492              		.thumb
 6493              		.thumb_func
 6495              	asnStoreFromAdv:
 6496              	.LFB72:
2808:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2809:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void asnStoreFromAdv(uint8_t* asn) {
 6497              		.loc 1 2809 0
 6498              		.cfi_startproc
 6499              		@ args = 0, pretend = 0, frame = 8
 6500              		@ frame_needed = 1, uses_anonymous_args = 0
 6501 2c64 90B5     		push	{r4, r7, lr}
 6502              	.LCFI177:
 6503              		.cfi_def_cfa_offset 12
 6504              		.cfi_offset 4, -12
 6505              		.cfi_offset 7, -8
 6506              		.cfi_offset 14, -4
 6507 2c66 83B0     		sub	sp, sp, #12
 6508              	.LCFI178:
 6509              		.cfi_def_cfa_offset 24
 6510 2c68 00AF     		add	r7, sp, #0
 6511              	.LCFI179:
 6512              		.cfi_def_cfa_register 7
 6513 2c6a 7860     		str	r0, [r7, #4]
2810:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2811:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // store the ASN
2812:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asn.bytes0and1   =     asn[0]+
 6514              		.loc 1 2812 0
 6515 2c6c 7B68     		ldr	r3, [r7, #4]
 6516 2c6e 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 6517 2c70 1A46     		mov	r2, r3
2813:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                     256*asn[1];
 6518              		.loc 1 2813 0
 6519 2c72 7B68     		ldr	r3, [r7, #4]
 6520 2c74 03F10103 		add	r3, r3, #1
 6521 2c78 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
2812:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asn.bytes0and1   =     asn[0]+
 6522              		.loc 1 2812 0
 6523 2c7a 4FEA0323 		lsl	r3, r3, #8
 6524 2c7e 9BB2     		uxth	r3, r3
 6525 2c80 D318     		adds	r3, r2, r3
 6526 2c82 9AB2     		uxth	r2, r3
 6527 2c84 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6528 2c88 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6529 2c8c A3F80320 		strh	r2, [r3, #3]	@ unaligned
2814:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asn.bytes2and3   =     asn[2]+
 6530              		.loc 1 2814 0
 6531 2c90 7B68     		ldr	r3, [r7, #4]
 6532 2c92 03F10203 		add	r3, r3, #2
 6533 2c96 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 6534 2c98 1A46     		mov	r2, r3
2815:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                     256*asn[3];
 6535              		.loc 1 2815 0
 6536 2c9a 7B68     		ldr	r3, [r7, #4]
 6537 2c9c 03F10303 		add	r3, r3, #3
 6538 2ca0 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
2814:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asn.bytes2and3   =     asn[2]+
 6539              		.loc 1 2814 0
 6540 2ca2 4FEA0323 		lsl	r3, r3, #8
 6541 2ca6 9BB2     		uxth	r3, r3
 6542 2ca8 D318     		adds	r3, r2, r3
 6543 2caa 9AB2     		uxth	r2, r3
 6544 2cac 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6545 2cb0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6546 2cb4 A3F80120 		strh	r2, [r3, #1]	@ unaligned
2816:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asn.byte4        =     asn[4];
 6547              		.loc 1 2816 0
 6548 2cb8 7B68     		ldr	r3, [r7, #4]
 6549 2cba 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 6550 2cbc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6551 2cc0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6552 2cc4 1A70     		strb	r2, [r3, #0]
2817:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2818:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // determine the current slotOffset
2819:openstack/02a-MAClow/IEEE802154Ecsl.c ****    /*
2820:openstack/02a-MAClow/IEEE802154Ecsl.c ****    Note: this is a bit of a hack. Normally, slotOffset=ASN%slotlength. But since
2821:openstack/02a-MAClow/IEEE802154Ecsl.c ****    the ADV is exchanged in slot 0, we know that we're currently at slotOffset==0
2822:openstack/02a-MAClow/IEEE802154Ecsl.c ****    */
2823:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.slotOffset       = 0;
 6553              		.loc 1 2823 0
 6554 2cc6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6555 2cca C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6556 2cce 4FF00002 		mov	r2, #0
 6557 2cd2 DA80     		strh	r2, [r3, #6]	@ movhi
2824:openstack/02a-MAClow/IEEE802154Ecsl.c ****    schedule_syncSlotOffset(ieee154e_vars.slotOffset);
 6558              		.loc 1 2824 0
 6559 2cd4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6560 2cd8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6561 2cdc DB88     		ldrh	r3, [r3, #6]
 6562 2cde 1846     		mov	r0, r3
 6563 2ce0 FFF7FEFF 		bl	schedule_syncSlotOffset
2825:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.nextActiveSlotOffset = schedule_getNextActiveSlotOffset();
 6564              		.loc 1 2825 0
 6565 2ce4 FFF7FEFF 		bl	schedule_getNextActiveSlotOffset
 6566 2ce8 0346     		mov	r3, r0
 6567 2cea 1A46     		mov	r2, r3
 6568 2cec 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6569 2cf0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6570 2cf4 1A81     		strh	r2, [r3, #8]	@ movhi
2826:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2827:openstack/02a-MAClow/IEEE802154Ecsl.c ****    /*
2828:openstack/02a-MAClow/IEEE802154Ecsl.c ****    infer the asnOffset based on the fact that
2829:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.freq = 11 + (asnOffset + channelOffset)%16
2830:openstack/02a-MAClow/IEEE802154Ecsl.c ****    */
2831:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asnOffset = ieee154e_vars.freq - 11 - schedule_getChannelOffset();
 6571              		.loc 1 2831 0
 6572 2cf6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6573 2cfa C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6574 2cfe 93F82C40 		ldrb	r4, [r3, #44]	@ zero_extendqisi2
 6575 2d02 FFF7FEFF 		bl	schedule_getChannelOffset
 6576 2d06 0346     		mov	r3, r0
 6577 2d08 E31A     		subs	r3, r4, r3
 6578 2d0a DBB2     		uxtb	r3, r3
 6579 2d0c A3F10B03 		sub	r3, r3, #11
 6580 2d10 DAB2     		uxtb	r2, r3
 6581 2d12 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6582 2d16 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6583 2d1a 83F82D20 		strb	r2, [r3, #45]
2832:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 6584              		.loc 1 2832 0
 6585 2d1e 07F10C07 		add	r7, r7, #12
 6586 2d22 BD46     		mov	sp, r7
 6587 2d24 90BD     		pop	{r4, r7, pc}
 6588              		.cfi_endproc
 6589              	.LFE72:
 6591 2d26 00BF     		.align	2
 6592              		.global	ieee154e_asnDiff
 6593              		.thumb
 6594              		.thumb_func
 6596              	ieee154e_asnDiff:
 6597              	.LFB73:
2833:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2834:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2835:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2836:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2837:openstack/02a-MAClow/IEEE802154Ecsl.c **** /brief Difference between some older ASN and the current ASN.
2838:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2839:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in] someASN some ASN to compare to the current
2840:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2841:openstack/02a-MAClow/IEEE802154Ecsl.c **** \returns The ASN difference, or 0xffff if more than 65535 different
2842:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2843:openstack/02a-MAClow/IEEE802154Ecsl.c **** PORT_RADIOTIMER_WIDTH ieee154e_asnDiff(asn_t* someASN) {
 6598              		.loc 1 2843 0
 6599              		.cfi_startproc
 6600              		@ args = 0, pretend = 0, frame = 16
 6601              		@ frame_needed = 1, uses_anonymous_args = 0
 6602 2d28 80B5     		push	{r7, lr}
 6603              	.LCFI180:
 6604              		.cfi_def_cfa_offset 8
 6605              		.cfi_offset 7, -8
 6606              		.cfi_offset 14, -4
 6607 2d2a 84B0     		sub	sp, sp, #16
 6608              	.LCFI181:
 6609              		.cfi_def_cfa_offset 24
 6610 2d2c 00AF     		add	r7, sp, #0
 6611              	.LCFI182:
 6612              		.cfi_def_cfa_register 7
 6613 2d2e 7860     		str	r0, [r7, #4]
2844:openstack/02a-MAClow/IEEE802154Ecsl.c ****    PORT_RADIOTIMER_WIDTH diff;
2845:openstack/02a-MAClow/IEEE802154Ecsl.c ****    INTERRUPT_DECLARATION();
2846:openstack/02a-MAClow/IEEE802154Ecsl.c ****    DISABLE_INTERRUPTS();
 6614              		.loc 1 2846 0
 6615 2d30 FFF7FEFF 		bl	IntMasterDisable
2847:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.asn.byte4 != someASN->byte4) {
 6616              		.loc 1 2847 0
 6617 2d34 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6618 2d38 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6619 2d3c 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 6620 2d3e 7B68     		ldr	r3, [r7, #4]
 6621 2d40 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 6622 2d42 9A42     		cmp	r2, r3
 6623 2d44 04D0     		beq	.L316
2848:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ENABLE_INTERRUPTS();
 6624              		.loc 1 2848 0
 6625 2d46 FFF7FEFF 		bl	IntMasterEnable
2849:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return (PORT_RADIOTIMER_WIDTH)0xFFFFFFFF;;
 6626              		.loc 1 2849 0
 6627 2d4a 4FF0FF33 		mov	r3, #-1
 6628 2d4e 4CE0     		b	.L317
 6629              	.L316:
2850:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2851:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2852:openstack/02a-MAClow/IEEE802154Ecsl.c ****    diff = 0;
 6630              		.loc 1 2852 0
 6631 2d50 4FF00003 		mov	r3, #0
 6632 2d54 FB60     		str	r3, [r7, #12]
2853:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.asn.bytes2and3 == someASN->bytes2and3) {
 6633              		.loc 1 2853 0
 6634 2d56 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6635 2d5a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6636 2d5e B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 6637 2d62 9AB2     		uxth	r2, r3
 6638 2d64 7B68     		ldr	r3, [r7, #4]
 6639 2d66 B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 6640 2d6a 9BB2     		uxth	r3, r3
 6641 2d6c 9A42     		cmp	r2, r3
 6642 2d6e 0FD1     		bne	.L318
2854:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ENABLE_INTERRUPTS();
 6643              		.loc 1 2854 0
 6644 2d70 FFF7FEFF 		bl	IntMasterEnable
2855:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return ieee154e_vars.asn.bytes0and1-someASN->bytes0and1;
 6645              		.loc 1 2855 0
 6646 2d74 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6647 2d78 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6648 2d7c B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 6649 2d80 9BB2     		uxth	r3, r3
 6650 2d82 1A46     		mov	r2, r3
 6651 2d84 7B68     		ldr	r3, [r7, #4]
 6652 2d86 B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 6653 2d8a 9BB2     		uxth	r3, r3
 6654 2d8c D31A     		subs	r3, r2, r3
 6655 2d8e 2CE0     		b	.L317
 6656              	.L318:
2856:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else if (ieee154e_vars.asn.bytes2and3-someASN->bytes2and3==1) {
 6657              		.loc 1 2856 0
 6658 2d90 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6659 2d94 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6660 2d98 B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 6661 2d9c 9BB2     		uxth	r3, r3
 6662 2d9e 1A46     		mov	r2, r3
 6663 2da0 7B68     		ldr	r3, [r7, #4]
 6664 2da2 B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 6665 2da6 9BB2     		uxth	r3, r3
 6666 2da8 D31A     		subs	r3, r2, r3
 6667 2daa 012B     		cmp	r3, #1
 6668 2dac 17D1     		bne	.L319
2857:openstack/02a-MAClow/IEEE802154Ecsl.c ****       diff  = ieee154e_vars.asn.bytes0and1;
 6669              		.loc 1 2857 0
 6670 2dae 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6671 2db2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6672 2db6 B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 6673 2dba 9BB2     		uxth	r3, r3
 6674 2dbc FB60     		str	r3, [r7, #12]
2858:openstack/02a-MAClow/IEEE802154Ecsl.c ****       diff += 0xffff-someASN->bytes0and1;
 6675              		.loc 1 2858 0
 6676 2dbe 7B68     		ldr	r3, [r7, #4]
 6677 2dc0 B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 6678 2dc4 9BB2     		uxth	r3, r3
 6679 2dc6 FA68     		ldr	r2, [r7, #12]
 6680 2dc8 D31A     		subs	r3, r2, r3
 6681 2dca 03F57F43 		add	r3, r3, #65280
 6682 2dce 03F1FF03 		add	r3, r3, #255
 6683 2dd2 FB60     		str	r3, [r7, #12]
2859:openstack/02a-MAClow/IEEE802154Ecsl.c ****       diff += 1;
 6684              		.loc 1 2859 0
 6685 2dd4 FB68     		ldr	r3, [r7, #12]
 6686 2dd6 03F10103 		add	r3, r3, #1
 6687 2dda FB60     		str	r3, [r7, #12]
 6688 2ddc 02E0     		b	.L320
 6689              	.L319:
2860:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
2861:openstack/02a-MAClow/IEEE802154Ecsl.c ****       diff = (PORT_RADIOTIMER_WIDTH)0xFFFFFFFF;;
 6690              		.loc 1 2861 0
 6691 2dde 4FF0FF33 		mov	r3, #-1
 6692 2de2 FB60     		str	r3, [r7, #12]
 6693              	.L320:
2862:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2863:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ENABLE_INTERRUPTS();
 6694              		.loc 1 2863 0
 6695 2de4 FFF7FEFF 		bl	IntMasterEnable
2864:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return diff;
 6696              		.loc 1 2864 0
 6697 2de8 FB68     		ldr	r3, [r7, #12]
 6698              	.L317:
2865:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 6699              		.loc 1 2865 0
 6700 2dea 1846     		mov	r0, r3
 6701 2dec 07F11007 		add	r7, r7, #16
 6702 2df0 BD46     		mov	sp, r7
 6703 2df2 80BD     		pop	{r7, pc}
 6704              		.cfi_endproc
 6705              	.LFE73:
 6707              	.Letext0:
 6708              		.file 2 "/opt/gcc-arm-none-eabi-4_7-2013q3/bin/../lib/gcc/arm-none-eabi/4.7.4/../../../../arm-none
 6709              		.file 3 "inc/opendefs.h"
 6710              		.file 4 "openstack/02b-MAChigh/schedule.h"
 6711              		.file 5 "openstack/02b-MAChigh/processIE.h"
 6712              		.file 6 "drivers/common/opentimers.h"
 6713              		.file 7 "openstack/02a-MAClow/IEEE802154Ecsl.h"
 6714              		.file 8 "openstack/02a-MAClow/IEEE802154.h"
 6715              		.file 9 "kernel/scheduler.h"
 6716              		.file 10 "bsp/boards/OpenMote-CC2538/board_info.h"
 6717              		.file 11 "openstack/03b-IPv6/icmpv6rpl.h"
DEFINED SYMBOLS
                            *ABS*:00000000 IEEE802154Ecsl.c
     /tmp/ccomcBxN.s:19     .rodata:00000000 $d
     /tmp/ccomcBxN.s:22     .rodata:00000000 rreg_uriquery
     /tmp/ccomcBxN.s:27     .rodata:00000008 infoBoardname
     /tmp/ccomcBxN.s:32     .rodata:00000010 infouCName
     /tmp/ccomcBxN.s:37     .rodata:00000018 infoRadioName
     /tmp/ccomcBxN.s:42     .rodata:00000024 infoStackName
     /tmp/ccomcBxN.s:47     .rodata:00000030 all_routers_multicast
                            *COM*:0000004c ieee154e_vars
                            *COM*:0000000f ieee154e_stats
                            *COM*:00000014 ieee154e_dbg
     /tmp/ccomcBxN.s:68     .text:00000000 $t
     /tmp/ccomcBxN.s:73     .text:00000000 ieee154e_init
     /tmp/ccomcBxN.s:5332   .text:00002478 changeIsSync
     /tmp/ccomcBxN.s:5500   .text:00002550 resetStats
     /tmp/ccomcBxN.s:186    .text:00000108 isr_ieee154ecsl_newChannelSample
     /tmp/ccomcBxN.s:247    .text:0000016c isr_ieee154ecsl_timer
     /tmp/ccomcBxN.s:511    .text:00000368 ieee154ecsl_startOfFrame
     /tmp/ccomcBxN.s:662    .text:0000049c ieee154ecsl_endOfFrame
     /tmp/ccomcBxN.s:805    .text:00000598 isr_ieee154ecsl_txtimer_cb
     /tmp/ccomcBxN.s:855    .text:000005dc isr_ieee154ecsl_addPacketToQueueForTestingCslTx_cb
     /tmp/ccomcBxN.s:2572   .text:0000119c activity_csl_wakeup_ri1
     /tmp/ccomcBxN.s:278    .text:00000198 $d
     /tmp/ccomcBxN.s:2640   .text:0000120c activity_csl_wakeup_ri2
     /tmp/ccomcBxN.s:296    .text:000001d8 $t
     /tmp/ccomcBxN.s:2690   .text:0000125c activity_csl_wakeup_rie1
     /tmp/ccomcBxN.s:2731   .text:0000128c activity_csl_wakeup_ri3
     /tmp/ccomcBxN.s:2767   .text:000012b4 activity_csl_wakeup_rie2
     /tmp/ccomcBxN.s:2845   .text:00001308 activity_csl_wakeup_rie3
     /tmp/ccomcBxN.s:2886   .text:00001338 activity_csl_wakeup_rie4
     /tmp/ccomcBxN.s:3244   .text:00001630 activity_csl_data_ri2
     /tmp/ccomcBxN.s:3294   .text:00001680 activity_csl_data_rie1
     /tmp/ccomcBxN.s:3335   .text:000016b0 activity_csl_data_ri3
     /tmp/ccomcBxN.s:3371   .text:000016d8 activity_csl_data_rie2
     /tmp/ccomcBxN.s:3449   .text:0000172c activity_csl_data_rie3
     /tmp/ccomcBxN.s:3844   .text:00001a60 activity_csl_data_ri6
     /tmp/ccomcBxN.s:4077   .text:00001c7c activity_csl_data_rie4
     /tmp/ccomcBxN.s:4118   .text:00001cac activity_csl_data_ri7
     /tmp/ccomcBxN.s:4154   .text:00001cd4 activity_csl_data_rie5
     /tmp/ccomcBxN.s:4242   .text:00001d40 activity_csl_data_rie6
     /tmp/ccomcBxN.s:5878   .text:000027f4 endOps
     /tmp/ccomcBxN.s:397    .text:0000028c $d
     /tmp/ccomcBxN.s:1168   .text:0000084c activity_csl_wakeup_ti2
     /tmp/ccomcBxN.s:414    .text:000002c8 $t
     /tmp/ccomcBxN.s:1353   .text:00000a04 activity_csl_wakeup_tie1
     /tmp/ccomcBxN.s:1389   .text:00000a2c activity_csl_wakeup_ti3
     /tmp/ccomcBxN.s:1425   .text:00000a54 activity_csl_wakeup_tie2
     /tmp/ccomcBxN.s:1508   .text:00000ab8 activity_csl_wakeup_tie3
     /tmp/ccomcBxN.s:1609   .text:00000b4c activity_csl_data_ti2
     /tmp/ccomcBxN.s:1673   .text:00000bbc activity_csl_data_tie1
     /tmp/ccomcBxN.s:1711   .text:00000be8 activity_csl_data_ti3
     /tmp/ccomcBxN.s:1747   .text:00000c10 activity_csl_data_tie2
     /tmp/ccomcBxN.s:1832   .text:00000c78 activity_csl_data_tie3
     /tmp/ccomcBxN.s:1996   .text:00000d90 activity_csl_data_ti6
     /tmp/ccomcBxN.s:2046   .text:00000de0 activity_csl_data_tie4
     /tmp/ccomcBxN.s:2084   .text:00000e0c activity_csl_data_ti7
     /tmp/ccomcBxN.s:2120   .text:00000e34 activity_csl_data_tie5
     /tmp/ccomcBxN.s:2225   .text:00000ed4 activity_csl_data_tie6
     /tmp/ccomcBxN.s:546    .text:00000398 $d
     /tmp/ccomcBxN.s:560    .text:000003c8 $t
     /tmp/ccomcBxN.s:2793   .text:000012c0 activity_csl_wakeup_ri4
     /tmp/ccomcBxN.s:3397   .text:000016e4 activity_csl_data_ri4
     /tmp/ccomcBxN.s:4195   .text:00001d04 activity_csl_data_ri8
     /tmp/ccomcBxN.s:592    .text:0000040c $d
     /tmp/ccomcBxN.s:605    .text:00000438 $t
     /tmp/ccomcBxN.s:2178   .text:00000e98 activity_csl_data_ti8
     /tmp/ccomcBxN.s:1461   .text:00000a7c activity_csl_wakeup_ti4
     /tmp/ccomcBxN.s:1785   .text:00000c3c activity_csl_data_ti4
     /tmp/ccomcBxN.s:2923   .text:00001360 activity_csl_wakeup_ri5
     /tmp/ccomcBxN.s:3490   .text:0000175c activity_csl_data_ri5
     /tmp/ccomcBxN.s:4283   .text:00001d70 activity_csl_data_ri9
     /tmp/ccomcBxN.s:1544   .text:00000ae0 activity_csl_wakeup_ti5
     /tmp/ccomcBxN.s:1870   .text:00000ca4 activity_csl_data_ti5
     /tmp/ccomcBxN.s:2251   .text:00000ee0 activity_csl_data_ti9
     /tmp/ccomcBxN.s:1016   .text:00000714 activity_csl_wakeup_ti1
     /tmp/ccomcBxN.s:5049   .text:0000224c incrementAsnOffset
     /tmp/ccomcBxN.s:5623   .text:00002614 changeState
     /tmp/ccomcBxN.s:4348   .text:00001ddc ieee802154_createWakeUpFrame
     /tmp/ccomcBxN.s:4960   .text:000021cc isValidAck
     /tmp/ccomcBxN.s:6107   .text:000029d4 ieee154e_processIEs
     /tmp/ccomcBxN.s:4464   .text:00001ea4 ieee802154_retrieveWakeUpFrame
     /tmp/ccomcBxN.s:4867   .text:00002150 isValidRxFrame
     /tmp/ccomcBxN.s:5439   .text:00002504 notif_receive
     /tmp/ccomcBxN.s:5151   .text:00002334 ieee154e_getAsn
     /tmp/ccomcBxN.s:5228   .text:000023c0 synchronizeAck
     /tmp/ccomcBxN.s:5562   .text:000025c0 updateStats
     /tmp/ccomcBxN.s:5385   .text:000024b8 notif_sendDone
     /tmp/ccomcBxN.s:5468   .text:00002520 $d
     /tmp/ccomcBxN.s:5474   .text:00002530 $t
     /tmp/ccomcBxN.s:5657   .text:00002640 $d
     /tmp/ccomcBxN.s:5718   .text:0000272c $t
     /tmp/ccomcBxN.s:5744   .text:00002748 debugPrint_asn
     /tmp/ccomcBxN.s:5799   .text:0000279c debugPrint_isSync
     /tmp/ccomcBxN.s:5845   .text:000027d4 debugPrint_macStats
     /tmp/ccomcBxN.s:6076   .text:000029bc ieee154e_isSynch
     /tmp/ccomcBxN.s:6495   .text:00002c64 asnStoreFromAdv
     /tmp/ccomcBxN.s:6451   .text:00002c2c joinPriorityStoreFromAdv
     /tmp/ccomcBxN.s:6596   .text:00002d28 ieee154e_asnDiff
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.1.e96eee74da26538b12ac9582e3798382
                           .group:00000000 wm4.newlib.h.8.a9901dc52d1357e3e94003403d43f8b5
                           .group:00000000 wm4.features.h.22.b72b3baab2bb2eab3661375590100b6b
                           .group:00000000 wm4.config.h.193.5fb8ef056cdff92dec3dee9552839d8c
                           .group:00000000 wm4._ansi.h.23.b5bb84d7ba97d82b5b1dc1826a7ae811
                           .group:00000000 wm4.stdint.h.20.54ad762faa59e3c05491630641c8d8bf
                           .group:00000000 wm4.toolchain_defs.h.2.e4ebbe6e0a48032a9b79077dc42e1ffd
                           .group:00000000 wm4._default_types.h.6.5e12cd604db8ce00b62bb2f02708eaf3
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4.stddef.h.349.31f4c5baff3fa2689010b32028da9c47
                           .group:00000000 wm4.reent.h.16.9e42f0e588b85e70b2bf6572af57ce64
                           .group:00000000 wm4.stddef.h.187.9e651b6b8b16e149c1353259404973ea
                           .group:00000000 wm4.string.h.17.f8d12df81104836a3f2a5d589ae830d8
                           .group:00000000 wm4.stdbool.h.29.1c9ee6859ce8145f7838a4f2549ccec2
                           .group:00000000 wm4.hw_types.h.67.b10589a0806dcc2d274d6fab6b736519
                           .group:00000000 wm4.interrupt.h.41.272fc4ec0e276feb439e7974d0f77eaf
                           .group:00000000 wm4.board_info.h.21.2f0cbb5ab4c556c54c487f727dca8532
                           .group:00000000 wm4.opendefs.h.19.05852eb648ac65e48c7817e5cbf03346
                           .group:00000000 wm4.schedule.h.2.74f699399ee9cbf3b59178f1204d8511
                           .group:00000000 wm4.processIE.h.2.1848f1e3c653035e9779472584ce0441
                           .group:00000000 wm4.opentimers.h.8.044f2d040a134cdb0ddb58adfc2508be
                           .group:00000000 wm4.IEEE802154Ecsl.h.21.a46c6cdefbea13cd7501756681c86a21
                           .group:00000000 wm4.idmanager.h.2.8c0e2159b32ef3125cbb1e984805cbfe
                           .group:00000000 wm4.openserial.h.8.8c63e3800d2936b44b5370ce1aae62b7
                           .group:00000000 wm4.scheduler.h.2.ca320b72942c5204a6e225e3c9c0814e
                           .group:00000000 wm4.icmpv6rpl.h.2.0ce84dbe8c203c7079b39e7e96c7c01e
                           .group:00000000 wm4.neighbors.h.15.9f35f180a0332d1bc442efb0ec51905c
                           .group:00000000 wm4.sixtop.h.2.0b8613e8e48e9109b53e6143f3ed1895

UNDEFINED SYMBOLS
memset
idmanager_getIsDAGroot
radio_rfOn
radio_setOverflowCb
radio_setCompareCb
radio_setStartFrameCb
radio_setEndFrameCb
opentimers_start
radio_startTimer
radio_setTimerPeriod
openserial_printInfo
openserial_printError
leds_all_off
openqueue_macGetDataPacket
openqueue_getFreePacketBuffer
ieee802154_prependHeader
packetfunctions_reserveFooterSize
debugpins_slot_toggle
debugpins_frame_toggle
schedule_advanceSlot
openserial_stop
schedule_getType
schedule_getOkToSend
schedule_getNeighbor
radiotimer_schedule
radio_loadPacket
radio_txEnable
radio_getTimerValue
radio_txNow
radiotimer_cancel
radio_rfOff
packetfunctions_isBroadcastMulticast
leds_sync_blink
schedule_indicateTx
radio_rxEnable
radio_rxNow
radio_getReceivedFrame
packetfunctions_tossFooter
ieee802154_retrieveHeader
packetfunctions_tossHeader
openqueue_freePacketBuffer
packetfunctions_sameAddress
idmanager_getMyID
packetfunctions_reserveHeaderSize
packetfunctions_writeAddress
packetfunctions_mac64bToMac16b
packetfunctions_readAddress
idmanager_isMyAddress
schedule_getFrameLength
radio_getTimerPeriod
adaptive_sync_indicateTimeCorrection
leds_sync_on
leds_sync_off
schedule_resetBackoff
task_sixtopNotifSendDone
scheduler_push_task
leds_radio_toggle
leds_sync_toggle
leds_error_toggle
debugpins_fsm_set
debugpins_fsm_clr
debugpins_fsm_toggle
openserial_printStatus
processIE_retrieveSlotframeLinkIE
neighbors_isPreferredParent
schedule_syncSlotOffset
schedule_getNextActiveSlotOffset
schedule_getChannelOffset
IntMasterDisable
IntMasterEnable
