   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"IEEE802154Ecsl.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.rodata
  19              		.align	2
  22              	rreg_uriquery:
  23 0000 683D7563 		.ascii	"h=ucb\000"
  23      6200
  24 0006 0000     		.align	2
  27              	infoBoardname:
  28 0008 43433235 		.ascii	"CC2538\000"
  28      333800
  29 000f 00       		.align	2
  32              	infouCName:
  33 0010 43433235 		.ascii	"CC2538\000"
  33      333800
  34 0017 00       		.align	2
  37              	infoRadioName:
  38 0018 43433235 		.ascii	"CC2538 SoC\000"
  38      33382053 
  38      6F4300
  39 0023 00       		.align	2
  42              	infoStackName:
  43 0024 4F70656E 		.ascii	"OpenWSN \000"
  43      57534E20 
  43      00
  44 002d 000000   		.align	2
  47              	all_routers_multicast:
  48 0030 FF       		.byte	-1
  49 0031 02       		.byte	2
  50 0032 00       		.byte	0
  51 0033 00       		.byte	0
  52 0034 00       		.byte	0
  53 0035 00       		.byte	0
  54 0036 00       		.byte	0
  55 0037 00       		.byte	0
  56 0038 00       		.byte	0
  57 0039 00       		.byte	0
  58 003a 00       		.byte	0
  59 003b 00       		.byte	0
  60 003c 00       		.byte	0
  61 003d 00       		.byte	0
  62 003e 00       		.byte	0
  63 003f 02       		.byte	2
  64              		.comm	ieee154e_vars,76,4
  65              		.comm	ieee154e_stats,15,4
  66              		.comm	ieee154e_dbg,20,4
  67              		.text
  68              		.align	2
  69              		.global	ieee154e_init
  70              		.thumb
  71              		.thumb_func
  73              	ieee154e_init:
  74              	.LFB0:
  75              		.file 1 "openstack/02a-MAClow/IEEE802154Ecsl.c"
   1:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "IEEE802154Ecsl.h"
   2:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
   3:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "opendefs.h"
   4:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "radio.h"
   5:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "radiotimer.h"
   6:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "IEEE802154.h"
   7:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "openqueue.h"
   8:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "idmanager.h"
   9:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "openserial.h"
  10:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "schedule.h"
  11:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "packetfunctions.h"
  12:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "scheduler.h"
  13:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "leds.h"
  14:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "neighbors.h"
  15:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "debugpins.h"
  16:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "sixtop.h"
  17:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "adaptive_sync.h"
  18:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "processIE.h"
  19:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  20:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
  21:openstack/02a-MAClow/IEEE802154Ecsl.c **** //=========================== VARIABLES ================================
  22:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
  23:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  24:openstack/02a-MAClow/IEEE802154Ecsl.c **** ieee154e_vars_t	   ieee154e_vars;
  25:openstack/02a-MAClow/IEEE802154Ecsl.c **** ieee154e_stats_t   ieee154e_stats;
  26:openstack/02a-MAClow/IEEE802154Ecsl.c **** ieee154e_dbg_t     ieee154e_dbg;
  27:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  28:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
  29:openstack/02a-MAClow/IEEE802154Ecsl.c **** //========================== PROTOTYPES ================================
  30:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
  31:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  32:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CSL]: FSM activities prototypes.
  33:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  34:openstack/02a-MAClow/IEEE802154Ecsl.c **** // TX-MODE: CSL Frame sending activities prototypes
  35:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ti1(void);
  36:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ti2(void);
  37:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_tie1(void);
  38:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ti3(void);
  39:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_tie2(void);
  40:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ti4(PORT_RADIOTIMER_WIDTH capturedTime);
  41:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_tie3(void);
  42:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ti5(PORT_RADIOTIMER_WIDTH capturedTime);
  43:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  44:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti1(void);
  45:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti2(void);
  46:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_tie1(void);
  47:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti3(void);
  48:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_tie2(void);
  49:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti4(PORT_RADIOTIMER_WIDTH capturedTime);
  50:openstack/02a-MAClow/IEEE802154Ecsl.c **** void	activity_csl_data_tie3(void);
  51:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti5(PORT_RADIOTIMER_WIDTH capturedTime);
  52:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti6(void);
  53:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_tie4(void);
  54:openstack/02a-MAClow/IEEE802154Ecsl.c **** void	activity_csl_data_ti7(void);
  55:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_tie5(void);
  56:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti8(PORT_RADIOTIMER_WIDTH capturedTime);
  57:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_tie6(void);
  58:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti9(PORT_RADIOTIMER_WIDTH capturedTime);
  59:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  60:openstack/02a-MAClow/IEEE802154Ecsl.c **** // RX-MODE: CSL Sampling activities prototypes
  61:openstack/02a-MAClow/IEEE802154Ecsl.c **** void 	activity_csl_wakeup_ri1(void);
  62:openstack/02a-MAClow/IEEE802154Ecsl.c **** void 	activity_csl_wakeup_ri2(void);
  63:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_rie1(void);
  64:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ri3(void);
  65:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_rie2(void);
  66:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ri4(PORT_RADIOTIMER_WIDTH capturedTime);
  67:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_rie3(void);
  68:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ri5(PORT_RADIOTIMER_WIDTH capturedTime);
  69:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_rie4(void);
  70:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  71:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ri2(void);
  72:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_rie1(void);
  73:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ri3(void);
  74:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_rie2(void);
  75:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ri4(PORT_RADIOTIMER_WIDTH capturedTime);
  76:openstack/02a-MAClow/IEEE802154Ecsl.c **** void	activity_csl_data_rie3(void);
  77:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ri5(PORT_RADIOTIMER_WIDTH capturedTime);
  78:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ri6(void);
  79:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_rie4(void);
  80:openstack/02a-MAClow/IEEE802154Ecsl.c **** void	activity_csl_data_ri7(void);
  81:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_rie5(void);
  82:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ri8(PORT_RADIOTIMER_WIDTH capturedTime);
  83:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_rie6(void);
  84:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ri9(PORT_RADIOTIMER_WIDTH capturedTime);
  85:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  86:openstack/02a-MAClow/IEEE802154Ecsl.c **** // frame validity check
  87:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool     isValidRxFrame(ieee802154_header_iht* ieee802514_header);
  88:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool     isValidAck(ieee802154_header_iht*     ieee802514_header,
  89:openstack/02a-MAClow/IEEE802154Ecsl.c ****                     OpenQueueEntry_t*          packetSent);
  90:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     changeIsSync(bool newIsSync);
  91:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  92:openstack/02a-MAClow/IEEE802154Ecsl.c **** // statistics
  93:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     resetStats(void);
  94:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     updateStats(PORT_SIGNED_INT_WIDTH timeCorrection);
  95:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  96:openstack/02a-MAClow/IEEE802154Ecsl.c **** // notifying upper layer
  97:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     notif_sendDone(OpenQueueEntry_t* packetSent, owerror_t error);
  98:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     notif_receive(OpenQueueEntry_t* packetReceived, uint8_t action);
  99:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 100:openstack/02a-MAClow/IEEE802154Ecsl.c **** // IEs Handling
 101:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool     ieee154e_processIEs(OpenQueueEntry_t* pkt, uint16_t* lenIE);
 102:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 103:openstack/02a-MAClow/IEEE802154Ecsl.c **** // ASN handling
 104:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     incrementAsnOffset(void);
 105:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     asnStoreFromAdv(uint8_t* asn);
 106:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     joinPriorityStoreFromAdv(uint8_t jp);
 107:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 108:openstack/02a-MAClow/IEEE802154Ecsl.c **** // misc
 109:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     changeState(ieee154e_state_t newstate);
 110:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     endOps(void);
 111:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool     debugPrint_asn(void);
 112:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool     debugPrint_isSync(void);
 113:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 114:openstack/02a-MAClow/IEEE802154Ecsl.c **** // CSL Sampling interrupts
 115:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     isr_ieee154ecsl_newChannelSample(void);
 116:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     isr_ieee154ecsl_timer(void);
 117:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 118:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CSL]: queue checking for local transmissions
 119:openstack/02a-MAClow/IEEE802154Ecsl.c **** void 	 isr_ieee154ecsl_txtimer_cb(void);
 120:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 121:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CSL-TEST]: Testing callback to put a packet on queue for testing CSL Tx mode.
 122:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     isr_ieee154ecsl_addPacketToQueueForTestingCslTx_cb (void);
 123:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 124:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CSL]: Wake-up frames prototypes (create and retrieve methods).
 125:openstack/02a-MAClow/IEEE802154Ecsl.c **** void 	ieee802154_retrieveWakeUpFrame(OpenQueueEntry_t* msg, ieee802154_header_iht* ieee802514_heade
 126:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    ieee802154_createWakeUpFrame(OpenQueueEntry_t* msg, uint8_t sequenceNumber, open_addr_t* ne
 127:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 128:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 129:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
 130:openstack/02a-MAClow/IEEE802154Ecsl.c **** //========================== INITIALIZATION ============================
 131:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
 132:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 133:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 134:openstack/02a-MAClow/IEEE802154Ecsl.c ****   \brief This function initializes this module.
 135:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 136:openstack/02a-MAClow/IEEE802154Ecsl.c ****   Call this function once before any other function in this module, possibly during boot-up.
 137:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 138:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CSL]: Modificaciones sobre método inicial referidas a los temporizadores y al estado inicial.
 139:openstack/02a-MAClow/IEEE802154Ecsl.c **** void ieee154e_init() {
  76              		.loc 1 139 0
  77              		.cfi_startproc
  78              		@ args = 0, pretend = 0, frame = 0
  79              		@ frame_needed = 1, uses_anonymous_args = 0
  80 0000 80B5     		push	{r7, lr}
  81              	.LCFI0:
  82              		.cfi_def_cfa_offset 8
  83              		.cfi_offset 7, -8
  84              		.cfi_offset 14, -4
  85 0002 00AF     		add	r7, sp, #0
  86              	.LCFI1:
  87              		.cfi_def_cfa_register 7
 140:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
 141:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // initialize variables
 142:openstack/02a-MAClow/IEEE802154Ecsl.c ****    memset(&ieee154e_vars,0,sizeof(ieee154e_vars_t));
  88              		.loc 1 142 0
  89 0004 40F20000 		movw	r0, #:lower16:ieee154e_vars
  90 0008 C0F20000 		movt	r0, #:upper16:ieee154e_vars
  91 000c 4FF00001 		mov	r1, #0
  92 0010 4FF04C02 		mov	r2, #76
  93 0014 FFF7FEFF 		bl	memset
 143:openstack/02a-MAClow/IEEE802154Ecsl.c ****    memset(&ieee154e_dbg,0,sizeof(ieee154e_dbg_t));
  94              		.loc 1 143 0
  95 0018 40F20000 		movw	r0, #:lower16:ieee154e_dbg
  96 001c C0F20000 		movt	r0, #:upper16:ieee154e_dbg
  97 0020 4FF00001 		mov	r1, #0
  98 0024 4FF01402 		mov	r2, #20
  99 0028 FFF7FEFF 		bl	memset
 144:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
 145:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (idmanager_getIsDAGroot()==TRUE) {
 100              		.loc 1 145 0
 101 002c FFF7FEFF 		bl	idmanager_getIsDAGroot
 102 0030 0346     		mov	r3, r0
 103 0032 002B     		cmp	r3, #0
 104 0034 04D0     		beq	.L2
 146:openstack/02a-MAClow/IEEE802154Ecsl.c ****       changeIsSync(TRUE);
 105              		.loc 1 146 0
 106 0036 4FF00100 		mov	r0, #1
 107 003a FFF7FEFF 		bl	changeIsSync
 108 003e 03E0     		b	.L3
 109              	.L2:
 147:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
 148:openstack/02a-MAClow/IEEE802154Ecsl.c ****       changeIsSync(FALSE);
 110              		.loc 1 148 0
 111 0040 4FF00000 		mov	r0, #0
 112 0044 FFF7FEFF 		bl	changeIsSync
 113              	.L3:
 149:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 150:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
 151:openstack/02a-MAClow/IEEE802154Ecsl.c ****    resetStats();
 114              		.loc 1 151 0
 115 0048 FFF7FEFF 		bl	resetStats
 152:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.numDeSync                 = 0;
 116              		.loc 1 152 0
 117 004c 40F20003 		movw	r3, #:lower16:ieee154e_stats
 118 0050 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 119 0054 4FF00002 		mov	r2, #0
 120 0058 9A71     		strb	r2, [r3, #6]
 153:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
 154:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // [CSL]: update CSL Mode to SLEEP in order to allow RX o TX.
 155:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.cslMode = CSL_SLEEP_MODE;
 121              		.loc 1 155 0
 122 005a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 123 005e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 124 0062 4FF00002 		mov	r2, #0
 125 0066 83F84520 		strb	r2, [r3, #69]
 156:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // [CSL]: Set initial DSN counter for wake-up sequence frames.
 157:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.cslDSN	 = 0;
 126              		.loc 1 157 0
 127 006a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 128 006e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 129 0072 4FF00002 		mov	r2, #0
 130 0076 83F84420 		strb	r2, [r3, #68]
 158:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 159:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // switch radio on - Does this function really do anything?. Its contents are commented...
 160:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rfOn();
 131              		.loc 1 160 0
 132 007a FFF7FEFF 		bl	radio_rfOn
 161:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
 162:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // set callback functions for the radio
 163:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_setOverflowCb(isr_ieee154ecsl_newChannelSample); // CSL - Fires every macCSLPeriod for sam
 133              		.loc 1 163 0
 134 007e 40F20000 		movw	r0, #:lower16:isr_ieee154ecsl_newChannelSample
 135 0082 C0F20000 		movt	r0, #:upper16:isr_ieee154ecsl_newChannelSample
 136 0086 FFF7FEFF 		bl	radio_setOverflowCb
 164:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_setCompareCb(isr_ieee154ecsl_timer);             // CSL - Fires for FSM state changing.
 137              		.loc 1 164 0
 138 008a 40F20000 		movw	r0, #:lower16:isr_ieee154ecsl_timer
 139 008e C0F20000 		movt	r0, #:upper16:isr_ieee154ecsl_timer
 140 0092 FFF7FEFF 		bl	radio_setCompareCb
 165:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_setStartFrameCb(ieee154ecsl_startOfFrame);       // CSL – Fires on start of frame detect
 141              		.loc 1 165 0
 142 0096 40F20000 		movw	r0, #:lower16:ieee154ecsl_startOfFrame
 143 009a C0F20000 		movt	r0, #:upper16:ieee154ecsl_startOfFrame
 144 009e FFF7FEFF 		bl	radio_setStartFrameCb
 166:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_setEndFrameCb(ieee154ecsl_endOfFrame);           // CSL – Fires on end of frame detected
 145              		.loc 1 166 0
 146 00a2 40F20000 		movw	r0, #:lower16:ieee154ecsl_endOfFrame
 147 00a6 C0F20000 		movt	r0, #:upper16:ieee154ecsl_endOfFrame
 148 00aa FFF7FEFF 		bl	radio_setEndFrameCb
 167:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 168:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // [CSL]: set timer for checking frames on local queue to transmit.
 169:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.txTimer = opentimers_start(macCSLTxChkFreq, TIMER_PERIODIC, TIME_TICS, isr_ieee154
 149              		.loc 1 169 0
 150 00ae 40F2AE70 		movw	r0, #1966
 151 00b2 4FF00001 		mov	r1, #0
 152 00b6 4FF00102 		mov	r2, #1
 153 00ba 40F20003 		movw	r3, #:lower16:isr_ieee154ecsl_txtimer_cb
 154 00be C0F20003 		movt	r3, #:upper16:isr_ieee154ecsl_txtimer_cb
 155 00c2 FFF7FEFF 		bl	opentimers_start
 156 00c6 0346     		mov	r3, r0
 157 00c8 1A46     		mov	r2, r3
 158 00ca 40F20003 		movw	r3, #:lower16:ieee154e_vars
 159 00ce C0F20003 		movt	r3, #:upper16:ieee154e_vars
 160 00d2 83F84620 		strb	r2, [r3, #70]
 170:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 171:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // [CSL-TEST]: set timer for callback to add packet to queue for testing CSL TX (every 5 seconds
 172:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.cslTxTestTimer = opentimers_start(2000, TIMER_PERIODIC, TIME_MS, isr_ieee154ecsl_a
 161              		.loc 1 172 0
 162 00d6 4FF4FA60 		mov	r0, #2000
 163 00da 4FF00001 		mov	r1, #0
 164 00de 4FF00002 		mov	r2, #0
 165 00e2 40F20003 		movw	r3, #:lower16:isr_ieee154ecsl_addPacketToQueueForTestingCslTx_cb
 166 00e6 C0F20003 		movt	r3, #:upper16:isr_ieee154ecsl_addPacketToQueueForTestingCslTx_cb
 167 00ea FFF7FEFF 		bl	opentimers_start
 168 00ee 0346     		mov	r3, r0
 169 00f0 1A46     		mov	r2, r3
 170 00f2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 171 00f6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 172 00fa 83F84720 		strb	r2, [r3, #71]
 173:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 174:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // [CSL]: have the radio start its timer for channel sampling (macCSLPeriod)
 175:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_startTimer(macCSLPeriod);
 173              		.loc 1 175 0
 174 00fe 41F69A10 		movw	r0, #6554
 175 0102 FFF7FEFF 		bl	radio_startTimer
 176:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 176              		.loc 1 176 0
 177 0106 80BD     		pop	{r7, pc}
 178              		.cfi_endproc
 179              	.LFE0:
 181              		.align	2
 182              		.global	isr_ieee154ecsl_newChannelSample
 183              		.thumb
 184              		.thumb_func
 186              	isr_ieee154ecsl_newChannelSample:
 187              	.LFB1:
 177:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 178:openstack/02a-MAClow/IEEE802154Ecsl.c **** //=========================== public ==========================================
 179:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 180:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
 181:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================  EVENTS & CALLBACKS ===========================
 182:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
 183:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 184:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 185:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Indicates a new CSL Channel Sample has just started.
 186:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 187:openstack/02a-MAClow/IEEE802154Ecsl.c **** This function executes in ISR mode, when the new CSÑ Channel Sample timer fires.
 188:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 189:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CSL]: Callback indicating the start of a new CSL channel sample.
 190:openstack/02a-MAClow/IEEE802154Ecsl.c **** void isr_ieee154ecsl_newChannelSample() {
 188              		.loc 1 190 0
 189              		.cfi_startproc
 190              		@ args = 0, pretend = 0, frame = 0
 191              		@ frame_needed = 1, uses_anonymous_args = 0
 192 0108 80B5     		push	{r7, lr}
 193              	.LCFI2:
 194              		.cfi_def_cfa_offset 8
 195              		.cfi_offset 7, -8
 196              		.cfi_offset 14, -4
 197 010a 00AF     		add	r7, sp, #0
 198              	.LCFI3:
 199              		.cfi_def_cfa_register 7
 191:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Establish the new timer for the next channel sample
 192:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_setTimerPeriod(macCSLPeriod);
 200              		.loc 1 192 0
 201 010c 41F69A10 		movw	r0, #6554
 202 0110 FFF7FEFF 		bl	radio_setTimerPeriod
 193:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 194:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Verificamos que no estamos ya en un proceso de TX o RX previo.
 195:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if(ieee154e_vars.cslMode == CSL_SLEEP_MODE) {
 203              		.loc 1 195 0
 204 0114 40F20003 		movw	r3, #:lower16:ieee154e_vars
 205 0118 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 206 011c 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 207 0120 002B     		cmp	r3, #0
 208 0122 02D1     		bne	.L5
 196:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // We call the first activity on FSM for channel sampling (CSL FSM RX mode)
 197:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  activity_csl_wakeup_ri1();
 209              		.loc 1 197 0
 210 0124 FFF7FEFF 		bl	activity_csl_wakeup_ri1
 211 0128 12E0     		b	.L6
 212              	.L5:
 198:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
 199:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // log the info about a operation in progress
 200:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printInfo(COMPONENT_IEEE802154E,ERR_MAC_OPERATION_IN_PROGRESS,
 201:openstack/02a-MAClow/IEEE802154Ecsl.c **** 						  (errorparameter_t)ieee154e_vars.cslMode, (errorparameter_t)ieee154e_dbg.num_cslSamples);
 213              		.loc 1 201 0
 214 012a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 215 012e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 216 0132 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 200:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printInfo(COMPONENT_IEEE802154E,ERR_MAC_OPERATION_IN_PROGRESS,
 217              		.loc 1 200 0
 218 0136 1A46     		mov	r2, r3
 219              		.loc 1 201 0
 220 0138 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 221 013c C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 222 0140 1B69     		ldr	r3, [r3, #16]
 200:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printInfo(COMPONENT_IEEE802154E,ERR_MAC_OPERATION_IN_PROGRESS,
 223              		.loc 1 200 0
 224 0142 9BB2     		uxth	r3, r3
 225 0144 4FF00900 		mov	r0, #9
 226 0148 4FF04001 		mov	r1, #64
 227 014c FFF7FEFF 		bl	openserial_printInfo
 228              	.L6:
 202:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 203:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 204:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Increment the number of cslSamples.
 205:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_dbg.num_cslSamples++;
 229              		.loc 1 205 0
 230 0150 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 231 0154 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 232 0158 1B69     		ldr	r3, [r3, #16]
 233 015a 03F10102 		add	r2, r3, #1
 234 015e 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 235 0162 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 236 0166 1A61     		str	r2, [r3, #16]
 206:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 237              		.loc 1 206 0
 238 0168 80BD     		pop	{r7, pc}
 239              		.cfi_endproc
 240              	.LFE1:
 242 016a 00BF     		.align	2
 243              		.global	isr_ieee154ecsl_timer
 244              		.thumb
 245              		.thumb_func
 247              	isr_ieee154ecsl_timer:
 248              	.LFB2:
 207:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 208:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 209:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Indicates the FSM timer has fired.
 210:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 211:openstack/02a-MAClow/IEEE802154Ecsl.c **** This function executes in ISR mode, when the FSM timer fires.
 212:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 213:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CSL]: Callback to select the next FSM action.
 214:openstack/02a-MAClow/IEEE802154Ecsl.c **** void isr_ieee154ecsl_timer() {
 249              		.loc 1 214 0
 250              		.cfi_startproc
 251              		@ args = 0, pretend = 0, frame = 0
 252              		@ frame_needed = 1, uses_anonymous_args = 0
 253 016c 80B5     		push	{r7, lr}
 254              	.LCFI4:
 255              		.cfi_def_cfa_offset 8
 256              		.cfi_offset 7, -8
 257              		.cfi_offset 14, -4
 258 016e 00AF     		add	r7, sp, #0
 259              	.LCFI5:
 260              		.cfi_def_cfa_register 7
 215:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.cslMode == CSL_RX_MODE)  { // Current CSL operation mode is channel sampling a
 261              		.loc 1 215 0
 262 0170 40F20003 		movw	r3, #:lower16:ieee154e_vars
 263 0174 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 264 0178 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 265 017c 012B     		cmp	r3, #1
 266 017e 71D1     		bne	.L8
 216:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   switch (ieee154e_vars.state) {
 267              		.loc 1 216 0
 268 0180 40F20003 		movw	r3, #:lower16:ieee154e_vars
 269 0184 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 270 0188 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 271 018a A3F12B03 		sub	r3, r3, #43
 272 018e 0F2B     		cmp	r3, #15
 273 0190 53D8     		bhi	.L9
 274 0192 01A2     		adr	r2, .L26
 275 0194 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 276              		.align	2
 277              	.L26:
 278 0198 D9010000 		.word	.L10+1
 279 019c DF010000 		.word	.L11+1
 280 01a0 E5010000 		.word	.L12+1
 281 01a4 EB010000 		.word	.L13+1
 282 01a8 F1010000 		.word	.L14+1
 283 01ac F7010000 		.word	.L15+1
 284 01b0 FD010000 		.word	.L16+1
 285 01b4 03020000 		.word	.L17+1
 286 01b8 09020000 		.word	.L18+1
 287 01bc 0F020000 		.word	.L19+1
 288 01c0 15020000 		.word	.L20+1
 289 01c4 1B020000 		.word	.L21+1
 290 01c8 21020000 		.word	.L22+1
 291 01cc 27020000 		.word	.L23+1
 292 01d0 2D020000 		.word	.L24+1
 293 01d4 33020000 		.word	.L25+1
 294              	.L10:
 217:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      // RX-MODE
 218:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUPOFFSET:      activity_csl_wakeup_ri2();  break;
 295              		.loc 1 218 0
 296 01d8 FFF7FEFF 		bl	activity_csl_wakeup_ri2
 297 01dc BBE0     		b	.L28
 298              	.L11:
 219:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUPPREPARE:     activity_csl_wakeup_rie1(); break;
 299              		.loc 1 219 0
 300 01de FFF7FEFF 		bl	activity_csl_wakeup_rie1
 301 01e2 B8E0     		b	.L28
 302              	.L12:
 220:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUPREADY:       activity_csl_wakeup_ri3();  break;
 303              		.loc 1 220 0
 304 01e4 FFF7FEFF 		bl	activity_csl_wakeup_ri3
 305 01e8 B5E0     		b	.L28
 306              	.L13:
 221:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUPLISTEN:      activity_csl_wakeup_rie2(); break;
 307              		.loc 1 221 0
 308 01ea FFF7FEFF 		bl	activity_csl_wakeup_rie2
 309 01ee B2E0     		b	.L28
 310              	.L14:
 222:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUP:			 activity_csl_wakeup_rie3(); break;
 311              		.loc 1 222 0
 312 01f0 FFF7FEFF 		bl	activity_csl_wakeup_rie3
 313 01f4 AFE0     		b	.L28
 314              	.L15:
 223:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUPVALIDATE: 	 activity_csl_wakeup_rie4(); break;
 315              		.loc 1 223 0
 316 01f6 FFF7FEFF 		bl	activity_csl_wakeup_rie4
 317 01fa ACE0     		b	.L28
 318              	.L16:
 224:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 225:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXDATAOFFSET:    	 activity_csl_data_ri2();    break;
 319              		.loc 1 225 0
 320 01fc FFF7FEFF 		bl	activity_csl_data_ri2
 321 0200 A9E0     		b	.L28
 322              	.L17:
 226:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXDATAPREPARE:       activity_csl_data_rie1();   break;
 323              		.loc 1 226 0
 324 0202 FFF7FEFF 		bl	activity_csl_data_rie1
 325 0206 A6E0     		b	.L28
 326              	.L18:
 227:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXDATAREADY:         activity_csl_data_ri3();    break;
 327              		.loc 1 227 0
 328 0208 FFF7FEFF 		bl	activity_csl_data_ri3
 329 020c A3E0     		b	.L28
 330              	.L19:
 228:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXDATALISTEN:        activity_csl_data_rie2();   break;
 331              		.loc 1 228 0
 332 020e FFF7FEFF 		bl	activity_csl_data_rie2
 333 0212 A0E0     		b	.L28
 334              	.L20:
 229:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXDATA:			     activity_csl_data_rie3();   break;
 335              		.loc 1 229 0
 336 0214 FFF7FEFF 		bl	activity_csl_data_rie3
 337 0218 9DE0     		b	.L28
 338              	.L21:
 230:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 231:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLTXACKOFFSET: 	     activity_csl_data_ri6();    break;
 339              		.loc 1 231 0
 340 021a FFF7FEFF 		bl	activity_csl_data_ri6
 341 021e 9AE0     		b	.L28
 342              	.L22:
 232:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLTXACKPREPARE:        activity_csl_data_rie4();   break;
 343              		.loc 1 232 0
 344 0220 FFF7FEFF 		bl	activity_csl_data_rie4
 345 0224 97E0     		b	.L28
 346              	.L23:
 233:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLTXACKREADY:          activity_csl_data_ri7();    break;
 347              		.loc 1 233 0
 348 0226 FFF7FEFF 		bl	activity_csl_data_ri7
 349 022a 94E0     		b	.L28
 350              	.L24:
 234:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLTXACKDELAY:          activity_csl_data_rie5();   break;
 351              		.loc 1 234 0
 352 022c FFF7FEFF 		bl	activity_csl_data_rie5
 353 0230 91E0     		b	.L28
 354              	.L25:
 235:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLTXACK:               activity_csl_data_rie6();   break;
 355              		.loc 1 235 0
 356 0232 FFF7FEFF 		bl	activity_csl_data_rie6
 357 0236 00BF     		nop
 358 0238 8DE0     		b	.L28
 359              	.L9:
 236:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  default:
 237:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 // log the error
 238:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_TIMERFIRES,
 239:openstack/02a-MAClow/IEEE802154Ecsl.c **** 								   (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_dbg.num_cslSamples);
 360              		.loc 1 239 0
 361 023a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 362 023e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 363 0242 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 238:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_TIMERFIRES,
 364              		.loc 1 238 0
 365 0244 1A46     		mov	r2, r3
 366              		.loc 1 239 0
 367 0246 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 368 024a C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 369 024e 1B69     		ldr	r3, [r3, #16]
 238:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_TIMERFIRES,
 370              		.loc 1 238 0
 371 0250 9BB2     		uxth	r3, r3
 372 0252 4FF00900 		mov	r0, #9
 373 0256 4FF03B01 		mov	r1, #59
 374 025a FFF7FEFF 		bl	openserial_printError
 240:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 // abort
 241:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 endOps();
 375              		.loc 1 241 0
 376 025e FFF7FEFF 		bl	endOps
 242:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 break;
 377              		.loc 1 242 0
 378 0262 78E0     		b	.L28
 379              	.L8:
 243:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 244:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else if (ieee154e_vars.cslMode == CSL_TX_MODE)  { // Current CSL operation mode is frame TX.
 380              		.loc 1 244 0
 381 0264 40F20003 		movw	r3, #:lower16:ieee154e_vars
 382 0268 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 383 026c 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 384 0270 022B     		cmp	r3, #2
 385 0272 70D1     		bne	.L28
 245:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   switch (ieee154e_vars.state) {
 386              		.loc 1 245 0
 387 0274 40F20003 		movw	r3, #:lower16:ieee154e_vars
 388 0278 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 389 027c 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 390 027e A3F11A03 		sub	r3, r3, #26
 391 0282 0F2B     		cmp	r3, #15
 392 0284 52D8     		bhi	.L29
 393 0286 01A2     		adr	r2, .L46
 394 0288 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 395              		.align	2
 396              	.L46:
 397 028c CD020000 		.word	.L30+1
 398 0290 D3020000 		.word	.L31+1
 399 0294 D9020000 		.word	.L32+1
 400 0298 DF020000 		.word	.L33+1
 401 029c E5020000 		.word	.L34+1
 402 02a0 EB020000 		.word	.L35+1
 403 02a4 F1020000 		.word	.L36+1
 404 02a8 F7020000 		.word	.L37+1
 405 02ac FD020000 		.word	.L38+1
 406 02b0 03030000 		.word	.L39+1
 407 02b4 09030000 		.word	.L40+1
 408 02b8 0F030000 		.word	.L41+1
 409 02bc 15030000 		.word	.L42+1
 410 02c0 1B030000 		.word	.L43+1
 411 02c4 21030000 		.word	.L44+1
 412 02c8 27030000 		.word	.L45+1
 413              	.L30:
 246:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      // TX-MODE
 247:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXWAKEUPOFFSET:		 activity_csl_wakeup_ti2();  break;
 414              		.loc 1 247 0
 415 02cc FFF7FEFF 		bl	activity_csl_wakeup_ti2
 416 02d0 41E0     		b	.L28
 417              	.L31:
 248:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXWAKEUPPREPARE:	 activity_csl_wakeup_tie1(); break;
 418              		.loc 1 248 0
 419 02d2 FFF7FEFF 		bl	activity_csl_wakeup_tie1
 420 02d6 3EE0     		b	.L28
 421              	.L32:
 249:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXWAKEUPREADY:	     activity_csl_wakeup_ti3();  break;
 422              		.loc 1 249 0
 423 02d8 FFF7FEFF 		bl	activity_csl_wakeup_ti3
 424 02dc 3BE0     		b	.L28
 425              	.L33:
 250:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXWAKEUPDELAY:	     activity_csl_wakeup_tie2(); break;
 426              		.loc 1 250 0
 427 02de FFF7FEFF 		bl	activity_csl_wakeup_tie2
 428 02e2 38E0     		b	.L28
 429              	.L34:
 251:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXWAKEUP: 	         activity_csl_wakeup_tie3(); break;
 430              		.loc 1 251 0
 431 02e4 FFF7FEFF 		bl	activity_csl_wakeup_tie3
 432 02e8 35E0     		b	.L28
 433              	.L35:
 252:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 253:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXDATAPREOFFSET:	 activity_csl_data_ti1();	 break;
 434              		.loc 1 253 0
 435 02ea FFF7FEFF 		bl	activity_csl_data_ti1
 436 02ee 32E0     		b	.L28
 437              	.L36:
 254:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXDATAOFFSET:        activity_csl_data_ti2();    break;
 438              		.loc 1 254 0
 439 02f0 FFF7FEFF 		bl	activity_csl_data_ti2
 440 02f4 2FE0     		b	.L28
 441              	.L37:
 255:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXDATAPREPARE:	     activity_csl_data_tie1(); 	 break;
 442              		.loc 1 255 0
 443 02f6 FFF7FEFF 		bl	activity_csl_data_tie1
 444 02fa 2CE0     		b	.L28
 445              	.L38:
 256:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXDATAREADY:	     activity_csl_data_ti3(); 	 break;
 446              		.loc 1 256 0
 447 02fc FFF7FEFF 		bl	activity_csl_data_ti3
 448 0300 29E0     		b	.L28
 449              	.L39:
 257:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXDATADELAY:	     activity_csl_data_tie2(); 	 break;
 450              		.loc 1 257 0
 451 0302 FFF7FEFF 		bl	activity_csl_data_tie2
 452 0306 26E0     		b	.L28
 453              	.L40:
 258:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXDATA: 	         activity_csl_data_tie3();	 break;
 454              		.loc 1 258 0
 455 0308 FFF7FEFF 		bl	activity_csl_data_tie3
 456 030c 23E0     		b	.L28
 457              	.L41:
 259:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 260:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLRXACKOFFSET: 	     activity_csl_data_ti6();	 break;
 458              		.loc 1 260 0
 459 030e FFF7FEFF 		bl	activity_csl_data_ti6
 460 0312 20E0     		b	.L28
 461              	.L42:
 261:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLRXACKPREPARE:	     activity_csl_data_tie4(); 	 break;
 462              		.loc 1 261 0
 463 0314 FFF7FEFF 		bl	activity_csl_data_tie4
 464 0318 1DE0     		b	.L28
 465              	.L43:
 262:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLRXACKREADY: 	     activity_csl_data_ti7(); 	 break;
 466              		.loc 1 262 0
 467 031a FFF7FEFF 		bl	activity_csl_data_ti7
 468 031e 1AE0     		b	.L28
 469              	.L44:
 263:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLRXACKLISTEN: 	     activity_csl_data_tie5(); 	 break;
 470              		.loc 1 263 0
 471 0320 FFF7FEFF 		bl	activity_csl_data_tie5
 472 0324 17E0     		b	.L28
 473              	.L45:
 264:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLRXACK:     	         activity_csl_data_tie6(); 	 break;
 474              		.loc 1 264 0
 475 0326 FFF7FEFF 		bl	activity_csl_data_tie6
 476 032a 14E0     		b	.L28
 477              	.L29:
 265:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 266:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  default:
 267:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 // log the error
 268:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_TIMERFIRES,
 269:openstack/02a-MAClow/IEEE802154Ecsl.c **** 								   (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_dbg.num_cslSamples);
 478              		.loc 1 269 0
 479 032c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 480 0330 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 481 0334 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 268:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_TIMERFIRES,
 482              		.loc 1 268 0
 483 0336 1A46     		mov	r2, r3
 484              		.loc 1 269 0
 485 0338 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 486 033c C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 487 0340 1B69     		ldr	r3, [r3, #16]
 268:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_TIMERFIRES,
 488              		.loc 1 268 0
 489 0342 9BB2     		uxth	r3, r3
 490 0344 4FF00900 		mov	r0, #9
 491 0348 4FF03B01 		mov	r1, #59
 492 034c FFF7FEFF 		bl	openserial_printError
 270:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 // abort
 271:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 endOps();
 493              		.loc 1 271 0
 494 0350 FFF7FEFF 		bl	endOps
 272:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 break;
 495              		.loc 1 272 0
 496 0354 00BF     		nop
 497              	.L28:
 273:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 274:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 275:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_dbg.num_timer++;
 498              		.loc 1 275 0
 499 0356 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 500 035a C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 501 035e 5B68     		ldr	r3, [r3, #4]
 502 0360 03F10102 		add	r2, r3, #1
 503 0364 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 504 0368 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 505 036c 5A60     		str	r2, [r3, #4]
 276:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 506              		.loc 1 276 0
 507 036e 80BD     		pop	{r7, pc}
 508              		.cfi_endproc
 509              	.LFE2:
 511              		.align	2
 512              		.global	ieee154ecsl_startOfFrame
 513              		.thumb
 514              		.thumb_func
 516              	ieee154ecsl_startOfFrame:
 517              	.LFB3:
 277:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 278:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CSL] – Callback fired after receive a start of frame on radio.
 279:openstack/02a-MAClow/IEEE802154Ecsl.c **** void ieee154ecsl_startOfFrame(PORT_RADIOTIMER_WIDTH capturedTime) {
 518              		.loc 1 279 0
 519              		.cfi_startproc
 520              		@ args = 0, pretend = 0, frame = 8
 521              		@ frame_needed = 1, uses_anonymous_args = 0
 522 0370 80B5     		push	{r7, lr}
 523              	.LCFI6:
 524              		.cfi_def_cfa_offset 8
 525              		.cfi_offset 7, -8
 526              		.cfi_offset 14, -4
 527 0372 82B0     		sub	sp, sp, #8
 528              	.LCFI7:
 529              		.cfi_def_cfa_offset 16
 530 0374 00AF     		add	r7, sp, #0
 531              	.LCFI8:
 532              		.cfi_def_cfa_register 7
 533 0376 7860     		str	r0, [r7, #4]
 280:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	if(ieee154e_vars.cslMode == CSL_RX_MODE)  { // Current CSL operation mode is channel sampling and 
 534              		.loc 1 280 0
 535 0378 40F20003 		movw	r3, #:lower16:ieee154e_vars
 536 037c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 537 0380 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 538 0384 012B     		cmp	r3, #1
 539 0386 33D1     		bne	.L48
 281:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   switch (ieee154e_vars.state) {
 540              		.loc 1 281 0
 541 0388 40F20003 		movw	r3, #:lower16:ieee154e_vars
 542 038c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 543 0390 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 544 0392 A3F12E03 		sub	r3, r3, #46
 545 0396 0B2B     		cmp	r3, #11
 546 0398 27D8     		bhi	.L49
 547 039a 01A2     		adr	r2, .L53
 548 039c 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 549              		.align	2
 550              	.L53:
 551 03a0 D1030000 		.word	.L50+1
 552 03a4 D1030000 		.word	.L50+1
 553 03a8 EB030000 		.word	.L49+1
 554 03ac EB030000 		.word	.L49+1
 555 03b0 EB030000 		.word	.L49+1
 556 03b4 D9030000 		.word	.L51+1
 557 03b8 D9030000 		.word	.L51+1
 558 03bc EB030000 		.word	.L49+1
 559 03c0 EB030000 		.word	.L49+1
 560 03c4 EB030000 		.word	.L49+1
 561 03c8 EB030000 		.word	.L49+1
 562 03cc E1030000 		.word	.L52+1
 563              	.L50:
 282:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  // RX MODE
 283:openstack/02a-MAClow/IEEE802154Ecsl.c ****           /*
 284:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   It is possible to receive in this state for radio where there is no way of differentiated betw
 285:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   (e.g. CC2420). We must therefore expect to the start of a packet in this "ready" state.
 286:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  */
 287:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUP:    			 // no break!
 288:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUPLISTEN:	 	     activity_csl_wakeup_ri4(capturedTime); break;
 564              		.loc 1 288 0
 565 03d0 7868     		ldr	r0, [r7, #4]
 566 03d2 FFF7FEFF 		bl	activity_csl_wakeup_ri4
 567 03d6 58E0     		b	.L55
 568              	.L51:
 289:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 290:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXDATAREADY:		     // no break!
 291:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXDATALISTEN:            activity_csl_data_ri4(capturedTime);   break;
 569              		.loc 1 291 0
 570 03d8 7868     		ldr	r0, [r7, #4]
 571 03da FFF7FEFF 		bl	activity_csl_data_ri4
 572 03de 54E0     		b	.L55
 573              	.L52:
 292:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 293:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLTXACKDELAY:              activity_csl_data_ri8(capturedTime);   break;
 574              		.loc 1 293 0
 575 03e0 7868     		ldr	r0, [r7, #4]
 576 03e2 FFF7FEFF 		bl	activity_csl_data_ri8
 577 03e6 00BF     		nop
 578 03e8 4FE0     		b	.L55
 579              	.L49:
 294:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  default:
 295:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			// log the error
 296:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			//openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_SAMPLE,
 297:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			//					  (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_dbg.num_cslSamples);
 298:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			// abort
 299:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			endOps();
 580              		.loc 1 299 0
 581 03ea FFF7FEFF 		bl	endOps
 300:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			break;
 582              		.loc 1 300 0
 583 03ee 4CE0     		b	.L55
 584              	.L48:
 301:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		}
 302:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	} else if (ieee154e_vars.cslMode == CSL_TX_MODE)  { // Current CSL operation mode is frame TX.
 585              		.loc 1 302 0
 586 03f0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 587 03f4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 588 03f8 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 589 03fc 022B     		cmp	r3, #2
 590 03fe 44D1     		bne	.L55
 303:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   switch (ieee154e_vars.state) {
 591              		.loc 1 303 0
 592 0400 40F20003 		movw	r3, #:lower16:ieee154e_vars
 593 0404 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 594 0408 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 595 040a A3F11D03 		sub	r3, r3, #29
 596 040e 0B2B     		cmp	r3, #11
 597 0410 26D8     		bhi	.L56
 598 0412 01A2     		adr	r2, .L60
 599 0414 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 600              		.align	2
 601              	.L60:
 602 0418 51040000 		.word	.L57+1
 603 041c 61040000 		.word	.L56+1
 604 0420 61040000 		.word	.L56+1
 605 0424 61040000 		.word	.L56+1
 606 0428 61040000 		.word	.L56+1
 607 042c 61040000 		.word	.L56+1
 608 0430 59040000 		.word	.L58+1
 609 0434 61040000 		.word	.L56+1
 610 0438 61040000 		.word	.L56+1
 611 043c 61040000 		.word	.L56+1
 612 0440 49040000 		.word	.L59+1
 613 0444 49040000 		.word	.L59+1
 614              	.L59:
 304:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  // TX MODE
 305:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 306:openstack/02a-MAClow/IEEE802154Ecsl.c ****           /*
 307:openstack/02a-MAClow/IEEE802154Ecsl.c ****           It is possible to receive in this state for radio where there is no way of differentiated
 308:openstack/02a-MAClow/IEEE802154Ecsl.c ****           (e.g. CC2420). We must therefore expect to the start of a packet in this "ready" state.
 309:openstack/02a-MAClow/IEEE802154Ecsl.c ****           */
 310:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLRXACKREADY:               // no break!
 311:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLRXACKLISTEN:              activity_csl_data_ti8(capturedTime);  break;
 615              		.loc 1 311 0
 616 0448 7868     		ldr	r0, [r7, #4]
 617 044a FFF7FEFF 		bl	activity_csl_data_ti8
 618 044e 1CE0     		b	.L55
 619              	.L57:
 312:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 313:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXWAKEUPDELAY:            activity_csl_wakeup_ti4(capturedTime); break;
 620              		.loc 1 313 0
 621 0450 7868     		ldr	r0, [r7, #4]
 622 0452 FFF7FEFF 		bl	activity_csl_wakeup_ti4
 623 0456 18E0     		b	.L55
 624              	.L58:
 314:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXDATADELAY:              activity_csl_data_ti4(capturedTime);   break;
 625              		.loc 1 314 0
 626 0458 7868     		ldr	r0, [r7, #4]
 627 045a FFF7FEFF 		bl	activity_csl_data_ti4
 628 045e 14E0     		b	.L55
 629              	.L56:
 315:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 316:openstack/02a-MAClow/IEEE802154Ecsl.c ****           default:
 317:openstack/02a-MAClow/IEEE802154Ecsl.c ****    			// log the error
 318:openstack/02a-MAClow/IEEE802154Ecsl.c ****    			openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_SAMPLE,
 319:openstack/02a-MAClow/IEEE802154Ecsl.c ****    								  (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_dbg.num_cslSamples);
 630              		.loc 1 319 0
 631 0460 40F20003 		movw	r3, #:lower16:ieee154e_vars
 632 0464 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 633 0468 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 318:openstack/02a-MAClow/IEEE802154Ecsl.c ****    			openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_SAMPLE,
 634              		.loc 1 318 0
 635 046a 1A46     		mov	r2, r3
 636              		.loc 1 319 0
 637 046c 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 638 0470 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 639 0474 1B69     		ldr	r3, [r3, #16]
 318:openstack/02a-MAClow/IEEE802154Ecsl.c ****    			openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_SAMPLE,
 640              		.loc 1 318 0
 641 0476 9BB2     		uxth	r3, r3
 642 0478 4FF00900 		mov	r0, #9
 643 047c 4FF03E01 		mov	r1, #62
 644 0480 FFF7FEFF 		bl	openserial_printError
 320:openstack/02a-MAClow/IEEE802154Ecsl.c ****    			// abort
 321:openstack/02a-MAClow/IEEE802154Ecsl.c ****    			endOps();
 645              		.loc 1 321 0
 646 0484 FFF7FEFF 		bl	endOps
 322:openstack/02a-MAClow/IEEE802154Ecsl.c ****    			break;
 647              		.loc 1 322 0
 648 0488 00BF     		nop
 649              	.L55:
 323:openstack/02a-MAClow/IEEE802154Ecsl.c ****    		}
 324:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	}
 325:openstack/02a-MAClow/IEEE802154Ecsl.c ****   ieee154e_dbg.num_startOfFrame++;
 650              		.loc 1 325 0
 651 048a 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 652 048e C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 653 0492 9B68     		ldr	r3, [r3, #8]
 654 0494 03F10102 		add	r2, r3, #1
 655 0498 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 656 049c C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 657 04a0 9A60     		str	r2, [r3, #8]
 326:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 658              		.loc 1 326 0
 659 04a2 07F10807 		add	r7, r7, #8
 660 04a6 BD46     		mov	sp, r7
 661 04a8 80BD     		pop	{r7, pc}
 662              		.cfi_endproc
 663              	.LFE3:
 665 04aa 00BF     		.align	2
 666              		.global	ieee154ecsl_endOfFrame
 667              		.thumb
 668              		.thumb_func
 670              	ieee154ecsl_endOfFrame:
 671              	.LFB4:
 327:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 328:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CSL] – Callback fired after receive a end of frame on radio.
 329:openstack/02a-MAClow/IEEE802154Ecsl.c **** void ieee154ecsl_endOfFrame(PORT_RADIOTIMER_WIDTH capturedTime) {
 672              		.loc 1 329 0
 673              		.cfi_startproc
 674              		@ args = 0, pretend = 0, frame = 8
 675              		@ frame_needed = 1, uses_anonymous_args = 0
 676 04ac 80B5     		push	{r7, lr}
 677              	.LCFI9:
 678              		.cfi_def_cfa_offset 8
 679              		.cfi_offset 7, -8
 680              		.cfi_offset 14, -4
 681 04ae 82B0     		sub	sp, sp, #8
 682              	.LCFI10:
 683              		.cfi_def_cfa_offset 16
 684 04b0 00AF     		add	r7, sp, #0
 685              	.LCFI11:
 686              		.cfi_def_cfa_register 7
 687 04b2 7860     		str	r0, [r7, #4]
 330:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	if(ieee154e_vars.cslMode == CSL_RX_MODE)  { // Current CSL operation mode is channel sampling and 
 688              		.loc 1 330 0
 689 04b4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 690 04b8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 691 04bc 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 692 04c0 012B     		cmp	r3, #1
 693 04c2 2CD1     		bne	.L62
 331:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   switch (ieee154e_vars.state) {
 694              		.loc 1 331 0
 695 04c4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 696 04c8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 697 04cc 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 698 04ce 352B     		cmp	r3, #53
 699 04d0 07D0     		beq	.L65
 700 04d2 3A2B     		cmp	r3, #58
 701 04d4 09D0     		beq	.L66
 702 04d6 2F2B     		cmp	r3, #47
 703 04d8 0CD1     		bne	.L73
 704              	.L64:
 332:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		 // RX MODE
 333:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		 case S_CSLRXWAKEUP:           activity_csl_wakeup_ri5(capturedTime);  break;
 705              		.loc 1 333 0
 706 04da 7868     		ldr	r0, [r7, #4]
 707 04dc FFF7FEFF 		bl	activity_csl_wakeup_ri5
 708 04e0 51E0     		b	.L68
 709              	.L65:
 334:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		 case S_CSLRXDATA:             activity_csl_data_ri5(capturedTime);    break;
 710              		.loc 1 334 0
 711 04e2 7868     		ldr	r0, [r7, #4]
 712 04e4 FFF7FEFF 		bl	activity_csl_data_ri5
 713 04e8 4DE0     		b	.L68
 714              	.L66:
 335:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		 case S_CSLTXACK:              activity_csl_data_ri9(capturedTime);    break;
 715              		.loc 1 335 0
 716 04ea 7868     		ldr	r0, [r7, #4]
 717 04ec FFF7FEFF 		bl	activity_csl_data_ri9
 718 04f0 00BF     		nop
 719 04f2 48E0     		b	.L68
 720              	.L73:
 336:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		 default:
 337:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			// log the error
 338:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_ENDOFFRAME,
 339:openstack/02a-MAClow/IEEE802154Ecsl.c **** 								  (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_dbg.num_cslSamples);
 721              		.loc 1 339 0
 722 04f4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 723 04f8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 724 04fc 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 338:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_ENDOFFRAME,
 725              		.loc 1 338 0
 726 04fe 1A46     		mov	r2, r3
 727              		.loc 1 339 0
 728 0500 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 729 0504 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 730 0508 1B69     		ldr	r3, [r3, #16]
 338:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_ENDOFFRAME,
 731              		.loc 1 338 0
 732 050a 9BB2     		uxth	r3, r3
 733 050c 4FF00900 		mov	r0, #9
 734 0510 4FF03F01 		mov	r1, #63
 735 0514 FFF7FEFF 		bl	openserial_printError
 340:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			// abort
 341:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			endOps();
 736              		.loc 1 341 0
 737 0518 FFF7FEFF 		bl	endOps
 342:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			break;
 738              		.loc 1 342 0
 739 051c 33E0     		b	.L68
 740              	.L62:
 343:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 344:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	} else if (ieee154e_vars.cslMode == CSL_TX_MODE)  { // Current CSL operation mode is frame TX.
 741              		.loc 1 344 0
 742 051e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 743 0522 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 744 0526 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 745 052a 022B     		cmp	r3, #2
 746 052c 2BD1     		bne	.L68
 345:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  switch (ieee154e_vars.state) {
 747              		.loc 1 345 0
 748 052e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 749 0532 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 750 0536 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 751 0538 242B     		cmp	r3, #36
 752 053a 07D0     		beq	.L71
 753 053c 292B     		cmp	r3, #41
 754 053e 09D0     		beq	.L72
 755 0540 1E2B     		cmp	r3, #30
 756 0542 0BD1     		bne	.L74
 757              	.L70:
 346:openstack/02a-MAClow/IEEE802154Ecsl.c ****         // TX MODE
 347:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	    case S_CSLTXWAKEUP:            activity_csl_wakeup_ti5(capturedTime); break;
 758              		.loc 1 347 0
 759 0544 7868     		ldr	r0, [r7, #4]
 760 0546 FFF7FEFF 		bl	activity_csl_wakeup_ti5
 761 054a 1CE0     		b	.L68
 762              	.L71:
 348:openstack/02a-MAClow/IEEE802154Ecsl.c ****         case S_CSLTXDATA:              activity_csl_data_ti5(capturedTime);   break;
 763              		.loc 1 348 0
 764 054c 7868     		ldr	r0, [r7, #4]
 765 054e FFF7FEFF 		bl	activity_csl_data_ti5
 766 0552 18E0     		b	.L68
 767              	.L72:
 349:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	    case S_CSLRXACK:               activity_csl_data_ti9(capturedTime);   break;
 768              		.loc 1 349 0
 769 0554 7868     		ldr	r0, [r7, #4]
 770 0556 FFF7FEFF 		bl	activity_csl_data_ti9
 771 055a 14E0     		b	.L68
 772              	.L74:
 350:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	    default:
 351:openstack/02a-MAClow/IEEE802154Ecsl.c ****            // log the error
 352:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_ENDOFFRAME,
 353:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			   				    (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_dbg.num_cslSamples)
 773              		.loc 1 353 0
 774 055c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 775 0560 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 776 0564 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 352:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_ENDOFFRAME,
 777              		.loc 1 352 0
 778 0566 1A46     		mov	r2, r3
 779              		.loc 1 353 0
 780 0568 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 781 056c C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 782 0570 1B69     		ldr	r3, [r3, #16]
 352:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_ENDOFFRAME,
 783              		.loc 1 352 0
 784 0572 9BB2     		uxth	r3, r3
 785 0574 4FF00900 		mov	r0, #9
 786 0578 4FF03F01 		mov	r1, #63
 787 057c FFF7FEFF 		bl	openserial_printError
 354:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	   // abort
 355:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   endOps();
 788              		.loc 1 355 0
 789 0580 FFF7FEFF 		bl	endOps
 356:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   break;
 790              		.loc 1 356 0
 791 0584 00BF     		nop
 792              	.L68:
 357:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  }
 358:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	}
 359:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_dbg.num_endOfFrame++;
 793              		.loc 1 359 0
 794 0586 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 795 058a C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 796 058e DB68     		ldr	r3, [r3, #12]
 797 0590 03F10102 		add	r2, r3, #1
 798 0594 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 799 0598 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 800 059c DA60     		str	r2, [r3, #12]
 360:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 801              		.loc 1 360 0
 802 059e 07F10807 		add	r7, r7, #8
 803 05a2 BD46     		mov	sp, r7
 804 05a4 80BD     		pop	{r7, pc}
 805              		.cfi_endproc
 806              	.LFE4:
 808 05a6 00BF     		.align	2
 809              		.global	isr_ieee154ecsl_txtimer_cb
 810              		.thumb
 811              		.thumb_func
 813              	isr_ieee154ecsl_txtimer_cb:
 814              	.LFB5:
 361:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 362:openstack/02a-MAClow/IEEE802154Ecsl.c **** // tx timer interrupt callbacks
 363:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 364:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CSL]: Callback to check pending data to be sent.
 365:openstack/02a-MAClow/IEEE802154Ecsl.c **** void isr_ieee154ecsl_txtimer_cb() {
 815              		.loc 1 365 0
 816              		.cfi_startproc
 817              		@ args = 0, pretend = 0, frame = 0
 818              		@ frame_needed = 1, uses_anonymous_args = 0
 819 05a8 80B5     		push	{r7, lr}
 820              	.LCFI12:
 821              		.cfi_def_cfa_offset 8
 822              		.cfi_offset 7, -8
 823              		.cfi_offset 14, -4
 824 05aa 00AF     		add	r7, sp, #0
 825              	.LCFI13:
 826              		.cfi_def_cfa_register 7
 366:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 367:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// Verificamos que no estamos ya en un proceso de TX o RX previo.
 368:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if(ieee154e_vars.cslMode == CSL_SLEEP_MODE) {
 827              		.loc 1 368 0
 828 05ac 40F20003 		movw	r3, #:lower16:ieee154e_vars
 829 05b0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 830 05b4 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 831 05b8 002B     		cmp	r3, #0
 832 05ba 02D1     		bne	.L76
 369:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // We call the first activity on FSM for channel sampling (CSL FSM RX mode)
 370:openstack/02a-MAClow/IEEE802154Ecsl.c ****       activity_csl_wakeup_ti1();
 833              		.loc 1 370 0
 834 05bc FFF7FEFF 		bl	activity_csl_wakeup_ti1
 835 05c0 12E0     		b	.L75
 836              	.L76:
 371:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 372:openstack/02a-MAClow/IEEE802154Ecsl.c ****    else {
 373:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // log the info about a operation in progress
 374:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printInfo(COMPONENT_IEEE802154E,ERR_MAC_OPERATION_IN_PROGRESS,
 375:openstack/02a-MAClow/IEEE802154Ecsl.c **** 						  (errorparameter_t)ieee154e_vars.cslMode, (errorparameter_t)ieee154e_dbg.num_cslSamples);
 837              		.loc 1 375 0
 838 05c2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 839 05c6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 840 05ca 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 374:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printInfo(COMPONENT_IEEE802154E,ERR_MAC_OPERATION_IN_PROGRESS,
 841              		.loc 1 374 0
 842 05ce 1A46     		mov	r2, r3
 843              		.loc 1 375 0
 844 05d0 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 845 05d4 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 846 05d8 1B69     		ldr	r3, [r3, #16]
 374:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printInfo(COMPONENT_IEEE802154E,ERR_MAC_OPERATION_IN_PROGRESS,
 847              		.loc 1 374 0
 848 05da 9BB2     		uxth	r3, r3
 849 05dc 4FF00900 		mov	r0, #9
 850 05e0 4FF04001 		mov	r1, #64
 851 05e4 FFF7FEFF 		bl	openserial_printInfo
 852              	.L75:
 376:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 377:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 853              		.loc 1 377 0
 854 05e8 80BD     		pop	{r7, pc}
 855              		.cfi_endproc
 856              	.LFE5:
 858 05ea 00BF     		.align	2
 859              		.global	isr_ieee154ecsl_addPacketToQueueForTestingCslTx_cb
 860              		.thumb
 861              		.thumb_func
 863              	isr_ieee154ecsl_addPacketToQueueForTestingCslTx_cb:
 864              	.LFB6:
 378:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 379:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CST-TEST]: test timer interrupt callback to put a new packet on queue for testing CSL TX mode.
 380:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 381:openstack/02a-MAClow/IEEE802154Ecsl.c **** void isr_ieee154ecsl_addPacketToQueueForTestingCslTx_cb () {
 865              		.loc 1 381 0
 866              		.cfi_startproc
 867              		@ args = 0, pretend = 0, frame = 24
 868              		@ frame_needed = 1, uses_anonymous_args = 0
 869 05ec B0B5     		push	{r4, r5, r7, lr}
 870              	.LCFI14:
 871              		.cfi_def_cfa_offset 16
 872              		.cfi_offset 4, -16
 873              		.cfi_offset 5, -12
 874              		.cfi_offset 7, -8
 875              		.cfi_offset 14, -4
 876 05ee 8AB0     		sub	sp, sp, #40
 877              	.LCFI15:
 878              		.cfi_def_cfa_offset 56
 879 05f0 04AF     		add	r7, sp, #16
 880              	.LCFI16:
 881              		.cfi_def_cfa 7, 40
 382:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 383:openstack/02a-MAClow/IEEE802154Ecsl.c ****   OpenQueueEntry_t* pkt;
 384:openstack/02a-MAClow/IEEE802154Ecsl.c ****   open_addr_t neighbor;
 385:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 386:openstack/02a-MAClow/IEEE802154Ecsl.c ****   // Simulate a ficticious address for CSL testing.
 387:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[0]=0x00;
 882              		.loc 1 387 0
 883 05f2 4FF00003 		mov	r3, #0
 884 05f6 7B70     		strb	r3, [r7, #1]
 388:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[1]=0x11;
 885              		.loc 1 388 0
 886 05f8 4FF01103 		mov	r3, #17
 887 05fc BB70     		strb	r3, [r7, #2]
 389:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[2]=0x22;
 888              		.loc 1 389 0
 889 05fe 4FF02203 		mov	r3, #34
 890 0602 FB70     		strb	r3, [r7, #3]
 390:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[3]=0x33;
 891              		.loc 1 390 0
 892 0604 4FF03303 		mov	r3, #51
 893 0608 3B71     		strb	r3, [r7, #4]
 391:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[4]=0x44;
 894              		.loc 1 391 0
 895 060a 4FF04403 		mov	r3, #68
 896 060e 7B71     		strb	r3, [r7, #5]
 392:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[5]=0x55;
 897              		.loc 1 392 0
 898 0610 4FF05503 		mov	r3, #85
 899 0614 BB71     		strb	r3, [r7, #6]
 393:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[6]=0x66;
 900              		.loc 1 393 0
 901 0616 4FF06603 		mov	r3, #102
 902 061a FB71     		strb	r3, [r7, #7]
 394:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[7]=0x77;
 903              		.loc 1 394 0
 904 061c 4FF07703 		mov	r3, #119
 905 0620 3B72     		strb	r3, [r7, #8]
 395:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 396:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.type=ADDR_64B;
 906              		.loc 1 396 0
 907 0622 4FF00203 		mov	r3, #2
 908 0626 3B70     		strb	r3, [r7, #0]
 397:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 398:openstack/02a-MAClow/IEEE802154Ecsl.c ****   // Switch off all the leds.
 399:openstack/02a-MAClow/IEEE802154Ecsl.c ****   leds_all_off();
 909              		.loc 1 399 0
 910 0628 FFF7FEFF 		bl	leds_all_off
 400:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 401:openstack/02a-MAClow/IEEE802154Ecsl.c ****   // CREATE DATA PACKET ONLY IF NOT ALREADY EXISTS ON QUEUE.
 402:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 403:openstack/02a-MAClow/IEEE802154Ecsl.c ****   if (openqueue_macGetDataPacket(&neighbor) == NULL) {
 911              		.loc 1 403 0
 912 062c 3B46     		mov	r3, r7
 913 062e 1846     		mov	r0, r3
 914 0630 FFF7FEFF 		bl	openqueue_macGetDataPacket
 915 0634 0346     		mov	r3, r0
 916 0636 002B     		cmp	r3, #0
 917 0638 6AD1     		bne	.L78
 404:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 405:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // get freebuffer.
 406:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt = openqueue_getFreePacketBuffer(COMPONENT_IEEE802154E);
 918              		.loc 1 406 0
 919 063a 4FF00900 		mov	r0, #9
 920 063e FFF7FEFF 		bl	openqueue_getFreePacketBuffer
 921 0642 7861     		str	r0, [r7, #20]
 407:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  if(pkt==NULL) {
 922              		.loc 1 407 0
 923 0644 7B69     		ldr	r3, [r7, #20]
 924 0646 002B     		cmp	r3, #0
 925 0648 0CD1     		bne	.L80
 408:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		// registro del error & fin de operaciones.
 409:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		openserial_printError(COMPONENT_IEEE802154E,ERR_NO_FREE_PACKET_BUFFER, (errorparameter_t)0, (erro
 926              		.loc 1 409 0
 927 064a 4FF00900 		mov	r0, #9
 928 064e 4FF02C01 		mov	r1, #44
 929 0652 4FF00002 		mov	r2, #0
 930 0656 4FF00003 		mov	r3, #0
 931 065a FFF7FEFF 		bl	openserial_printError
 410:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		endOps();
 932              		.loc 1 410 0
 933 065e FFF7FEFF 		bl	endOps
 934 0662 55E0     		b	.L78
 935              	.L80:
 411:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		return;
 412:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  }
 413:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 414:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // Declaración de propiedad sobre el paquete.
 415:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->creator = COMPONENT_SIXTOP_TO_IEEE802154E;
 936              		.loc 1 415 0
 937 0664 7B69     		ldr	r3, [r7, #20]
 938 0666 4FF00A02 		mov	r2, #10
 939 066a 1A70     		strb	r2, [r3, #0]
 416:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->owner   = COMPONENT_SIXTOP_TO_IEEE802154E;
 940              		.loc 1 416 0
 941 066c 7B69     		ldr	r3, [r7, #20]
 942 066e 4FF00A02 		mov	r2, #10
 943 0672 5A70     		strb	r2, [r3, #1]
 417:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 418:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // Frame type (data frame).
 419:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->l2_frameType=IEEE154_TYPE_DATA;
 944              		.loc 1 419 0
 945 0674 7B69     		ldr	r3, [r7, #20]
 946 0676 4FF00102 		mov	r2, #1
 947 067a 83F84920 		strb	r2, [r3, #73]
 420:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 421:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // Neighbor address.
 422:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  memcpy(&(pkt->l2_nextORpreviousHop),&neighbor,sizeof(open_addr_t));
 948              		.loc 1 422 0
 949 067e 7B69     		ldr	r3, [r7, #20]
 950 0680 03F13803 		add	r3, r3, #56
 951 0684 1D46     		mov	r5, r3
 952 0686 3C46     		mov	r4, r7
 953 0688 0FCC     		ldmia	r4!, {r0, r1, r2, r3}
 954 068a 2860     		str	r0, [r5, #0]	@ unaligned
 955 068c 6960     		str	r1, [r5, #4]	@ unaligned
 956 068e AA60     		str	r2, [r5, #8]	@ unaligned
 957 0690 EB60     		str	r3, [r5, #12]	@ unaligned
 958 0692 2378     		ldrb	r3, [r4, #0]
 959 0694 2B74     		strb	r3, [r5, #16]
 423:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 424:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // TX retries
 425:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->l2_retriesLeft = TXRETRIES;
 960              		.loc 1 425 0
 961 0696 7B69     		ldr	r3, [r7, #20]
 962 0698 4FF00302 		mov	r2, #3
 963 069c 83F84B20 		strb	r2, [r3, #75]
 426:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 427:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // record this packet's dsn (for matching the ACK)
 428:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->l2_dsn = ieee154e_vars.cslDSN++;
 964              		.loc 1 428 0
 965 06a0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 966 06a4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 967 06a8 93F84430 		ldrb	r3, [r3, #68]	@ zero_extendqisi2
 968 06ac 7A69     		ldr	r2, [r7, #20]
 969 06ae 1946     		mov	r1, r3
 970 06b0 82F84A10 		strb	r1, [r2, #74]
 971 06b4 03F10103 		add	r3, r3, #1
 972 06b8 DAB2     		uxtb	r2, r3
 973 06ba 40F20003 		movw	r3, #:lower16:ieee154e_vars
 974 06be C0F20003 		movt	r3, #:upper16:ieee154e_vars
 975 06c2 83F84420 		strb	r2, [r3, #68]
 429:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 430:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // this is a new packet which I never attempted to send
 431:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->l2_numTxAttempts = 0;
 976              		.loc 1 431 0
 977 06c6 7B69     		ldr	r3, [r7, #20]
 978 06c8 4FF00002 		mov	r2, #0
 979 06cc 83F84C20 		strb	r2, [r3, #76]
 432:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 433:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // transmit with the default TX power
 434:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->l1_txPower = TX_POWER;
 980              		.loc 1 434 0
 981 06d0 7B69     		ldr	r3, [r7, #20]
 982 06d2 4FF01F02 		mov	r2, #31
 983 06d6 83F86720 		strb	r2, [r3, #103]
 435:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 436:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // add a IEEE802.15.4 header
 437:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  ieee802154_prependHeader(pkt,
 438:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							   pkt->l2_frameType,
 984              		.loc 1 438 0
 985 06da 7B69     		ldr	r3, [r7, #20]
 437:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  ieee802154_prependHeader(pkt,
 986              		.loc 1 437 0
 987 06dc 93F84930 		ldrb	r3, [r3, #73]	@ zero_extendqisi2
 439:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							   IEEE154_IELIST_NO,
 440:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							   IEEE154_FRAMEVERSION,
 441:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							   IEEE154_SEC_NO_SECURITY,
 442:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							   pkt->l2_dsn,
 988              		.loc 1 442 0
 989 06e0 7A69     		ldr	r2, [r7, #20]
 437:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  ieee802154_prependHeader(pkt,
 990              		.loc 1 437 0
 991 06e2 92F84A10 		ldrb	r1, [r2, #74]	@ zero_extendqisi2
 992 06e6 7A69     		ldr	r2, [r7, #20]
 993 06e8 02F13802 		add	r2, r2, #56
 994 06ec 4FF00000 		mov	r0, #0
 995 06f0 0090     		str	r0, [sp, #0]
 996 06f2 0191     		str	r1, [sp, #4]
 997 06f4 0292     		str	r2, [sp, #8]
 998 06f6 7869     		ldr	r0, [r7, #20]
 999 06f8 1946     		mov	r1, r3
 1000 06fa 4FF00002 		mov	r2, #0
 1001 06fe 4FF00203 		mov	r3, #2
 1002 0702 FFF7FEFF 		bl	ieee802154_prependHeader
 443:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							   &(pkt->l2_nextORpreviousHop)
 444:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							   );
 445:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 446:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // reserve space for 2-byte CRC
 447:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  packetfunctions_reserveFooterSize(pkt,2);
 1003              		.loc 1 447 0
 1004 0706 7869     		ldr	r0, [r7, #20]
 1005 0708 4FF00201 		mov	r1, #2
 1006 070c FFF7FEFF 		bl	packetfunctions_reserveFooterSize
 1007              	.L78:
 448:openstack/02a-MAClow/IEEE802154Ecsl.c ****   }
 449:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 450:openstack/02a-MAClow/IEEE802154Ecsl.c ****   return;
 451:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1008              		.loc 1 451 0
 1009 0710 07F11807 		add	r7, r7, #24
 1010 0714 BD46     		mov	sp, r7
 1011 0716 B0BD     		pop	{r4, r5, r7, pc}
 1012              		.cfi_endproc
 1013              	.LFE6:
 1015              		.align	2
 1016              		.global	activity_csl_wakeup_ti1
 1017              		.thumb
 1018              		.thumb_func
 1020              	activity_csl_wakeup_ti1:
 1021              	.LFB7:
 452:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 453:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 454:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
 455:openstack/02a-MAClow/IEEE802154Ecsl.c **** //========================== CSL TX MODE ===============================
 456:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
 457:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 458:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 459:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [wake-up ti1].
 460:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 461:openstack/02a-MAClow/IEEE802154Ecsl.c ****  This method is invoked in ISR-mode from "isr_ieee154ecsl_txtimer_cb" function when TX Timer is fir
 462:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 463:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 464:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ti1() {
 1022              		.loc 1 464 0
 1023              		.cfi_startproc
 1024              		@ args = 0, pretend = 0, frame = 24
 1025              		@ frame_needed = 1, uses_anonymous_args = 0
 1026 0718 80B5     		push	{r7, lr}
 1027              	.LCFI17:
 1028              		.cfi_def_cfa_offset 8
 1029              		.cfi_offset 7, -8
 1030              		.cfi_offset 14, -4
 1031 071a 86B0     		sub	sp, sp, #24
 1032              	.LCFI18:
 1033              		.cfi_def_cfa_offset 32
 1034 071c 00AF     		add	r7, sp, #0
 1035              	.LCFI19:
 1036              		.cfi_def_cfa_register 7
 465:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   cellType_t  cellType;
 466:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   open_addr_t neighbor;
 467:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 468:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // update CSL Mode to TX in order to avoid problems in FSM.
 469:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   ieee154e_vars.cslMode = CSL_TX_MODE;
 1037              		.loc 1 469 0
 1038 071e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1039 0722 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1040 0726 4FF00202 		mov	r2, #2
 1041 072a 83F84520 		strb	r2, [r3, #69]
 470:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 471:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // Las acciones que realizaremos son las siguientes:
 472:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   //  - Avanzar el schedule para posicionar la siguiente posición en éste, el cual marcará la 
 473:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   //  - Verificar el estado actual dentro de la FSM para comprobar que efectivamente nos encontra
 474:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   //  - Si no hay problema en ambos, verificamos el tipo de slot en el schedule y preparamos un p
 475:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   //    destino asociado a dicho slot.
 476:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 477:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // increment ASN (do this first so debug pins are in sync)
 478:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   incrementAsnOffset();
 1042              		.loc 1 478 0
 1043 072e FFF7FEFF 		bl	incrementAsnOffset
 479:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 480:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // wiggle debug pins
 481:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   debugpins_slot_toggle();
 1044              		.loc 1 481 0
 1045 0732 FFF7FEFF 		bl	debugpins_slot_toggle
 482:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   if (ieee154e_vars.slotOffset==0) {
 1046              		.loc 1 482 0
 1047 0736 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1048 073a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1049 073e DB88     		ldrh	r3, [r3, #6]
 1050 0740 002B     		cmp	r3, #0
 1051 0742 01D1     		bne	.L83
 483:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      debugpins_frame_toggle();
 1052              		.loc 1 483 0
 1053 0744 FFF7FEFF 		bl	debugpins_frame_toggle
 1054              	.L83:
 484:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 485:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 486:openstack/02a-MAClow/IEEE802154Ecsl.c ****        // if the previous slot took too long, we will not be in the right state
 487:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   if (ieee154e_vars.state!=S_SLEEP) {
 1055              		.loc 1 487 0
 1056 0748 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1057 074c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1058 0750 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 1059 0752 002B     		cmp	r3, #0
 1060 0754 14D0     		beq	.L84
 488:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      // log the error
 489:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_STARTSLOT,
 490:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	                            (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_dbg.
 1061              		.loc 1 490 0
 1062 0756 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1063 075a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1064 075e 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 489:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_STARTSLOT,
 1065              		.loc 1 489 0
 1066 0760 1A46     		mov	r2, r3
 1067              		.loc 1 490 0
 1068 0762 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 1069 0766 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 1070 076a 1B69     		ldr	r3, [r3, #16]
 489:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_STARTSLOT,
 1071              		.loc 1 489 0
 1072 076c 9BB2     		uxth	r3, r3
 1073 076e 4FF00900 		mov	r0, #9
 1074 0772 4FF01E01 		mov	r1, #30
 1075 0776 FFF7FEFF 		bl	openserial_printError
 491:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      // abort
 492:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      endOps();
 1076              		.loc 1 492 0
 1077 077a FFF7FEFF 		bl	endOps
 1078 077e 51E0     		b	.L82
 1079              	.L84:
 493:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      return;
 494:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 495:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 496:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // advance the schedule
 497:openstack/02a-MAClow/IEEE802154Ecsl.c ****        schedule_advanceSlot();
 1080              		.loc 1 497 0
 1081 0780 FFF7FEFF 		bl	schedule_advanceSlot
 498:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 499:openstack/02a-MAClow/IEEE802154Ecsl.c ****        // stop using serial
 500:openstack/02a-MAClow/IEEE802154Ecsl.c ****        openserial_stop();
 1082              		.loc 1 500 0
 1083 0784 FFF7FEFF 		bl	openserial_stop
 501:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 502:openstack/02a-MAClow/IEEE802154Ecsl.c ****        // check the schedule to see what type of slot this is
 503:openstack/02a-MAClow/IEEE802154Ecsl.c ****        cellType = schedule_getType();
 1084              		.loc 1 503 0
 1085 0788 FFF7FEFF 		bl	schedule_getType
 1086 078c 0346     		mov	r3, r0
 1087 078e FB75     		strb	r3, [r7, #23]
 504:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 505:openstack/02a-MAClow/IEEE802154Ecsl.c ****        // check whether we can send
 506:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   if (schedule_getOkToSend()) {
 1088              		.loc 1 506 0
 1089 0790 FFF7FEFF 		bl	schedule_getOkToSend
 1090 0794 0346     		mov	r3, r0
 1091 0796 002B     		cmp	r3, #0
 1092 0798 10D0     		beq	.L86
 507:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       schedule_getNeighbor(&neighbor);
 1093              		.loc 1 507 0
 1094 079a 07F10403 		add	r3, r7, #4
 1095 079e 1846     		mov	r0, r3
 1096 07a0 FFF7FEFF 		bl	schedule_getNeighbor
 508:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       ieee154e_vars.dataToSend = openqueue_macGetDataPacket(&neighbor);
 1097              		.loc 1 508 0
 1098 07a4 07F10403 		add	r3, r7, #4
 1099 07a8 1846     		mov	r0, r3
 1100 07aa FFF7FEFF 		bl	openqueue_macGetDataPacket
 1101 07ae 0246     		mov	r2, r0
 1102 07b0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1103 07b4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1104 07b8 5A61     		str	r2, [r3, #20]
 1105 07ba 06E0     		b	.L87
 1106              	.L86:
 509:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   } else {
 510:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       ieee154e_vars.dataToSend = NULL;
 1107              		.loc 1 510 0
 1108 07bc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1109 07c0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1110 07c4 4FF00002 		mov	r2, #0
 1111 07c8 5A61     		str	r2, [r3, #20]
 1112              	.L87:
 511:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 512:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   if((ieee154e_vars.dataToSend!=NULL) && (cellType == CELLTYPE_TX)) {   // If I have a packet to 
 1113              		.loc 1 512 0
 1114 07ca 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1115 07ce C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1116 07d2 5B69     		ldr	r3, [r3, #20]
 1117 07d4 002B     		cmp	r3, #0
 1118 07d6 1DD0     		beq	.L88
 1119              		.loc 1 512 0 is_stmt 0 discriminator 1
 1120 07d8 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 1121 07da 022B     		cmp	r3, #2
 1122 07dc 1AD1     		bne	.L88
 513:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       // change state to start sending CSL preamble before send the data packet.
 514:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       changeState(S_CSLTXWAKEUPOFFSET);
 1123              		.loc 1 514 0 is_stmt 1
 1124 07de 4FF01A00 		mov	r0, #26
 1125 07e2 FFF7FEFF 		bl	changeState
 515:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 516:openstack/02a-MAClow/IEEE802154Ecsl.c ****            // record that I will attempt to transmit this packet
 517:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       ieee154e_vars.dataToSend->l2_numTxAttempts++;
 1126              		.loc 1 517 0
 1127 07e6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1128 07ea C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1129 07ee 5B69     		ldr	r3, [r3, #20]
 1130 07f0 93F84C20 		ldrb	r2, [r3, #76]	@ zero_extendqisi2
 1131 07f4 02F10102 		add	r2, r2, #1
 1132 07f8 D2B2     		uxtb	r2, r2
 1133 07fa 83F84C20 		strb	r2, [r3, #76]
 518:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 519:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       // arm tt1
 520:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       radiotimer_schedule(DURATION_tt1);
 1134              		.loc 1 520 0
 1135 07fe 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1136 0802 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1137 0806 5B6A     		ldr	r3, [r3, #36]
 1138 0808 03F13A03 		add	r3, r3, #58
 1139 080c 1846     		mov	r0, r3
 1140 080e FFF7FEFF 		bl	radiotimer_schedule
 1141 0812 07E0     		b	.L82
 1142              	.L88:
 521:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   } else {
 522:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       // abort because slot is not TX or there is no data to send, so we reset TX Mode state
 523:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   ieee154e_vars.cslMode = CSL_SLEEP_MODE;
 1143              		.loc 1 523 0
 1144 0814 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1145 0818 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1146 081c 4FF00002 		mov	r2, #0
 1147 0820 83F84520 		strb	r2, [r3, #69]
 1148              	.L82:
 524:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 525:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1149              		.loc 1 525 0
 1150 0824 07F11807 		add	r7, r7, #24
 1151 0828 BD46     		mov	sp, r7
 1152 082a 80BD     		pop	{r7, pc}
 1153              		.cfi_endproc
 1154              	.LFE7:
 1156              		.align	2
 1157              		.global	activity_csl_wakeup_ti2
 1158              		.thumb
 1159              		.thumb_func
 1161              	activity_csl_wakeup_ti2:
 1162              	.LFB8:
 526:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 527:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 528:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 529:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [wake-up ti2].
 530:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 531:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 532:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to prepare the radio for sending packets.
 533:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 534:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ti2() {
 1163              		.loc 1 534 0
 1164              		.cfi_startproc
 1165              		@ args = 0, pretend = 0, frame = 24
 1166              		@ frame_needed = 1, uses_anonymous_args = 0
 1167 082c 80B5     		push	{r7, lr}
 1168              	.LCFI20:
 1169              		.cfi_def_cfa_offset 8
 1170              		.cfi_offset 7, -8
 1171              		.cfi_offset 14, -4
 1172 082e 86B0     		sub	sp, sp, #24
 1173              	.LCFI21:
 1174              		.cfi_def_cfa_offset 32
 1175 0830 00AF     		add	r7, sp, #0
 1176              	.LCFI22:
 1177              		.cfi_def_cfa_register 7
 535:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 536:openstack/02a-MAClow/IEEE802154Ecsl.c ****    open_addr_t neighbor;
 537:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 538:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // El tiempo de rendezvous que será necesario esperar será macCSLMaxPeriod al tratarse de
 539:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // una comunicación en modo TX no sincronizado.
 540:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 541:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Calculamos el valor del rz-time en cada trama wake-up de la secuencia dado que debe ir reduci
 542:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // al extemo remoto el tiempo restante hasta el envío de la trama de datos.
 543:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 544:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // El tiempo lastCapturedTime se ve incrementado tras el envio de cada trama wake-up por lo que 
 545:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // valor más proximo al macCSLMaxPeriod.
 546:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 547:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.remainingRzTime = macCSLMaxPeriod - ieee154e_vars.lastCapturedTime;
 1178              		.loc 1 547 0
 1179 0832 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1180 0836 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1181 083a 5B6A     		ldr	r3, [r3, #36]
 1182 083c 9BB2     		uxth	r3, r3
 1183 083e C3F5CC53 		rsb	r3, r3, #6528
 1184 0842 03F11A03 		add	r3, r3, #26
 1185 0846 9AB2     		uxth	r2, r3
 1186 0848 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1187 084c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1188 0850 A3F84820 		strh	r2, [r3, #72]	@ movhi
 548:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 549:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (MaxWakeUpTxTime < ieee154e_vars.remainingRzTime) { // Si da tiempo a enviar una nueva trama 
 1189              		.loc 1 549 0
 1190 0854 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1191 0858 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1192 085c B3F84820 		ldrh	r2, [r3, #72]
 1193 0860 40F24113 		movw	r3, #321
 1194 0864 9A42     		cmp	r2, r3
 1195 0866 40F2CB80 		bls	.L91
 550:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 551:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // change state
 552:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   changeState(S_CSLTXWAKEUPPREPARE);
 1196              		.loc 1 552 0
 1197 086a 4FF01B00 		mov	r0, #27
 1198 086e FFF7FEFF 		bl	changeState
 553:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 554:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   //
 555:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // Construimos el paquete Wake-Up con su valor RZTime asociado en caso de no existir ya.
 556:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   //
 557:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 558:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   if (ieee154e_vars.wakeupToSend == NULL) { // first time
 1199              		.loc 1 558 0
 1200 0872 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1201 0876 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1202 087a DB6B     		ldr	r3, [r3, #60]
 1203 087c 002B     		cmp	r3, #0
 1204 087e 7FD1     		bne	.L92
 559:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 560:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // obtenemos un buffer en el cual poder guardar los datos recibidos.
 561:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   ieee154e_vars.wakeupToSend = openqueue_getFreePacketBuffer(COMPONENT_IEEE802154E);
 1205              		.loc 1 561 0
 1206 0880 4FF00900 		mov	r0, #9
 1207 0884 FFF7FEFF 		bl	openqueue_getFreePacketBuffer
 1208 0888 0246     		mov	r2, r0
 1209 088a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1210 088e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1211 0892 DA63     		str	r2, [r3, #60]
 562:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   if (ieee154e_vars.wakeupToSend == NULL) {
 1212              		.loc 1 562 0
 1213 0894 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1214 0898 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1215 089c DB6B     		ldr	r3, [r3, #60]
 1216 089e 002B     		cmp	r3, #0
 1217 08a0 0CD1     		bne	.L93
 563:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			  // registro del error & fin de operaciones.
 564:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			  openserial_printError(COMPONENT_IEEE802154E,ERR_NO_FREE_PACKET_BUFFER, (errorparameter_t)0, (e
 1218              		.loc 1 564 0
 1219 08a2 4FF00900 		mov	r0, #9
 1220 08a6 4FF02C01 		mov	r1, #44
 1221 08aa 4FF00002 		mov	r2, #0
 1222 08ae 4FF00003 		mov	r3, #0
 1223 08b2 FFF7FEFF 		bl	openserial_printError
 565:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			  endOps();
 1224              		.loc 1 565 0
 1225 08b6 FFF7FEFF 		bl	endOps
 1226 08ba AEE0     		b	.L90
 1227              	.L93:
 566:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			  return;
 567:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   }
 568:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 569:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // Declaración de propiedad sobre el paquete.
 570:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   ieee154e_vars.wakeupToSend->creator = COMPONENT_IEEE802154E;
 1228              		.loc 1 570 0
 1229 08bc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1230 08c0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1231 08c4 DB6B     		ldr	r3, [r3, #60]
 1232 08c6 4FF00902 		mov	r2, #9
 1233 08ca 1A70     		strb	r2, [r3, #0]
 571:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   ieee154e_vars.wakeupToSend->owner   = COMPONENT_IEEE802154E;
 1234              		.loc 1 571 0
 1235 08cc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1236 08d0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1237 08d4 DB6B     		ldr	r3, [r3, #60]
 1238 08d6 4FF00902 		mov	r2, #9
 1239 08da 5A70     		strb	r2, [r3, #1]
 572:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 573:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // El tipo de trama es Multipurpose.
 574:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   ieee154e_vars.wakeupToSend->l2_frameType = IEEE154_TYPE_MULTIPURPOSE;
 1240              		.loc 1 574 0
 1241 08dc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1242 08e0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1243 08e4 DB6B     		ldr	r3, [r3, #60]
 1244 08e6 4FF00502 		mov	r2, #5
 1245 08ea 83F84920 		strb	r2, [r3, #73]
 575:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 576:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // El dsn del paquete lo obtenemos a partir del actual DSN incrementado en cada paquete de la 
 577:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   ieee154e_vars.wakeupToSend->l2_dsn = ieee154e_vars.cslDSN++;
 1246              		.loc 1 577 0
 1247 08ee 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1248 08f2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1249 08f6 DA6B     		ldr	r2, [r3, #60]
 1250 08f8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1251 08fc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1252 0900 93F84430 		ldrb	r3, [r3, #68]	@ zero_extendqisi2
 1253 0904 1946     		mov	r1, r3
 1254 0906 82F84A10 		strb	r1, [r2, #74]
 1255 090a 03F10103 		add	r3, r3, #1
 1256 090e DAB2     		uxtb	r2, r3
 1257 0910 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1258 0914 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1259 0918 83F84420 		strb	r2, [r3, #68]
 578:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 579:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // El destinatario es el mismo que el destinatario del mensaje de datos indicado en el schedul
 580:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   schedule_getNeighbor(&neighbor);
 1260              		.loc 1 580 0
 1261 091c 07F10403 		add	r3, r7, #4
 1262 0920 1846     		mov	r0, r3
 1263 0922 FFF7FEFF 		bl	schedule_getNeighbor
 581:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 582:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // Verificamos que se trata de una dirección corta (short address). En caso contrario generam
 583:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   if(neighbor.type != ADDR_16B) {
 1264              		.loc 1 583 0
 1265 0926 3B79     		ldrb	r3, [r7, #4]	@ zero_extendqisi2
 1266 0928 012B     		cmp	r3, #1
 1267 092a 08D0     		beq	.L95
 584:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			   // CSL: This is an invalid address because address in wake-up frame must be short address.
 585:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			   // We do not finish operations but we will use later short address getting it from long addre
 586:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			   openserial_printInfo(COMPONENT_IEEE802154,ERR_IEEE154_UNSUPPORTED, (errorparameter_t)1, (erro
 1268              		.loc 1 586 0
 1269 092c 3B79     		ldrb	r3, [r7, #4]	@ zero_extendqisi2
 1270 092e 4FF00800 		mov	r0, #8
 1271 0932 4FF01901 		mov	r1, #25
 1272 0936 4FF00102 		mov	r2, #1
 1273 093a FFF7FEFF 		bl	openserial_printInfo
 1274              	.L95:
 587:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   }
 588:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 589:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // create frame header.
 590:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   ieee802154_createWakeUpFrame(ieee154e_vars.wakeupToSend,
 1275              		.loc 1 590 0
 1276 093e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1277 0942 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1278 0946 D86B     		ldr	r0, [r3, #60]
 591:openstack/02a-MAClow/IEEE802154Ecsl.c **** 										ieee154e_vars.wakeupToSend->l2_dsn,
 1279              		.loc 1 591 0
 1280 0948 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1281 094c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1282 0950 DB6B     		ldr	r3, [r3, #60]
 590:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   ieee802154_createWakeUpFrame(ieee154e_vars.wakeupToSend,
 1283              		.loc 1 590 0
 1284 0952 93F84A10 		ldrb	r1, [r3, #74]	@ zero_extendqisi2
 1285 0956 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1286 095a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1287 095e B3F84830 		ldrh	r3, [r3, #72]
 1288 0962 07F10402 		add	r2, r7, #4
 1289 0966 FFF7FEFF 		bl	ieee802154_createWakeUpFrame
 592:openstack/02a-MAClow/IEEE802154Ecsl.c **** 										&neighbor,
 593:openstack/02a-MAClow/IEEE802154Ecsl.c **** 										ieee154e_vars.remainingRzTime);
 594:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 595:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // space for 2-byte CRC
 596:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   packetfunctions_reserveFooterSize(ieee154e_vars.wakeupToSend,2);
 1290              		.loc 1 596 0
 1291 096a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1292 096e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1293 0972 DB6B     		ldr	r3, [r3, #60]
 1294 0974 1846     		mov	r0, r3
 1295 0976 4FF00201 		mov	r1, #2
 1296 097a FFF7FEFF 		bl	packetfunctions_reserveFooterSize
 1297 097e 0EE0     		b	.L96
 1298              	.L92:
 597:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 598:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   else {
 599:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // update rztime in header.
 600:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // Se posiciona 8 posiciones antes dado que estamos escribiendo el paquete de atras hacia dela
 601:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // - 1 byte FCF
 602:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // - 1 byte SEQ
 603:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // - 2 bytes PANID
 604:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // - 2 bytes DEST ADDR
 605:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // - 2 bytes RZTIME IE HEADER
 606:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // - 2 bytes RZTIME (el cual se sobrescribirá con el nuevo valor).
 607:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   *((uint16_t*)(ieee154e_vars.wakeupToSend->payload+8)) = ieee154e_vars.remainingRzTime;
 1299              		.loc 1 607 0
 1300 0980 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1301 0984 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1302 0988 DB6B     		ldr	r3, [r3, #60]
 1303 098a 5B68     		ldr	r3, [r3, #4]
 1304 098c 03F10802 		add	r2, r3, #8
 1305 0990 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1306 0994 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1307 0998 B3F84830 		ldrh	r3, [r3, #72]
 1308 099c 1380     		strh	r3, [r2, #0]	@ movhi
 1309              	.L96:
 608:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 609:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 610:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // load the packet in the radio's Tx buffer
 611:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   radio_loadPacket(ieee154e_vars.wakeupToSend->payload, ieee154e_vars.wakeupToSend->length);
 1310              		.loc 1 611 0
 1311 099e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1312 09a2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1313 09a6 DB6B     		ldr	r3, [r3, #60]
 1314 09a8 5A68     		ldr	r2, [r3, #4]
 1315 09aa 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1316 09ae C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1317 09b2 DB6B     		ldr	r3, [r3, #60]
 1318 09b4 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 1319 09b6 1046     		mov	r0, r2
 1320 09b8 1946     		mov	r1, r3
 1321 09ba FFF7FEFF 		bl	radio_loadPacket
 612:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 613:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // enable the radio in Tx mode. This does not send the packet.
 614:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   radio_txEnable();
 1322              		.loc 1 614 0
 1323 09be FFF7FEFF 		bl	radio_txEnable
 615:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   ieee154e_vars.radioOnInit=radio_getTimerValue();
 1324              		.loc 1 615 0
 1325 09c2 FFF7FEFF 		bl	radio_getTimerValue
 1326 09c6 0246     		mov	r2, r0
 1327 09c8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1328 09cc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1329 09d0 1A63     		str	r2, [r3, #48]
 616:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   ieee154e_vars.radioOnThisSlot=TRUE;
 1330              		.loc 1 616 0
 1331 09d2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1332 09d6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1333 09da 4FF00102 		mov	r2, #1
 1334 09de 83F83820 		strb	r2, [r3, #56]
 617:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 618:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // arm tt2
 619:openstack/02a-MAClow/IEEE802154Ecsl.c ****        radiotimer_schedule(DURATION_tt2);
 1335              		.loc 1 619 0
 1336 09e2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1337 09e6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1338 09ea 5B6A     		ldr	r3, [r3, #36]
 1339 09ec 03F17C03 		add	r3, r3, #124
 1340 09f0 1846     		mov	r0, r3
 1341 09f2 FFF7FEFF 		bl	radiotimer_schedule
 620:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 621:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // change state
 622:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   changeState(S_CSLTXWAKEUPREADY);
 1342              		.loc 1 622 0
 1343 09f6 4FF01C00 		mov	r0, #28
 1344 09fa FFF7FEFF 		bl	changeState
 1345 09fe 0CE0     		b	.L90
 1346              	.L91:
 623:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 624:openstack/02a-MAClow/IEEE802154Ecsl.c ****    else {
 625:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // Si no da tiempo a enviar una nueva trama, simplemente esperamos un tiempo igual a remainingR
 626:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // el tiempo que queda pendiente hasta el envío de la trama de datos y actualizamos directamen
 627:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // pasar a la transmisión de los datos, a través del estado CSLTXDATAPREOFFSET.
 628:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 629:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // change state
 630:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   changeState(S_CSLTXDATAPREOFFSET);
 1347              		.loc 1 630 0
 1348 0a00 4FF01F00 		mov	r0, #31
 1349 0a04 FFF7FEFF 		bl	changeState
 631:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 632:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // arm remaining rendezvous time.
 633:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   radiotimer_schedule(ieee154e_vars.remainingRzTime);
 1350              		.loc 1 633 0
 1351 0a08 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1352 0a0c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1353 0a10 B3F84830 		ldrh	r3, [r3, #72]
 1354 0a14 1846     		mov	r0, r3
 1355 0a16 FFF7FEFF 		bl	radiotimer_schedule
 1356              	.L90:
 634:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 635:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1357              		.loc 1 635 0
 1358 0a1a 07F11807 		add	r7, r7, #24
 1359 0a1e BD46     		mov	sp, r7
 1360 0a20 80BD     		pop	{r7, pc}
 1361              		.cfi_endproc
 1362              	.LFE8:
 1364 0a22 00BF     		.align	2
 1365              		.global	activity_csl_wakeup_tie1
 1366              		.thumb
 1367              		.thumb_func
 1369              	activity_csl_wakeup_tie1:
 1370              	.LFB9:
 636:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 637:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 638:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [wake-up tie1].
 639:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 640:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #tt2 expiring, i.e. timer fires while state = S_CSLTXWAKEUPPREPARE. This is 
 641:openstack/02a-MAClow/IEEE802154Ecsl.c ****   did not have enough time to execute. Chances are to set maxTxDataPrepare too small. The implement
 642:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 643:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_tie1() {
 1371              		.loc 1 643 0
 1372              		.cfi_startproc
 1373              		@ args = 0, pretend = 0, frame = 0
 1374              		@ frame_needed = 1, uses_anonymous_args = 0
 1375 0a24 80B5     		push	{r7, lr}
 1376              	.LCFI23:
 1377              		.cfi_def_cfa_offset 8
 1378              		.cfi_offset 7, -8
 1379              		.cfi_offset 14, -4
 1380 0a26 00AF     		add	r7, sp, #0
 1381              	.LCFI24:
 1382              		.cfi_def_cfa_register 7
 644:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
 645:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXDATAPREPARE_OVERFLOW,
 646:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_vars.slo
 1383              		.loc 1 646 0
 1384 0a28 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1385 0a2c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1386 0a30 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 645:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXDATAPREPARE_OVERFLOW,
 1387              		.loc 1 645 0
 1388 0a32 1A46     		mov	r2, r3
 1389 0a34 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1390 0a38 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1391 0a3c DB88     		ldrh	r3, [r3, #6]
 1392 0a3e 4FF00900 		mov	r0, #9
 1393 0a42 4FF02201 		mov	r1, #34
 1394 0a46 FFF7FEFF 		bl	openserial_printError
 647:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 648:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
 649:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 1395              		.loc 1 649 0
 1396 0a4a FFF7FEFF 		bl	endOps
 650:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1397              		.loc 1 650 0
 1398 0a4e 80BD     		pop	{r7, pc}
 1399              		.cfi_endproc
 1400              	.LFE9:
 1402              		.align	2
 1403              		.global	activity_csl_wakeup_ti3
 1404              		.thumb
 1405              		.thumb_func
 1407              	activity_csl_wakeup_ti3:
 1408              	.LFB10:
 651:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 652:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 653:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [wake-up ti3].
 654:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 655:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 656:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The radio is configured and this interrupt gives it the "go" signal to start listening.
 657:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 658:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 659:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ti3() {
 1409              		.loc 1 659 0
 1410              		.cfi_startproc
 1411              		@ args = 0, pretend = 0, frame = 0
 1412              		@ frame_needed = 1, uses_anonymous_args = 0
 1413 0a50 80B5     		push	{r7, lr}
 1414              	.LCFI25:
 1415              		.cfi_def_cfa_offset 8
 1416              		.cfi_offset 7, -8
 1417              		.cfi_offset 14, -4
 1418 0a52 00AF     		add	r7, sp, #0
 1419              	.LCFI26:
 1420              		.cfi_def_cfa_register 7
 660:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 661:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXWAKEUPDELAY);
 1421              		.loc 1 661 0
 1422 0a54 4FF01D00 		mov	r0, #29
 1423 0a58 FFF7FEFF 		bl	changeState
 662:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 663:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt3
 664:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt3);
 1424              		.loc 1 664 0
 1425 0a5c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1426 0a60 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1427 0a64 5B6A     		ldr	r3, [r3, #36]
 1428 0a66 03F19D03 		add	r3, r3, #157
 1429 0a6a 1846     		mov	r0, r3
 1430 0a6c FFF7FEFF 		bl	radiotimer_schedule
 665:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 666:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // give the 'go' to transmit
 667:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_txNow();
 1431              		.loc 1 667 0
 1432 0a70 FFF7FEFF 		bl	radio_txNow
 668:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1433              		.loc 1 668 0
 1434 0a74 80BD     		pop	{r7, pc}
 1435              		.cfi_endproc
 1436              	.LFE10:
 1438 0a76 00BF     		.align	2
 1439              		.global	activity_csl_wakeup_tie2
 1440              		.thumb
 1441              		.thumb_func
 1443              	activity_csl_wakeup_tie2:
 1444              	.LFB11:
 669:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 670:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 671:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [wakeup tie2].
 672:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 673:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #tt3 expiring, i.e. timer fires while state = S_CSLTXWAKEUPDELAY. If no pack
 674:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 675:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_tie2() {
 1445              		.loc 1 675 0
 1446              		.cfi_startproc
 1447              		@ args = 0, pretend = 0, frame = 0
 1448              		@ frame_needed = 1, uses_anonymous_args = 0
 1449 0a78 80B5     		push	{r7, lr}
 1450              	.LCFI27:
 1451              		.cfi_def_cfa_offset 8
 1452              		.cfi_offset 7, -8
 1453              		.cfi_offset 14, -4
 1454 0a7a 00AF     		add	r7, sp, #0
 1455              	.LCFI28:
 1456              		.cfi_def_cfa_register 7
 676:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
 677:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIO_OVERFLOWS,
 678:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_vars.slo
 1457              		.loc 1 678 0
 1458 0a7c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1459 0a80 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1460 0a84 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 677:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIO_OVERFLOWS,
 1461              		.loc 1 677 0
 1462 0a86 1A46     		mov	r2, r3
 1463 0a88 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1464 0a8c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1465 0a90 DB88     		ldrh	r3, [r3, #6]
 1466 0a92 4FF00900 		mov	r0, #9
 1467 0a96 4FF02701 		mov	r1, #39
 1468 0a9a FFF7FEFF 		bl	openserial_printError
 679:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
 680:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 1469              		.loc 1 680 0
 1470 0a9e FFF7FEFF 		bl	endOps
 681:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1471              		.loc 1 681 0
 1472 0aa2 80BD     		pop	{r7, pc}
 1473              		.cfi_endproc
 1474              	.LFE11:
 1476              		.align	2
 1477              		.global	activity_csl_wakeup_ti4
 1478              		.thumb
 1479              		.thumb_func
 1481              	activity_csl_wakeup_ti4:
 1482              	.LFB12:
 682:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 683:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 684:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [wake-up ti4].
 685:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 686:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_startOfFrame" function when a start of frame ev
 687:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to capture the time, cancel #tt3 and arm #tt4 (max time to send all the pack
 688:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 689:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ti4(PORT_RADIOTIMER_WIDTH capturedTime) {
 1483              		.loc 1 689 0
 1484              		.cfi_startproc
 1485              		@ args = 0, pretend = 0, frame = 8
 1486              		@ frame_needed = 1, uses_anonymous_args = 0
 1487 0aa4 80B5     		push	{r7, lr}
 1488              	.LCFI29:
 1489              		.cfi_def_cfa_offset 8
 1490              		.cfi_offset 7, -8
 1491              		.cfi_offset 14, -4
 1492 0aa6 82B0     		sub	sp, sp, #8
 1493              	.LCFI30:
 1494              		.cfi_def_cfa_offset 16
 1495 0aa8 00AF     		add	r7, sp, #0
 1496              	.LCFI31:
 1497              		.cfi_def_cfa_register 7
 1498 0aaa 7860     		str	r0, [r7, #4]
 690:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 691:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel tt3
 692:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 1499              		.loc 1 692 0
 1500 0aac FFF7FEFF 		bl	radiotimer_cancel
 693:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 694:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
 695:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.lastCapturedTime = capturedTime;
 1501              		.loc 1 695 0
 1502 0ab0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1503 0ab4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1504 0ab8 7A68     		ldr	r2, [r7, #4]
 1505 0aba 5A62     		str	r2, [r3, #36]
 696:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 697:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 698:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXWAKEUP);
 1506              		.loc 1 698 0
 1507 0abc 4FF01E00 		mov	r0, #30
 1508 0ac0 FFF7FEFF 		bl	changeState
 699:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 700:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt4
 701:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt4);
 1509              		.loc 1 701 0
 1510 0ac4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1511 0ac8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1512 0acc 5B6A     		ldr	r3, [r3, #36]
 1513 0ace 03F1A403 		add	r3, r3, #164
 1514 0ad2 1846     		mov	r0, r3
 1515 0ad4 FFF7FEFF 		bl	radiotimer_schedule
 702:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1516              		.loc 1 702 0
 1517 0ad8 07F10807 		add	r7, r7, #8
 1518 0adc BD46     		mov	sp, r7
 1519 0ade 80BD     		pop	{r7, pc}
 1520              		.cfi_endproc
 1521              	.LFE12:
 1523              		.align	2
 1524              		.global	activity_csl_wakeup_tie3
 1525              		.thumb
 1526              		.thumb_func
 1528              	activity_csl_wakeup_tie3:
 1529              	.LFB13:
 703:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 704:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 705:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [wake-up tie3].
 706:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 707:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #tt4 expiring, i.e. timer fires while state = S_CSLTXWAKEUP. This is an erro
 708:openstack/02a-MAClow/IEEE802154Ecsl.c ****   took too long to transmit the data packet. The implemented behaviour is to log the error and fini
 709:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 710:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_tie3() {
 1530              		.loc 1 710 0
 1531              		.cfi_startproc
 1532              		@ args = 0, pretend = 0, frame = 0
 1533              		@ frame_needed = 1, uses_anonymous_args = 0
 1534 0ae0 80B5     		push	{r7, lr}
 1535              	.LCFI32:
 1536              		.cfi_def_cfa_offset 8
 1537              		.cfi_offset 7, -8
 1538              		.cfi_offset 14, -4
 1539 0ae2 00AF     		add	r7, sp, #0
 1540              	.LCFI33:
 1541              		.cfi_def_cfa_register 7
 711:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
 712:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
 713:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_vars.slo
 1542              		.loc 1 713 0
 1543 0ae4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1544 0ae8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1545 0aec 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 712:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
 1546              		.loc 1 712 0
 1547 0aee 1A46     		mov	r2, r3
 1548 0af0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1549 0af4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1550 0af8 DB88     		ldrh	r3, [r3, #6]
 1551 0afa 4FF00900 		mov	r0, #9
 1552 0afe 4FF02601 		mov	r1, #38
 1553 0b02 FFF7FEFF 		bl	openserial_printError
 714:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
 715:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 1554              		.loc 1 715 0
 1555 0b06 FFF7FEFF 		bl	endOps
 716:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1556              		.loc 1 716 0
 1557 0b0a 80BD     		pop	{r7, pc}
 1558              		.cfi_endproc
 1559              	.LFE13:
 1561              		.align	2
 1562              		.global	activity_csl_wakeup_ti5
 1563              		.thumb
 1564              		.thumb_func
 1566              	activity_csl_wakeup_ti5:
 1567              	.LFB14:
 717:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 718:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 719:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 720:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [wake-up ri5].
 721:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 722:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_endOfFrame" function when a end of frame event 
 723:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change state, cancel #rt4, and start sending data frame and wait for ACK.
 724:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 725:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ti5(PORT_RADIOTIMER_WIDTH capturedTime) {
 1568              		.loc 1 725 0
 1569              		.cfi_startproc
 1570              		@ args = 0, pretend = 0, frame = 8
 1571              		@ frame_needed = 1, uses_anonymous_args = 0
 1572 0b0c 80B5     		push	{r7, lr}
 1573              	.LCFI34:
 1574              		.cfi_def_cfa_offset 8
 1575              		.cfi_offset 7, -8
 1576              		.cfi_offset 14, -4
 1577 0b0e 82B0     		sub	sp, sp, #8
 1578              	.LCFI35:
 1579              		.cfi_def_cfa_offset 16
 1580 0b10 00AF     		add	r7, sp, #0
 1581              	.LCFI36:
 1582              		.cfi_def_cfa_register 7
 1583 0b12 7860     		str	r0, [r7, #4]
 726:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 727:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// record the captured time
 728:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	ieee154e_vars.lastCapturedTime = capturedTime;
 1584              		.loc 1 728 0
 1585 0b14 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1586 0b18 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1587 0b1c 7A68     		ldr	r2, [r7, #4]
 1588 0b1e 5A62     		str	r2, [r3, #36]
 729:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 730:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// Mientras el tiempo capturado en el envío de la ultima trama wake-up de la trama wake-up sequen
 731:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// sea inferior al tiempo de la duración del rztime inicial, debemos seguir enviando tramas wake-
 732:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// En caso contrario, enviamos la trama de datos.
 733:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 734:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//if((macCSLMaxPeriod - ieee154e_vars.lastCapturedTime) < ieee154e_vars.remainingRzTime) {
 735:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//	changeState(S_CSLTXWAKEUPOFFSET);
 736:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//}
 737:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//else {
 738:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //   changeState(S_CSLTXDATAOFFSET);
 739:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //}
 740:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 741:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	changeState(S_CSLTXWAKEUPOFFSET);
 1589              		.loc 1 741 0
 1590 0b20 4FF01A00 		mov	r0, #26
 1591 0b24 FFF7FEFF 		bl	changeState
 742:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 743:openstack/02a-MAClow/IEEE802154Ecsl.c ****     // arm tt1 (enviemos de nuevo una trama de wake-up o de datos, el tiempo será tt1).
 744:openstack/02a-MAClow/IEEE802154Ecsl.c ****     radiotimer_schedule(DURATION_tt1);
 1592              		.loc 1 744 0
 1593 0b28 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1594 0b2c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1595 0b30 5B6A     		ldr	r3, [r3, #36]
 1596 0b32 03F13A03 		add	r3, r3, #58
 1597 0b36 1846     		mov	r0, r3
 1598 0b38 FFF7FEFF 		bl	radiotimer_schedule
 745:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1599              		.loc 1 745 0
 1600 0b3c 07F10807 		add	r7, r7, #8
 1601 0b40 BD46     		mov	sp, r7
 1602 0b42 80BD     		pop	{r7, pc}
 1603              		.cfi_endproc
 1604              	.LFE14:
 1606              		.align	2
 1607              		.global	activity_csl_data_ti1
 1608              		.thumb
 1609              		.thumb_func
 1611              	activity_csl_data_ti1:
 1612              	.LFB15:
 746:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 747:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 748:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti1].
 749:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 750:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires after 
 751:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to prepare the data to be sent.
 752:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 753:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 754:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti1() {
 1613              		.loc 1 754 0
 1614              		.cfi_startproc
 1615              		@ args = 0, pretend = 0, frame = 0
 1616              		@ frame_needed = 1, uses_anonymous_args = 0
 1617 0b44 80B5     		push	{r7, lr}
 1618              	.LCFI37:
 1619              		.cfi_def_cfa_offset 8
 1620              		.cfi_offset 7, -8
 1621              		.cfi_offset 14, -4
 1622 0b46 00AF     		add	r7, sp, #0
 1623              	.LCFI38:
 1624              		.cfi_def_cfa_register 7
 755:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 756:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// change state
 757:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	changeState(S_CSLTXDATAOFFSET);
 1625              		.loc 1 757 0
 1626 0b48 4FF02000 		mov	r0, #32
 1627 0b4c FFF7FEFF 		bl	changeState
 758:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 759:openstack/02a-MAClow/IEEE802154Ecsl.c ****     // arm tt1 (enviemos de nuevo una trama de wake-up o de datos, el tiempo será tt1).
 760:openstack/02a-MAClow/IEEE802154Ecsl.c ****     radiotimer_schedule(DURATION_tt1);
 1628              		.loc 1 760 0
 1629 0b50 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1630 0b54 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1631 0b58 5B6A     		ldr	r3, [r3, #36]
 1632 0b5a 03F13A03 		add	r3, r3, #58
 1633 0b5e 1846     		mov	r0, r3
 1634 0b60 FFF7FEFF 		bl	radiotimer_schedule
 761:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1635              		.loc 1 761 0
 1636 0b64 80BD     		pop	{r7, pc}
 1637              		.cfi_endproc
 1638              	.LFE15:
 1640 0b66 00BF     		.align	2
 1641              		.global	activity_csl_data_ti2
 1642              		.thumb
 1643              		.thumb_func
 1645              	activity_csl_data_ti2:
 1646              	.LFB16:
 762:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 763:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 764:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 765:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 766:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti2].
 767:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 768:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 769:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to prepare the radio for sending packets.
 770:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 771:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti2() {
 1647              		.loc 1 771 0
 1648              		.cfi_startproc
 1649              		@ args = 0, pretend = 0, frame = 0
 1650              		@ frame_needed = 1, uses_anonymous_args = 0
 1651 0b68 80B5     		push	{r7, lr}
 1652              	.LCFI39:
 1653              		.cfi_def_cfa_offset 8
 1654              		.cfi_offset 7, -8
 1655              		.cfi_offset 14, -4
 1656 0b6a 00AF     		add	r7, sp, #0
 1657              	.LCFI40:
 1658              		.cfi_def_cfa_register 7
 772:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 773:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXDATAPREPARE);
 1659              		.loc 1 773 0
 1660 0b6c 4FF02100 		mov	r0, #33
 1661 0b70 FFF7FEFF 		bl	changeState
 774:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 775:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // load the packet in the radio's Tx buffer
 776:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_loadPacket(ieee154e_vars.dataToSend->payload,
 1662              		.loc 1 776 0
 1663 0b74 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1664 0b78 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1665 0b7c 5B69     		ldr	r3, [r3, #20]
 1666 0b7e 5A68     		ldr	r2, [r3, #4]
 777:openstack/02a-MAClow/IEEE802154Ecsl.c ****                     ieee154e_vars.dataToSend->length);
 1667              		.loc 1 777 0
 1668 0b80 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1669 0b84 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1670 0b88 5B69     		ldr	r3, [r3, #20]
 776:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_loadPacket(ieee154e_vars.dataToSend->payload,
 1671              		.loc 1 776 0
 1672 0b8a 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 1673 0b8c 1046     		mov	r0, r2
 1674 0b8e 1946     		mov	r1, r3
 1675 0b90 FFF7FEFF 		bl	radio_loadPacket
 778:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 779:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // enable the radio in Tx mode. This does not send the packet.
 780:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_txEnable();
 1676              		.loc 1 780 0
 1677 0b94 FFF7FEFF 		bl	radio_txEnable
 781:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnInit=radio_getTimerValue();
 1678              		.loc 1 781 0
 1679 0b98 FFF7FEFF 		bl	radio_getTimerValue
 1680 0b9c 0246     		mov	r2, r0
 1681 0b9e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1682 0ba2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1683 0ba6 1A63     		str	r2, [r3, #48]
 782:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnThisSlot=TRUE;
 1684              		.loc 1 782 0
 1685 0ba8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1686 0bac C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1687 0bb0 4FF00102 		mov	r2, #1
 1688 0bb4 83F83820 		strb	r2, [r3, #56]
 783:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 784:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt2
 785:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt2);
 1689              		.loc 1 785 0
 1690 0bb8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1691 0bbc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1692 0bc0 5B6A     		ldr	r3, [r3, #36]
 1693 0bc2 03F17C03 		add	r3, r3, #124
 1694 0bc6 1846     		mov	r0, r3
 1695 0bc8 FFF7FEFF 		bl	radiotimer_schedule
 786:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 787:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 788:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXDATAREADY);
 1696              		.loc 1 788 0
 1697 0bcc 4FF02200 		mov	r0, #34
 1698 0bd0 FFF7FEFF 		bl	changeState
 789:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 790:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1699              		.loc 1 790 0
 1700 0bd4 80BD     		pop	{r7, pc}
 1701              		.cfi_endproc
 1702              	.LFE16:
 1704 0bd6 00BF     		.align	2
 1705              		.global	activity_csl_data_tie1
 1706              		.thumb
 1707              		.thumb_func
 1709              	activity_csl_data_tie1:
 1710              	.LFB17:
 791:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 792:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 793:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data tie1].
 794:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 795:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #tt2 expiring, i.e. timer fires while state = S_CSLTXDATAPREPARE. This is re
 796:openstack/02a-MAClow/IEEE802154Ecsl.c ****   did not have enough time to execute. Chances are to set maxTxDataPrepare too small. The implement
 797:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 798:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_tie1() {
 1711              		.loc 1 798 0
 1712              		.cfi_startproc
 1713              		@ args = 0, pretend = 0, frame = 0
 1714              		@ frame_needed = 1, uses_anonymous_args = 0
 1715 0bd8 80B5     		push	{r7, lr}
 1716              	.LCFI41:
 1717              		.cfi_def_cfa_offset 8
 1718              		.cfi_offset 7, -8
 1719              		.cfi_offset 14, -4
 1720 0bda 00AF     		add	r7, sp, #0
 1721              	.LCFI42:
 1722              		.cfi_def_cfa_register 7
 799:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
 800:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXDATAPREPARE_OVERFLOW,
 801:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_vars.slo
 1723              		.loc 1 801 0
 1724 0bdc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1725 0be0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1726 0be4 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 800:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXDATAPREPARE_OVERFLOW,
 1727              		.loc 1 800 0
 1728 0be6 1A46     		mov	r2, r3
 1729 0be8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1730 0bec C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1731 0bf0 DB88     		ldrh	r3, [r3, #6]
 1732 0bf2 4FF00900 		mov	r0, #9
 1733 0bf6 4FF02201 		mov	r1, #34
 1734 0bfa FFF7FEFF 		bl	openserial_printError
 802:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
 803:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 1735              		.loc 1 803 0
 1736 0bfe FFF7FEFF 		bl	endOps
 804:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1737              		.loc 1 804 0
 1738 0c02 80BD     		pop	{r7, pc}
 1739              		.cfi_endproc
 1740              	.LFE17:
 1742              		.align	2
 1743              		.global	activity_csl_data_ti3
 1744              		.thumb
 1745              		.thumb_func
 1747              	activity_csl_data_ti3:
 1748              	.LFB18:
 805:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 806:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 807:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti3].
 808:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 809:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 810:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The radio is configured and this interrupt gives it the "go" signal to start listening.
 811:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 812:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti3() {
 1749              		.loc 1 812 0
 1750              		.cfi_startproc
 1751              		@ args = 0, pretend = 0, frame = 0
 1752              		@ frame_needed = 1, uses_anonymous_args = 0
 1753 0c04 80B5     		push	{r7, lr}
 1754              	.LCFI43:
 1755              		.cfi_def_cfa_offset 8
 1756              		.cfi_offset 7, -8
 1757              		.cfi_offset 14, -4
 1758 0c06 00AF     		add	r7, sp, #0
 1759              	.LCFI44:
 1760              		.cfi_def_cfa_register 7
 813:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 814:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXDATADELAY);
 1761              		.loc 1 814 0
 1762 0c08 4FF02300 		mov	r0, #35
 1763 0c0c FFF7FEFF 		bl	changeState
 815:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 816:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt3
 817:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt3);
 1764              		.loc 1 817 0
 1765 0c10 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1766 0c14 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1767 0c18 5B6A     		ldr	r3, [r3, #36]
 1768 0c1a 03F19D03 		add	r3, r3, #157
 1769 0c1e 1846     		mov	r0, r3
 1770 0c20 FFF7FEFF 		bl	radiotimer_schedule
 818:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 819:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // give the 'go' to transmit
 820:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_txNow();
 1771              		.loc 1 820 0
 1772 0c24 FFF7FEFF 		bl	radio_txNow
 821:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1773              		.loc 1 821 0
 1774 0c28 80BD     		pop	{r7, pc}
 1775              		.cfi_endproc
 1776              	.LFE18:
 1778 0c2a 00BF     		.align	2
 1779              		.global	activity_csl_data_tie2
 1780              		.thumb
 1781              		.thumb_func
 1783              	activity_csl_data_tie2:
 1784              	.LFB19:
 822:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 823:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 824:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 825:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX Sampling error [data tie2].
 826:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 827:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #tt3 expiring, i.e. timer fires while state = S_CSLTXDATADELAY. If no packet
 828:openstack/02a-MAClow/IEEE802154Ecsl.c ****   none will be sent and it is safe to switch off the radio. This timer is set such that the radio w
 829:openstack/02a-MAClow/IEEE802154Ecsl.c ****   duration (#TsLongGT).
 830:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 831:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_tie2() {
 1785              		.loc 1 831 0
 1786              		.cfi_startproc
 1787              		@ args = 0, pretend = 0, frame = 0
 1788              		@ frame_needed = 1, uses_anonymous_args = 0
 1789 0c2c 80B5     		push	{r7, lr}
 1790              	.LCFI45:
 1791              		.cfi_def_cfa_offset 8
 1792              		.cfi_offset 7, -8
 1793              		.cfi_offset 14, -4
 1794 0c2e 00AF     		add	r7, sp, #0
 1795              	.LCFI46:
 1796              		.cfi_def_cfa_register 7
 832:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
 833:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIO_OVERFLOWS,
 834:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_vars.slo
 1797              		.loc 1 834 0
 1798 0c30 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1799 0c34 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1800 0c38 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 833:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIO_OVERFLOWS,
 1801              		.loc 1 833 0
 1802 0c3a 1A46     		mov	r2, r3
 1803 0c3c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1804 0c40 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1805 0c44 DB88     		ldrh	r3, [r3, #6]
 1806 0c46 4FF00900 		mov	r0, #9
 1807 0c4a 4FF02701 		mov	r1, #39
 1808 0c4e FFF7FEFF 		bl	openserial_printError
 835:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 836:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
 837:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 1809              		.loc 1 837 0
 1810 0c52 FFF7FEFF 		bl	endOps
 838:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1811              		.loc 1 838 0
 1812 0c56 80BD     		pop	{r7, pc}
 1813              		.cfi_endproc
 1814              	.LFE19:
 1816              		.align	2
 1817              		.global	activity_csl_data_ti4
 1818              		.thumb
 1819              		.thumb_func
 1821              	activity_csl_data_ti4:
 1822              	.LFB20:
 839:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 840:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 841:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 842:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti4].
 843:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 844:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_startOfFrame" function when a start of frame ev
 845:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change state, cancel #tt3 and arm #tt4 (max time to sent all the packet).
 846:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 847:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti4(PORT_RADIOTIMER_WIDTH capturedTime) {
 1823              		.loc 1 847 0
 1824              		.cfi_startproc
 1825              		@ args = 0, pretend = 0, frame = 8
 1826              		@ frame_needed = 1, uses_anonymous_args = 0
 1827 0c58 80B5     		push	{r7, lr}
 1828              	.LCFI47:
 1829              		.cfi_def_cfa_offset 8
 1830              		.cfi_offset 7, -8
 1831              		.cfi_offset 14, -4
 1832 0c5a 82B0     		sub	sp, sp, #8
 1833              	.LCFI48:
 1834              		.cfi_def_cfa_offset 16
 1835 0c5c 00AF     		add	r7, sp, #0
 1836              	.LCFI49:
 1837              		.cfi_def_cfa_register 7
 1838 0c5e 7860     		str	r0, [r7, #4]
 848:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 849:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXDATA);
 1839              		.loc 1 849 0
 1840 0c60 4FF02400 		mov	r0, #36
 1841 0c64 FFF7FEFF 		bl	changeState
 850:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 851:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel tt3
 852:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 1842              		.loc 1 852 0
 1843 0c68 FFF7FEFF 		bl	radiotimer_cancel
 853:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 854:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
 855:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.lastCapturedTime = capturedTime;
 1844              		.loc 1 855 0
 1845 0c6c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1846 0c70 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1847 0c74 7A68     		ldr	r2, [r7, #4]
 1848 0c76 5A62     		str	r2, [r3, #36]
 856:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 857:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt4
 858:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt4);
 1849              		.loc 1 858 0
 1850 0c78 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1851 0c7c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1852 0c80 5B6A     		ldr	r3, [r3, #36]
 1853 0c82 03F1A403 		add	r3, r3, #164
 1854 0c86 1846     		mov	r0, r3
 1855 0c88 FFF7FEFF 		bl	radiotimer_schedule
 859:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1856              		.loc 1 859 0
 1857 0c8c 07F10807 		add	r7, r7, #8
 1858 0c90 BD46     		mov	sp, r7
 1859 0c92 80BD     		pop	{r7, pc}
 1860              		.cfi_endproc
 1861              	.LFE20:
 1863              		.align	2
 1864              		.global	activity_csl_data_tie3
 1865              		.thumb
 1866              		.thumb_func
 1868              	activity_csl_data_tie3:
 1869              	.LFB21:
 860:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 861:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 862:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data tie3].
 863:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 864:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #tt4 expiring, i.e. timer fires while state = S_CSLTXDATA. This is an error 
 865:openstack/02a-MAClow/IEEE802154Ecsl.c ****   to transmit the data packet. The implemented behaviour is to log the error and finish.
 866:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 867:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_tie3() {
 1870              		.loc 1 867 0
 1871              		.cfi_startproc
 1872              		@ args = 0, pretend = 0, frame = 0
 1873              		@ frame_needed = 1, uses_anonymous_args = 0
 1874 0c94 80B5     		push	{r7, lr}
 1875              	.LCFI50:
 1876              		.cfi_def_cfa_offset 8
 1877              		.cfi_offset 7, -8
 1878              		.cfi_offset 14, -4
 1879 0c96 00AF     		add	r7, sp, #0
 1880              	.LCFI51:
 1881              		.cfi_def_cfa_register 7
 868:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
 869:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
 870:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_vars.slo
 1882              		.loc 1 870 0
 1883 0c98 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1884 0c9c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1885 0ca0 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 869:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
 1886              		.loc 1 869 0
 1887 0ca2 1A46     		mov	r2, r3
 1888 0ca4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1889 0ca8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1890 0cac DB88     		ldrh	r3, [r3, #6]
 1891 0cae 4FF00900 		mov	r0, #9
 1892 0cb2 4FF02601 		mov	r1, #38
 1893 0cb6 FFF7FEFF 		bl	openserial_printError
 871:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
 872:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 1894              		.loc 1 872 0
 1895 0cba FFF7FEFF 		bl	endOps
 873:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1896              		.loc 1 873 0
 1897 0cbe 80BD     		pop	{r7, pc}
 1898              		.cfi_endproc
 1899              	.LFE21:
 1901              		.align	2
 1902              		.global	activity_csl_data_ti5
 1903              		.thumb
 1904              		.thumb_func
 1906              	activity_csl_data_ti5:
 1907              	.LFB22:
 874:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 875:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 876:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ri5].
 877:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 878:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_endOfFrame" function when a end of frame event 
 879:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change state, cancel #tt4, and notify upper layer and schedule about succ
 880:openstack/02a-MAClow/IEEE802154Ecsl.c ****   start process for receive ACK frame (arm #tt5).
 881:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 882:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti5(PORT_RADIOTIMER_WIDTH capturedTime) {
 1908              		.loc 1 882 0
 1909              		.cfi_startproc
 1910              		@ args = 0, pretend = 0, frame = 16
 1911              		@ frame_needed = 1, uses_anonymous_args = 0
 1912 0cc0 90B5     		push	{r4, r7, lr}
 1913              	.LCFI52:
 1914              		.cfi_def_cfa_offset 12
 1915              		.cfi_offset 4, -12
 1916              		.cfi_offset 7, -8
 1917              		.cfi_offset 14, -4
 1918 0cc2 85B0     		sub	sp, sp, #20
 1919              	.LCFI53:
 1920              		.cfi_def_cfa_offset 32
 1921 0cc4 00AF     		add	r7, sp, #0
 1922              	.LCFI54:
 1923              		.cfi_def_cfa_register 7
 1924 0cc6 7860     		str	r0, [r7, #4]
 883:openstack/02a-MAClow/IEEE802154Ecsl.c ****    bool listenForAck;
 884:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 885:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 886:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXACKOFFSET);
 1925              		.loc 1 886 0
 1926 0cc8 4FF02500 		mov	r0, #37
 1927 0ccc FFF7FEFF 		bl	changeState
 887:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 888:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel tt4
 889:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 1928              		.loc 1 889 0
 1929 0cd0 FFF7FEFF 		bl	radiotimer_cancel
 890:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 891:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // turn off the radio
 892:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rfOff();
 1930              		.loc 1 892 0
 1931 0cd4 FFF7FEFF 		bl	radio_rfOff
 893:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnTics+=(radio_getTimerValue()-ieee154e_vars.radioOnInit);
 1932              		.loc 1 893 0
 1933 0cd8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1934 0cdc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1935 0ce0 5C6B     		ldr	r4, [r3, #52]
 1936 0ce2 FFF7FEFF 		bl	radio_getTimerValue
 1937 0ce6 0246     		mov	r2, r0
 1938 0ce8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1939 0cec C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1940 0cf0 1B6B     		ldr	r3, [r3, #48]
 1941 0cf2 D31A     		subs	r3, r2, r3
 1942 0cf4 E218     		adds	r2, r4, r3
 1943 0cf6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1944 0cfa C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1945 0cfe 5A63     		str	r2, [r3, #52]
 894:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 895:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
 896:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //ieee154e_vars.lastCapturedTime = capturedTime;
 897:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 898:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // decides whether to listen for an ACK
 899:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (packetfunctions_isBroadcastMulticast(&ieee154e_vars.dataToSend->l2_nextORpreviousHop)==TRUE)
 1946              		.loc 1 899 0
 1947 0d00 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1948 0d04 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1949 0d08 5B69     		ldr	r3, [r3, #20]
 1950 0d0a 03F13803 		add	r3, r3, #56
 1951 0d0e 1846     		mov	r0, r3
 1952 0d10 FFF7FEFF 		bl	packetfunctions_isBroadcastMulticast
 1953 0d14 0346     		mov	r3, r0
 1954 0d16 002B     		cmp	r3, #0
 1955 0d18 03D0     		beq	.L112
 900:openstack/02a-MAClow/IEEE802154Ecsl.c ****       listenForAck = FALSE;
 1956              		.loc 1 900 0
 1957 0d1a 4FF00003 		mov	r3, #0
 1958 0d1e FB73     		strb	r3, [r7, #15]
 1959 0d20 02E0     		b	.L113
 1960              	.L112:
 901:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
 902:openstack/02a-MAClow/IEEE802154Ecsl.c ****       listenForAck = TRUE;
 1961              		.loc 1 902 0
 1962 0d22 4FF00103 		mov	r3, #1
 1963 0d26 FB73     		strb	r3, [r7, #15]
 1964              	.L113:
 903:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 904:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 905:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // [CSL-TEST]: testing code for toggling orange led to indicate OK TX.
 906:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 907:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if((ieee154e_vars.dataToSend->l2_frameType == IEEE154_TYPE_DATA) &&
 1965              		.loc 1 907 0
 1966 0d28 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1967 0d2c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1968 0d30 5B69     		ldr	r3, [r3, #20]
 1969 0d32 93F84930 		ldrb	r3, [r3, #73]	@ zero_extendqisi2
 1970 0d36 012B     		cmp	r3, #1
 1971 0d38 0CD1     		bne	.L114
 908:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  (ieee154e_vars.dataToSend->owner == COMPONENT_SIXTOP_TO_IEEE802154E)) {
 1972              		.loc 1 908 0 discriminator 1
 1973 0d3a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1974 0d3e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1975 0d42 5B69     		ldr	r3, [r3, #20]
 1976 0d44 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 907:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if((ieee154e_vars.dataToSend->l2_frameType == IEEE154_TYPE_DATA) &&
 1977              		.loc 1 907 0 discriminator 1
 1978 0d46 0A2B     		cmp	r3, #10
 1979 0d48 04D1     		bne	.L114
 909:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	 leds_sync_blink();
 1980              		.loc 1 909 0
 1981 0d4a FFF7FEFF 		bl	leds_sync_blink
 910:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	 listenForAck = FALSE;
 1982              		.loc 1 910 0
 1983 0d4e 4FF00003 		mov	r3, #0
 1984 0d52 FB73     		strb	r3, [r7, #15]
 1985              	.L114:
 911:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 912:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // [CSL-TEST]: end test code
 913:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 914:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 915:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (listenForAck==TRUE) {
 1986              		.loc 1 915 0
 1987 0d54 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 1988 0d56 002B     		cmp	r3, #0
 1989 0d58 0AD0     		beq	.L115
 916:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // arm tt5
 917:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radiotimer_schedule(DURATION_tt5);
 1990              		.loc 1 917 0
 1991 0d5a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1992 0d5e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1993 0d62 5B6A     		ldr	r3, [r3, #36]
 1994 0d64 03F17D03 		add	r3, r3, #125
 1995 0d68 1846     		mov	r0, r3
 1996 0d6a FFF7FEFF 		bl	radiotimer_schedule
 1997 0d6e 09E0     		b	.L111
 1998              	.L115:
 918:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
 919:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // indicate succesful Tx to schedule to keep statistics
 920:openstack/02a-MAClow/IEEE802154Ecsl.c ****       schedule_indicateTx(&ieee154e_vars.asn,TRUE);
 1999              		.loc 1 920 0
 2000 0d70 40F20000 		movw	r0, #:lower16:ieee154e_vars
 2001 0d74 C0F20000 		movt	r0, #:upper16:ieee154e_vars
 2002 0d78 4FF00101 		mov	r1, #1
 2003 0d7c FFF7FEFF 		bl	schedule_indicateTx
 921:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 922:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // [CSL-TEST]: comment notification
 923:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 924:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // indicate to upper later the packet was sent successfully
 925:openstack/02a-MAClow/IEEE802154Ecsl.c ****       //notif_sendDone(ieee154e_vars.dataToSend,E_SUCCESS);
 926:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 927:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset local variable
 928:openstack/02a-MAClow/IEEE802154Ecsl.c ****       //ieee154e_vars.dataToSend = NULL;
 929:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 930:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // [CSL-TEST]: end test code
 931:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 932:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // abort
 933:openstack/02a-MAClow/IEEE802154Ecsl.c ****       endOps();
 2004              		.loc 1 933 0
 2005 0d80 FFF7FEFF 		bl	endOps
 2006              	.L111:
 934:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 935:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2007              		.loc 1 935 0
 2008 0d84 07F11407 		add	r7, r7, #20
 2009 0d88 BD46     		mov	sp, r7
 2010 0d8a 90BD     		pop	{r4, r7, pc}
 2011              		.cfi_endproc
 2012              	.LFE22:
 2014              		.align	2
 2015              		.global	activity_csl_data_ti6
 2016              		.thumb
 2017              		.thumb_func
 2019              	activity_csl_data_ti6:
 2020              	.LFB23:
 936:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 937:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 938:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti6].
 939:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 940:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 941:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The functionality is to prepare the radio for ACK reception.
 942:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 943:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti6() {
 2021              		.loc 1 943 0
 2022              		.cfi_startproc
 2023              		@ args = 0, pretend = 0, frame = 0
 2024              		@ frame_needed = 1, uses_anonymous_args = 0
 2025 0d8c 80B5     		push	{r7, lr}
 2026              	.LCFI55:
 2027              		.cfi_def_cfa_offset 8
 2028              		.cfi_offset 7, -8
 2029              		.cfi_offset 14, -4
 2030 0d8e 00AF     		add	r7, sp, #0
 2031              	.LCFI56:
 2032              		.cfi_def_cfa_register 7
 944:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 945:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXACKPREPARE);
 2033              		.loc 1 945 0
 2034 0d90 4FF02600 		mov	r0, #38
 2035 0d94 FFF7FEFF 		bl	changeState
 946:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 947:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // enable the radio in Rx mode. The radio is not actively listening yet.
 948:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rxEnable();
 2036              		.loc 1 948 0
 2037 0d98 FFF7FEFF 		bl	radio_rxEnable
 949:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 950:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //caputre init of radio for duty cycle calculation
 951:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnInit=radio_getTimerValue();
 2038              		.loc 1 951 0
 2039 0d9c FFF7FEFF 		bl	radio_getTimerValue
 2040 0da0 0246     		mov	r2, r0
 2041 0da2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2042 0da6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2043 0daa 1A63     		str	r2, [r3, #48]
 952:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnThisSlot=TRUE;
 2044              		.loc 1 952 0
 2045 0dac 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2046 0db0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2047 0db4 4FF00102 		mov	r2, #1
 2048 0db8 83F83820 		strb	r2, [r3, #56]
 953:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 954:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt6
 955:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt6);
 2049              		.loc 1 955 0
 2050 0dbc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2051 0dc0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2052 0dc4 5B6A     		ldr	r3, [r3, #36]
 2053 0dc6 03F18703 		add	r3, r3, #135
 2054 0dca 1846     		mov	r0, r3
 2055 0dcc FFF7FEFF 		bl	radiotimer_schedule
 956:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 957:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 958:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXACKREADY);
 2056              		.loc 1 958 0
 2057 0dd0 4FF02700 		mov	r0, #39
 2058 0dd4 FFF7FEFF 		bl	changeState
 959:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2059              		.loc 1 959 0
 2060 0dd8 80BD     		pop	{r7, pc}
 2061              		.cfi_endproc
 2062              	.LFE23:
 2064 0dda 00BF     		.align	2
 2065              		.global	activity_csl_data_tie4
 2066              		.thumb
 2067              		.thumb_func
 2069              	activity_csl_data_tie4:
 2070              	.LFB24:
 960:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 961:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 962:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data tie4].
 963:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 964:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 965:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The functionality is to prepare the radio for ACK sending.
 966:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 967:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_tie4() {
 2071              		.loc 1 967 0
 2072              		.cfi_startproc
 2073              		@ args = 0, pretend = 0, frame = 0
 2074              		@ frame_needed = 1, uses_anonymous_args = 0
 2075 0ddc 80B5     		push	{r7, lr}
 2076              	.LCFI57:
 2077              		.cfi_def_cfa_offset 8
 2078              		.cfi_offset 7, -8
 2079              		.cfi_offset 14, -4
 2080 0dde 00AF     		add	r7, sp, #0
 2081              	.LCFI58:
 2082              		.cfi_def_cfa_register 7
 968:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
 969:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXACKPREPARE_OVERFLOWS,
 970:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_vars.slo
 2083              		.loc 1 970 0
 2084 0de0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2085 0de4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2086 0de8 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 969:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXACKPREPARE_OVERFLOWS,
 2087              		.loc 1 969 0
 2088 0dea 1A46     		mov	r2, r3
 2089 0dec 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2090 0df0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2091 0df4 DB88     		ldrh	r3, [r3, #6]
 2092 0df6 4FF00900 		mov	r0, #9
 2093 0dfa 4FF02301 		mov	r1, #35
 2094 0dfe FFF7FEFF 		bl	openserial_printError
 971:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
 972:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 2095              		.loc 1 972 0
 2096 0e02 FFF7FEFF 		bl	endOps
 973:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2097              		.loc 1 973 0
 2098 0e06 80BD     		pop	{r7, pc}
 2099              		.cfi_endproc
 2100              	.LFE24:
 2102              		.align	2
 2103              		.global	activity_csl_data_ti7
 2104              		.thumb
 2105              		.thumb_func
 2107              	activity_csl_data_ti7:
 2108              	.LFB25:
 974:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 975:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 976:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti7].
 977:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 978:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 979:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The radio is configured and this interrupt gives it the "go" signal to start listening.
 980:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 981:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti7() {
 2109              		.loc 1 981 0
 2110              		.cfi_startproc
 2111              		@ args = 0, pretend = 0, frame = 0
 2112              		@ frame_needed = 1, uses_anonymous_args = 0
 2113 0e08 80B5     		push	{r7, lr}
 2114              	.LCFI59:
 2115              		.cfi_def_cfa_offset 8
 2116              		.cfi_offset 7, -8
 2117              		.cfi_offset 14, -4
 2118 0e0a 00AF     		add	r7, sp, #0
 2119              	.LCFI60:
 2120              		.cfi_def_cfa_register 7
 982:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 983:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXACKLISTEN);
 2121              		.loc 1 983 0
 2122 0e0c 4FF02800 		mov	r0, #40
 2123 0e10 FFF7FEFF 		bl	changeState
 984:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 985:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // start listening
 986:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rxNow();
 2124              		.loc 1 986 0
 2125 0e14 FFF7FEFF 		bl	radio_rxNow
 987:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 988:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt7
 989:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt7);
 2126              		.loc 1 989 0
 2127 0e18 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2128 0e1c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2129 0e20 5B6A     		ldr	r3, [r3, #36]
 2130 0e22 03F1A703 		add	r3, r3, #167
 2131 0e26 1846     		mov	r0, r3
 2132 0e28 FFF7FEFF 		bl	radiotimer_schedule
 990:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2133              		.loc 1 990 0
 2134 0e2c 80BD     		pop	{r7, pc}
 2135              		.cfi_endproc
 2136              	.LFE25:
 2138 0e2e 00BF     		.align	2
 2139              		.global	activity_csl_data_tie5
 2140              		.thumb
 2141              		.thumb_func
 2143              	activity_csl_data_tie5:
 2144              	.LFB26:
 991:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 992:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 993:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data tie5].
 994:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 995:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 996:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to notify upper level, updating the number of remaining retries of the packe
 997:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 998:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_tie5() {
 2145              		.loc 1 998 0
 2146              		.cfi_startproc
 2147              		@ args = 0, pretend = 0, frame = 0
 2148              		@ frame_needed = 1, uses_anonymous_args = 0
 2149 0e30 80B5     		push	{r7, lr}
 2150              	.LCFI61:
 2151              		.cfi_def_cfa_offset 8
 2152              		.cfi_offset 7, -8
 2153              		.cfi_offset 14, -4
 2154 0e32 00AF     		add	r7, sp, #0
 2155              	.LCFI62:
 2156              		.cfi_def_cfa_register 7
 999:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // indicate transmit failed to schedule to keep stats
1000:openstack/02a-MAClow/IEEE802154Ecsl.c ****    schedule_indicateTx(&ieee154e_vars.asn,FALSE);
 2157              		.loc 1 1000 0
 2158 0e34 40F20000 		movw	r0, #:lower16:ieee154e_vars
 2159 0e38 C0F20000 		movt	r0, #:upper16:ieee154e_vars
 2160 0e3c 4FF00001 		mov	r1, #0
 2161 0e40 FFF7FEFF 		bl	schedule_indicateTx
1001:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1002:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // decrement transmits left counter
1003:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.dataToSend->l2_retriesLeft--;
 2162              		.loc 1 1003 0
 2163 0e44 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2164 0e48 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2165 0e4c 5B69     		ldr	r3, [r3, #20]
 2166 0e4e 93F84B20 		ldrb	r2, [r3, #75]	@ zero_extendqisi2
 2167 0e52 02F1FF32 		add	r2, r2, #-1
 2168 0e56 D2B2     		uxtb	r2, r2
 2169 0e58 83F84B20 		strb	r2, [r3, #75]
1004:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1005:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.dataToSend->l2_retriesLeft==0) {
 2170              		.loc 1 1005 0
 2171 0e5c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2172 0e60 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2173 0e64 5B69     		ldr	r3, [r3, #20]
 2174 0e66 93F84B30 		ldrb	r3, [r3, #75]	@ zero_extendqisi2
 2175 0e6a 002B     		cmp	r3, #0
 2176 0e6c 07D0     		beq	.L121
1006:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1007:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // [CSL-TEST]: comment notification
1008:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1009:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // indicate tx fail if no more retries left
1010:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // notif_sendDone(ieee154e_vars.dataToSend,E_FAIL);
1011:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1012:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // [CSL-TEST]: end test code
1013:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1014:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
1015:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // return packet to the virtual COMPONENT_SIXTOP_TO_IEEE802154E component
1016:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataToSend->owner = COMPONENT_SIXTOP_TO_IEEE802154E;
 2177              		.loc 1 1016 0
 2178 0e6e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2179 0e72 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2180 0e76 5B69     		ldr	r3, [r3, #20]
 2181 0e78 4FF00A02 		mov	r2, #10
 2182 0e7c 5A70     		strb	r2, [r3, #1]
 2183              	.L121:
1017:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
1018:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1019:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // reset local variable
1020:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.dataToSend = NULL;
 2184              		.loc 1 1020 0
 2185 0e7e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2186 0e82 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2187 0e86 4FF00002 		mov	r2, #0
 2188 0e8a 5A61     		str	r2, [r3, #20]
1021:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1022:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1023:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 2189              		.loc 1 1023 0
 2190 0e8c FFF7FEFF 		bl	endOps
1024:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2191              		.loc 1 1024 0
 2192 0e90 80BD     		pop	{r7, pc}
 2193              		.cfi_endproc
 2194              	.LFE26:
 2196 0e92 00BF     		.align	2
 2197              		.global	activity_csl_data_ti8
 2198              		.thumb
 2199              		.thumb_func
 2201              	activity_csl_data_ti8:
 2202              	.LFB27:
1025:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1026:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1027:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti8].
1028:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1029:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_startOfFrame" function when a start of frame ev
1030:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change the state, cancel #tt7 and arm #tt8 (max time to receive the ack p
1031:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1032:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti8(PORT_RADIOTIMER_WIDTH capturedTime) {
 2203              		.loc 1 1032 0
 2204              		.cfi_startproc
 2205              		@ args = 0, pretend = 0, frame = 8
 2206              		@ frame_needed = 1, uses_anonymous_args = 0
 2207 0e94 80B5     		push	{r7, lr}
 2208              	.LCFI63:
 2209              		.cfi_def_cfa_offset 8
 2210              		.cfi_offset 7, -8
 2211              		.cfi_offset 14, -4
 2212 0e96 82B0     		sub	sp, sp, #8
 2213              	.LCFI64:
 2214              		.cfi_def_cfa_offset 16
 2215 0e98 00AF     		add	r7, sp, #0
 2216              	.LCFI65:
 2217              		.cfi_def_cfa_register 7
 2218 0e9a 7860     		str	r0, [r7, #4]
1033:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1034:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXACK);
 2219              		.loc 1 1034 0
 2220 0e9c 4FF02900 		mov	r0, #41
 2221 0ea0 FFF7FEFF 		bl	changeState
1035:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1036:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel tt7
1037:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 2222              		.loc 1 1037 0
 2223 0ea4 FFF7FEFF 		bl	radiotimer_cancel
1038:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1039:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
1040:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //ieee154e_vars.lastCapturedTime = capturedTime;
1041:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1042:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt8
1043:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt8);
 2224              		.loc 1 1043 0
 2225 0ea8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2226 0eac C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2227 0eb0 5B6A     		ldr	r3, [r3, #36]
 2228 0eb2 03F16203 		add	r3, r3, #98
 2229 0eb6 1846     		mov	r0, r3
 2230 0eb8 FFF7FEFF 		bl	radiotimer_schedule
1044:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2231              		.loc 1 1044 0
 2232 0ebc 07F10807 		add	r7, r7, #8
 2233 0ec0 BD46     		mov	sp, r7
 2234 0ec2 80BD     		pop	{r7, pc}
 2235              		.cfi_endproc
 2236              	.LFE27:
 2238              		.align	2
 2239              		.global	activity_csl_data_tie6
 2240              		.thumb
 2241              		.thumb_func
 2243              	activity_csl_data_tie6:
 2244              	.LFB28:
1045:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1046:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1047:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data tie6].
1048:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1049:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1050:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to finish and clean registers.
1051:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1052:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_tie6() {
 2245              		.loc 1 1052 0
 2246              		.cfi_startproc
 2247              		@ args = 0, pretend = 0, frame = 0
 2248              		@ frame_needed = 1, uses_anonymous_args = 0
 2249 0ec4 80B5     		push	{r7, lr}
 2250              	.LCFI66:
 2251              		.cfi_def_cfa_offset 8
 2252              		.cfi_offset 7, -8
 2253              		.cfi_offset 14, -4
 2254 0ec6 00AF     		add	r7, sp, #0
 2255              	.LCFI67:
 2256              		.cfi_def_cfa_register 7
1053:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1054:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 2257              		.loc 1 1054 0
 2258 0ec8 FFF7FEFF 		bl	endOps
1055:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2259              		.loc 1 1055 0
 2260 0ecc 80BD     		pop	{r7, pc}
 2261              		.cfi_endproc
 2262              	.LFE28:
 2264 0ece 00BF     		.align	2
 2265              		.global	activity_csl_data_ti9
 2266              		.thumb
 2267              		.thumb_func
 2269              	activity_csl_data_ti9:
 2270              	.LFB29:
1056:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1057:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1058:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1059:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti9].
1060:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1061:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_endOfFrame" function when a end of frame event 
1062:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change the state, cancel #tt8, analyze ack packet and notify upper layer.
1063:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1064:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti9(PORT_RADIOTIMER_WIDTH capturedTime) {
 2271              		.loc 1 1064 0
 2272              		.cfi_startproc
 2273              		@ args = 0, pretend = 0, frame = 80
 2274              		@ frame_needed = 1, uses_anonymous_args = 0
 2275 0ed0 B0B5     		push	{r4, r5, r7, lr}
 2276              	.LCFI68:
 2277              		.cfi_def_cfa_offset 16
 2278              		.cfi_offset 4, -16
 2279              		.cfi_offset 5, -12
 2280              		.cfi_offset 7, -8
 2281              		.cfi_offset 14, -4
 2282 0ed2 96B0     		sub	sp, sp, #88
 2283              	.LCFI69:
 2284              		.cfi_def_cfa_offset 104
 2285 0ed4 02AF     		add	r7, sp, #8
 2286              	.LCFI70:
 2287              		.cfi_def_cfa 7, 96
 2288 0ed6 7860     		str	r0, [r7, #4]
1065:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802154_header_iht     ieee802514_header;
1066:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint16_t                  lenIE;
1067:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1068:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1069:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXPROC);
 2289              		.loc 1 1069 0
 2290 0ed8 4FF02A00 		mov	r0, #42
 2291 0edc FFF7FEFF 		bl	changeState
1070:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1071:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel tt8
1072:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 2292              		.loc 1 1072 0
 2293 0ee0 FFF7FEFF 		bl	radiotimer_cancel
1073:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1074:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // turn off the radio
1075:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rfOff();
 2294              		.loc 1 1075 0
 2295 0ee4 FFF7FEFF 		bl	radio_rfOff
1076:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //compute tics radio on.
1077:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnTics+=(radio_getTimerValue()-ieee154e_vars.radioOnInit);
 2296              		.loc 1 1077 0
 2297 0ee8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2298 0eec C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2299 0ef0 5C6B     		ldr	r4, [r3, #52]
 2300 0ef2 FFF7FEFF 		bl	radio_getTimerValue
 2301 0ef6 0246     		mov	r2, r0
 2302 0ef8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2303 0efc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2304 0f00 1B6B     		ldr	r3, [r3, #48]
 2305 0f02 D31A     		subs	r3, r2, r3
 2306 0f04 E218     		adds	r2, r4, r3
 2307 0f06 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2308 0f0a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2309 0f0e 5A63     		str	r2, [r3, #52]
1078:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1079:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
1080:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //ieee154e_vars.lastCapturedTime = capturedTime;
1081:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1082:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // get a buffer to put the (received) ACK in
1083:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackReceived = openqueue_getFreePacketBuffer(COMPONENT_IEEE802154E);
 2310              		.loc 1 1083 0
 2311 0f10 4FF00900 		mov	r0, #9
 2312 0f14 FFF7FEFF 		bl	openqueue_getFreePacketBuffer
 2313 0f18 0246     		mov	r2, r0
 2314 0f1a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2315 0f1e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2316 0f22 1A62     		str	r2, [r3, #32]
1084:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.ackReceived==NULL) {
 2317              		.loc 1 1084 0
 2318 0f24 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2319 0f28 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2320 0f2c 1B6A     		ldr	r3, [r3, #32]
 2321 0f2e 002B     		cmp	r3, #0
 2322 0f30 0CD1     		bne	.L125
1085:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // log the error
1086:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openserial_printError(COMPONENT_IEEE802154E,ERR_NO_FREE_PACKET_BUFFER,
 2323              		.loc 1 1086 0
 2324 0f32 4FF00900 		mov	r0, #9
 2325 0f36 4FF02C01 		mov	r1, #44
 2326 0f3a 4FF00002 		mov	r2, #0
 2327 0f3e 4FF00003 		mov	r3, #0
 2328 0f42 FFF7FEFF 		bl	openserial_printError
1087:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)0,
1088:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)0);
1089:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // abort
1090:openstack/02a-MAClow/IEEE802154Ecsl.c ****       endOps();
 2329              		.loc 1 1090 0
 2330 0f46 FFF7FEFF 		bl	endOps
 2331 0f4a 20E1     		b	.L124
 2332              	.L125:
1091:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return;
1092:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
1093:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1094:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // declare ownership over that packet
1095:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackReceived->creator = COMPONENT_IEEE802154E;
 2333              		.loc 1 1095 0
 2334 0f4c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2335 0f50 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2336 0f54 1B6A     		ldr	r3, [r3, #32]
 2337 0f56 4FF00902 		mov	r2, #9
 2338 0f5a 1A70     		strb	r2, [r3, #0]
1096:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackReceived->owner   = COMPONENT_IEEE802154E;
 2339              		.loc 1 1096 0
 2340 0f5c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2341 0f60 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2342 0f64 1B6A     		ldr	r3, [r3, #32]
 2343 0f66 4FF00902 		mov	r2, #9
 2344 0f6a 5A70     		strb	r2, [r3, #1]
1097:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1098:openstack/02a-MAClow/IEEE802154Ecsl.c ****    /*
1099:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The do-while loop that follows is a little parsing trick.
1100:openstack/02a-MAClow/IEEE802154Ecsl.c ****    Because it contains a while(0) condition, it gets executed only once.
1101:openstack/02a-MAClow/IEEE802154Ecsl.c ****    Below the do-while loop is some code to cleans up the ack variable.
1102:openstack/02a-MAClow/IEEE802154Ecsl.c ****    Anywhere in the do-while loop, a break statement can be called to jump to
1103:openstack/02a-MAClow/IEEE802154Ecsl.c ****    the clean up code early. If the loop ends without a break, the received
1104:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packet was correct. If it got aborted early (through a break), the packet
1105:openstack/02a-MAClow/IEEE802154Ecsl.c ****    was faulty.
1106:openstack/02a-MAClow/IEEE802154Ecsl.c ****    */
1107:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1108:openstack/02a-MAClow/IEEE802154Ecsl.c ****    do { // this "loop" is only executed once
1109:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1110:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // retrieve the received ack frame from the radio's Rx buffer
1111:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.ackReceived->payload = &(ieee154e_vars.ackReceived->packet[FIRST_FRAME_BYTE]);
 2345              		.loc 1 1111 0
 2346 0f6c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2347 0f70 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2348 0f74 1A6A     		ldr	r2, [r3, #32]
 2349 0f76 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2350 0f7a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2351 0f7e 1B6A     		ldr	r3, [r3, #32]
 2352 0f80 03F16C03 		add	r3, r3, #108
 2353 0f84 5360     		str	r3, [r2, #4]
1112:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.ackReceived->payload,
 2354              		.loc 1 1112 0
 2355 0f86 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2356 0f8a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2357 0f8e 1B6A     		ldr	r3, [r3, #32]
 2358 0f90 5968     		ldr	r1, [r3, #4]
1113:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.ackReceived->length,
 2359              		.loc 1 1113 0
 2360 0f92 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2361 0f96 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2362 0f9a 1B6A     		ldr	r3, [r3, #32]
1112:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.ackReceived->payload,
 2363              		.loc 1 1112 0
 2364 0f9c 03F10802 		add	r2, r3, #8
1114:openstack/02a-MAClow/IEEE802154Ecsl.c ****                              sizeof(ieee154e_vars.ackReceived->packet),
1115:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.ackReceived->l1_rssi,
 2365              		.loc 1 1115 0
 2366 0fa0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2367 0fa4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2368 0fa8 1B6A     		ldr	r3, [r3, #32]
1112:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.ackReceived->payload,
 2369              		.loc 1 1112 0
 2370 0faa 03F16804 		add	r4, r3, #104
1116:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.ackReceived->l1_lqi,
 2371              		.loc 1 1116 0
 2372 0fae 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2373 0fb2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2374 0fb6 1B6A     		ldr	r3, [r3, #32]
1112:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.ackReceived->payload,
 2375              		.loc 1 1112 0
 2376 0fb8 03F16900 		add	r0, r3, #105
1117:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.ackReceived->l1_crc);
 2377              		.loc 1 1117 0
 2378 0fbc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2379 0fc0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2380 0fc4 1B6A     		ldr	r3, [r3, #32]
1112:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.ackReceived->payload,
 2381              		.loc 1 1112 0
 2382 0fc6 03F16A03 		add	r3, r3, #106
 2383 0fca 0090     		str	r0, [sp, #0]
 2384 0fcc 0193     		str	r3, [sp, #4]
 2385 0fce 0846     		mov	r0, r1
 2386 0fd0 1146     		mov	r1, r2
 2387 0fd2 4FF08202 		mov	r2, #130
 2388 0fd6 2346     		mov	r3, r4
 2389 0fd8 FFF7FEFF 		bl	radio_getReceivedFrame
1118:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1119:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // break if wrong length
1120:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.ackReceived->length<LENGTH_CRC || ieee154e_vars.ackReceived->length>LENGTH_
 2390              		.loc 1 1120 0
 2391 0fdc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2392 0fe0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2393 0fe4 1B6A     		ldr	r3, [r3, #32]
 2394 0fe6 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 2395 0fe8 012B     		cmp	r3, #1
 2396 0fea 07D9     		bls	.L127
 2397              		.loc 1 1120 0 is_stmt 0 discriminator 1
 2398 0fec 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2399 0ff0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2400 0ff4 1B6A     		ldr	r3, [r3, #32]
 2401 0ff6 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 2402 0ff8 802B     		cmp	r3, #128
 2403 0ffa 0ED9     		bls	.L128
 2404              	.L127:
1121:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // break from the do-while loop and execute the clean-up code below
1122:openstack/02a-MAClow/IEEE802154Ecsl.c ****         openserial_printError(COMPONENT_IEEE802154E,ERR_INVALIDPACKETFROMRADIO,
1123:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)1,
1124:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             ieee154e_vars.ackReceived->length);
 2405              		.loc 1 1124 0 is_stmt 1
 2406 0ffc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2407 1000 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2408 1004 1B6A     		ldr	r3, [r3, #32]
 2409 1006 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
1122:openstack/02a-MAClow/IEEE802154Ecsl.c ****         openserial_printError(COMPONENT_IEEE802154E,ERR_INVALIDPACKETFROMRADIO,
 2410              		.loc 1 1122 0
 2411 1008 4FF00900 		mov	r0, #9
 2412 100c 4FF03701 		mov	r1, #55
 2413 1010 4FF00102 		mov	r2, #1
 2414 1014 FFF7FEFF 		bl	openserial_printError
1125:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1126:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 2415              		.loc 1 1126 0
 2416 1018 A8E0     		b	.L129
 2417              	.L128:
1127:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1128:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1129:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // toss CRC (2 last bytes)
1130:openstack/02a-MAClow/IEEE802154Ecsl.c ****       packetfunctions_tossFooter(   ieee154e_vars.ackReceived, LENGTH_CRC);
 2418              		.loc 1 1130 0
 2419 101a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2420 101e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2421 1022 1B6A     		ldr	r3, [r3, #32]
 2422 1024 1846     		mov	r0, r3
 2423 1026 4FF00201 		mov	r1, #2
 2424 102a FFF7FEFF 		bl	packetfunctions_tossFooter
1131:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1132:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // break if invalid CRC
1133:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.ackReceived->l1_crc==FALSE) {
 2425              		.loc 1 1133 0
 2426 102e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2427 1032 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2428 1036 1B6A     		ldr	r3, [r3, #32]
 2429 1038 93F86A30 		ldrb	r3, [r3, #106]	@ zero_extendqisi2
 2430 103c 83F00103 		eor	r3, r3, #1
 2431 1040 DBB2     		uxtb	r3, r3
 2432 1042 002B     		cmp	r3, #0
 2433 1044 40F08980 		bne	.L135
 2434              	.L130:
1134:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // break from the do-while loop and execute the clean-up code below
1135:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
1136:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1137:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1138:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // parse the IEEE802.15.4 header (RX ACK)
1139:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee802154_retrieveHeader(ieee154e_vars.ackReceived,&ieee802514_header);
 2435              		.loc 1 1139 0
 2436 1048 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2437 104c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2438 1050 1A6A     		ldr	r2, [r3, #32]
 2439 1052 07F11003 		add	r3, r7, #16
 2440 1056 1046     		mov	r0, r2
 2441 1058 1946     		mov	r1, r3
 2442 105a FFF7FEFF 		bl	ieee802154_retrieveHeader
1140:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1141:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // break if invalid IEEE802.15.4 header
1142:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee802514_header.valid==FALSE) {
 2443              		.loc 1 1142 0
 2444 105e 3B7C     		ldrb	r3, [r7, #16]	@ zero_extendqisi2
 2445 1060 83F00103 		eor	r3, r3, #1
 2446 1064 DBB2     		uxtb	r3, r3
 2447 1066 002B     		cmp	r3, #0
 2448 1068 79D1     		bne	.L136
 2449              	.L131:
1143:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // break from the do-while loop and execute the clean-up code below
1144:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
1145:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1146:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1147:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // store header details in packet buffer
1148:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.ackReceived->l2_frameType  = ieee802514_header.frameType;
 2450              		.loc 1 1148 0
 2451 106a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2452 106e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2453 1072 1B6A     		ldr	r3, [r3, #32]
 2454 1074 BA7C     		ldrb	r2, [r7, #18]	@ zero_extendqisi2
 2455 1076 83F84920 		strb	r2, [r3, #73]
1149:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.ackReceived->l2_dsn        = ieee802514_header.dsn;
 2456              		.loc 1 1149 0
 2457 107a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2458 107e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2459 1082 1B6A     		ldr	r3, [r3, #32]
 2460 1084 7A7E     		ldrb	r2, [r7, #25]	@ zero_extendqisi2
 2461 1086 83F84A20 		strb	r2, [r3, #74]
1150:openstack/02a-MAClow/IEEE802154Ecsl.c ****       memcpy(&(ieee154e_vars.ackReceived->l2_nextORpreviousHop),&(ieee802514_header.src),sizeof(ope
 2462              		.loc 1 1150 0
 2463 108a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2464 108e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2465 1092 1B6A     		ldr	r3, [r3, #32]
 2466 1094 03F13803 		add	r3, r3, #56
 2467 1098 1D46     		mov	r5, r3
 2468 109a 07F13C04 		add	r4, r7, #60
 2469 109e 0FCC     		ldmia	r4!, {r0, r1, r2, r3}
 2470 10a0 2860     		str	r0, [r5, #0]	@ unaligned
 2471 10a2 6960     		str	r1, [r5, #4]	@ unaligned
 2472 10a4 AA60     		str	r2, [r5, #8]	@ unaligned
 2473 10a6 EB60     		str	r3, [r5, #12]	@ unaligned
 2474 10a8 2378     		ldrb	r3, [r4, #0]
 2475 10aa 2B74     		strb	r3, [r5, #16]
1151:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1152:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // toss the IEEE802.15.4 header
1153:openstack/02a-MAClow/IEEE802154Ecsl.c ****       packetfunctions_tossHeader(ieee154e_vars.ackReceived,ieee802514_header.headerLength);
 2476              		.loc 1 1153 0
 2477 10ac 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2478 10b0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2479 10b4 1A6A     		ldr	r2, [r3, #32]
 2480 10b6 7B7C     		ldrb	r3, [r7, #17]	@ zero_extendqisi2
 2481 10b8 1046     		mov	r0, r2
 2482 10ba 1946     		mov	r1, r3
 2483 10bc FFF7FEFF 		bl	packetfunctions_tossHeader
1154:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1155:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // break if invalid ACK
1156:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (isValidAck(&ieee802514_header,ieee154e_vars.dataToSend)==FALSE) {
 2484              		.loc 1 1156 0
 2485 10c0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2486 10c4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2487 10c8 5B69     		ldr	r3, [r3, #20]
 2488 10ca 07F11002 		add	r2, r7, #16
 2489 10ce 1046     		mov	r0, r2
 2490 10d0 1946     		mov	r1, r3
 2491 10d2 FFF7FEFF 		bl	isValidAck
 2492 10d6 0346     		mov	r3, r0
 2493 10d8 83F00103 		eor	r3, r3, #1
 2494 10dc DBB2     		uxtb	r3, r3
 2495 10de 002B     		cmp	r3, #0
 2496 10e0 3FD1     		bne	.L137
 2497              	.L132:
1157:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // break from the do-while loop and execute the clean-up code below
1158:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
1159:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1160:openstack/02a-MAClow/IEEE802154Ecsl.c ****       //hanlde IEs --xv poipoi
1161:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee802514_header.ieListPresent==FALSE){
 2498              		.loc 1 1161 0
 2499 10e2 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 2500 10e4 83F00103 		eor	r3, r3, #1
 2501 10e8 DBB2     		uxtb	r3, r3
 2502 10ea 002B     		cmp	r3, #0
 2503 10ec 3BD1     		bne	.L138
 2504              	.L133:
1162:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break; //ack should contain IEs.
1163:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1164:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1165:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_processIEs(ieee154e_vars.ackReceived,&lenIE)==FALSE){
 2505              		.loc 1 1165 0
 2506 10ee 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2507 10f2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2508 10f6 1A6A     		ldr	r2, [r3, #32]
 2509 10f8 07F10E03 		add	r3, r7, #14
 2510 10fc 1046     		mov	r0, r2
 2511 10fe 1946     		mov	r1, r3
 2512 1100 FFF7FEFF 		bl	ieee154e_processIEs
 2513 1104 0346     		mov	r3, r0
 2514 1106 83F00103 		eor	r3, r3, #1
 2515 110a DBB2     		uxtb	r3, r3
 2516 110c 002B     		cmp	r3, #0
 2517 110e 2CD1     		bne	.L139
 2518              	.L134:
1166:openstack/02a-MAClow/IEEE802154Ecsl.c ****         // invalid IEs in ACK
1167:openstack/02a-MAClow/IEEE802154Ecsl.c ****         break;
1168:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1169:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1170:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // toss the IEs
1171:openstack/02a-MAClow/IEEE802154Ecsl.c ****       packetfunctions_tossHeader(ieee154e_vars.ackReceived,lenIE);
 2519              		.loc 1 1171 0
 2520 1110 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2521 1114 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2522 1118 1A6A     		ldr	r2, [r3, #32]
 2523 111a FB89     		ldrh	r3, [r7, #14]
 2524 111c DBB2     		uxtb	r3, r3
 2525 111e 1046     		mov	r0, r2
 2526 1120 1946     		mov	r1, r3
 2527 1122 FFF7FEFF 		bl	packetfunctions_tossHeader
1172:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1173:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // inform schedule of successful transmission
1174:openstack/02a-MAClow/IEEE802154Ecsl.c ****       schedule_indicateTx(&ieee154e_vars.asn,TRUE);
 2528              		.loc 1 1174 0
 2529 1126 40F20000 		movw	r0, #:lower16:ieee154e_vars
 2530 112a C0F20000 		movt	r0, #:upper16:ieee154e_vars
 2531 112e 4FF00101 		mov	r1, #1
 2532 1132 FFF7FEFF 		bl	schedule_indicateTx
1175:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1176:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // inform upper layer
1177:openstack/02a-MAClow/IEEE802154Ecsl.c ****       notif_sendDone(ieee154e_vars.dataToSend,E_SUCCESS);
 2533              		.loc 1 1177 0
 2534 1136 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2535 113a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2536 113e 5B69     		ldr	r3, [r3, #20]
 2537 1140 1846     		mov	r0, r3
 2538 1142 4FF00001 		mov	r1, #0
 2539 1146 FFF7FEFF 		bl	notif_sendDone
1178:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1179:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataToSend = NULL;
 2540              		.loc 1 1179 0
 2541 114a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2542 114e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2543 1152 4FF00002 		mov	r2, #0
 2544 1156 5A61     		str	r2, [r3, #20]
 2545 1158 08E0     		b	.L129
 2546              	.L135:
1135:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 2547              		.loc 1 1135 0
 2548 115a 00BF     		nop
 2549 115c 06E0     		b	.L129
 2550              	.L136:
1144:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 2551              		.loc 1 1144 0
 2552 115e 00BF     		nop
 2553 1160 04E0     		b	.L129
 2554              	.L137:
1158:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 2555              		.loc 1 1158 0
 2556 1162 00BF     		nop
 2557 1164 02E0     		b	.L129
 2558              	.L138:
1162:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break; //ack should contain IEs.
 2559              		.loc 1 1162 0
 2560 1166 00BF     		nop
 2561 1168 00E0     		b	.L129
 2562              	.L139:
1167:openstack/02a-MAClow/IEEE802154Ecsl.c ****         break;
 2563              		.loc 1 1167 0
 2564 116a 00BF     		nop
 2565              	.L129:
1180:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1181:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // in any case, execute the clean-up code below (processing of ACK done)
1182:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } while (0);
1183:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1184:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // free the received ack so corresponding RAM memory can be recycled
1185:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openqueue_freePacketBuffer(ieee154e_vars.ackReceived);
 2566              		.loc 1 1185 0
 2567 116c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2568 1170 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2569 1174 1B6A     		ldr	r3, [r3, #32]
 2570 1176 1846     		mov	r0, r3
 2571 1178 FFF7FEFF 		bl	openqueue_freePacketBuffer
1186:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1187:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clear local variable
1188:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackReceived = NULL;
 2572              		.loc 1 1188 0
 2573 117c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2574 1180 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2575 1184 4FF00002 		mov	r2, #0
 2576 1188 1A62     		str	r2, [r3, #32]
1189:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1190:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // official end of Tx
1191:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 2577              		.loc 1 1191 0
 2578 118a FFF7FEFF 		bl	endOps
 2579              	.L124:
1192:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2580              		.loc 1 1192 0
 2581 118e 07F15007 		add	r7, r7, #80
 2582 1192 BD46     		mov	sp, r7
 2583 1194 B0BD     		pop	{r4, r5, r7, pc}
 2584              		.cfi_endproc
 2585              	.LFE29:
 2587 1196 00BF     		.align	2
 2588              		.global	activity_csl_wakeup_ri1
 2589              		.thumb
 2590              		.thumb_func
 2592              	activity_csl_wakeup_ri1:
 2593              	.LFB30:
1193:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1194:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
1195:openstack/02a-MAClow/IEEE802154Ecsl.c **** //========================== CSL RX MODE ===============================
1196:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
1197:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1198:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1199:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1200:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [wake-up ri1].
1201:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1202:openstack/02a-MAClow/IEEE802154Ecsl.c ****  This method is invoked in ISR-mode from "isr_ieee154ecsl_newChannelSample" function when a new CSL
1203:openstack/02a-MAClow/IEEE802154Ecsl.c ****  
1204:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \note The FSM state should be S_SLEEP (initial state), raising an error in otherwise.
1205:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1206:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ri1() { // Activity for stage [ri1] on CSL RX Sampling.
 2594              		.loc 1 1206 0
 2595              		.cfi_startproc
 2596              		@ args = 0, pretend = 0, frame = 0
 2597              		@ frame_needed = 1, uses_anonymous_args = 0
 2598 1198 80B5     		push	{r7, lr}
 2599              	.LCFI71:
 2600              		.cfi_def_cfa_offset 8
 2601              		.cfi_offset 7, -8
 2602              		.cfi_offset 14, -4
 2603 119a 00AF     		add	r7, sp, #0
 2604              	.LCFI72:
 2605              		.cfi_def_cfa_register 7
1207:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1208:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // if the previous sample took too long or the state is incorrect, we will not be in the right 
1209:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // we register an error indicating the number of CSL sample where the problem have been detecte
1210:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   if (ieee154e_vars.state!=S_SLEEP) {
 2606              		.loc 1 1210 0
 2607 119c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2608 11a0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2609 11a4 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 2610 11a6 002B     		cmp	r3, #0
 2611 11a8 14D0     		beq	.L141
1211:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  // log the error
1212:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_START_CSL_SAMPLING,
1213:openstack/02a-MAClow/IEEE802154Ecsl.c **** 								(errorparameter_t)ieee154e_vars.state,
 2612              		.loc 1 1213 0
 2613 11aa 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2614 11ae C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2615 11b2 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1212:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_START_CSL_SAMPLING,
 2616              		.loc 1 1212 0
 2617 11b4 1A46     		mov	r2, r3
1214:openstack/02a-MAClow/IEEE802154Ecsl.c **** 								(errorparameter_t)ieee154e_dbg.num_cslSamples);
 2618              		.loc 1 1214 0
 2619 11b6 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 2620 11ba C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 2621 11be 1B69     		ldr	r3, [r3, #16]
1212:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_START_CSL_SAMPLING,
 2622              		.loc 1 1212 0
 2623 11c0 9BB2     		uxth	r3, r3
 2624 11c2 4FF00900 		mov	r0, #9
 2625 11c6 4FF03A01 		mov	r1, #58
 2626 11ca FFF7FEFF 		bl	openserial_printError
1215:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1216:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  // Abort in case of error. The signature of the function has been changed (instead of endSlot()
1217:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  // functionality. However, this function is equal for CSL and not-CSL.
1218:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  endOps();
 2627              		.loc 1 1218 0
 2628 11ce FFF7FEFF 		bl	endOps
1219:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  return;
 2629              		.loc 1 1219 0
 2630 11d2 17E0     		b	.L140
 2631              	.L141:
1220:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
1221:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1222:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // stop using serial
1223:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   openserial_stop();
 2632              		.loc 1 1223 0
 2633 11d4 FFF7FEFF 		bl	openserial_stop
1224:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1225:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // change state --> Next State will be S_CSLRXWAKEUPOFFSET in order to prepare for CSL Rx wake-
1226:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   changeState(S_CSLRXWAKEUPOFFSET);
 2634              		.loc 1 1226 0
 2635 11d8 4FF02B00 		mov	r0, #43
 2636 11dc FFF7FEFF 		bl	changeState
1227:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1228:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // update CSL Mode to RX in order to avoid problems in FSM.
1229:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   ieee154e_vars.cslMode = CSL_RX_MODE;
 2637              		.loc 1 1229 0
 2638 11e0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2639 11e4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2640 11e8 4FF00102 		mov	r2, #1
 2641 11ec 83F84520 		strb	r2, [r3, #69]
1230:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1231:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // arm rt1
1232:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   radiotimer_schedule(DURATION_rt1);
 2642              		.loc 1 1232 0
 2643 11f0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2644 11f4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2645 11f8 5B6A     		ldr	r3, [r3, #36]
 2646 11fa 03F13703 		add	r3, r3, #55
 2647 11fe 1846     		mov	r0, r3
 2648 1200 FFF7FEFF 		bl	radiotimer_schedule
 2649              	.L140:
1233:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2650              		.loc 1 1233 0
 2651 1204 80BD     		pop	{r7, pc}
 2652              		.cfi_endproc
 2653              	.LFE30:
 2655 1206 00BF     		.align	2
 2656              		.global	activity_csl_wakeup_ri2
 2657              		.thumb
 2658              		.thumb_func
 2660              	activity_csl_wakeup_ri2:
 2661              	.LFB31:
1234:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1235:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1236:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1237:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [wake-up ri2].
1238:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1239:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1240:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to prepare the radio for receiving packets.
1241:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1242:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ri2() { // Activity for stage [ri2] on CSL RX Sampling.
 2662              		.loc 1 1242 0
 2663              		.cfi_startproc
 2664              		@ args = 0, pretend = 0, frame = 0
 2665              		@ frame_needed = 1, uses_anonymous_args = 0
 2666 1208 80B5     		push	{r7, lr}
 2667              	.LCFI73:
 2668              		.cfi_def_cfa_offset 8
 2669              		.cfi_offset 7, -8
 2670              		.cfi_offset 14, -4
 2671 120a 00AF     		add	r7, sp, #0
 2672              	.LCFI74:
 2673              		.cfi_def_cfa_register 7
1243:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1244:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXWAKEUPPREPARE);
 2674              		.loc 1 1244 0
 2675 120c 4FF02C00 		mov	r0, #44
 2676 1210 FFF7FEFF 		bl	changeState
1245:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1246:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // We use always the same frequency so it is not necessary to change it on radio.
1247:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Enable the radio in Rx mode. The radio does not actively listen yet.
1248:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rxEnable();
 2677              		.loc 1 1248 0
 2678 1214 FFF7FEFF 		bl	radio_rxEnable
1249:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnInit=radio_getTimerValue();
 2679              		.loc 1 1249 0
 2680 1218 FFF7FEFF 		bl	radio_getTimerValue
 2681 121c 0246     		mov	r2, r0
 2682 121e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2683 1222 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2684 1226 1A63     		str	r2, [r3, #48]
1250:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnThisSlot=TRUE;
 2685              		.loc 1 1250 0
 2686 1228 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2687 122c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2688 1230 4FF00102 		mov	r2, #1
 2689 1234 83F83820 		strb	r2, [r3, #56]
1251:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1252:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt2
1253:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt2);
 2690              		.loc 1 1253 0
 2691 1238 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2692 123c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2693 1240 5B6A     		ldr	r3, [r3, #36]
 2694 1242 03F15803 		add	r3, r3, #88
 2695 1246 1846     		mov	r0, r3
 2696 1248 FFF7FEFF 		bl	radiotimer_schedule
1254:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1255:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Change state.
1256:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // If this action is not performed before rt2 has expired, we need to manage the error in activi
1257:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // prepare has exceeded the maximum allowed time (duration_rt2).
1258:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXWAKEUPREADY);
 2697              		.loc 1 1258 0
 2698 124c 4FF02D00 		mov	r0, #45
 2699 1250 FFF7FEFF 		bl	changeState
1259:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2700              		.loc 1 1259 0
 2701 1254 80BD     		pop	{r7, pc}
 2702              		.cfi_endproc
 2703              	.LFE31:
 2705 1256 00BF     		.align	2
 2706              		.global	activity_csl_wakeup_rie1
 2707              		.thumb
 2708              		.thumb_func
 2710              	activity_csl_wakeup_rie1:
 2711              	.LFB32:
1260:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1261:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1262:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1263:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling error [wake-up rie1].
1264:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1265:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #rt2 expiring, i.e. timer fires while state = S_CSLRXWAKEUPPREPARE. This is 
1266:openstack/02a-MAClow/IEEE802154Ecsl.c ****   did not have enough time to execute. Chances are to set maxRxDataPrepare too small. The implement
1267:openstack/02a-MAClow/IEEE802154Ecsl.c ****   next CSL sample.
1268:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1269:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_rie1() {  // Activity for error event [rie1] on CSL RX Samplin
 2712              		.loc 1 1269 0
 2713              		.cfi_startproc
 2714              		@ args = 0, pretend = 0, frame = 0
 2715              		@ frame_needed = 1, uses_anonymous_args = 0
 2716 1258 80B5     		push	{r7, lr}
 2717              	.LCFI75:
 2718              		.cfi_def_cfa_offset 8
 2719              		.cfi_offset 7, -8
 2720              		.cfi_offset 14, -4
 2721 125a 00AF     		add	r7, sp, #0
 2722              	.LCFI76:
 2723              		.cfi_def_cfa_register 7
1270:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
1271:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXWAKEUPPREPARE_OVERFLOWS,
1272:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state,
 2724              		.loc 1 1272 0
 2725 125c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2726 1260 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2727 1264 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1271:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXWAKEUPPREPARE_OVERFLOWS,
 2728              		.loc 1 1271 0
 2729 1266 1A46     		mov	r2, r3
1273:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_dbg.num_cslSamples);
 2730              		.loc 1 1273 0
 2731 1268 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 2732 126c C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 2733 1270 1B69     		ldr	r3, [r3, #16]
1271:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXWAKEUPPREPARE_OVERFLOWS,
 2734              		.loc 1 1271 0
 2735 1272 9BB2     		uxth	r3, r3
 2736 1274 4FF00900 		mov	r0, #9
 2737 1278 4FF03C01 		mov	r1, #60
 2738 127c FFF7FEFF 		bl	openserial_printError
1274:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1275:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 2739              		.loc 1 1275 0
 2740 1280 FFF7FEFF 		bl	endOps
1276:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2741              		.loc 1 1276 0
 2742 1284 80BD     		pop	{r7, pc}
 2743              		.cfi_endproc
 2744              	.LFE32:
 2746 1286 00BF     		.align	2
 2747              		.global	activity_csl_wakeup_ri3
 2748              		.thumb
 2749              		.thumb_func
 2751              	activity_csl_wakeup_ri3:
 2752              	.LFB33:
1277:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1278:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1279:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1280:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [wake-up ri3].
1281:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1282:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1283:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The radio is configured and this interrupt gives it the "go" signal to start listening.
1284:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1285:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ri3() { // Activity for stage [ri3] on CSL RX Sampling.
 2753              		.loc 1 1285 0
 2754              		.cfi_startproc
 2755              		@ args = 0, pretend = 0, frame = 0
 2756              		@ frame_needed = 1, uses_anonymous_args = 0
 2757 1288 80B5     		push	{r7, lr}
 2758              	.LCFI77:
 2759              		.cfi_def_cfa_offset 8
 2760              		.cfi_offset 7, -8
 2761              		.cfi_offset 14, -4
 2762 128a 00AF     		add	r7, sp, #0
 2763              	.LCFI78:
 2764              		.cfi_def_cfa_register 7
1286:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1287:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXWAKEUPLISTEN);
 2765              		.loc 1 1287 0
 2766 128c 4FF02E00 		mov	r0, #46
 2767 1290 FFF7FEFF 		bl	changeState
1288:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1289:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // give the 'go' to receive
1290:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rxNow();
 2768              		.loc 1 1290 0
 2769 1294 FFF7FEFF 		bl	radio_rxNow
1291:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1292:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt3
1293:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt3);
 2770              		.loc 1 1293 0
 2771 1298 40F24110 		movw	r0, #321
 2772 129c FFF7FEFF 		bl	radiotimer_schedule
1294:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2773              		.loc 1 1294 0
 2774 12a0 80BD     		pop	{r7, pc}
 2775              		.cfi_endproc
 2776              	.LFE33:
 2778 12a2 00BF     		.align	2
 2779              		.global	activity_csl_wakeup_rie2
 2780              		.thumb
 2781              		.thumb_func
 2783              	activity_csl_wakeup_rie2:
 2784              	.LFB34:
1295:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1296:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1297:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1298:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling error [wake-up rie2].
1299:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1300:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #rt3 expiring, i.e. timer fires while state = S_CSLRXWAKEUPLISTEN. If no pac
1301:openstack/02a-MAClow/IEEE802154Ecsl.c ****   none will be received ever and it is safe to switch of the radio. This timer is set such that the
1302:openstack/02a-MAClow/IEEE802154Ecsl.c ****   duration (#TsLongGT).
1303:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1304:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_rie2() { // Activity for error event [rie2] on CSL RX Sampling
 2785              		.loc 1 1304 0
 2786              		.cfi_startproc
 2787              		@ args = 0, pretend = 0, frame = 0
 2788              		@ frame_needed = 1, uses_anonymous_args = 0
 2789 12a4 80B5     		push	{r7, lr}
 2790              	.LCFI79:
 2791              		.cfi_def_cfa_offset 8
 2792              		.cfi_offset 7, -8
 2793              		.cfi_offset 14, -4
 2794 12a6 00AF     		add	r7, sp, #0
 2795              	.LCFI80:
 2796              		.cfi_def_cfa_register 7
1305:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state --> Next State will be S_CSLRXWAKEUPOFFSET in order to prepare for CSL Rx wake-u
1306:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXWAKEUPOFFSET);
 2797              		.loc 1 1306 0
 2798 12a8 4FF02B00 		mov	r0, #43
 2799 12ac FFF7FEFF 		bl	changeState
1307:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1308:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt1
1309:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt1);
 2800              		.loc 1 1309 0
 2801 12b0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2802 12b4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2803 12b8 5B6A     		ldr	r3, [r3, #36]
 2804 12ba 03F13703 		add	r3, r3, #55
 2805 12be 1846     		mov	r0, r3
 2806 12c0 FFF7FEFF 		bl	radiotimer_schedule
1310:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1311:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1312:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 2807              		.loc 1 1312 0
 2808 12c4 FFF7FEFF 		bl	endOps
1313:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2809              		.loc 1 1313 0
 2810 12c8 80BD     		pop	{r7, pc}
 2811              		.cfi_endproc
 2812              	.LFE34:
 2814 12ca 00BF     		.align	2
 2815              		.global	activity_csl_wakeup_ri4
 2816              		.thumb
 2817              		.thumb_func
 2819              	activity_csl_wakeup_ri4:
 2820              	.LFB35:
1314:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1315:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1316:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1317:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [wake-up ri4].
1318:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1319:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_startOfFrame" function when a start of frame ev
1320:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to capture the time, cancel #rt3 and arm #rt4 (max time to receive all the p
1321:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1322:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ri4(PORT_RADIOTIMER_WIDTH capturedTime) {  // Activity for sta
 2821              		.loc 1 1322 0
 2822              		.cfi_startproc
 2823              		@ args = 0, pretend = 0, frame = 8
 2824              		@ frame_needed = 1, uses_anonymous_args = 0
 2825 12cc 80B5     		push	{r7, lr}
 2826              	.LCFI81:
 2827              		.cfi_def_cfa_offset 8
 2828              		.cfi_offset 7, -8
 2829              		.cfi_offset 14, -4
 2830 12ce 82B0     		sub	sp, sp, #8
 2831              	.LCFI82:
 2832              		.cfi_def_cfa_offset 16
 2833 12d0 00AF     		add	r7, sp, #0
 2834              	.LCFI83:
 2835              		.cfi_def_cfa_register 7
 2836 12d2 7860     		str	r0, [r7, #4]
1323:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1324:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1325:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXWAKEUP);
 2837              		.loc 1 1325 0
 2838 12d4 4FF02F00 		mov	r0, #47
 2839 12d8 FFF7FEFF 		bl	changeState
1326:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1327:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel rt3
1328:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 2840              		.loc 1 1328 0
 2841 12dc FFF7FEFF 		bl	radiotimer_cancel
1329:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1330:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
1331:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.lastCapturedTime = capturedTime;
 2842              		.loc 1 1331 0
 2843 12e0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2844 12e4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2845 12e8 7A68     		ldr	r2, [r7, #4]
 2846 12ea 5A62     		str	r2, [r3, #36]
1332:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1333:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time to sync
1334:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.syncCapturedTime = capturedTime;
 2847              		.loc 1 1334 0
 2848 12ec 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2849 12f0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2850 12f4 7A68     		ldr	r2, [r7, #4]
 2851 12f6 9A62     		str	r2, [r3, #40]
1335:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1336:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt4);
 2852              		.loc 1 1336 0
 2853 12f8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2854 12fc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2855 1300 5B6A     		ldr	r3, [r3, #36]
 2856 1302 03F1A403 		add	r3, r3, #164
 2857 1306 1846     		mov	r0, r3
 2858 1308 FFF7FEFF 		bl	radiotimer_schedule
1337:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2859              		.loc 1 1337 0
 2860 130c 07F10807 		add	r7, r7, #8
 2861 1310 BD46     		mov	sp, r7
 2862 1312 80BD     		pop	{r7, pc}
 2863              		.cfi_endproc
 2864              	.LFE35:
 2866              		.align	2
 2867              		.global	activity_csl_wakeup_rie3
 2868              		.thumb
 2869              		.thumb_func
 2871              	activity_csl_wakeup_rie3:
 2872              	.LFB36:
1338:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1339:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1340:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1341:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling error [wake-up rie3].
1342:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1343:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #rt4 expiring, i.e. timer fires while state = S_CSLRXWAKEUP. This is an erro
1344:openstack/02a-MAClow/IEEE802154Ecsl.c ****   transmit the data packet. The implemented behaviour is to log the error and move on the next CSL 
1345:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1346:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_rie3() {
 2873              		.loc 1 1346 0
 2874              		.cfi_startproc
 2875              		@ args = 0, pretend = 0, frame = 0
 2876              		@ frame_needed = 1, uses_anonymous_args = 0
 2877 1314 80B5     		push	{r7, lr}
 2878              	.LCFI84:
 2879              		.cfi_def_cfa_offset 8
 2880              		.cfi_offset 7, -8
 2881              		.cfi_offset 14, -4
 2882 1316 00AF     		add	r7, sp, #0
 2883              	.LCFI85:
 2884              		.cfi_def_cfa_register 7
1347:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1348:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
1349:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDWAKEUPDURATION_OVERFLOWS,
1350:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state,
 2885              		.loc 1 1350 0
 2886 1318 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2887 131c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2888 1320 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1349:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDWAKEUPDURATION_OVERFLOWS,
 2889              		.loc 1 1349 0
 2890 1322 1A46     		mov	r2, r3
1351:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_dbg.num_cslSamples);
 2891              		.loc 1 1351 0
 2892 1324 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 2893 1328 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 2894 132c 1B69     		ldr	r3, [r3, #16]
1349:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDWAKEUPDURATION_OVERFLOWS,
 2895              		.loc 1 1349 0
 2896 132e 9BB2     		uxth	r3, r3
 2897 1330 4FF00900 		mov	r0, #9
 2898 1334 4FF03D01 		mov	r1, #61
 2899 1338 FFF7FEFF 		bl	openserial_printError
1352:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1353:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 2900              		.loc 1 1353 0
 2901 133c FFF7FEFF 		bl	endOps
1354:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2902              		.loc 1 1354 0
 2903 1340 80BD     		pop	{r7, pc}
 2904              		.cfi_endproc
 2905              	.LFE36:
 2907 1342 00BF     		.align	2
 2908              		.global	activity_csl_wakeup_ri5
 2909              		.thumb
 2910              		.thumb_func
 2912              	activity_csl_wakeup_ri5:
 2913              	.LFB37:
1355:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1356:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1357:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1358:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [wake-up ri5].
1359:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1360:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_endOfFrame" function when a end of frame event 
1361:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change state, cancel #rt4, validate wake-up frame and destination, and ar
1362:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1363:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ri5(PORT_RADIOTIMER_WIDTH capturedTime) {
 2914              		.loc 1 1363 0
 2915              		.cfi_startproc
 2916              		@ args = 0, pretend = 0, frame = 120
 2917              		@ frame_needed = 1, uses_anonymous_args = 0
 2918 1344 90B5     		push	{r4, r7, lr}
 2919              	.LCFI86:
 2920              		.cfi_def_cfa_offset 12
 2921              		.cfi_offset 4, -12
 2922              		.cfi_offset 7, -8
 2923              		.cfi_offset 14, -4
 2924 1346 A1B0     		sub	sp, sp, #132
 2925              	.LCFI87:
 2926              		.cfi_def_cfa_offset 144
 2927 1348 02AF     		add	r7, sp, #8
 2928              	.LCFI88:
 2929              		.cfi_def_cfa 7, 136
 2930 134a 7860     		str	r0, [r7, #4]
1364:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1365:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	ieee802154_header_iht ieee802514_header;
1366:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	open_addr_t myID, myID16b;
1367:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	uint16_t rztime = 0;
 2931              		.loc 1 1367 0
 2932 134c 4FF00003 		mov	r3, #0
 2933 1350 FB81     		strh	r3, [r7, #14]	@ movhi
1368:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1369:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// [CSL-TEST]: hard-code mac address to match dest address on schedule in tx activity.
1370:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1371:openstack/02a-MAClow/IEEE802154Ecsl.c ****     myID.addr_64b[0]=0x00;
 2934              		.loc 1 1371 0
 2935 1352 4FF00003 		mov	r3, #0
 2936 1356 87F82530 		strb	r3, [r7, #37]
1372:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.addr_64b[1]=0x11;
 2937              		.loc 1 1372 0
 2938 135a 4FF01103 		mov	r3, #17
 2939 135e 87F82630 		strb	r3, [r7, #38]
1373:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.addr_64b[2]=0x22;
 2940              		.loc 1 1373 0
 2941 1362 4FF02203 		mov	r3, #34
 2942 1366 87F82730 		strb	r3, [r7, #39]
1374:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.addr_64b[3]=0x33;
 2943              		.loc 1 1374 0
 2944 136a 4FF03303 		mov	r3, #51
 2945 136e 87F82830 		strb	r3, [r7, #40]
1375:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.addr_64b[4]=0x44;
 2946              		.loc 1 1375 0
 2947 1372 4FF04403 		mov	r3, #68
 2948 1376 87F82930 		strb	r3, [r7, #41]
1376:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.addr_64b[5]=0x55;
 2949              		.loc 1 1376 0
 2950 137a 4FF05503 		mov	r3, #85
 2951 137e 87F82A30 		strb	r3, [r7, #42]
1377:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.addr_64b[6]=0x66;
 2952              		.loc 1 1377 0
 2953 1382 4FF06603 		mov	r3, #102
 2954 1386 87F82B30 		strb	r3, [r7, #43]
1378:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.addr_64b[7]=0x77;
 2955              		.loc 1 1378 0
 2956 138a 4FF07703 		mov	r3, #119
 2957 138e 87F82C30 		strb	r3, [r7, #44]
1379:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1380:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.type=ADDR_64B;
 2958              		.loc 1 1380 0
 2959 1392 4FF00203 		mov	r3, #2
 2960 1396 87F82430 		strb	r3, [r7, #36]
1381:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1382:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// [CSL-TEST]: end test code
1383:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1384:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// En este punto ya hemos recibido la trama por lo que hay que hacer las siguientes validaciones:
1385:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   1.- Cambiar el estado a S_CSLRXWAKEUPVALIDATE y cancelar el temporizador rt4.
1386:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   2.- Apagar la radio.
1387:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   3.- Analizar el mensaje recibido y parsear su cabecera.
1388:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   4.- Verificar que se trata de una trama de tipo wake-up.
1389:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   5.- Comprobar que el destinatario soy yo mismo.
1390:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//
1391:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// En caso afirmativo, utilizamos el Rendezvous time recibido para saber cuánto tiempo hay que do
1392:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// En caso negativo, desactivamos la radio e iniciamos de nuevo el proceso de channel sampling.
1393:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1394:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // actualizamos el estado.
1395:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXWAKEUPVALIDATE);
 2961              		.loc 1 1395 0
 2962 139a 4FF03000 		mov	r0, #48
 2963 139e FFF7FEFF 		bl	changeState
1396:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1397:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancelamos el timer #rt4
1398:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 2964              		.loc 1 1398 0
 2965 13a2 FFF7FEFF 		bl	radiotimer_cancel
1399:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1400:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // apagamos la radio
1401:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rfOff();
 2966              		.loc 1 1401 0
 2967 13a6 FFF7FEFF 		bl	radio_rfOff
1402:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1403:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // obtenemos un buffer en el cual poder guardar los datos recibidos.
1404:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.wakeupReceived = openqueue_getFreePacketBuffer(COMPONENT_IEEE802154E);
 2968              		.loc 1 1404 0
 2969 13aa 4FF00900 		mov	r0, #9
 2970 13ae FFF7FEFF 		bl	openqueue_getFreePacketBuffer
 2971 13b2 0246     		mov	r2, r0
 2972 13b4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2973 13b8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2974 13bc 1A64     		str	r2, [r3, #64]
1405:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.wakeupReceived==NULL) {
 2975              		.loc 1 1405 0
 2976 13be 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2977 13c2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2978 13c6 1B6C     		ldr	r3, [r3, #64]
 2979 13c8 002B     		cmp	r3, #0
 2980 13ca 0CD1     		bne	.L150
1406:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // registro del error & fin de operaciones.
1407:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openserial_printError(COMPONENT_IEEE802154E,ERR_NO_FREE_PACKET_BUFFER, (errorparameter_t)0, (
 2981              		.loc 1 1407 0
 2982 13cc 4FF00900 		mov	r0, #9
 2983 13d0 4FF02C01 		mov	r1, #44
 2984 13d4 4FF00002 		mov	r2, #0
 2985 13d8 4FF00003 		mov	r3, #0
 2986 13dc FFF7FEFF 		bl	openserial_printError
1408:openstack/02a-MAClow/IEEE802154Ecsl.c ****       endOps();
 2987              		.loc 1 1408 0
 2988 13e0 FFF7FEFF 		bl	endOps
 2989 13e4 40E1     		b	.L149
 2990              	.L150:
1409:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return;
1410:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
1411:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1412:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Declaración de propiedad sobre el paquete.
1413:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.wakeupReceived->creator = COMPONENT_IEEE802154E;
 2991              		.loc 1 1413 0
 2992 13e6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2993 13ea C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2994 13ee 1B6C     		ldr	r3, [r3, #64]
 2995 13f0 4FF00902 		mov	r2, #9
 2996 13f4 1A70     		strb	r2, [r3, #0]
1414:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.wakeupReceived->owner   = COMPONENT_IEEE802154E;
 2997              		.loc 1 1414 0
 2998 13f6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2999 13fa C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3000 13fe 1B6C     		ldr	r3, [r3, #64]
 3001 1400 4FF00902 		mov	r2, #9
 3002 1404 5A70     		strb	r2, [r3, #1]
1415:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1416:openstack/02a-MAClow/IEEE802154Ecsl.c ****    /*
1417:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The do-while loop that follows is a little parsing trick.
1418:openstack/02a-MAClow/IEEE802154Ecsl.c ****    Because it contains a while(0) condition, it gets executed only once.
1419:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The behavior is:
1420:openstack/02a-MAClow/IEEE802154Ecsl.c ****    - if a break occurs inside the do{} body, the error code below the loop gets executed. This indi
1421:openstack/02a-MAClow/IEEE802154Ecsl.c ****    - if a return occurs inside the do{} body, the error code below the loop does not get executed. 
1422:openstack/02a-MAClow/IEEE802154Ecsl.c ****    */
1423:openstack/02a-MAClow/IEEE802154Ecsl.c ****    do { // Este "loop" es ejecutado sólo en una ocasión.
1424:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1425:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Obtenemos la trama con los datos recibidos desde el buffer de recepción de la radio.
1426:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.wakeupReceived->payload = &(ieee154e_vars.wakeupReceived->packet[FIRST_FRAME_BY
 3003              		.loc 1 1426 0
 3004 1406 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3005 140a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3006 140e 1A6C     		ldr	r2, [r3, #64]
 3007 1410 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3008 1414 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3009 1418 1B6C     		ldr	r3, [r3, #64]
 3010 141a 03F16C03 		add	r3, r3, #108
 3011 141e 5360     		str	r3, [r2, #4]
1427:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(      ieee154e_vars.wakeupReceived->payload,
 3012              		.loc 1 1427 0
 3013 1420 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3014 1424 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3015 1428 1B6C     		ldr	r3, [r3, #64]
 3016 142a 5968     		ldr	r1, [r3, #4]
1428:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.wakeupReceived->length,
 3017              		.loc 1 1428 0
 3018 142c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3019 1430 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3020 1434 1B6C     		ldr	r3, [r3, #64]
1427:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(      ieee154e_vars.wakeupReceived->payload,
 3021              		.loc 1 1427 0
 3022 1436 03F10802 		add	r2, r3, #8
1429:openstack/02a-MAClow/IEEE802154Ecsl.c ****                              sizeof(ieee154e_vars.wakeupReceived->packet),
1430:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.wakeupReceived->l1_rssi,
 3023              		.loc 1 1430 0
 3024 143a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3025 143e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3026 1442 1B6C     		ldr	r3, [r3, #64]
1427:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(      ieee154e_vars.wakeupReceived->payload,
 3027              		.loc 1 1427 0
 3028 1444 03F16804 		add	r4, r3, #104
1431:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.wakeupReceived->l1_lqi,
 3029              		.loc 1 1431 0
 3030 1448 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3031 144c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3032 1450 1B6C     		ldr	r3, [r3, #64]
1427:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(      ieee154e_vars.wakeupReceived->payload,
 3033              		.loc 1 1427 0
 3034 1452 03F16900 		add	r0, r3, #105
1432:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.wakeupReceived->l1_crc);
 3035              		.loc 1 1432 0
 3036 1456 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3037 145a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3038 145e 1B6C     		ldr	r3, [r3, #64]
1427:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(      ieee154e_vars.wakeupReceived->payload,
 3039              		.loc 1 1427 0
 3040 1460 03F16A03 		add	r3, r3, #106
 3041 1464 0090     		str	r0, [sp, #0]
 3042 1466 0193     		str	r3, [sp, #4]
 3043 1468 0846     		mov	r0, r1
 3044 146a 1146     		mov	r1, r2
 3045 146c 4FF08202 		mov	r2, #130
 3046 1470 2346     		mov	r3, r4
 3047 1472 FFF7FEFF 		bl	radio_getReceivedFrame
1433:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1434:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Finalizamos si la longitud no es correcta.
1435:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.wakeupReceived->length<LENGTH_CRC || ieee154e_vars.wakeupReceived->length>L
 3048              		.loc 1 1435 0
 3049 1476 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3050 147a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3051 147e 1B6C     		ldr	r3, [r3, #64]
 3052 1480 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 3053 1482 012B     		cmp	r3, #1
 3054 1484 07D9     		bls	.L152
 3055              		.loc 1 1435 0 is_stmt 0 discriminator 1
 3056 1486 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3057 148a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3058 148e 1B6C     		ldr	r3, [r3, #64]
 3059 1490 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 3060 1492 802B     		cmp	r3, #128
 3061 1494 0ED9     		bls	.L153
 3062              	.L152:
1436:openstack/02a-MAClow/IEEE802154Ecsl.c ****         openserial_printError(COMPONENT_IEEE802154E,ERR_INVALIDPACKETFROMRADIO, (errorparameter_t)2
 3063              		.loc 1 1436 0 is_stmt 1
 3064 1496 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3065 149a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3066 149e 1B6C     		ldr	r3, [r3, #64]
 3067 14a0 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 3068 14a2 4FF00900 		mov	r0, #9
 3069 14a6 4FF03701 		mov	r1, #55
 3070 14aa 4FF00202 		mov	r2, #2
 3071 14ae FFF7FEFF 		bl	openserial_printError
1437:openstack/02a-MAClow/IEEE802154Ecsl.c ****         break;
 3072              		.loc 1 1437 0
 3073 14b2 C8E0     		b	.L154
 3074              	.L153:
1438:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1439:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1440:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // toss CRC (2 últimos bytes)
1441:openstack/02a-MAClow/IEEE802154Ecsl.c ****       packetfunctions_tossFooter(ieee154e_vars.wakeupReceived, LENGTH_CRC);
 3075              		.loc 1 1441 0
 3076 14b4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3077 14b8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3078 14bc 1B6C     		ldr	r3, [r3, #64]
 3079 14be 1846     		mov	r0, r3
 3080 14c0 4FF00201 		mov	r1, #2
 3081 14c4 FFF7FEFF 		bl	packetfunctions_tossFooter
1442:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1443:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // si CRC no es válido, finalizamos el proceso.
1444:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.wakeupReceived->l1_crc==FALSE) { break; }
 3082              		.loc 1 1444 0
 3083 14c8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3084 14cc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3085 14d0 1B6C     		ldr	r3, [r3, #64]
 3086 14d2 93F86A30 		ldrb	r3, [r3, #106]	@ zero_extendqisi2
 3087 14d6 83F00103 		eor	r3, r3, #1
 3088 14da DBB2     		uxtb	r3, r3
 3089 14dc 002B     		cmp	r3, #0
 3090 14de 40F0AD80 		bne	.L162
 3091              	.L155:
1445:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1446:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // parseamos la trama IEEE802.15.4 WAKE-UP y su cabecera.
1447:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee802154_retrieveWakeUpFrame(ieee154e_vars.wakeupReceived,&ieee802514_header,&rztime);
 3092              		.loc 1 1447 0
 3093 14e2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3094 14e6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3095 14ea 196C     		ldr	r1, [r3, #64]
 3096 14ec 07F13802 		add	r2, r7, #56
 3097 14f0 07F10E03 		add	r3, r7, #14
 3098 14f4 0846     		mov	r0, r1
 3099 14f6 1146     		mov	r1, r2
 3100 14f8 1A46     		mov	r2, r3
 3101 14fa FFF7FEFF 		bl	ieee802154_retrieveWakeUpFrame
1448:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1449:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // En el caso de que no sea una cabecera IEEE802.15.4 válida, finalizamos el proceso.
1450:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee802514_header.valid==FALSE) { break; }
 3102              		.loc 1 1450 0
 3103 14fe 97F83830 		ldrb	r3, [r7, #56]	@ zero_extendqisi2
 3104 1502 83F00103 		eor	r3, r3, #1
 3105 1506 DBB2     		uxtb	r3, r3
 3106 1508 002B     		cmp	r3, #0
 3107 150a 40F09980 		bne	.L163
 3108              	.L156:
1451:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1452:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Verificamos que se trata de una trama WAKE-UP, perteneciente a la misma PAN ID, y dirigida
1453:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if(ieee802514_header.frameType==IEEE154_TYPE_MULTIPURPOSE) {
 3109              		.loc 1 1453 0
 3110 150e 97F83A30 		ldrb	r3, [r7, #58]	@ zero_extendqisi2
 3111 1512 052B     		cmp	r3, #5
 3112 1514 40F09680 		bne	.L164
1454:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1455:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	  // [CSL-TEST]: comment and substituted due to mac address is hard-coded in tx and rx for tes
1456:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1457:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	  //if(packetfunctions_sameAddress(&ieee802514_header.dest,idmanager_getMyID(ADDR_16B)) &&
1458:openstack/02a-MAClow/IEEE802154Ecsl.c ****    	      //   packetfunctions_sameAddress(&ieee802514_header.panid,idmanager_getMyID(ADDR_PANID)))
1459:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1460:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	  packetfunctions_mac64bToMac16b(&myID,&myID16b);
 3113              		.loc 1 1460 0
 3114 1518 07F12402 		add	r2, r7, #36
 3115 151c 07F11003 		add	r3, r7, #16
 3116 1520 1046     		mov	r0, r2
 3117 1522 1946     		mov	r1, r3
 3118 1524 FFF7FEFF 		bl	packetfunctions_mac64bToMac16b
1461:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	  if(packetfunctions_sameAddress(&ieee802514_header.dest, &myID16b) &&
 3119              		.loc 1 1461 0
 3120 1528 07F13803 		add	r3, r7, #56
 3121 152c 03F11B02 		add	r2, r3, #27
 3122 1530 07F11003 		add	r3, r7, #16
 3123 1534 1046     		mov	r0, r2
 3124 1536 1946     		mov	r1, r3
 3125 1538 FFF7FEFF 		bl	packetfunctions_sameAddress
 3126 153c 0346     		mov	r3, r0
 3127 153e 002B     		cmp	r3, #0
 3128 1540 43D0     		beq	.L158
1462:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     packetfunctions_sameAddress(&ieee802514_header.panid,idmanager_getMyID(ADDR_PANID))) {
 3129              		.loc 1 1462 0 discriminator 1
 3130 1542 4FF00400 		mov	r0, #4
 3131 1546 FFF7FEFF 		bl	idmanager_getMyID
 3132 154a 0346     		mov	r3, r0
 3133 154c 07F13802 		add	r2, r7, #56
 3134 1550 02F10A02 		add	r2, r2, #10
 3135 1554 1046     		mov	r0, r2
 3136 1556 1946     		mov	r1, r3
 3137 1558 FFF7FEFF 		bl	packetfunctions_sameAddress
 3138 155c 0346     		mov	r3, r0
1461:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	  if(packetfunctions_sameAddress(&ieee802514_header.dest, &myID16b) &&
 3139              		.loc 1 1461 0 discriminator 1
 3140 155e 002B     		cmp	r3, #0
 3141 1560 33D0     		beq	.L158
1463:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1464:openstack/02a-MAClow/IEEE802154Ecsl.c ****    		  // [CSL-TEST]: end test code
1465:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1466:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	   // En este caso, debemos dormir el tiempo indicado por RZ Time, estableciendo el estado a S
1467:openstack/02a-MAClow/IEEE802154Ecsl.c ****  	       changeState(S_CSLRXDATAOFFSET);
 3142              		.loc 1 1467 0
 3143 1562 4FF03100 		mov	r0, #49
 3144 1566 FFF7FEFF 		bl	changeState
1468:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1469:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	   // registro del tiempo de captura
1470:openstack/02a-MAClow/IEEE802154Ecsl.c ****            ieee154e_vars.lastCapturedTime = capturedTime;
 3145              		.loc 1 1470 0
 3146 156a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3147 156e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3148 1572 7A68     		ldr	r2, [r7, #4]
 3149 1574 5A62     		str	r2, [r3, #36]
1471:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1472:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	   // Tratamos el caso en el cual rztime_ie.time sea cero, es decir, sea la ultima trama wake-
1473:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	   if (rztime == 0) {
 3150              		.loc 1 1473 0
 3151 1576 FB89     		ldrh	r3, [r7, #14]
 3152 1578 002B     		cmp	r3, #0
 3153 157a 0AD1     		bne	.L159
1474:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     // Establecemos el timer rt1 (consideramos el mismo tiempo de offset para la recepción d
1475:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     radiotimer_schedule(DURATION_rt1);
 3154              		.loc 1 1475 0
 3155 157c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3156 1580 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3157 1584 5B6A     		ldr	r3, [r3, #36]
 3158 1586 03F13703 		add	r3, r3, #55
 3159 158a 1846     		mov	r0, r3
 3160 158c FFF7FEFF 		bl	radiotimer_schedule
 3161 1590 0BE0     		b	.L160
 3162              	.L159:
1476:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	   } else {
1477:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     // Establecemos el timer al valor rt1 pero desplazado el tiempo indicado por rendezvous-t
1478:openstack/02a-MAClow/IEEE802154Ecsl.c ****         	 radiotimer_schedule(DURATION_rt1 + rztime);
 3163              		.loc 1 1478 0
 3164 1592 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3165 1596 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3166 159a 5A6A     		ldr	r2, [r3, #36]
 3167 159c FB89     		ldrh	r3, [r7, #14]
 3168 159e D318     		adds	r3, r2, r3
 3169 15a0 03F13703 		add	r3, r3, #55
 3170 15a4 1846     		mov	r0, r3
 3171 15a6 FFF7FEFF 		bl	radiotimer_schedule
 3172              	.L160:
1479:openstack/02a-MAClow/IEEE802154Ecsl.c ****            }
1480:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1481:openstack/02a-MAClow/IEEE802154Ecsl.c ****            // Descartamos el paquete una vez recibido y tratado.
1482:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1483:openstack/02a-MAClow/IEEE802154Ecsl.c ****            openqueue_freePacketBuffer(ieee154e_vars.wakeupReceived);
 3173              		.loc 1 1483 0
 3174 15aa 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3175 15ae C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3176 15b2 1B6C     		ldr	r3, [r3, #64]
 3177 15b4 1846     		mov	r0, r3
 3178 15b6 FFF7FEFF 		bl	openqueue_freePacketBuffer
1484:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1485:openstack/02a-MAClow/IEEE802154Ecsl.c ****            // clear local variable
1486:openstack/02a-MAClow/IEEE802154Ecsl.c ****            ieee154e_vars.wakeupReceived = NULL;
 3179              		.loc 1 1486 0
 3180 15ba 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3181 15be C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3182 15c2 4FF00002 		mov	r2, #0
 3183 15c6 1A64     		str	r2, [r3, #64]
 3184 15c8 4EE0     		b	.L149
 3185              	.L158:
1487:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1488:openstack/02a-MAClow/IEEE802154Ecsl.c ****            // retornamos para no ejecutar el codigo inferior y finalizar el proceso.
1489:openstack/02a-MAClow/IEEE802154Ecsl.c ****            return;
1490:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 }
1491:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 // En el caso que sea una trama dentro de mi PANID pero no dirigida a mi, entonces dormimos u
1492:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 //   - RZ time + Maximum length payload frame + secure ack frame (consideraremos un tiempo ig
1493:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 // dado que TsSlotDuration es el tiempo utilizado en OpenWSN-TSCH para enviar y recibir una t
1494:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 // en cualquier caso revisar estos timings mediante medidas y mecanismos más precisos (oscil
1495:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1496:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 else if( ! packetfunctions_sameAddress(&ieee802514_header.dest,idmanager_getMyID(ADDR_16B)) &
 3186              		.loc 1 1496 0
 3187 15ca 4FF00100 		mov	r0, #1
 3188 15ce FFF7FEFF 		bl	idmanager_getMyID
 3189 15d2 0346     		mov	r3, r0
 3190 15d4 07F13802 		add	r2, r7, #56
 3191 15d8 02F11B02 		add	r2, r2, #27
 3192 15dc 1046     		mov	r0, r2
 3193 15de 1946     		mov	r1, r3
 3194 15e0 FFF7FEFF 		bl	packetfunctions_sameAddress
 3195 15e4 0346     		mov	r3, r0
 3196 15e6 83F00103 		eor	r3, r3, #1
 3197 15ea DBB2     		uxtb	r3, r3
 3198 15ec 002B     		cmp	r3, #0
 3199 15ee 2AD0     		beq	.L154
1497:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	   		    packetfunctions_sameAddress(&ieee802514_header.panid,idmanager_getMyID(ADDR_PANID))) 
 3200              		.loc 1 1497 0 discriminator 1
 3201 15f0 4FF00400 		mov	r0, #4
 3202 15f4 FFF7FEFF 		bl	idmanager_getMyID
 3203 15f8 0346     		mov	r3, r0
 3204 15fa 07F13802 		add	r2, r7, #56
 3205 15fe 02F10A02 		add	r2, r2, #10
 3206 1602 1046     		mov	r0, r2
 3207 1604 1946     		mov	r1, r3
 3208 1606 FFF7FEFF 		bl	packetfunctions_sameAddress
 3209 160a 0346     		mov	r3, r0
1496:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 else if( ! packetfunctions_sameAddress(&ieee802514_header.dest,idmanager_getMyID(ADDR_16B)) &
 3210              		.loc 1 1496 0 discriminator 1
 3211 160c 002B     		cmp	r3, #0
 3212 160e 1AD0     		beq	.L154
1498:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1499:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     // La limpieza del paquete y los datos recibidos será realizada en el metodo activity_cs
1500:openstack/02a-MAClow/IEEE802154Ecsl.c ****     		 radiotimer_schedule(rztime + TsSlotDuration);
 3213              		.loc 1 1500 0
 3214 1610 FB89     		ldrh	r3, [r7, #14]
 3215 1612 03F5F673 		add	r3, r3, #492
 3216 1616 1846     		mov	r0, r3
 3217 1618 FFF7FEFF 		bl	radiotimer_schedule
1501:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1502:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     // Descartamos el paquete una vez recibido y tratado.
1503:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1504:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     openqueue_freePacketBuffer(ieee154e_vars.wakeupReceived);
 3218              		.loc 1 1504 0
 3219 161c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3220 1620 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3221 1624 1B6C     		ldr	r3, [r3, #64]
 3222 1626 1846     		mov	r0, r3
 3223 1628 FFF7FEFF 		bl	openqueue_freePacketBuffer
1505:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1506:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     // clear local variable
1507:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     ieee154e_vars.wakeupReceived = NULL;
 3224              		.loc 1 1507 0
 3225 162c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3226 1630 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3227 1634 4FF00002 		mov	r2, #0
 3228 1638 1A64     		str	r2, [r3, #64]
 3229 163a 15E0     		b	.L149
 3230              	.L162:
1444:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.wakeupReceived->l1_crc==FALSE) { break; }
 3231              		.loc 1 1444 0
 3232 163c 00BF     		nop
 3233 163e 02E0     		b	.L154
 3234              	.L163:
1450:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee802514_header.valid==FALSE) { break; }
 3235              		.loc 1 1450 0
 3236 1640 00BF     		nop
 3237 1642 00E0     		b	.L154
 3238              	.L164:
1508:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1509:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     return;
1510:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 }
1511:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1512:openstack/02a-MAClow/IEEE802154Ecsl.c ****       else {
1513:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	  break; // cualquier otro tipo de trama recibida en este punto de la FSM es descartada.
 3239              		.loc 1 1513 0
 3240 1644 00BF     		nop
 3241              	.L154:
1514:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1515:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1516:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } while(0);
1517:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1518:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // En cualquier otro caso, descartamos el paquete e iniciamos de nuevo el proceso de channel sam
1519:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1520:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openqueue_freePacketBuffer(ieee154e_vars.wakeupReceived);
 3242              		.loc 1 1520 0
 3243 1646 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3244 164a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3245 164e 1B6C     		ldr	r3, [r3, #64]
 3246 1650 1846     		mov	r0, r3
 3247 1652 FFF7FEFF 		bl	openqueue_freePacketBuffer
1521:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1522:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clear local variable
1523:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.wakeupReceived = NULL;
 3248              		.loc 1 1523 0
 3249 1656 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3250 165a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3251 165e 4FF00002 		mov	r2, #0
 3252 1662 1A64     		str	r2, [r3, #64]
1524:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1525:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1526:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 3253              		.loc 1 1526 0
 3254 1664 FFF7FEFF 		bl	endOps
 3255              	.L149:
1527:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3256              		.loc 1 1527 0
 3257 1668 07F17C07 		add	r7, r7, #124
 3258 166c BD46     		mov	sp, r7
 3259 166e 90BD     		pop	{r4, r7, pc}
 3260              		.cfi_endproc
 3261              	.LFE37:
 3263              		.align	2
 3264              		.global	activity_csl_wakeup_rie4
 3265              		.thumb
 3266              		.thumb_func
 3268              	activity_csl_wakeup_rie4:
 3269              	.LFB38:
1528:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1529:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1530:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1531:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling error [wake-up rie4].
1532:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1533:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by rztime+TsSlotDuration expiring, i.e. timer fires while state = S_CSLRXWAKEUP
1534:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The behaviour is to free mem used and restart CSL sampling.
1535:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1536:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_rie4() {
 3270              		.loc 1 1536 0
 3271              		.cfi_startproc
 3272              		@ args = 0, pretend = 0, frame = 0
 3273              		@ frame_needed = 1, uses_anonymous_args = 0
 3274 1670 80B5     		push	{r7, lr}
 3275              	.LCFI89:
 3276              		.cfi_def_cfa_offset 8
 3277              		.cfi_offset 7, -8
 3278              		.cfi_offset 14, -4
 3279 1672 00AF     		add	r7, sp, #0
 3280              	.LCFI90:
 3281              		.cfi_def_cfa_register 7
1537:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1538:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 3282              		.loc 1 1538 0
 3283 1674 FFF7FEFF 		bl	endOps
1539:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3284              		.loc 1 1539 0
 3285 1678 80BD     		pop	{r7, pc}
 3286              		.cfi_endproc
 3287              	.LFE38:
 3289 167a 00BF     		.align	2
 3290              		.global	activity_csl_data_ri2
 3291              		.thumb
 3292              		.thumb_func
 3294              	activity_csl_data_ri2:
 3295              	.LFB39:
1540:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1541:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1542:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1543:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri2].
1544:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1545:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1546:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to prepare the radio for receiving packets.
1547:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1548:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1549:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri2() {
 3296              		.loc 1 1549 0
 3297              		.cfi_startproc
 3298              		@ args = 0, pretend = 0, frame = 0
 3299              		@ frame_needed = 1, uses_anonymous_args = 0
 3300 167c 80B5     		push	{r7, lr}
 3301              	.LCFI91:
 3302              		.cfi_def_cfa_offset 8
 3303              		.cfi_offset 7, -8
 3304              		.cfi_offset 14, -4
 3305 167e 00AF     		add	r7, sp, #0
 3306              	.LCFI92:
 3307              		.cfi_def_cfa_register 7
1550:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1551:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXDATAPREPARE);
 3308              		.loc 1 1551 0
 3309 1680 4FF03200 		mov	r0, #50
 3310 1684 FFF7FEFF 		bl	changeState
1552:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1553:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // We use always the same frequency so it is not necessary to change it on radio.
1554:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Enable the radio in Rx mode. The radio does not actively listen yet.
1555:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rxEnable();
 3311              		.loc 1 1555 0
 3312 1688 FFF7FEFF 		bl	radio_rxEnable
1556:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnInit=radio_getTimerValue();
 3313              		.loc 1 1556 0
 3314 168c FFF7FEFF 		bl	radio_getTimerValue
 3315 1690 0246     		mov	r2, r0
 3316 1692 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3317 1696 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3318 169a 1A63     		str	r2, [r3, #48]
1557:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnThisSlot=TRUE;
 3319              		.loc 1 1557 0
 3320 169c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3321 16a0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3322 16a4 4FF00102 		mov	r2, #1
 3323 16a8 83F83820 		strb	r2, [r3, #56]
1558:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1559:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt2
1560:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt2);
 3324              		.loc 1 1560 0
 3325 16ac 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3326 16b0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3327 16b4 5B6A     		ldr	r3, [r3, #36]
 3328 16b6 03F15803 		add	r3, r3, #88
 3329 16ba 1846     		mov	r0, r3
 3330 16bc FFF7FEFF 		bl	radiotimer_schedule
1561:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1562:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1563:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // If this action is not performed before rt2 has expired, we need to manage the error in activi
1564:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // prepare has exceeded the maximum allowed time (duration_rt2).
1565:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXDATAREADY);
 3331              		.loc 1 1565 0
 3332 16c0 4FF03300 		mov	r0, #51
 3333 16c4 FFF7FEFF 		bl	changeState
1566:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3334              		.loc 1 1566 0
 3335 16c8 80BD     		pop	{r7, pc}
 3336              		.cfi_endproc
 3337              	.LFE39:
 3339 16ca 00BF     		.align	2
 3340              		.global	activity_csl_data_rie1
 3341              		.thumb
 3342              		.thumb_func
 3344              	activity_csl_data_rie1:
 3345              	.LFB40:
1567:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1568:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1569:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1570:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling error [data_rie1].
1571:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1572:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #rt2 expiring, i.e. timer fires while state = S_CSLRXDATAPREPARE. This is re
1573:openstack/02a-MAClow/IEEE802154Ecsl.c ****   did not have enough time to execute. Chances are to set maxRxDataPrepare too small. The implement
1574:openstack/02a-MAClow/IEEE802154Ecsl.c ****   next CSL sample.
1575:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1576:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_rie1() {  // Activity for error event [rie1] on CSL RX Sampling.
 3346              		.loc 1 1576 0
 3347              		.cfi_startproc
 3348              		@ args = 0, pretend = 0, frame = 0
 3349              		@ frame_needed = 1, uses_anonymous_args = 0
 3350 16cc 80B5     		push	{r7, lr}
 3351              	.LCFI93:
 3352              		.cfi_def_cfa_offset 8
 3353              		.cfi_offset 7, -8
 3354              		.cfi_offset 14, -4
 3355 16ce 00AF     		add	r7, sp, #0
 3356              	.LCFI94:
 3357              		.cfi_def_cfa_register 7
1577:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
1578:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXDATAPREPARE_OVERFLOWS,
1579:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state,
 3358              		.loc 1 1579 0
 3359 16d0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3360 16d4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3361 16d8 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1578:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXDATAPREPARE_OVERFLOWS,
 3362              		.loc 1 1578 0
 3363 16da 1A46     		mov	r2, r3
1580:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_dbg.num_cslSamples);
 3364              		.loc 1 1580 0
 3365 16dc 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 3366 16e0 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 3367 16e4 1B69     		ldr	r3, [r3, #16]
1578:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXDATAPREPARE_OVERFLOWS,
 3368              		.loc 1 1578 0
 3369 16e6 9BB2     		uxth	r3, r3
 3370 16e8 4FF00900 		mov	r0, #9
 3371 16ec 4FF02401 		mov	r1, #36
 3372 16f0 FFF7FEFF 		bl	openserial_printError
1581:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1582:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 3373              		.loc 1 1582 0
 3374 16f4 FFF7FEFF 		bl	endOps
1583:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3375              		.loc 1 1583 0
 3376 16f8 80BD     		pop	{r7, pc}
 3377              		.cfi_endproc
 3378              	.LFE40:
 3380 16fa 00BF     		.align	2
 3381              		.global	activity_csl_data_ri3
 3382              		.thumb
 3383              		.thumb_func
 3385              	activity_csl_data_ri3:
 3386              	.LFB41:
1584:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1585:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1586:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1587:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri3].
1588:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1589:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1590:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The radio is configured and this interrupt gives it the "go" signal to start listening.
1591:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1592:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri3() { // Activity for stage [data ri3] on CSL RX Sampling.
 3387              		.loc 1 1592 0
 3388              		.cfi_startproc
 3389              		@ args = 0, pretend = 0, frame = 0
 3390              		@ frame_needed = 1, uses_anonymous_args = 0
 3391 16fc 80B5     		push	{r7, lr}
 3392              	.LCFI95:
 3393              		.cfi_def_cfa_offset 8
 3394              		.cfi_offset 7, -8
 3395              		.cfi_offset 14, -4
 3396 16fe 00AF     		add	r7, sp, #0
 3397              	.LCFI96:
 3398              		.cfi_def_cfa_register 7
1593:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1594:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXDATALISTEN);
 3399              		.loc 1 1594 0
 3400 1700 4FF03400 		mov	r0, #52
 3401 1704 FFF7FEFF 		bl	changeState
1595:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1596:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // give the 'go' to receive
1597:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rxNow();
 3402              		.loc 1 1597 0
 3403 1708 FFF7FEFF 		bl	radio_rxNow
1598:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1599:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt3
1600:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt3);
 3404              		.loc 1 1600 0
 3405 170c 40F24110 		movw	r0, #321
 3406 1710 FFF7FEFF 		bl	radiotimer_schedule
1601:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3407              		.loc 1 1601 0
 3408 1714 80BD     		pop	{r7, pc}
 3409              		.cfi_endproc
 3410              	.LFE41:
 3412 1716 00BF     		.align	2
 3413              		.global	activity_csl_data_rie2
 3414              		.thumb
 3415              		.thumb_func
 3417              	activity_csl_data_rie2:
 3418              	.LFB42:
1602:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1603:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1604:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1605:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling error [data rie2].
1606:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1607:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #rt3 expiring, i.e. timer fires while state = S_CSLRXDATALISTEN. If no packe
1608:openstack/02a-MAClow/IEEE802154Ecsl.c ****   none will be received ever and it is safe to switch of the radio. This timer is set such that the
1609:openstack/02a-MAClow/IEEE802154Ecsl.c ****   duration (#TsLongGT).
1610:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1611:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_rie2() { // Activity for error event [data rie2] on CSL RX Sampl
 3419              		.loc 1 1611 0
 3420              		.cfi_startproc
 3421              		@ args = 0, pretend = 0, frame = 0
 3422              		@ frame_needed = 1, uses_anonymous_args = 0
 3423 1718 80B5     		push	{r7, lr}
 3424              	.LCFI97:
 3425              		.cfi_def_cfa_offset 8
 3426              		.cfi_offset 7, -8
 3427              		.cfi_offset 14, -4
 3428 171a 00AF     		add	r7, sp, #0
 3429              	.LCFI98:
 3430              		.cfi_def_cfa_register 7
1612:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1613:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 3431              		.loc 1 1613 0
 3432 171c FFF7FEFF 		bl	endOps
1614:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3433              		.loc 1 1614 0
 3434 1720 80BD     		pop	{r7, pc}
 3435              		.cfi_endproc
 3436              	.LFE42:
 3438 1722 00BF     		.align	2
 3439              		.global	activity_csl_data_ri4
 3440              		.thumb
 3441              		.thumb_func
 3443              	activity_csl_data_ri4:
 3444              	.LFB43:
1615:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1616:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1617:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri4].
1618:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1619:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_startOfFrame" function when a start of frame ev
1620:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to capture the time, cancel #rt3 and arm #rt4 (max time to receive all the p
1621:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1622:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri4(PORT_RADIOTIMER_WIDTH capturedTime) {  // Activity for stage
 3445              		.loc 1 1622 0
 3446              		.cfi_startproc
 3447              		@ args = 0, pretend = 0, frame = 8
 3448              		@ frame_needed = 1, uses_anonymous_args = 0
 3449 1724 80B5     		push	{r7, lr}
 3450              	.LCFI99:
 3451              		.cfi_def_cfa_offset 8
 3452              		.cfi_offset 7, -8
 3453              		.cfi_offset 14, -4
 3454 1726 82B0     		sub	sp, sp, #8
 3455              	.LCFI100:
 3456              		.cfi_def_cfa_offset 16
 3457 1728 00AF     		add	r7, sp, #0
 3458              	.LCFI101:
 3459              		.cfi_def_cfa_register 7
 3460 172a 7860     		str	r0, [r7, #4]
1623:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1624:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1625:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXDATA);
 3461              		.loc 1 1625 0
 3462 172c 4FF03500 		mov	r0, #53
 3463 1730 FFF7FEFF 		bl	changeState
1626:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1627:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel rt3
1628:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 3464              		.loc 1 1628 0
 3465 1734 FFF7FEFF 		bl	radiotimer_cancel
1629:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1630:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
1631:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.lastCapturedTime = capturedTime;
 3466              		.loc 1 1631 0
 3467 1738 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3468 173c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3469 1740 7A68     		ldr	r2, [r7, #4]
 3470 1742 5A62     		str	r2, [r3, #36]
1632:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1633:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time to sync
1634:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.syncCapturedTime = capturedTime;
 3471              		.loc 1 1634 0
 3472 1744 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3473 1748 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3474 174c 7A68     		ldr	r2, [r7, #4]
 3475 174e 9A62     		str	r2, [r3, #40]
1635:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1636:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt4);
 3476              		.loc 1 1636 0
 3477 1750 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3478 1754 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3479 1758 5B6A     		ldr	r3, [r3, #36]
 3480 175a 03F1A403 		add	r3, r3, #164
 3481 175e 1846     		mov	r0, r3
 3482 1760 FFF7FEFF 		bl	radiotimer_schedule
1637:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3483              		.loc 1 1637 0
 3484 1764 07F10807 		add	r7, r7, #8
 3485 1768 BD46     		mov	sp, r7
 3486 176a 80BD     		pop	{r7, pc}
 3487              		.cfi_endproc
 3488              	.LFE43:
 3490              		.align	2
 3491              		.global	activity_csl_data_rie3
 3492              		.thumb
 3493              		.thumb_func
 3495              	activity_csl_data_rie3:
 3496              	.LFB44:
1638:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1639:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1640:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1641:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling error [data rie3].
1642:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1643:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #rt4 expiring, i.e. timer fires while state = S_CSLRXDATA. This is an error 
1644:openstack/02a-MAClow/IEEE802154Ecsl.c ****   transmit the data packet. The implemented behaviour is to log the error and move on the next CSL 
1645:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1646:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_rie3() {
 3497              		.loc 1 1646 0
 3498              		.cfi_startproc
 3499              		@ args = 0, pretend = 0, frame = 0
 3500              		@ frame_needed = 1, uses_anonymous_args = 0
 3501 176c 80B5     		push	{r7, lr}
 3502              	.LCFI102:
 3503              		.cfi_def_cfa_offset 8
 3504              		.cfi_offset 7, -8
 3505              		.cfi_offset 14, -4
 3506 176e 00AF     		add	r7, sp, #0
 3507              	.LCFI103:
 3508              		.cfi_def_cfa_register 7
1647:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1648:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
1649:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
1650:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state,
 3509              		.loc 1 1650 0
 3510 1770 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3511 1774 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3512 1778 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1649:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
 3513              		.loc 1 1649 0
 3514 177a 1A46     		mov	r2, r3
1651:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_dbg.num_cslSamples);
 3515              		.loc 1 1651 0
 3516 177c 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 3517 1780 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 3518 1784 1B69     		ldr	r3, [r3, #16]
1649:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
 3519              		.loc 1 1649 0
 3520 1786 9BB2     		uxth	r3, r3
 3521 1788 4FF00900 		mov	r0, #9
 3522 178c 4FF02601 		mov	r1, #38
 3523 1790 FFF7FEFF 		bl	openserial_printError
1652:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1653:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1654:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 3524              		.loc 1 1654 0
 3525 1794 FFF7FEFF 		bl	endOps
1655:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3526              		.loc 1 1655 0
 3527 1798 80BD     		pop	{r7, pc}
 3528              		.cfi_endproc
 3529              	.LFE44:
 3531 179a 00BF     		.align	2
 3532              		.global	activity_csl_data_ri5
 3533              		.thumb
 3534              		.thumb_func
 3536              	activity_csl_data_ri5:
 3537              	.LFB45:
1656:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1657:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1658:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri5].
1659:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1660:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_endOfFrame" function when a end of frame event 
1661:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change state, cancel #rt4, validate data frame, and transmit ACK.
1662:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1663:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri5(PORT_RADIOTIMER_WIDTH capturedTime) {
 3538              		.loc 1 1663 0
 3539              		.cfi_startproc
 3540              		@ args = 0, pretend = 0, frame = 80
 3541              		@ frame_needed = 1, uses_anonymous_args = 0
 3542 179c B0B5     		push	{r4, r5, r7, lr}
 3543              	.LCFI104:
 3544              		.cfi_def_cfa_offset 16
 3545              		.cfi_offset 4, -16
 3546              		.cfi_offset 5, -12
 3547              		.cfi_offset 7, -8
 3548              		.cfi_offset 14, -4
 3549 179e 96B0     		sub	sp, sp, #88
 3550              	.LCFI105:
 3551              		.cfi_def_cfa_offset 104
 3552 17a0 02AF     		add	r7, sp, #8
 3553              	.LCFI106:
 3554              		.cfi_def_cfa 7, 96
 3555 17a2 7860     		str	r0, [r7, #4]
1664:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802154_header_iht ieee802514_header;
1665:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint16_t lenIE=0;
 3556              		.loc 1 1665 0
 3557 17a4 4FF00003 		mov	r3, #0
 3558 17a8 FB81     		strh	r3, [r7, #14]	@ movhi
1666:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1667:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1668:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXACKOFFSET);
 3559              		.loc 1 1668 0
 3560 17aa 4FF03600 		mov	r0, #54
 3561 17ae FFF7FEFF 		bl	changeState
1669:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1670:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel rt4
1671:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 3562              		.loc 1 1671 0
 3563 17b2 FFF7FEFF 		bl	radiotimer_cancel
1672:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1673:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // turn off the radio
1674:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rfOff();
 3564              		.loc 1 1674 0
 3565 17b6 FFF7FEFF 		bl	radio_rfOff
1675:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnTics+=radio_getTimerValue()-ieee154e_vars.radioOnInit;
 3566              		.loc 1 1675 0
 3567 17ba 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3568 17be C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3569 17c2 5C6B     		ldr	r4, [r3, #52]
 3570 17c4 FFF7FEFF 		bl	radio_getTimerValue
 3571 17c8 0246     		mov	r2, r0
 3572 17ca 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3573 17ce C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3574 17d2 1B6B     		ldr	r3, [r3, #48]
 3575 17d4 D31A     		subs	r3, r2, r3
 3576 17d6 E218     		adds	r2, r4, r3
 3577 17d8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3578 17dc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3579 17e0 5A63     		str	r2, [r3, #52]
1676:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // get a buffer to put the (received) data in
1677:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.dataReceived = openqueue_getFreePacketBuffer(COMPONENT_IEEE802154E);
 3580              		.loc 1 1677 0
 3581 17e2 4FF00900 		mov	r0, #9
 3582 17e6 FFF7FEFF 		bl	openqueue_getFreePacketBuffer
 3583 17ea 0246     		mov	r2, r0
 3584 17ec 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3585 17f0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3586 17f4 9A61     		str	r2, [r3, #24]
1678:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.dataReceived==NULL) {
 3587              		.loc 1 1678 0
 3588 17f6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3589 17fa C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3590 17fe 9B69     		ldr	r3, [r3, #24]
 3591 1800 002B     		cmp	r3, #0
 3592 1802 0CD1     		bne	.L173
1679:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // log the error
1680:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openserial_printError(COMPONENT_IEEE802154E,ERR_NO_FREE_PACKET_BUFFER,
 3593              		.loc 1 1680 0
 3594 1804 4FF00900 		mov	r0, #9
 3595 1808 4FF02C01 		mov	r1, #44
 3596 180c 4FF00002 		mov	r2, #0
 3597 1810 4FF00003 		mov	r3, #0
 3598 1814 FFF7FEFF 		bl	openserial_printError
1681:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)0,
1682:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)0);
1683:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // abort
1684:openstack/02a-MAClow/IEEE802154Ecsl.c ****       endOps();
 3599              		.loc 1 1684 0
 3600 1818 FFF7FEFF 		bl	endOps
 3601 181c 3FE1     		b	.L172
 3602              	.L173:
1685:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return;
1686:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
1687:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1688:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // declare ownership over that packet
1689:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.dataReceived->creator = COMPONENT_IEEE802154E;
 3603              		.loc 1 1689 0
 3604 181e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3605 1822 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3606 1826 9B69     		ldr	r3, [r3, #24]
 3607 1828 4FF00902 		mov	r2, #9
 3608 182c 1A70     		strb	r2, [r3, #0]
1690:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.dataReceived->owner   = COMPONENT_IEEE802154E;
 3609              		.loc 1 1690 0
 3610 182e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3611 1832 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3612 1836 9B69     		ldr	r3, [r3, #24]
 3613 1838 4FF00902 		mov	r2, #9
 3614 183c 5A70     		strb	r2, [r3, #1]
1691:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1692:openstack/02a-MAClow/IEEE802154Ecsl.c ****    /*
1693:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The do-while loop that follows is a little parsing trick.
1694:openstack/02a-MAClow/IEEE802154Ecsl.c ****    Because it contains a while(0) condition, it gets executed only once.
1695:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The behavior is:
1696:openstack/02a-MAClow/IEEE802154Ecsl.c ****    - if a break occurs inside the do{} body, the error code below the loop
1697:openstack/02a-MAClow/IEEE802154Ecsl.c ****      gets executed. This indicates something is wrong with the packet being
1698:openstack/02a-MAClow/IEEE802154Ecsl.c ****      parsed.
1699:openstack/02a-MAClow/IEEE802154Ecsl.c ****    - if a return occurs inside the do{} body, the error code below the loop
1700:openstack/02a-MAClow/IEEE802154Ecsl.c ****      does not get executed. This indicates the received packet is correct.
1701:openstack/02a-MAClow/IEEE802154Ecsl.c ****    */
1702:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1703:openstack/02a-MAClow/IEEE802154Ecsl.c ****    do { // this "loop" is only executed once
1704:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1705:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // retrieve the received data frame from the radio's Rx buffer
1706:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataReceived->payload = &(ieee154e_vars.dataReceived->packet[FIRST_FRAME_BYTE])
 3615              		.loc 1 1706 0
 3616 183e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3617 1842 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3618 1846 9A69     		ldr	r2, [r3, #24]
 3619 1848 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3620 184c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3621 1850 9B69     		ldr	r3, [r3, #24]
 3622 1852 03F16C03 		add	r3, r3, #108
 3623 1856 5360     		str	r3, [r2, #4]
1707:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.dataReceived->payload,
 3624              		.loc 1 1707 0
 3625 1858 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3626 185c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3627 1860 9B69     		ldr	r3, [r3, #24]
 3628 1862 5968     		ldr	r1, [r3, #4]
1708:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.dataReceived->length,
 3629              		.loc 1 1708 0
 3630 1864 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3631 1868 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3632 186c 9B69     		ldr	r3, [r3, #24]
1707:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.dataReceived->payload,
 3633              		.loc 1 1707 0
 3634 186e 03F10802 		add	r2, r3, #8
1709:openstack/02a-MAClow/IEEE802154Ecsl.c ****                              sizeof(ieee154e_vars.dataReceived->packet),
1710:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.dataReceived->l1_rssi,
 3635              		.loc 1 1710 0
 3636 1872 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3637 1876 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3638 187a 9B69     		ldr	r3, [r3, #24]
1707:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.dataReceived->payload,
 3639              		.loc 1 1707 0
 3640 187c 03F16804 		add	r4, r3, #104
1711:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.dataReceived->l1_lqi,
 3641              		.loc 1 1711 0
 3642 1880 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3643 1884 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3644 1888 9B69     		ldr	r3, [r3, #24]
1707:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.dataReceived->payload,
 3645              		.loc 1 1707 0
 3646 188a 03F16900 		add	r0, r3, #105
1712:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.dataReceived->l1_crc);
 3647              		.loc 1 1712 0
 3648 188e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3649 1892 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3650 1896 9B69     		ldr	r3, [r3, #24]
1707:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.dataReceived->payload,
 3651              		.loc 1 1707 0
 3652 1898 03F16A03 		add	r3, r3, #106
 3653 189c 0090     		str	r0, [sp, #0]
 3654 189e 0193     		str	r3, [sp, #4]
 3655 18a0 0846     		mov	r0, r1
 3656 18a2 1146     		mov	r1, r2
 3657 18a4 4FF08202 		mov	r2, #130
 3658 18a8 2346     		mov	r3, r4
 3659 18aa FFF7FEFF 		bl	radio_getReceivedFrame
1713:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1714:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // break if wrong length
1715:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.dataReceived->length<LENGTH_CRC || ieee154e_vars.dataReceived->length>LENGT
 3660              		.loc 1 1715 0
 3661 18ae 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3662 18b2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3663 18b6 9B69     		ldr	r3, [r3, #24]
 3664 18b8 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 3665 18ba 012B     		cmp	r3, #1
 3666 18bc 07D9     		bls	.L175
 3667              		.loc 1 1715 0 is_stmt 0 discriminator 1
 3668 18be 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3669 18c2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3670 18c6 9B69     		ldr	r3, [r3, #24]
 3671 18c8 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 3672 18ca 802B     		cmp	r3, #128
 3673 18cc 0ED9     		bls	.L176
 3674              	.L175:
1716:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // jump to the error code below this do-while loop
1717:openstack/02a-MAClow/IEEE802154Ecsl.c ****         openserial_printError(COMPONENT_IEEE802154E,ERR_INVALIDPACKETFROMRADIO,
1718:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)2,
1719:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             ieee154e_vars.dataReceived->length);
 3675              		.loc 1 1719 0 is_stmt 1
 3676 18ce 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3677 18d2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3678 18d6 9B69     		ldr	r3, [r3, #24]
 3679 18d8 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
1717:openstack/02a-MAClow/IEEE802154Ecsl.c ****         openserial_printError(COMPONENT_IEEE802154E,ERR_INVALIDPACKETFROMRADIO,
 3680              		.loc 1 1717 0
 3681 18da 4FF00900 		mov	r0, #9
 3682 18de 4FF03701 		mov	r1, #55
 3683 18e2 4FF00202 		mov	r2, #2
 3684 18e6 FFF7FEFF 		bl	openserial_printError
1720:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 3685              		.loc 1 1720 0
 3686 18ea C7E0     		b	.L177
 3687              	.L176:
1721:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1722:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1723:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // toss CRC (2 last bytes)
1724:openstack/02a-MAClow/IEEE802154Ecsl.c ****       packetfunctions_tossFooter(   ieee154e_vars.dataReceived, LENGTH_CRC);
 3688              		.loc 1 1724 0
 3689 18ec 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3690 18f0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3691 18f4 9B69     		ldr	r3, [r3, #24]
 3692 18f6 1846     		mov	r0, r3
 3693 18f8 4FF00201 		mov	r1, #2
 3694 18fc FFF7FEFF 		bl	packetfunctions_tossFooter
1725:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1726:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // if CRC doesn't check, stop
1727:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.dataReceived->l1_crc==FALSE) {
 3695              		.loc 1 1727 0
 3696 1900 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3697 1904 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3698 1908 9B69     		ldr	r3, [r3, #24]
 3699 190a 93F86A30 		ldrb	r3, [r3, #106]	@ zero_extendqisi2
 3700 190e 83F00103 		eor	r3, r3, #1
 3701 1912 DBB2     		uxtb	r3, r3
 3702 1914 002B     		cmp	r3, #0
 3703 1916 40F0AC80 		bne	.L185
 3704              	.L178:
1728:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // jump to the error code below this do-while loop
1729:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
1730:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1731:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1732:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // parse the IEEE802.15.4 header (RX DATA)
1733:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee802154_retrieveHeader(ieee154e_vars.dataReceived,&ieee802514_header);
 3705              		.loc 1 1733 0
 3706 191a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3707 191e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3708 1922 9A69     		ldr	r2, [r3, #24]
 3709 1924 07F11003 		add	r3, r7, #16
 3710 1928 1046     		mov	r0, r2
 3711 192a 1946     		mov	r1, r3
 3712 192c FFF7FEFF 		bl	ieee802154_retrieveHeader
1734:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1735:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // break if invalid IEEE802.15.4 header
1736:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee802514_header.valid==FALSE) {
 3713              		.loc 1 1736 0
 3714 1930 3B7C     		ldrb	r3, [r7, #16]	@ zero_extendqisi2
 3715 1932 83F00103 		eor	r3, r3, #1
 3716 1936 DBB2     		uxtb	r3, r3
 3717 1938 002B     		cmp	r3, #0
 3718 193a 40F09C80 		bne	.L186
 3719              	.L179:
1737:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // break from the do-while loop and execute the clean-up code below
1738:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
1739:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1740:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1741:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // store header details in packet buffer
1742:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataReceived->l2_frameType      = ieee802514_header.frameType;
 3720              		.loc 1 1742 0
 3721 193e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3722 1942 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3723 1946 9B69     		ldr	r3, [r3, #24]
 3724 1948 BA7C     		ldrb	r2, [r7, #18]	@ zero_extendqisi2
 3725 194a 83F84920 		strb	r2, [r3, #73]
1743:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataReceived->l2_dsn            = ieee802514_header.dsn;
 3726              		.loc 1 1743 0
 3727 194e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3728 1952 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3729 1956 9B69     		ldr	r3, [r3, #24]
 3730 1958 7A7E     		ldrb	r2, [r7, #25]	@ zero_extendqisi2
 3731 195a 83F84A20 		strb	r2, [r3, #74]
1744:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataReceived->l2_IEListPresent  = ieee802514_header.ieListPresent;
 3732              		.loc 1 1744 0
 3733 195e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3734 1962 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3735 1966 9B69     		ldr	r3, [r3, #24]
 3736 1968 FA7D     		ldrb	r2, [r7, #23]	@ zero_extendqisi2
 3737 196a 83F86520 		strb	r2, [r3, #101]
1745:openstack/02a-MAClow/IEEE802154Ecsl.c ****       memcpy(&(ieee154e_vars.dataReceived->l2_nextORpreviousHop),&(ieee802514_header.src),sizeof(op
 3738              		.loc 1 1745 0
 3739 196e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3740 1972 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3741 1976 9B69     		ldr	r3, [r3, #24]
 3742 1978 03F13803 		add	r3, r3, #56
 3743 197c 1D46     		mov	r5, r3
 3744 197e 07F13C04 		add	r4, r7, #60
 3745 1982 0FCC     		ldmia	r4!, {r0, r1, r2, r3}
 3746 1984 2860     		str	r0, [r5, #0]	@ unaligned
 3747 1986 6960     		str	r1, [r5, #4]	@ unaligned
 3748 1988 AA60     		str	r2, [r5, #8]	@ unaligned
 3749 198a EB60     		str	r3, [r5, #12]	@ unaligned
 3750 198c 2378     		ldrb	r3, [r4, #0]
 3751 198e 2B74     		strb	r3, [r5, #16]
1746:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1747:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // toss the IEEE802.15.4 header
1748:openstack/02a-MAClow/IEEE802154Ecsl.c ****       packetfunctions_tossHeader(ieee154e_vars.dataReceived,ieee802514_header.headerLength);
 3752              		.loc 1 1748 0
 3753 1990 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3754 1994 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3755 1998 9A69     		ldr	r2, [r3, #24]
 3756 199a 7B7C     		ldrb	r3, [r7, #17]	@ zero_extendqisi2
 3757 199c 1046     		mov	r0, r2
 3758 199e 1946     		mov	r1, r3
 3759 19a0 FFF7FEFF 		bl	packetfunctions_tossHeader
1749:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1750:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // handle IEs xv poipoi
1751:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset join priority
1752:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // retrieve IE in sixtop
1753:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if ((ieee802514_header.valid==TRUE &&
 3760              		.loc 1 1753 0
 3761 19a4 3B7C     		ldrb	r3, [r7, #16]	@ zero_extendqisi2
1754:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header.ieListPresent==TRUE &&
1755:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header.frameType==IEEE154_TYPE_BEACON && // if it is not a beacon and have ie,
1756:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header.panid,idmanager_getMyID(ADDR_PANID)) &&
 3762              		.loc 1 1756 0
 3763 19a6 002B     		cmp	r3, #0
 3764 19a8 22D0     		beq	.L181
1754:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header.ieListPresent==TRUE &&
 3765              		.loc 1 1754 0
 3766 19aa FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
1753:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if ((ieee802514_header.valid==TRUE &&
 3767              		.loc 1 1753 0
 3768 19ac 002B     		cmp	r3, #0
 3769 19ae 1FD0     		beq	.L181
1755:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header.frameType==IEEE154_TYPE_BEACON && // if it is not a beacon and have ie,
 3770              		.loc 1 1755 0
 3771 19b0 BB7C     		ldrb	r3, [r7, #18]	@ zero_extendqisi2
1754:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header.ieListPresent==TRUE &&
 3772              		.loc 1 1754 0
 3773 19b2 002B     		cmp	r3, #0
 3774 19b4 1CD1     		bne	.L181
 3775              		.loc 1 1756 0
 3776 19b6 4FF00400 		mov	r0, #4
 3777 19ba FFF7FEFF 		bl	idmanager_getMyID
 3778 19be 0346     		mov	r3, r0
 3779 19c0 07F11002 		add	r2, r7, #16
 3780 19c4 02F10A02 		add	r2, r2, #10
 3781 19c8 1046     		mov	r0, r2
 3782 19ca 1946     		mov	r1, r3
 3783 19cc FFF7FEFF 		bl	packetfunctions_sameAddress
 3784 19d0 0346     		mov	r3, r0
1755:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header.frameType==IEEE154_TYPE_BEACON && // if it is not a beacon and have ie,
 3785              		.loc 1 1755 0
 3786 19d2 002B     		cmp	r3, #0
 3787 19d4 0CD0     		beq	.L181
1757:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee154e_processIEs(ieee154e_vars.dataReceived,&lenIE))==FALSE) {
 3788              		.loc 1 1757 0
 3789 19d6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3790 19da C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3791 19de 9A69     		ldr	r2, [r3, #24]
 3792 19e0 07F10E03 		add	r3, r7, #14
 3793 19e4 1046     		mov	r0, r2
 3794 19e6 1946     		mov	r1, r3
 3795 19e8 FFF7FEFF 		bl	ieee154e_processIEs
 3796 19ec 0346     		mov	r3, r0
1756:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header.panid,idmanager_getMyID(ADDR_PANID)) &&
 3797              		.loc 1 1756 0
 3798 19ee 002B     		cmp	r3, #0
 3799              	.L181:
1758:openstack/02a-MAClow/IEEE802154Ecsl.c ****           //log  that the packet is not carrying IEs
1759:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1760:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1761:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // toss the IEs including Synch
1762:openstack/02a-MAClow/IEEE802154Ecsl.c ****       packetfunctions_tossHeader(ieee154e_vars.dataReceived,lenIE);
 3800              		.loc 1 1762 0
 3801 19f0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3802 19f4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3803 19f8 9A69     		ldr	r2, [r3, #24]
 3804 19fa FB89     		ldrh	r3, [r7, #14]
 3805 19fc DBB2     		uxtb	r3, r3
 3806 19fe 1046     		mov	r0, r2
 3807 1a00 1946     		mov	r1, r3
 3808 1a02 FFF7FEFF 		bl	packetfunctions_tossHeader
1763:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1764:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // record the captured time
1765:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.lastCapturedTime = capturedTime;
 3809              		.loc 1 1765 0
 3810 1a06 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3811 1a0a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3812 1a0e 7A68     		ldr	r2, [r7, #4]
 3813 1a10 5A62     		str	r2, [r3, #36]
1766:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1767:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // if I just received an invalid frame, stop
1768:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (isValidRxFrame(&ieee802514_header)==FALSE) {
 3814              		.loc 1 1768 0
 3815 1a12 07F11003 		add	r3, r7, #16
 3816 1a16 1846     		mov	r0, r3
 3817 1a18 FFF7FEFF 		bl	isValidRxFrame
 3818 1a1c 0346     		mov	r3, r0
 3819 1a1e 83F00103 		eor	r3, r3, #1
 3820 1a22 DBB2     		uxtb	r3, r3
 3821 1a24 002B     		cmp	r3, #0
 3822 1a26 28D1     		bne	.L187
 3823              	.L182:
1769:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // jump to the error code below this do-while loop
1770:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
1771:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1772:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1773:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // [CSL-TEST]: Force to not send ack packet
1774:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1775:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee802514_header.ackRequested = 0;
 3824              		.loc 1 1775 0
 3825 1a28 4FF00003 		mov	r3, #0
 3826 1a2c 7B75     		strb	r3, [r7, #21]
1776:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1777:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // [CSL-TEST]: end test code
1778:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1779:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // check if ack requested
1780:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee802514_header.ackRequested==1) {
 3827              		.loc 1 1780 0
 3828 1a2e 7B7D     		ldrb	r3, [r7, #21]	@ zero_extendqisi2
 3829 1a30 002B     		cmp	r3, #0
 3830 1a32 0AD0     		beq	.L183
1781:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // arm rt5
1782:openstack/02a-MAClow/IEEE802154Ecsl.c ****          radiotimer_schedule(DURATION_rt5);
 3831              		.loc 1 1782 0
 3832 1a34 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3833 1a38 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3834 1a3c 5B6A     		ldr	r3, [r3, #36]
 3835 1a3e 03F17A03 		add	r3, r3, #122
 3836 1a42 1846     		mov	r0, r3
 3837 1a44 FFF7FEFF 		bl	radiotimer_schedule
 3838 1a48 29E0     		b	.L172
 3839              	.L183:
1783:openstack/02a-MAClow/IEEE802154Ecsl.c ****       } else {
1784:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // synchronize to the received packet if I'm not a DAGroot and this is my preferred parent
1785:openstack/02a-MAClow/IEEE802154Ecsl.c ****          //if (idmanager_getIsDAGroot()==FALSE && neighbors_isPreferredParent(&(ieee154e_vars.dataR
1786:openstack/02a-MAClow/IEEE802154Ecsl.c ****          //   synchronizePacket(ieee154e_vars.syncCapturedTime);
1787:openstack/02a-MAClow/IEEE802154Ecsl.c ****          //}
1788:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // indicate reception to upper layer (no ACK asked)
1789:openstack/02a-MAClow/IEEE802154Ecsl.c ****          notif_receive(ieee154e_vars.dataReceived, 1);
 3840              		.loc 1 1789 0
 3841 1a4a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3842 1a4e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3843 1a52 9B69     		ldr	r3, [r3, #24]
 3844 1a54 1846     		mov	r0, r3
 3845 1a56 4FF00101 		mov	r1, #1
 3846 1a5a FFF7FEFF 		bl	notif_receive
1790:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // reset local variable
1791:openstack/02a-MAClow/IEEE802154Ecsl.c ****          ieee154e_vars.dataReceived = NULL;
 3847              		.loc 1 1791 0
 3848 1a5e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3849 1a62 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3850 1a66 4FF00002 		mov	r2, #0
 3851 1a6a 9A61     		str	r2, [r3, #24]
1792:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // abort
1793:openstack/02a-MAClow/IEEE802154Ecsl.c ****          endOps();
 3852              		.loc 1 1793 0
 3853 1a6c FFF7FEFF 		bl	endOps
 3854 1a70 15E0     		b	.L172
 3855              	.L185:
1729:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 3856              		.loc 1 1729 0
 3857 1a72 00BF     		nop
 3858 1a74 02E0     		b	.L177
 3859              	.L186:
1738:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 3860              		.loc 1 1738 0
 3861 1a76 00BF     		nop
 3862 1a78 00E0     		b	.L177
 3863              	.L187:
1770:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 3864              		.loc 1 1770 0
 3865 1a7a 00BF     		nop
 3866              	.L177:
1794:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1795:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1796:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // everything went well, return here not to execute the error code below
1797:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return;
1798:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1799:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } while(0);
1800:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1801:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // free the (invalid) received data so RAM memory can be recycled
1802:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openqueue_freePacketBuffer(ieee154e_vars.dataReceived);
 3867              		.loc 1 1802 0
 3868 1a7c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3869 1a80 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3870 1a84 9B69     		ldr	r3, [r3, #24]
 3871 1a86 1846     		mov	r0, r3
 3872 1a88 FFF7FEFF 		bl	openqueue_freePacketBuffer
1803:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1804:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clear local variable
1805:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.dataReceived = NULL;
 3873              		.loc 1 1805 0
 3874 1a8c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3875 1a90 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3876 1a94 4FF00002 		mov	r2, #0
 3877 1a98 9A61     		str	r2, [r3, #24]
1806:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1807:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1808:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 3878              		.loc 1 1808 0
 3879 1a9a FFF7FEFF 		bl	endOps
 3880              	.L172:
1809:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3881              		.loc 1 1809 0
 3882 1a9e 07F15007 		add	r7, r7, #80
 3883 1aa2 BD46     		mov	sp, r7
 3884 1aa4 B0BD     		pop	{r4, r5, r7, pc}
 3885              		.cfi_endproc
 3886              	.LFE45:
 3888 1aa6 00BF     		.align	2
 3889              		.global	activity_csl_data_ri6
 3890              		.thumb
 3891              		.thumb_func
 3893              	activity_csl_data_ri6:
 3894              	.LFB46:
1810:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1811:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1812:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri6].
1813:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1814:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1815:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The functionality is to prepare the radio for ACK sending.
1816:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1817:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri6() {
 3895              		.loc 1 1817 0
 3896              		.cfi_startproc
 3897              		@ args = 0, pretend = 0, frame = 8
 3898              		@ frame_needed = 1, uses_anonymous_args = 0
 3899 1aa8 90B5     		push	{r4, r7, lr}
 3900              	.LCFI107:
 3901              		.cfi_def_cfa_offset 12
 3902              		.cfi_offset 4, -12
 3903              		.cfi_offset 7, -8
 3904              		.cfi_offset 14, -4
 3905 1aaa 87B0     		sub	sp, sp, #28
 3906              	.LCFI108:
 3907              		.cfi_def_cfa_offset 40
 3908 1aac 04AF     		add	r7, sp, #16
 3909              	.LCFI109:
 3910              		.cfi_def_cfa 7, 24
1818:openstack/02a-MAClow/IEEE802154Ecsl.c ****    PORT_SIGNED_INT_WIDTH timeCorrection;
1819:openstack/02a-MAClow/IEEE802154Ecsl.c ****    header_IE_ht header_desc;
1820:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1821:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1822:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXACKPREPARE);
 3911              		.loc 1 1822 0
 3912 1aae 4FF03700 		mov	r0, #55
 3913 1ab2 FFF7FEFF 		bl	changeState
1823:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1824:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // get a buffer to put the ack to send in
1825:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend = openqueue_getFreePacketBuffer(COMPONENT_IEEE802154E);
 3914              		.loc 1 1825 0
 3915 1ab6 4FF00900 		mov	r0, #9
 3916 1aba FFF7FEFF 		bl	openqueue_getFreePacketBuffer
 3917 1abe 0246     		mov	r2, r0
 3918 1ac0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3919 1ac4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3920 1ac8 DA61     		str	r2, [r3, #28]
1826:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.ackToSend==NULL) {
 3921              		.loc 1 1826 0
 3922 1aca 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3923 1ace C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3924 1ad2 DB69     		ldr	r3, [r3, #28]
 3925 1ad4 002B     		cmp	r3, #0
 3926 1ad6 1DD1     		bne	.L189
1827:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // log the error
1828:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openserial_printError(COMPONENT_IEEE802154E,ERR_NO_FREE_PACKET_BUFFER, (errorparameter_t)0, (
 3927              		.loc 1 1828 0
 3928 1ad8 4FF00900 		mov	r0, #9
 3929 1adc 4FF02C01 		mov	r1, #44
 3930 1ae0 4FF00002 		mov	r2, #0
 3931 1ae4 4FF00003 		mov	r3, #0
 3932 1ae8 FFF7FEFF 		bl	openserial_printError
1829:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // indicate we received a packet anyway (we don't want to loose any)
1830:openstack/02a-MAClow/IEEE802154Ecsl.c ****       notif_receive(ieee154e_vars.dataReceived,0);
 3933              		.loc 1 1830 0
 3934 1aec 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3935 1af0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3936 1af4 9B69     		ldr	r3, [r3, #24]
 3937 1af6 1846     		mov	r0, r3
 3938 1af8 4FF00001 		mov	r1, #0
 3939 1afc FFF7FEFF 		bl	notif_receive
1831:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // free local variable
1832:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataReceived = NULL;
 3940              		.loc 1 1832 0
 3941 1b00 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3942 1b04 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3943 1b08 4FF00002 		mov	r2, #0
 3944 1b0c 9A61     		str	r2, [r3, #24]
1833:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // abort
1834:openstack/02a-MAClow/IEEE802154Ecsl.c ****       endOps();
 3945              		.loc 1 1834 0
 3946 1b0e FFF7FEFF 		bl	endOps
 3947 1b12 D3E0     		b	.L188
 3948              	.L189:
1835:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return;
1836:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
1837:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1838:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // declare ownership over that packet
1839:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend->creator = COMPONENT_IEEE802154E;
 3949              		.loc 1 1839 0
 3950 1b14 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3951 1b18 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3952 1b1c DB69     		ldr	r3, [r3, #28]
 3953 1b1e 4FF00902 		mov	r2, #9
 3954 1b22 1A70     		strb	r2, [r3, #0]
1840:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend->owner   = COMPONENT_IEEE802154E;
 3955              		.loc 1 1840 0
 3956 1b24 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3957 1b28 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3958 1b2c DB69     		ldr	r3, [r3, #28]
 3959 1b2e 4FF00902 		mov	r2, #9
 3960 1b32 5A70     		strb	r2, [r3, #1]
1841:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1842:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // calculate the time timeCorrection (this is the time when the packet arrive w.r.t the time it 
1843:openstack/02a-MAClow/IEEE802154Ecsl.c ****    timeCorrection = (PORT_SIGNED_INT_WIDTH)((PORT_SIGNED_INT_WIDTH)ieee154e_vars.syncCapturedTime-(
 3961              		.loc 1 1843 0
 3962 1b34 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3963 1b38 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3964 1b3c 9B6A     		ldr	r3, [r3, #40]
 3965 1b3e A3F18303 		sub	r3, r3, #131
 3966 1b42 7B60     		str	r3, [r7, #4]
1844:openstack/02a-MAClow/IEEE802154Ecsl.c ****     
1845:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // add the payload to the ACK (i.e. the timeCorrection)
1846:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packetfunctions_reserveHeaderSize(ieee154e_vars.ackToSend,sizeof(timecorrection_IE_ht));
 3967              		.loc 1 1846 0
 3968 1b44 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3969 1b48 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3970 1b4c DB69     		ldr	r3, [r3, #28]
 3971 1b4e 1846     		mov	r0, r3
 3972 1b50 4FF00201 		mov	r1, #2
 3973 1b54 FFF7FEFF 		bl	packetfunctions_reserveHeaderSize
1847:openstack/02a-MAClow/IEEE802154Ecsl.c ****    timeCorrection  = -timeCorrection;
 3974              		.loc 1 1847 0
 3975 1b58 7B68     		ldr	r3, [r7, #4]
 3976 1b5a C3F10003 		rsb	r3, r3, #0
 3977 1b5e 7B60     		str	r3, [r7, #4]
1848:openstack/02a-MAClow/IEEE802154Ecsl.c ****    timeCorrection *= US_PER_TICK;
 3978              		.loc 1 1848 0
 3979 1b60 7A68     		ldr	r2, [r7, #4]
 3980 1b62 1346     		mov	r3, r2
 3981 1b64 4FEA0313 		lsl	r3, r3, #4
 3982 1b68 9B1A     		subs	r3, r3, r2
 3983 1b6a 4FEA4303 		lsl	r3, r3, #1
 3984 1b6e 7B60     		str	r3, [r7, #4]
1849:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend->payload[0] = (uint8_t)((((uint16_t)timeCorrection)   ) & 0xff);
 3985              		.loc 1 1849 0
 3986 1b70 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3987 1b74 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3988 1b78 DB69     		ldr	r3, [r3, #28]
 3989 1b7a 5B68     		ldr	r3, [r3, #4]
 3990 1b7c 7A68     		ldr	r2, [r7, #4]
 3991 1b7e D2B2     		uxtb	r2, r2
 3992 1b80 1A70     		strb	r2, [r3, #0]
1850:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend->payload[1] = (uint8_t)((((uint16_t)timeCorrection)>>8) & 0xff);
 3993              		.loc 1 1850 0
 3994 1b82 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3995 1b86 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3996 1b8a DB69     		ldr	r3, [r3, #28]
 3997 1b8c 5B68     		ldr	r3, [r3, #4]
 3998 1b8e 03F10103 		add	r3, r3, #1
 3999 1b92 7A68     		ldr	r2, [r7, #4]
 4000 1b94 92B2     		uxth	r2, r2
 4001 1b96 4FEA1222 		lsr	r2, r2, #8
 4002 1b9a 92B2     		uxth	r2, r2
 4003 1b9c D2B2     		uxtb	r2, r2
 4004 1b9e 1A70     		strb	r2, [r3, #0]
1851:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1852:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // add header IE header -- xv poipoi -- pkt is filled in reverse order..
1853:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packetfunctions_reserveHeaderSize(ieee154e_vars.ackToSend,sizeof(header_IE_ht));
 4005              		.loc 1 1853 0
 4006 1ba0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4007 1ba4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4008 1ba8 DB69     		ldr	r3, [r3, #28]
 4009 1baa 1846     		mov	r0, r3
 4010 1bac 4FF00201 		mov	r1, #2
 4011 1bb0 FFF7FEFF 		bl	packetfunctions_reserveHeaderSize
1854:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //create the header for ack IE
1855:openstack/02a-MAClow/IEEE802154Ecsl.c ****    header_desc.length_elementid_type=(sizeof(timecorrection_IE_ht)<< IEEE802154E_DESC_LEN_HEADER_IE
 4012              		.loc 1 1855 0
 4013 1bb4 40F23C43 		movw	r3, #1084
 4014 1bb8 3B80     		strh	r3, [r7, #0]	@ movhi
1856:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                      (IEEE802154E_ACK_NACK_TIMECORRECTION_ELEMENTID << IEEE802154E_
1857:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                      IEEE802154E_DESC_TYPE_SHORT; 
1858:openstack/02a-MAClow/IEEE802154Ecsl.c ****    memcpy(ieee154e_vars.ackToSend->payload,&header_desc,sizeof(header_IE_ht));
 4015              		.loc 1 1858 0
 4016 1bba 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4017 1bbe C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4018 1bc2 DB69     		ldr	r3, [r3, #28]
 4019 1bc4 5B68     		ldr	r3, [r3, #4]
 4020 1bc6 3A46     		mov	r2, r7
 4021 1bc8 1288     		ldrh	r2, [r2, #0]	@ unaligned
 4022 1bca 1A80     		strh	r2, [r3, #0]	@ unaligned
1859:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1860:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // prepend the IEEE802.15.4 header to the ACK
1861:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend->l2_frameType = IEEE154_TYPE_ACK;
 4023              		.loc 1 1861 0
 4024 1bcc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4025 1bd0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4026 1bd4 DB69     		ldr	r3, [r3, #28]
 4027 1bd6 4FF00202 		mov	r2, #2
 4028 1bda 83F84920 		strb	r2, [r3, #73]
1862:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend->l2_dsn       = ieee154e_vars.dataReceived->l2_dsn;
 4029              		.loc 1 1862 0
 4030 1bde 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4031 1be2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4032 1be6 DA69     		ldr	r2, [r3, #28]
 4033 1be8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4034 1bec C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4035 1bf0 9B69     		ldr	r3, [r3, #24]
 4036 1bf2 93F84A30 		ldrb	r3, [r3, #74]	@ zero_extendqisi2
 4037 1bf6 82F84A30 		strb	r3, [r2, #74]
1863:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802154_prependHeader(ieee154e_vars.ackToSend,
 4038              		.loc 1 1863 0
 4039 1bfa 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4040 1bfe C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4041 1c02 D969     		ldr	r1, [r3, #28]
1864:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             ieee154e_vars.ackToSend->l2_frameType,
 4042              		.loc 1 1864 0
 4043 1c04 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4044 1c08 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4045 1c0c DB69     		ldr	r3, [r3, #28]
1863:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802154_prependHeader(ieee154e_vars.ackToSend,
 4046              		.loc 1 1863 0
 4047 1c0e 93F84920 		ldrb	r2, [r3, #73]	@ zero_extendqisi2
1865:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             IEEE154_IELIST_YES,//ie in ack
1866:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             IEEE154_FRAMEVERSION,//enhanced ack
1867:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             IEEE154_SEC_NO_SECURITY,
1868:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             ieee154e_vars.dataReceived->l2_dsn,
 4048              		.loc 1 1868 0
 4049 1c12 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4050 1c16 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4051 1c1a 9B69     		ldr	r3, [r3, #24]
1863:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802154_prependHeader(ieee154e_vars.ackToSend,
 4052              		.loc 1 1863 0
 4053 1c1c 93F84A00 		ldrb	r0, [r3, #74]	@ zero_extendqisi2
1869:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             &(ieee154e_vars.dataReceived->l2_nextORpreviousHop)
 4054              		.loc 1 1869 0
 4055 1c20 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4056 1c24 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4057 1c28 9B69     		ldr	r3, [r3, #24]
1863:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802154_prependHeader(ieee154e_vars.ackToSend,
 4058              		.loc 1 1863 0
 4059 1c2a 03F13803 		add	r3, r3, #56
 4060 1c2e 4FF00004 		mov	r4, #0
 4061 1c32 0094     		str	r4, [sp, #0]
 4062 1c34 0190     		str	r0, [sp, #4]
 4063 1c36 0293     		str	r3, [sp, #8]
 4064 1c38 0846     		mov	r0, r1
 4065 1c3a 1146     		mov	r1, r2
 4066 1c3c 4FF00102 		mov	r2, #1
 4067 1c40 4FF00203 		mov	r3, #2
 4068 1c44 FFF7FEFF 		bl	ieee802154_prependHeader
1870:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             );
1871:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1872:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // space for 2-byte CRC
1873:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packetfunctions_reserveFooterSize(ieee154e_vars.ackToSend,2);
 4069              		.loc 1 1873 0
 4070 1c48 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4071 1c4c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4072 1c50 DB69     		ldr	r3, [r3, #28]
 4073 1c52 1846     		mov	r0, r3
 4074 1c54 4FF00201 		mov	r1, #2
 4075 1c58 FFF7FEFF 		bl	packetfunctions_reserveFooterSize
1874:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1875:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // load the packet in the radio's Tx buffer
1876:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_loadPacket(ieee154e_vars.ackToSend->payload,
 4076              		.loc 1 1876 0
 4077 1c5c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4078 1c60 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4079 1c64 DB69     		ldr	r3, [r3, #28]
 4080 1c66 5A68     		ldr	r2, [r3, #4]
1877:openstack/02a-MAClow/IEEE802154Ecsl.c ****                     ieee154e_vars.ackToSend->length);
 4081              		.loc 1 1877 0
 4082 1c68 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4083 1c6c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4084 1c70 DB69     		ldr	r3, [r3, #28]
1876:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_loadPacket(ieee154e_vars.ackToSend->payload,
 4085              		.loc 1 1876 0
 4086 1c72 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4087 1c74 1046     		mov	r0, r2
 4088 1c76 1946     		mov	r1, r3
 4089 1c78 FFF7FEFF 		bl	radio_loadPacket
1878:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1879:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // enable the radio in Tx mode. This does not send that packet.
1880:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_txEnable();
 4090              		.loc 1 1880 0
 4091 1c7c FFF7FEFF 		bl	radio_txEnable
1881:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnInit=radio_getTimerValue();
 4092              		.loc 1 1881 0
 4093 1c80 FFF7FEFF 		bl	radio_getTimerValue
 4094 1c84 0246     		mov	r2, r0
 4095 1c86 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4096 1c8a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4097 1c8e 1A63     		str	r2, [r3, #48]
1882:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnThisSlot=TRUE;
 4098              		.loc 1 1882 0
 4099 1c90 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4100 1c94 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4101 1c98 4FF00102 		mov	r2, #1
 4102 1c9c 83F83820 		strb	r2, [r3, #56]
1883:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt6
1884:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt6);
 4103              		.loc 1 1884 0
 4104 1ca0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4105 1ca4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4106 1ca8 5B6A     		ldr	r3, [r3, #36]
 4107 1caa 03F19003 		add	r3, r3, #144
 4108 1cae 1846     		mov	r0, r3
 4109 1cb0 FFF7FEFF 		bl	radiotimer_schedule
1885:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1886:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1887:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXACKREADY);
 4110              		.loc 1 1887 0
 4111 1cb4 4FF03800 		mov	r0, #56
 4112 1cb8 FFF7FEFF 		bl	changeState
 4113              	.L188:
1888:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4114              		.loc 1 1888 0
 4115 1cbc 07F10C07 		add	r7, r7, #12
 4116 1cc0 BD46     		mov	sp, r7
 4117 1cc2 90BD     		pop	{r4, r7, pc}
 4118              		.cfi_endproc
 4119              	.LFE46:
 4121              		.align	2
 4122              		.global	activity_csl_data_rie4
 4123              		.thumb
 4124              		.thumb_func
 4126              	activity_csl_data_rie4:
 4127              	.LFB47:
1889:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1890:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1891:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data rie4].
1892:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1893:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1894:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The functionality is to prepare the radio for ACK sending.
1895:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1896:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_rie4() {
 4128              		.loc 1 1896 0
 4129              		.cfi_startproc
 4130              		@ args = 0, pretend = 0, frame = 0
 4131              		@ frame_needed = 1, uses_anonymous_args = 0
 4132 1cc4 80B5     		push	{r7, lr}
 4133              	.LCFI110:
 4134              		.cfi_def_cfa_offset 8
 4135              		.cfi_offset 7, -8
 4136              		.cfi_offset 14, -4
 4137 1cc6 00AF     		add	r7, sp, #0
 4138              	.LCFI111:
 4139              		.cfi_def_cfa_register 7
1897:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
1898:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXACKPREPARE_OVERFLOWS,
1899:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		                 (errorparameter_t)ieee154e_vars.state,
 4140              		.loc 1 1899 0
 4141 1cc8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4142 1ccc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4143 1cd0 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1898:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXACKPREPARE_OVERFLOWS,
 4144              		.loc 1 1898 0
 4145 1cd2 1A46     		mov	r2, r3
1900:openstack/02a-MAClow/IEEE802154Ecsl.c **** 						 (errorparameter_t)ieee154e_dbg.num_cslSamples);
 4146              		.loc 1 1900 0
 4147 1cd4 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 4148 1cd8 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 4149 1cdc 1B69     		ldr	r3, [r3, #16]
1898:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXACKPREPARE_OVERFLOWS,
 4150              		.loc 1 1898 0
 4151 1cde 9BB2     		uxth	r3, r3
 4152 1ce0 4FF00900 		mov	r0, #9
 4153 1ce4 4FF02501 		mov	r1, #37
 4154 1ce8 FFF7FEFF 		bl	openserial_printError
1901:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1902:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1903:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 4155              		.loc 1 1903 0
 4156 1cec FFF7FEFF 		bl	endOps
1904:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4157              		.loc 1 1904 0
 4158 1cf0 80BD     		pop	{r7, pc}
 4159              		.cfi_endproc
 4160              	.LFE47:
 4162 1cf2 00BF     		.align	2
 4163              		.global	activity_csl_data_ri7
 4164              		.thumb
 4165              		.thumb_func
 4167              	activity_csl_data_ri7:
 4168              	.LFB48:
1905:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1906:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1907:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri7].
1908:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1909:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1910:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The radio is configured and this interrupt gives it the "go" signal to start listening.
1911:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1912:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri7() {
 4169              		.loc 1 1912 0
 4170              		.cfi_startproc
 4171              		@ args = 0, pretend = 0, frame = 0
 4172              		@ frame_needed = 1, uses_anonymous_args = 0
 4173 1cf4 80B5     		push	{r7, lr}
 4174              	.LCFI112:
 4175              		.cfi_def_cfa_offset 8
 4176              		.cfi_offset 7, -8
 4177              		.cfi_offset 14, -4
 4178 1cf6 00AF     		add	r7, sp, #0
 4179              	.LCFI113:
 4180              		.cfi_def_cfa_register 7
1913:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1914:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXACKDELAY);
 4181              		.loc 1 1914 0
 4182 1cf8 4FF03900 		mov	r0, #57
 4183 1cfc FFF7FEFF 		bl	changeState
1915:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1916:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt7
1917:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt7);
 4184              		.loc 1 1917 0
 4185 1d00 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4186 1d04 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4187 1d08 5B6A     		ldr	r3, [r3, #36]
 4188 1d0a 03F1B103 		add	r3, r3, #177
 4189 1d0e 1846     		mov	r0, r3
 4190 1d10 FFF7FEFF 		bl	radiotimer_schedule
1918:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1919:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // give the 'go' to transmit
1920:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_txNow(); 
 4191              		.loc 1 1920 0
 4192 1d14 FFF7FEFF 		bl	radio_txNow
1921:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4193              		.loc 1 1921 0
 4194 1d18 80BD     		pop	{r7, pc}
 4195              		.cfi_endproc
 4196              	.LFE48:
 4198 1d1a 00BF     		.align	2
 4199              		.global	activity_csl_data_rie5
 4200              		.thumb
 4201              		.thumb_func
 4203              	activity_csl_data_rie5:
 4204              	.LFB49:
1922:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1923:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1924:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data rie5].
1925:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1926:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1927:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The functionality is to prepare the radio for ACK sending.
1928:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1929:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_rie5() {
 4205              		.loc 1 1929 0
 4206              		.cfi_startproc
 4207              		@ args = 0, pretend = 0, frame = 0
 4208              		@ frame_needed = 1, uses_anonymous_args = 0
 4209 1d1c 80B5     		push	{r7, lr}
 4210              	.LCFI114:
 4211              		.cfi_def_cfa_offset 8
 4212              		.cfi_offset 7, -8
 4213              		.cfi_offset 14, -4
 4214 1d1e 00AF     		add	r7, sp, #0
 4215              	.LCFI115:
 4216              		.cfi_def_cfa_register 7
1930:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
1931:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIOTX_OVERFLOWS,
1932:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state,
 4217              		.loc 1 1932 0
 4218 1d20 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4219 1d24 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4220 1d28 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1931:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIOTX_OVERFLOWS,
 4221              		.loc 1 1931 0
 4222 1d2a 1A46     		mov	r2, r3
1933:openstack/02a-MAClow/IEEE802154Ecsl.c **** 						 (errorparameter_t)ieee154e_dbg.num_cslSamples);
 4223              		.loc 1 1933 0
 4224 1d2c 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 4225 1d30 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 4226 1d34 1B69     		ldr	r3, [r3, #16]
1931:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIOTX_OVERFLOWS,
 4227              		.loc 1 1931 0
 4228 1d36 9BB2     		uxth	r3, r3
 4229 1d38 4FF00900 		mov	r0, #9
 4230 1d3c 4FF02801 		mov	r1, #40
 4231 1d40 FFF7FEFF 		bl	openserial_printError
1934:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1935:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 4232              		.loc 1 1935 0
 4233 1d44 FFF7FEFF 		bl	endOps
1936:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4234              		.loc 1 1936 0
 4235 1d48 80BD     		pop	{r7, pc}
 4236              		.cfi_endproc
 4237              	.LFE49:
 4239 1d4a 00BF     		.align	2
 4240              		.global	activity_csl_data_ri8
 4241              		.thumb
 4242              		.thumb_func
 4244              	activity_csl_data_ri8:
 4245              	.LFB50:
1937:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1938:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1939:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri8].
1940:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1941:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_startOfFrame" function when a start of frame ev
1942:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change the state to set transmission, cancel #rt7 and arm #rt8 (max time 
1943:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1944:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri8(PORT_RADIOTIMER_WIDTH capturedTime) {
 4246              		.loc 1 1944 0
 4247              		.cfi_startproc
 4248              		@ args = 0, pretend = 0, frame = 8
 4249              		@ frame_needed = 1, uses_anonymous_args = 0
 4250 1d4c 80B5     		push	{r7, lr}
 4251              	.LCFI116:
 4252              		.cfi_def_cfa_offset 8
 4253              		.cfi_offset 7, -8
 4254              		.cfi_offset 14, -4
 4255 1d4e 82B0     		sub	sp, sp, #8
 4256              	.LCFI117:
 4257              		.cfi_def_cfa_offset 16
 4258 1d50 00AF     		add	r7, sp, #0
 4259              	.LCFI118:
 4260              		.cfi_def_cfa_register 7
 4261 1d52 7860     		str	r0, [r7, #4]
1945:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1946:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXACK);
 4262              		.loc 1 1946 0
 4263 1d54 4FF03A00 		mov	r0, #58
 4264 1d58 FFF7FEFF 		bl	changeState
1947:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1948:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel rt7
1949:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 4265              		.loc 1 1949 0
 4266 1d5c FFF7FEFF 		bl	radiotimer_cancel
1950:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1951:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
1952:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.lastCapturedTime = capturedTime;
 4267              		.loc 1 1952 0
 4268 1d60 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4269 1d64 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4270 1d68 7A68     		ldr	r2, [r7, #4]
 4271 1d6a 5A62     		str	r2, [r3, #36]
1953:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1954:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt8
1955:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt8);
 4272              		.loc 1 1955 0
 4273 1d6c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4274 1d70 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4275 1d74 5B6A     		ldr	r3, [r3, #36]
 4276 1d76 03F16203 		add	r3, r3, #98
 4277 1d7a 1846     		mov	r0, r3
 4278 1d7c FFF7FEFF 		bl	radiotimer_schedule
1956:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4279              		.loc 1 1956 0
 4280 1d80 07F10807 		add	r7, r7, #8
 4281 1d84 BD46     		mov	sp, r7
 4282 1d86 80BD     		pop	{r7, pc}
 4283              		.cfi_endproc
 4284              	.LFE50:
 4286              		.align	2
 4287              		.global	activity_csl_data_rie6
 4288              		.thumb
 4289              		.thumb_func
 4291              	activity_csl_data_rie6:
 4292              	.LFB51:
1957:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1958:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1959:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data rie6].
1960:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1961:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1962:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to register an error when timer for sent ACK has expired.
1963:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1964:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_rie6() {
 4293              		.loc 1 1964 0
 4294              		.cfi_startproc
 4295              		@ args = 0, pretend = 0, frame = 0
 4296              		@ frame_needed = 1, uses_anonymous_args = 0
 4297 1d88 80B5     		push	{r7, lr}
 4298              	.LCFI119:
 4299              		.cfi_def_cfa_offset 8
 4300              		.cfi_offset 7, -8
 4301              		.cfi_offset 14, -4
 4302 1d8a 00AF     		add	r7, sp, #0
 4303              	.LCFI120:
 4304              		.cfi_def_cfa_register 7
1965:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
1966:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDACKDURATION_OVERFLOWS,
1967:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state,
 4305              		.loc 1 1967 0
 4306 1d8c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4307 1d90 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4308 1d94 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1966:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDACKDURATION_OVERFLOWS,
 4309              		.loc 1 1966 0
 4310 1d96 1A46     		mov	r2, r3
1968:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_dbg.num_cslSamples);
 4311              		.loc 1 1968 0
 4312 1d98 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 4313 1d9c C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 4314 1da0 1B69     		ldr	r3, [r3, #16]
1966:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDACKDURATION_OVERFLOWS,
 4315              		.loc 1 1966 0
 4316 1da2 9BB2     		uxth	r3, r3
 4317 1da4 4FF00900 		mov	r0, #9
 4318 1da8 4FF02901 		mov	r1, #41
 4319 1dac FFF7FEFF 		bl	openserial_printError
1969:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1970:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 4320              		.loc 1 1970 0
 4321 1db0 FFF7FEFF 		bl	endOps
1971:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4322              		.loc 1 1971 0
 4323 1db4 80BD     		pop	{r7, pc}
 4324              		.cfi_endproc
 4325              	.LFE51:
 4327 1db6 00BF     		.align	2
 4328              		.global	activity_csl_data_ri9
 4329              		.thumb
 4330              		.thumb_func
 4332              	activity_csl_data_ri9:
 4333              	.LFB52:
1972:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1973:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1974:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri9].
1975:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1976:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_endOfFrame" function when a end of frame event 
1977:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change the state, cancel #rt8, free ack packet and notify upper layer.
1978:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1979:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri9(PORT_RADIOTIMER_WIDTH capturedTime) {
 4334              		.loc 1 1979 0
 4335              		.cfi_startproc
 4336              		@ args = 0, pretend = 0, frame = 8
 4337              		@ frame_needed = 1, uses_anonymous_args = 0
 4338 1db8 80B5     		push	{r7, lr}
 4339              	.LCFI121:
 4340              		.cfi_def_cfa_offset 8
 4341              		.cfi_offset 7, -8
 4342              		.cfi_offset 14, -4
 4343 1dba 82B0     		sub	sp, sp, #8
 4344              	.LCFI122:
 4345              		.cfi_def_cfa_offset 16
 4346 1dbc 00AF     		add	r7, sp, #0
 4347              	.LCFI123:
 4348              		.cfi_def_cfa_register 7
 4349 1dbe 7860     		str	r0, [r7, #4]
1980:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1981:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXPROC);
 4350              		.loc 1 1981 0
 4351 1dc0 4FF03B00 		mov	r0, #59
 4352 1dc4 FFF7FEFF 		bl	changeState
1982:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1983:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel rt8
1984:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 4353              		.loc 1 1984 0
 4354 1dc8 FFF7FEFF 		bl	radiotimer_cancel
1985:openstack/02a-MAClow/IEEE802154Ecsl.c ****   
1986:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
1987:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.lastCapturedTime = capturedTime;
 4355              		.loc 1 1987 0
 4356 1dcc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4357 1dd0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4358 1dd4 7A68     		ldr	r2, [r7, #4]
 4359 1dd6 5A62     		str	r2, [r3, #36]
1988:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1989:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // free the ack we just sent so corresponding RAM memory can be recycled
1990:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openqueue_freePacketBuffer(ieee154e_vars.ackToSend);
 4360              		.loc 1 1990 0
 4361 1dd8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4362 1ddc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4363 1de0 DB69     		ldr	r3, [r3, #28]
 4364 1de2 1846     		mov	r0, r3
 4365 1de4 FFF7FEFF 		bl	openqueue_freePacketBuffer
1991:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1992:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clear local variable
1993:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend = NULL;
 4366              		.loc 1 1993 0
 4367 1de8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4368 1dec C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4369 1df0 4FF00002 		mov	r2, #0
 4370 1df4 DA61     		str	r2, [r3, #28]
1994:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1995:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // synchronize to the received packet
1996:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //if (idmanager_getIsDAGroot()==FALSE && neighbors_isPreferredParent(&(ieee154e_vars.dataReceive
1997:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   synchronizePacket(ieee154e_vars.syncCapturedTime);
1998:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //}
1999:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
2000:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // inform upper layer of reception (after ACK sent)
2001:openstack/02a-MAClow/IEEE802154Ecsl.c ****    notif_receive(ieee154e_vars.dataReceived,1);
 4371              		.loc 1 2001 0
 4372 1df6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4373 1dfa C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4374 1dfe 9B69     		ldr	r3, [r3, #24]
 4375 1e00 1846     		mov	r0, r3
 4376 1e02 4FF00101 		mov	r1, #1
 4377 1e06 FFF7FEFF 		bl	notif_receive
2002:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
2003:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clear local variable
2004:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.dataReceived = NULL;
 4378              		.loc 1 2004 0
 4379 1e0a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4380 1e0e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4381 1e12 4FF00002 		mov	r2, #0
 4382 1e16 9A61     		str	r2, [r3, #24]
2005:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
2006:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // official end of Rx slot
2007:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 4383              		.loc 1 2007 0
 4384 1e18 FFF7FEFF 		bl	endOps
2008:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4385              		.loc 1 2008 0
 4386 1e1c 07F10807 		add	r7, r7, #8
 4387 1e20 BD46     		mov	sp, r7
 4388 1e22 80BD     		pop	{r7, pc}
 4389              		.cfi_endproc
 4390              	.LFE52:
 4392              		.align	2
 4393              		.global	ieee802154_createWakeUpFrame
 4394              		.thumb
 4395              		.thumb_func
 4397              	ieee802154_createWakeUpFrame:
 4398              	.LFB53:
2009:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2010:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2011:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2012:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================= WAKE-UP FRAMES ===============================
2013:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2014:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2015:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2016:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Prepend the IEEE802.15.4 MAC Wake-Up header to a (to be transmitted) packet.
2017:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2018:openstack/02a-MAClow/IEEE802154Ecsl.c **** Note that we are writing the field from the end of the header to the beginning.
2019:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2020:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in,out] msg              The message to append the header to.
2021:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in]     sequenceNumber   Sequence number of this frame.
2022:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in]     nextHop          Address of the next hop
2023:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in]     rztime           Rendezvoud time
2024:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2025:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2026:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CSL]: Prepend  a wake-up header to a packet.
2027:openstack/02a-MAClow/IEEE802154Ecsl.c **** void ieee802154_createWakeUpFrame(OpenQueueEntry_t*		msg,
2028:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                   uint8_t           	sequenceNumber,
2029:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                   open_addr_t*        	nextHop,
2030:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							      uint16_t				rz_time) {
 4399              		.loc 1 2030 0
 4400              		.cfi_startproc
 4401              		@ args = 0, pretend = 0, frame = 40
 4402              		@ frame_needed = 1, uses_anonymous_args = 0
 4403 1e24 80B5     		push	{r7, lr}
 4404              	.LCFI124:
 4405              		.cfi_def_cfa_offset 8
 4406              		.cfi_offset 7, -8
 4407              		.cfi_offset 14, -4
 4408 1e26 8AB0     		sub	sp, sp, #40
 4409              	.LCFI125:
 4410              		.cfi_def_cfa_offset 48
 4411 1e28 00AF     		add	r7, sp, #0
 4412              	.LCFI126:
 4413              		.cfi_def_cfa_register 7
 4414 1e2a F860     		str	r0, [r7, #12]
 4415 1e2c 7A60     		str	r2, [r7, #4]
 4416 1e2e 0A46     		mov	r2, r1
 4417 1e30 FA72     		strb	r2, [r7, #11]
 4418 1e32 3B81     		strh	r3, [r7, #8]	@ movhi
2031:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2032:openstack/02a-MAClow/IEEE802154Ecsl.c ****     open_addr_t	nextHop16b;
2033:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2034:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// La estructura de una trama Wake-Up es la siguiente:
2035:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//
2036:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   - FRAME CONTROL: 1 byte
2037:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   - SEQ NUMBER (macDSN): 1 byte
2038:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   - PAN ID: 2 bytes
2039:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   - DEST ADDR: 2 bytes
2040:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   - RZ TIME IE: 2 bytes (header) + 2 bytes (body)
2041:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   - IE LIST TERMINATOR: 2 bytes
2042:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//
2043:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//  | FRAME   |  SEQ   | PAN | DEST | RZ TIME  | IE LIST    |
2044:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//  | CONTROL | NUMBER |  ID | ADDR |  HDR IE  | TERMINATOR |
2045:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//
2046:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2047:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// Empezamos a escribir el payload de la trama wake-up empezando del final hacia adelante.
2048:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2049:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// IE LIST TERMINATOR, formado por 2 bytes con la siguiente estructura (0x3F80 o 0x3F00)
2050:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  - b0-b6 (Length) = 0
2051:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  - b7-b14 (Element ID) = 0x7e o 0x7f
2052:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  - b15 (Type) = 0
2053:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //
2054:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  b15 | b14 | b13 | b12 | b11 | b10 | b9 | b8 | b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 |
2055:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //   0  |  0  |  1  |  1  |  1  |  1  | 1  | 1  |  0 |  0 |  0 |  0 |  0 |  0 |  0 |  0 |
2056:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	packetfunctions_reserveHeaderSize(msg,sizeof(uint16_t));
 4419              		.loc 1 2056 0
 4420 1e34 F868     		ldr	r0, [r7, #12]
 4421 1e36 4FF00201 		mov	r1, #2
 4422 1e3a FFF7FEFF 		bl	packetfunctions_reserveHeaderSize
2057:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	*((uint16_t*)(msg->payload)) = 0x3F00;  // Element ID = 0x7e
 4423              		.loc 1 2057 0
 4424 1e3e FB68     		ldr	r3, [r7, #12]
 4425 1e40 5B68     		ldr	r3, [r3, #4]
 4426 1e42 4FF47C52 		mov	r2, #16128
 4427 1e46 1A80     		strh	r2, [r3, #0]	@ movhi
2058:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2059:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// RZ TIME IE, formado por 4 bytes con la siguiente estructura (0x0E82). La cabecera es igual a:
2060:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  - b0-b6 (Length) = 2
2061:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  - b7-b14 (Element ID) = 0x1D
2062:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  - b15 (Type) = 0
2063:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  - b16-b31 (IE Content) = time (2 bytes)
2064:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //
2065:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  b15 | b14 | b13 | b12 | b11 | b10 | b9 | b8 | b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 |
2066:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //   0  |  0  |  0  |  0  |  1  |  1  |  1 |  0 |  1 |  0 |  0 |  0 |  0 |  0 |  1 |  0 |
2067:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2068:openstack/02a-MAClow/IEEE802154Ecsl.c ****  	// rz time ie body (time)
2069:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	packetfunctions_reserveHeaderSize(msg,sizeof(uint16_t));
 4428              		.loc 1 2069 0
 4429 1e48 F868     		ldr	r0, [r7, #12]
 4430 1e4a 4FF00201 		mov	r1, #2
 4431 1e4e FFF7FEFF 		bl	packetfunctions_reserveHeaderSize
2070:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	*((uint16_t*)(msg->payload)) = rz_time;
 4432              		.loc 1 2070 0
 4433 1e52 FB68     		ldr	r3, [r7, #12]
 4434 1e54 5B68     		ldr	r3, [r3, #4]
 4435 1e56 3A89     		ldrh	r2, [r7, #8]	@ movhi
 4436 1e58 1A80     		strh	r2, [r3, #0]	@ movhi
2071:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2072:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// rz time ie header
2073:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	packetfunctions_reserveHeaderSize(msg,sizeof(uint16_t));
 4437              		.loc 1 2073 0
 4438 1e5a F868     		ldr	r0, [r7, #12]
 4439 1e5c 4FF00201 		mov	r1, #2
 4440 1e60 FFF7FEFF 		bl	packetfunctions_reserveHeaderSize
2074:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	*((uint16_t*)(msg->payload)) = 0x0E82;
 4441              		.loc 1 2074 0
 4442 1e64 FB68     		ldr	r3, [r7, #12]
 4443 1e66 5B68     		ldr	r3, [r3, #4]
 4444 1e68 40F68262 		movw	r2, #3714
 4445 1e6c 1A80     		strh	r2, [r3, #0]	@ movhi
2075:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2076:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// DEST ADDR
2077:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	if (nextHop->type == ADDR_16B) {
 4446              		.loc 1 2077 0
 4447 1e6e 7B68     		ldr	r3, [r7, #4]
 4448 1e70 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 4449 1e72 012B     		cmp	r3, #1
 4450 1e74 06D1     		bne	.L198
2078:openstack/02a-MAClow/IEEE802154Ecsl.c ****   	   packetfunctions_writeAddress(msg,nextHop,OW_LITTLE_ENDIAN);
 4451              		.loc 1 2078 0
 4452 1e76 F868     		ldr	r0, [r7, #12]
 4453 1e78 7968     		ldr	r1, [r7, #4]
 4454 1e7a 4FF00102 		mov	r2, #1
 4455 1e7e FFF7FEFF 		bl	packetfunctions_writeAddress
 4456 1e82 11E0     		b	.L199
 4457              	.L198:
2079:openstack/02a-MAClow/IEEE802154Ecsl.c ****     } else if (nextHop->type == ADDR_64B) {
 4458              		.loc 1 2079 0
 4459 1e84 7B68     		ldr	r3, [r7, #4]
 4460 1e86 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 4461 1e88 022B     		cmp	r3, #2
 4462 1e8a 0DD1     		bne	.L199
2080:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   packetfunctions_mac64bToMac16b(nextHop, &nextHop16b);
 4463              		.loc 1 2080 0
 4464 1e8c 07F11403 		add	r3, r7, #20
 4465 1e90 7868     		ldr	r0, [r7, #4]
 4466 1e92 1946     		mov	r1, r3
 4467 1e94 FFF7FEFF 		bl	packetfunctions_mac64bToMac16b
2081:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   packetfunctions_writeAddress(msg,&nextHop16b,OW_LITTLE_ENDIAN);
 4468              		.loc 1 2081 0
 4469 1e98 07F11403 		add	r3, r7, #20
 4470 1e9c F868     		ldr	r0, [r7, #12]
 4471 1e9e 1946     		mov	r1, r3
 4472 1ea0 4FF00102 		mov	r2, #1
 4473 1ea4 FFF7FEFF 		bl	packetfunctions_writeAddress
 4474              	.L199:
2082:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	}
2083:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2084:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// PAN ID
2085:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	packetfunctions_writeAddress(msg,idmanager_getMyID(ADDR_PANID),OW_LITTLE_ENDIAN);
 4475              		.loc 1 2085 0
 4476 1ea8 4FF00400 		mov	r0, #4
 4477 1eac FFF7FEFF 		bl	idmanager_getMyID
 4478 1eb0 0346     		mov	r3, r0
 4479 1eb2 F868     		ldr	r0, [r7, #12]
 4480 1eb4 1946     		mov	r1, r3
 4481 1eb6 4FF00102 		mov	r2, #1
 4482 1eba FFF7FEFF 		bl	packetfunctions_writeAddress
2086:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2087:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// SEQ NUMBER
2088:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	packetfunctions_reserveHeaderSize(msg,sizeof(uint8_t));
 4483              		.loc 1 2088 0
 4484 1ebe F868     		ldr	r0, [r7, #12]
 4485 1ec0 4FF00101 		mov	r1, #1
 4486 1ec4 FFF7FEFF 		bl	packetfunctions_reserveHeaderSize
2089:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	*((uint8_t*)(msg->payload)) = sequenceNumber;
 4487              		.loc 1 2089 0
 4488 1ec8 FB68     		ldr	r3, [r7, #12]
 4489 1eca 5B68     		ldr	r3, [r3, #4]
 4490 1ecc FA7A     		ldrb	r2, [r7, #11]
 4491 1ece 1A70     		strb	r2, [r3, #0]
2090:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2091:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// La estructura del FCF en la trama de wake-up es 0x55 = 01010101b:
2092:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// b0-b2 -- Frame Type (debe ser 101 para trama wake-up)
2093:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// b3 ----- Long Frame Control (debe ser 0 para indicar que se trata de un FCF de 1 byte como es e
2094:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// b4-b5 -- Dest Addr Mode (en este caso, short address por lo que tiene que valer 10).
2095:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// b6-b7 -- Src Addr Mode (en este caso, short address por lo que tiene que valer 10).
2096:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2097:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//  b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 |
2098:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   0 |  1 |  0 |  1 |  0 |  1 |  0 |  1 |
2099:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2100:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// FCF
2101:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	packetfunctions_reserveHeaderSize(msg,sizeof(uint8_t));
 4492              		.loc 1 2101 0
 4493 1ed0 F868     		ldr	r0, [r7, #12]
 4494 1ed2 4FF00101 		mov	r1, #1
 4495 1ed6 FFF7FEFF 		bl	packetfunctions_reserveHeaderSize
2102:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	*((uint8_t*)(msg->payload)) = 0x55;
 4496              		.loc 1 2102 0
 4497 1eda FB68     		ldr	r3, [r7, #12]
 4498 1edc 5B68     		ldr	r3, [r3, #4]
 4499 1ede 4FF05502 		mov	r2, #85
 4500 1ee2 1A70     		strb	r2, [r3, #0]
2103:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2104:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4501              		.loc 1 2104 0
 4502 1ee4 07F12807 		add	r7, r7, #40
 4503 1ee8 BD46     		mov	sp, r7
 4504 1eea 80BD     		pop	{r7, pc}
 4505              		.cfi_endproc
 4506              	.LFE53:
 4508              		.align	2
 4509              		.global	ieee802154_retrieveWakeUpFrame
 4510              		.thumb
 4511              		.thumb_func
 4513              	ieee802154_retrieveWakeUpFrame:
 4514              	.LFB54:
2105:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2106:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2107:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Retrieve the IEEE802.15.4 MAC Wake-Up Frame header from a (just received) packet.
2108:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2109:openstack/02a-MAClow/IEEE802154Ecsl.c **** Note We are writing the fields from the beginning of the header to the end.
2110:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2111:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in,out] msg            The message just received.
2112:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[out] ieee802514_header The internal header to write the data to.
2113:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[out] rztime  		  Rendezvous time to wait for data packet.
2114:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2115:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2116:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CSL]: Retrieve a wake-up header from the received packet.
2117:openstack/02a-MAClow/IEEE802154Ecsl.c **** void ieee802154_retrieveWakeUpFrame(OpenQueueEntry_t*      msg,
2118:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                     ieee802154_header_iht* ieee802514_header,
2119:openstack/02a-MAClow/IEEE802154Ecsl.c **** 									uint16_t* rztime) {
 4515              		.loc 1 2119 0
 4516              		.cfi_startproc
 4517              		@ args = 0, pretend = 0, frame = 24
 4518              		@ frame_needed = 1, uses_anonymous_args = 0
 4519 1eec 80B5     		push	{r7, lr}
 4520              	.LCFI127:
 4521              		.cfi_def_cfa_offset 8
 4522              		.cfi_offset 7, -8
 4523              		.cfi_offset 14, -4
 4524 1eee 86B0     		sub	sp, sp, #24
 4525              	.LCFI128:
 4526              		.cfi_def_cfa_offset 32
 4527 1ef0 00AF     		add	r7, sp, #0
 4528              	.LCFI129:
 4529              		.cfi_def_cfa_register 7
 4530 1ef2 F860     		str	r0, [r7, #12]
 4531 1ef4 B960     		str	r1, [r7, #8]
 4532 1ef6 7A60     		str	r2, [r7, #4]
2120:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t temp_8b, temp_8b1, temp_8b2;
2121:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t src_addr_mode, dst_addr_mode;
2122:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint16_t temp_16b;
2123:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2124:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2125:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // La estructura de una trama Wake-Up es la siguiente:
2126:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2127:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - FRAME CONTROL: 1 byte
2128:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - SEQ NUMBER (macDSN): 1 byte
2129:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - PAN ID: 2 bytes
2130:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - DEST ADDR: 2 bytes
2131:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - RZ TIME IE: 2 bytes
2132:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - IE LIST TERMINATOR: 2 bytes
2133:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2134:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  | FRAME   |  SEQ   | PAN | DEST | RZ TIME  | IE LIST    |
2135:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  | CONTROL | NUMBER |  ID | ADDR |  HDR IE  | TERMINATOR |
2136:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2137:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2138:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Por defecto, se asume que la cabecera no es válida en el caso de
2139:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abandonar la función al ser el paquete más corto que la cabecera.
2140:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->valid=FALSE;
 4533              		.loc 1 2140 0
 4534 1ef8 BB68     		ldr	r3, [r7, #8]
 4535 1efa 4FF00002 		mov	r2, #0
 4536 1efe 1A70     		strb	r2, [r3, #0]
2141:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength = 0;
 4537              		.loc 1 2141 0
 4538 1f00 BB68     		ldr	r3, [r7, #8]
 4539 1f02 4FF00002 		mov	r2, #0
 4540 1f06 5A70     		strb	r2, [r3, #1]
2142:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2143:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Validamos la existencia de datos que leer.
2144:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; }
 4541              		.loc 1 2144 0
 4542 1f08 BB68     		ldr	r3, [r7, #8]
 4543 1f0a 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 4544 1f0c FB68     		ldr	r3, [r7, #12]
 4545 1f0e 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4546 1f10 9A42     		cmp	r2, r3
 4547 1f12 00F25F81 		bhi	.L223
 4548              	.L201:
2145:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2146:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Frame Control Field (1 byte)
2147:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_8b = *((uint8_t*)(msg->payload)+ieee802514_header->headerLength);
 4549              		.loc 1 2147 0
 4550 1f16 FB68     		ldr	r3, [r7, #12]
 4551 1f18 5A68     		ldr	r2, [r3, #4]
 4552 1f1a BB68     		ldr	r3, [r7, #8]
 4553 1f1c 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4554 1f1e D318     		adds	r3, r2, r3
 4555 1f20 1B78     		ldrb	r3, [r3, #0]
 4556 1f22 FB75     		strb	r3, [r7, #23]
2148:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2149:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // La estructura del FCF en la trama de wake-up es 0x55 = 01010101b:
2150:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // b0-b2 -- Frame Type (debe ser 101 para trama wake-up)
2151:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // b3 ----- Long Frame Control (debe ser 0 para indicar que se trata de un FCF de 1 byte como es
2152:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // b4-b5 -- Dest Addr Mode (en este caso, short address por lo que tiene que valer 10).
2153:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // b6-b7 -- Src Addr Mode (en este caso, short address por lo que tiene que valer 10).
2154:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2155:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 |
2156:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   0 |  1 |  0 |  1 |  0 |  1 |  0 |  1 |
2157:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2158:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->frameType = (temp_8b >> IEEE154_FCF_FRAME_TYPE) & 0x07;//3b
 4557              		.loc 1 2158 0
 4558 1f24 FB7D     		ldrb	r3, [r7, #23]
 4559 1f26 03F00703 		and	r3, r3, #7
 4560 1f2a DAB2     		uxtb	r2, r3
 4561 1f2c BB68     		ldr	r3, [r7, #8]
 4562 1f2e 9A70     		strb	r2, [r3, #2]
2159:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2160:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Comprobamos que efectivamente se trata de una trama de tipo MULTIPURPOSE.
2161:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->frameType != IEEE154_TYPE_MULTIPURPOSE) {return; }
 4563              		.loc 1 2161 0
 4564 1f30 BB68     		ldr	r3, [r7, #8]
 4565 1f32 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 4566 1f34 052B     		cmp	r3, #5
 4567 1f36 40F04F81 		bne	.L224
 4568              	.L203:
2162:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2163:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Verificamos que efectivamente el campo Long Frame Control tiene valor cero para indicar que e
2164:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_8b >> 3) & 0x01) { return; }
 4569              		.loc 1 2164 0
 4570 1f3a FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 4571 1f3c 4FEAD303 		lsr	r3, r3, #3
 4572 1f40 DBB2     		uxtb	r3, r3
 4573 1f42 03F00103 		and	r3, r3, #1
 4574 1f46 002B     		cmp	r3, #0
 4575 1f48 40F04881 		bne	.L225
 4576              	.L204:
2165:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2166:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Recuperamos los Destination y Source Address Mode
2167:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2168:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Destination Address Mode
2169:openstack/02a-MAClow/IEEE802154Ecsl.c ****    dst_addr_mode = (temp_8b >> 4) & 0x03;
 4577              		.loc 1 2169 0
 4578 1f4c FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 4579 1f4e 4FEA1313 		lsr	r3, r3, #4
 4580 1f52 DBB2     		uxtb	r3, r3
 4581 1f54 03F00303 		and	r3, r3, #3
 4582 1f58 BB75     		strb	r3, [r7, #22]
2170:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if(dst_addr_mode == 1) { // 01 en binario en bits b5-b4
 4583              		.loc 1 2170 0
 4584 1f5a BB7D     		ldrb	r3, [r7, #22]	@ zero_extendqisi2
 4585 1f5c 012B     		cmp	r3, #1
 4586 1f5e 0BD1     		bne	.L205
2171:openstack/02a-MAClow/IEEE802154Ecsl.c ****      // Debería ser siempre este caso en las tramas wake-up por lo que se trata como error cualqui
2172:openstack/02a-MAClow/IEEE802154Ecsl.c ****      ieee802514_header->dest.type = ADDR_16B;
 4587              		.loc 1 2172 0
 4588 1f60 BB68     		ldr	r3, [r7, #8]
 4589 1f62 4FF00102 		mov	r2, #1
 4590 1f66 DA76     		strb	r2, [r3, #27]
2173:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2174:openstack/02a-MAClow/IEEE802154Ecsl.c ****    else {
2175:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	 openserial_printError(COMPONENT_IEEE802154,ERR_IEEE154_UNSUPPORTED, (errorparameter_t)1, (errorpa
2176:openstack/02a-MAClow/IEEE802154Ecsl.c ****      return; // this is an invalid packet, return
2177:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2178:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2179:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Source Address Mode
2180:openstack/02a-MAClow/IEEE802154Ecsl.c ****    src_addr_mode = (temp_8b >> 6) & 0x03;
 4591              		.loc 1 2180 0
 4592 1f68 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 4593 1f6a 4FEA9313 		lsr	r3, r3, #6
 4594 1f6e 7B75     		strb	r3, [r7, #21]
2181:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if(src_addr_mode == 1) { // 01 en binario en bits b7-b6
 4595              		.loc 1 2181 0
 4596 1f70 7B7D     		ldrb	r3, [r7, #21]	@ zero_extendqisi2
 4597 1f72 012B     		cmp	r3, #1
 4598 1f74 0BD0     		beq	.L206
 4599 1f76 1EE0     		b	.L221
 4600              	.L205:
2175:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	 openserial_printError(COMPONENT_IEEE802154,ERR_IEEE154_UNSUPPORTED, (errorparameter_t)1, (errorpa
 4601              		.loc 1 2175 0
 4602 1f78 BB7D     		ldrb	r3, [r7, #22]	@ zero_extendqisi2
 4603 1f7a 9BB2     		uxth	r3, r3
 4604 1f7c 4FF00800 		mov	r0, #8
 4605 1f80 4FF01901 		mov	r1, #25
 4606 1f84 4FF00102 		mov	r2, #1
 4607 1f88 FFF7FEFF 		bl	openserial_printError
2176:openstack/02a-MAClow/IEEE802154Ecsl.c ****      return; // this is an invalid packet, return
 4608              		.loc 1 2176 0
 4609 1f8c 3FE1     		b	.L200
 4610              	.L206:
2182:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Debería ser siempre este caso en las tramas wake-up por lo que se trata como error cualqu
2183:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee802514_header->src.type = ADDR_16B;
 4611              		.loc 1 2183 0
 4612 1f8e BB68     		ldr	r3, [r7, #8]
 4613 1f90 4FF00102 		mov	r2, #1
 4614 1f94 83F82C20 		strb	r2, [r3, #44]
2184:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2185:openstack/02a-MAClow/IEEE802154Ecsl.c ****    else {
2186:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printError(COMPONENT_IEEE802154,ERR_IEEE154_UNSUPPORTED, (errorparameter_t)2, (errorp
2187:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return; // this is an invalid packet, return
2188:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2189:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2190:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2191:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // En este punto ya hemos analizado el contenido del primer byte de la cabecera correspondiente 
2192:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2193:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2194:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // A partir de este punto, la estructura del paquete es la siguiente:
2195:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - SEQ NUMBER (macDSN): 1 byte
2196:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - PAN ID: 2 bytes
2197:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - DEST ADDR: 2 bytes
2198:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - RZ TIME IE: 2 bytes
2199:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - IE LIST TERMINATOR: 2 bytes
2200:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2201:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2202:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Avanzamos 1 byte en el procesamiento de la cabecera.
2203:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 1;
 4615              		.loc 1 2203 0
 4616 1f98 BB68     		ldr	r3, [r7, #8]
 4617 1f9a 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4618 1f9c 03F10103 		add	r3, r3, #1
 4619 1fa0 DAB2     		uxtb	r2, r3
 4620 1fa2 BB68     		ldr	r3, [r7, #8]
 4621 1fa4 5A70     		strb	r2, [r3, #1]
2204:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2205:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Posicionamos dentro del paquete para leer el resto de elementos.
2206:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2207:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // 1.- SequenceNumber
2208:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4622              		.loc 1 2208 0
 4623 1fa6 BB68     		ldr	r3, [r7, #8]
 4624 1fa8 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 4625 1faa FB68     		ldr	r3, [r7, #12]
 4626 1fac 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4627 1fae 9A42     		cmp	r2, r3
 4628 1fb0 00F21681 		bhi	.L226
 4629 1fb4 0AE0     		b	.L222
 4630              	.L221:
2186:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printError(COMPONENT_IEEE802154,ERR_IEEE154_UNSUPPORTED, (errorparameter_t)2, (errorp
 4631              		.loc 1 2186 0
 4632 1fb6 7B7D     		ldrb	r3, [r7, #21]	@ zero_extendqisi2
 4633 1fb8 9BB2     		uxth	r3, r3
 4634 1fba 4FF00800 		mov	r0, #8
 4635 1fbe 4FF01901 		mov	r1, #25
 4636 1fc2 4FF00202 		mov	r2, #2
 4637 1fc6 FFF7FEFF 		bl	openserial_printError
2187:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return; // this is an invalid packet, return
 4638              		.loc 1 2187 0
 4639 1fca 20E1     		b	.L200
 4640              	.L222:
2209:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->dsn  = *((uint8_t*)(msg->payload)+ieee802514_header->headerLength);
 4641              		.loc 1 2209 0
 4642 1fcc FB68     		ldr	r3, [r7, #12]
 4643 1fce 5A68     		ldr	r2, [r3, #4]
 4644 1fd0 BB68     		ldr	r3, [r7, #8]
 4645 1fd2 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4646 1fd4 D318     		adds	r3, r2, r3
 4647 1fd6 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 4648 1fd8 BB68     		ldr	r3, [r7, #8]
 4649 1fda 5A72     		strb	r2, [r3, #9]
2210:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 1;
 4650              		.loc 1 2210 0
 4651 1fdc BB68     		ldr	r3, [r7, #8]
 4652 1fde 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4653 1fe0 03F10103 		add	r3, r3, #1
 4654 1fe4 DAB2     		uxtb	r2, r3
 4655 1fe6 BB68     		ldr	r3, [r7, #8]
 4656 1fe8 5A70     		strb	r2, [r3, #1]
2211:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2212:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // 2.- panID
2213:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4657              		.loc 1 2213 0
 4658 1fea BB68     		ldr	r3, [r7, #8]
 4659 1fec 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 4660 1fee FB68     		ldr	r3, [r7, #12]
 4661 1ff0 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4662 1ff2 9A42     		cmp	r2, r3
 4663 1ff4 00F2F680 		bhi	.L227
 4664              	.L210:
2214:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packetfunctions_readAddress(((uint8_t*)(msg->payload)+ieee802514_header->headerLength), ADDR_PAN
 4665              		.loc 1 2214 0
 4666 1ff8 FB68     		ldr	r3, [r7, #12]
 4667 1ffa 5A68     		ldr	r2, [r3, #4]
 4668 1ffc BB68     		ldr	r3, [r7, #8]
 4669 1ffe 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4670 2000 D218     		adds	r2, r2, r3
 4671 2002 BB68     		ldr	r3, [r7, #8]
 4672 2004 03F10A03 		add	r3, r3, #10
 4673 2008 1046     		mov	r0, r2
 4674 200a 4FF00401 		mov	r1, #4
 4675 200e 1A46     		mov	r2, r3
 4676 2010 4FF00103 		mov	r3, #1
 4677 2014 FFF7FEFF 		bl	packetfunctions_readAddress
2215:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 2;
 4678              		.loc 1 2215 0
 4679 2018 BB68     		ldr	r3, [r7, #8]
 4680 201a 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4681 201c 03F10203 		add	r3, r3, #2
 4682 2020 DAB2     		uxtb	r2, r3
 4683 2022 BB68     		ldr	r3, [r7, #8]
 4684 2024 5A70     		strb	r2, [r3, #1]
2216:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2217:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // 3.- Dest Addr
2218:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4685              		.loc 1 2218 0
 4686 2026 BB68     		ldr	r3, [r7, #8]
 4687 2028 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 4688 202a FB68     		ldr	r3, [r7, #12]
 4689 202c 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4690 202e 9A42     		cmp	r2, r3
 4691 2030 00F2DA80 		bhi	.L228
 4692              	.L211:
2219:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2220:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // En este punto ya sabemos que el tipo de dirección tiene que ser ADDR_16B dado que cualquier 
2221:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // en la lectura del frame control field por lo que leemos los 2 bytes de la dirección del dest
2222:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packetfunctions_readAddress(((uint8_t*)(msg->payload)+ieee802514_header->headerLength), ADDR_16B
 4693              		.loc 1 2222 0
 4694 2034 FB68     		ldr	r3, [r7, #12]
 4695 2036 5A68     		ldr	r2, [r3, #4]
 4696 2038 BB68     		ldr	r3, [r7, #8]
 4697 203a 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4698 203c D218     		adds	r2, r2, r3
 4699 203e BB68     		ldr	r3, [r7, #8]
 4700 2040 03F11B03 		add	r3, r3, #27
 4701 2044 1046     		mov	r0, r2
 4702 2046 4FF00101 		mov	r1, #1
 4703 204a 1A46     		mov	r2, r3
 4704 204c 4FF00103 		mov	r3, #1
 4705 2050 FFF7FEFF 		bl	packetfunctions_readAddress
2223:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 2;
 4706              		.loc 1 2223 0
 4707 2054 BB68     		ldr	r3, [r7, #8]
 4708 2056 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4709 2058 03F10203 		add	r3, r3, #2
 4710 205c DAB2     		uxtb	r2, r3
 4711 205e BB68     		ldr	r3, [r7, #8]
 4712 2060 5A70     		strb	r2, [r3, #1]
2224:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2225:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // 4.- RZ Time Header IE, formado por 4 bytes con la siguiente estructura (0x0E82)
2226:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  - b0-b6 (Length) = 2
2227:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  - b7-b14 (Element ID) = 0x1D
2228:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  - b15 (Type) = 0
2229:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  - b16-b31 (IE Content) = time (2 bytes)
2230:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2231:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  b15 | b14 | b13 | b12 | b11 | b10 | b9 | b8 | b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 |
2232:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   0  |  0  |  0  |  0  |  1  |  1  |  1 |  0 |  1 |  0 |  0 |  0 |  0 |  0 |  1 |  0 |
2233:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2234:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) {  return; } // no more to read!
 4713              		.loc 1 2234 0
 4714 2062 BB68     		ldr	r3, [r7, #8]
 4715 2064 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 4716 2066 FB68     		ldr	r3, [r7, #12]
 4717 2068 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4718 206a 9A42     		cmp	r2, r3
 4719 206c 00F2BE80 		bhi	.L229
 4720              	.L212:
2235:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2236:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Verificamos longitud a valor 2 y el elementID a valor 0x1D. Lo hacemos leyendo los primeros 2
2237:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_8b1 = *((uint8_t*)(msg->payload)+ieee802514_header->headerLength);
 4721              		.loc 1 2237 0
 4722 2070 FB68     		ldr	r3, [r7, #12]
 4723 2072 5A68     		ldr	r2, [r3, #4]
 4724 2074 BB68     		ldr	r3, [r7, #8]
 4725 2076 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4726 2078 D318     		adds	r3, r2, r3
 4727 207a 1B78     		ldrb	r3, [r3, #0]
 4728 207c 3B75     		strb	r3, [r7, #20]
2238:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 1;
 4729              		.loc 1 2238 0
 4730 207e BB68     		ldr	r3, [r7, #8]
 4731 2080 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4732 2082 03F10103 		add	r3, r3, #1
 4733 2086 DAB2     		uxtb	r2, r3
 4734 2088 BB68     		ldr	r3, [r7, #8]
 4735 208a 5A70     		strb	r2, [r3, #1]
2239:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2240:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_8b2 = *((uint8_t*)(msg->payload)+ieee802514_header->headerLength);
 4736              		.loc 1 2240 0
 4737 208c FB68     		ldr	r3, [r7, #12]
 4738 208e 5A68     		ldr	r2, [r3, #4]
 4739 2090 BB68     		ldr	r3, [r7, #8]
 4740 2092 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4741 2094 D318     		adds	r3, r2, r3
 4742 2096 1B78     		ldrb	r3, [r3, #0]
 4743 2098 FB74     		strb	r3, [r7, #19]
2241:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 1;
 4744              		.loc 1 2241 0
 4745 209a BB68     		ldr	r3, [r7, #8]
 4746 209c 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4747 209e 03F10103 		add	r3, r3, #1
 4748 20a2 DAB2     		uxtb	r2, r3
 4749 20a4 BB68     		ldr	r3, [r7, #8]
 4750 20a6 5A70     		strb	r2, [r3, #1]
2242:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2243:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_16b = (temp_8b2 << 8) | temp_8b1;
 4751              		.loc 1 2243 0
 4752 20a8 FB7C     		ldrb	r3, [r7, #19]	@ zero_extendqisi2
 4753 20aa 4FEA0323 		lsl	r3, r3, #8
 4754 20ae 9AB2     		uxth	r2, r3
 4755 20b0 3B7D     		ldrb	r3, [r7, #20]	@ zero_extendqisi2
 4756 20b2 9BB2     		uxth	r3, r3
 4757 20b4 1343     		orrs	r3, r3, r2
 4758 20b6 9BB2     		uxth	r3, r3
 4759 20b8 3B82     		strh	r3, [r7, #16]	@ movhi
2244:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2245:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Comprobación de longitud a valor 2.
2246:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b & 0x007f) != 2) { return; }
 4760              		.loc 1 2246 0
 4761 20ba 3B8A     		ldrh	r3, [r7, #16]
 4762 20bc 03F07F03 		and	r3, r3, #127
 4763 20c0 022B     		cmp	r3, #2
 4764 20c2 40F09580 		bne	.L230
 4765              	.L213:
2247:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2248:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Comprobación de element ID = 0x1D.
2249:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b >> 7) != 0x001d) { return; }
 4766              		.loc 1 2249 0
 4767 20c6 3B8A     		ldrh	r3, [r7, #16]
 4768 20c8 4FEAD313 		lsr	r3, r3, #7
 4769 20cc 9BB2     		uxth	r3, r3
 4770 20ce 1D2B     		cmp	r3, #29
 4771 20d0 40F09080 		bne	.L231
 4772              	.L214:
2250:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2251:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Comprobación del type = 0.
2252:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b >> 15) & 0x0001) { return; }
 4773              		.loc 1 2252 0
 4774 20d4 3B8A     		ldrh	r3, [r7, #16]
 4775 20d6 4FEAD333 		lsr	r3, r3, #15
 4776 20da 9BB2     		uxth	r3, r3
 4777 20dc 03F00103 		and	r3, r3, #1
 4778 20e0 002B     		cmp	r3, #0
 4779 20e2 40F08980 		bne	.L232
 4780              	.L215:
2253:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2254:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Obtención del IE Content (rztime).
2255:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4781              		.loc 1 2255 0
 4782 20e6 BB68     		ldr	r3, [r7, #8]
 4783 20e8 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 4784 20ea FB68     		ldr	r3, [r7, #12]
 4785 20ec 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4786 20ee 9A42     		cmp	r2, r3
 4787 20f0 00F28480 		bhi	.L233
 4788              	.L216:
2256:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2257:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_8b1 = *((uint8_t*)(msg->payload)+ieee802514_header->headerLength);
 4789              		.loc 1 2257 0
 4790 20f4 FB68     		ldr	r3, [r7, #12]
 4791 20f6 5A68     		ldr	r2, [r3, #4]
 4792 20f8 BB68     		ldr	r3, [r7, #8]
 4793 20fa 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4794 20fc D318     		adds	r3, r2, r3
 4795 20fe 1B78     		ldrb	r3, [r3, #0]
 4796 2100 3B75     		strb	r3, [r7, #20]
2258:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 1;
 4797              		.loc 1 2258 0
 4798 2102 BB68     		ldr	r3, [r7, #8]
 4799 2104 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4800 2106 03F10103 		add	r3, r3, #1
 4801 210a DAB2     		uxtb	r2, r3
 4802 210c BB68     		ldr	r3, [r7, #8]
 4803 210e 5A70     		strb	r2, [r3, #1]
2259:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2260:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_8b2 = *((uint8_t*)(msg->payload)+ieee802514_header->headerLength);
 4804              		.loc 1 2260 0
 4805 2110 FB68     		ldr	r3, [r7, #12]
 4806 2112 5A68     		ldr	r2, [r3, #4]
 4807 2114 BB68     		ldr	r3, [r7, #8]
 4808 2116 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4809 2118 D318     		adds	r3, r2, r3
 4810 211a 1B78     		ldrb	r3, [r3, #0]
 4811 211c FB74     		strb	r3, [r7, #19]
2261:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 1;
 4812              		.loc 1 2261 0
 4813 211e BB68     		ldr	r3, [r7, #8]
 4814 2120 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4815 2122 03F10103 		add	r3, r3, #1
 4816 2126 DAB2     		uxtb	r2, r3
 4817 2128 BB68     		ldr	r3, [r7, #8]
 4818 212a 5A70     		strb	r2, [r3, #1]
2262:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2263:openstack/02a-MAClow/IEEE802154Ecsl.c ****    (*rztime) = (temp_8b2 << 8) | temp_8b1;
 4819              		.loc 1 2263 0
 4820 212c FB7C     		ldrb	r3, [r7, #19]	@ zero_extendqisi2
 4821 212e 4FEA0323 		lsl	r3, r3, #8
 4822 2132 9AB2     		uxth	r2, r3
 4823 2134 3B7D     		ldrb	r3, [r7, #20]	@ zero_extendqisi2
 4824 2136 9BB2     		uxth	r3, r3
 4825 2138 1343     		orrs	r3, r3, r2
 4826 213a 9BB2     		uxth	r3, r3
 4827 213c 9AB2     		uxth	r2, r3
 4828 213e 7B68     		ldr	r3, [r7, #4]
 4829 2140 1A80     		strh	r2, [r3, #0]	@ movhi
2264:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2265:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // 5.- IE List Terminator, formado por 2 bytes con la siguiente estructura (0x3F80 o 0x3F00)
2266:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  - b0-b6 (Length) = 0
2267:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  - b7-b14 (Element ID) = 0x7e o 0x7f
2268:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  - b15 (Type) = 0
2269:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2270:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  b15 | b14 | b13 | b12 | b11 | b10 | b9 | b8 | b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 |
2271:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   0  |  0  |  1  |  1  |  1  |  1  | 1  | 1  |  0 |  0 |  0 |  0 |  0 |  0 |  0 |  0 |
2272:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2273:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4830              		.loc 1 2273 0
 4831 2142 BB68     		ldr	r3, [r7, #8]
 4832 2144 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 4833 2146 FB68     		ldr	r3, [r7, #12]
 4834 2148 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4835 214a 9A42     		cmp	r2, r3
 4836 214c 58D8     		bhi	.L234
 4837              	.L217:
2274:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2275:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Verificamos longitud a valor 0 y el elementID a valor 0x7E o 0x7F. Lo hacemos leyendo los 2 b
2276:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_8b1 = *((uint8_t*)(msg->payload)+ieee802514_header->headerLength);
 4838              		.loc 1 2276 0
 4839 214e FB68     		ldr	r3, [r7, #12]
 4840 2150 5A68     		ldr	r2, [r3, #4]
 4841 2152 BB68     		ldr	r3, [r7, #8]
 4842 2154 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4843 2156 D318     		adds	r3, r2, r3
 4844 2158 1B78     		ldrb	r3, [r3, #0]
 4845 215a 3B75     		strb	r3, [r7, #20]
2277:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 1;
 4846              		.loc 1 2277 0
 4847 215c BB68     		ldr	r3, [r7, #8]
 4848 215e 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4849 2160 03F10103 		add	r3, r3, #1
 4850 2164 DAB2     		uxtb	r2, r3
 4851 2166 BB68     		ldr	r3, [r7, #8]
 4852 2168 5A70     		strb	r2, [r3, #1]
2278:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2279:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_8b2 = *((uint8_t*)(msg->payload)+ieee802514_header->headerLength);
 4853              		.loc 1 2279 0
 4854 216a FB68     		ldr	r3, [r7, #12]
 4855 216c 5A68     		ldr	r2, [r3, #4]
 4856 216e BB68     		ldr	r3, [r7, #8]
 4857 2170 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4858 2172 D318     		adds	r3, r2, r3
 4859 2174 1B78     		ldrb	r3, [r3, #0]
 4860 2176 FB74     		strb	r3, [r7, #19]
2280:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 1;
 4861              		.loc 1 2280 0
 4862 2178 BB68     		ldr	r3, [r7, #8]
 4863 217a 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4864 217c 03F10103 		add	r3, r3, #1
 4865 2180 DAB2     		uxtb	r2, r3
 4866 2182 BB68     		ldr	r3, [r7, #8]
 4867 2184 5A70     		strb	r2, [r3, #1]
2281:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2282:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_16b = (temp_8b2 << 8) | temp_8b1;
 4868              		.loc 1 2282 0
 4869 2186 FB7C     		ldrb	r3, [r7, #19]	@ zero_extendqisi2
 4870 2188 4FEA0323 		lsl	r3, r3, #8
 4871 218c 9AB2     		uxth	r2, r3
 4872 218e 3B7D     		ldrb	r3, [r7, #20]	@ zero_extendqisi2
 4873 2190 9BB2     		uxth	r3, r3
 4874 2192 1343     		orrs	r3, r3, r2
 4875 2194 9BB2     		uxth	r3, r3
 4876 2196 3B82     		strh	r3, [r7, #16]	@ movhi
2283:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2284:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Comprobación de longitud a valor 0.
2285:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (temp_16b & 0x007f) { return; }
 4877              		.loc 1 2285 0
 4878 2198 3B8A     		ldrh	r3, [r7, #16]
 4879 219a 03F07F03 		and	r3, r3, #127
 4880 219e 002B     		cmp	r3, #0
 4881 21a0 30D1     		bne	.L235
 4882              	.L218:
2286:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2287:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Comprobación de element ID = 0x7E o 0x7F.
2288:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (((temp_16b >> 7) != 0x7e) && ((temp_16b >> 7) != 0x7f)) { return; }
 4883              		.loc 1 2288 0
 4884 21a2 3B8A     		ldrh	r3, [r7, #16]
 4885 21a4 4FEAD313 		lsr	r3, r3, #7
 4886 21a8 9BB2     		uxth	r3, r3
 4887 21aa 7E2B     		cmp	r3, #126
 4888 21ac 05D0     		beq	.L219
 4889              		.loc 1 2288 0 is_stmt 0 discriminator 1
 4890 21ae 3B8A     		ldrh	r3, [r7, #16]
 4891 21b0 4FEAD313 		lsr	r3, r3, #7
 4892 21b4 9BB2     		uxth	r3, r3
 4893 21b6 7F2B     		cmp	r3, #127
 4894 21b8 26D1     		bne	.L236
 4895              	.L219:
2289:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2290:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Comprobación del type = 0.
2291:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b >> 15) & 0x0001) { return; }
 4896              		.loc 1 2291 0 is_stmt 1
 4897 21ba 3B8A     		ldrh	r3, [r7, #16]
 4898 21bc 4FEAD333 		lsr	r3, r3, #15
 4899 21c0 9BB2     		uxth	r3, r3
 4900 21c2 03F00103 		and	r3, r3, #1
 4901 21c6 002B     		cmp	r3, #0
 4902 21c8 20D1     		bne	.L237
 4903              	.L220:
2292:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2293:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Por ultimo y en el caso de haber llegado aquí, consideramos la cabecera como válida.
2294:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->valid=TRUE;
 4904              		.loc 1 2294 0
 4905 21ca BB68     		ldr	r3, [r7, #8]
 4906 21cc 4FF00102 		mov	r2, #1
 4907 21d0 1A70     		strb	r2, [r3, #0]
 4908 21d2 1CE0     		b	.L200
 4909              	.L223:
2144:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; }
 4910              		.loc 1 2144 0
 4911 21d4 00BF     		nop
 4912 21d6 1AE0     		b	.L200
 4913              	.L224:
2161:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->frameType != IEEE154_TYPE_MULTIPURPOSE) {return; }
 4914              		.loc 1 2161 0
 4915 21d8 00BF     		nop
 4916 21da 18E0     		b	.L200
 4917              	.L225:
2164:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_8b >> 3) & 0x01) { return; }
 4918              		.loc 1 2164 0
 4919 21dc 00BF     		nop
 4920 21de 16E0     		b	.L200
 4921              	.L226:
2208:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4922              		.loc 1 2208 0
 4923 21e0 00BF     		nop
 4924 21e2 14E0     		b	.L200
 4925              	.L227:
2213:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4926              		.loc 1 2213 0
 4927 21e4 00BF     		nop
 4928 21e6 12E0     		b	.L200
 4929              	.L228:
2218:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4930              		.loc 1 2218 0
 4931 21e8 00BF     		nop
 4932 21ea 10E0     		b	.L200
 4933              	.L229:
2234:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) {  return; } // no more to read!
 4934              		.loc 1 2234 0
 4935 21ec 00BF     		nop
 4936 21ee 0EE0     		b	.L200
 4937              	.L230:
2246:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b & 0x007f) != 2) { return; }
 4938              		.loc 1 2246 0
 4939 21f0 00BF     		nop
 4940 21f2 0CE0     		b	.L200
 4941              	.L231:
2249:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b >> 7) != 0x001d) { return; }
 4942              		.loc 1 2249 0
 4943 21f4 00BF     		nop
 4944 21f6 0AE0     		b	.L200
 4945              	.L232:
2252:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b >> 15) & 0x0001) { return; }
 4946              		.loc 1 2252 0
 4947 21f8 00BF     		nop
 4948 21fa 08E0     		b	.L200
 4949              	.L233:
2255:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4950              		.loc 1 2255 0
 4951 21fc 00BF     		nop
 4952 21fe 06E0     		b	.L200
 4953              	.L234:
2273:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4954              		.loc 1 2273 0
 4955 2200 00BF     		nop
 4956 2202 04E0     		b	.L200
 4957              	.L235:
2285:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (temp_16b & 0x007f) { return; }
 4958              		.loc 1 2285 0
 4959 2204 00BF     		nop
 4960 2206 02E0     		b	.L200
 4961              	.L236:
2288:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (((temp_16b >> 7) != 0x7e) && ((temp_16b >> 7) != 0x7f)) { return; }
 4962              		.loc 1 2288 0
 4963 2208 00BF     		nop
 4964 220a 00E0     		b	.L200
 4965              	.L237:
2291:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b >> 15) & 0x0001) { return; }
 4966              		.loc 1 2291 0
 4967 220c 00BF     		nop
 4968              	.L200:
2295:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4969              		.loc 1 2295 0
 4970 220e 07F11807 		add	r7, r7, #24
 4971 2212 BD46     		mov	sp, r7
 4972 2214 80BD     		pop	{r7, pc}
 4973              		.cfi_endproc
 4974              	.LFE54:
 4976 2216 00BF     		.align	2
 4977              		.global	isValidRxFrame
 4978              		.thumb
 4979              		.thumb_func
 4981              	isValidRxFrame:
 4982              	.LFB55:
2296:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2297:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2298:openstack/02a-MAClow/IEEE802154Ecsl.c **** //====================  FRAME VALIDITY CHECK ===========================
2299:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2300:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2301:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2302:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Decides whether the packet I just received is valid received frame.
2303:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2304:openstack/02a-MAClow/IEEE802154Ecsl.c **** A valid Rx frame satisfies the following constraints:
2305:openstack/02a-MAClow/IEEE802154Ecsl.c **** - its IEEE802.15.4 header is well formatted
2306:openstack/02a-MAClow/IEEE802154Ecsl.c **** - it's a DATA of BEACON frame (i.e. not ACK and not COMMAND)
2307:openstack/02a-MAClow/IEEE802154Ecsl.c **** - it's sent on the same PANid as mine
2308:openstack/02a-MAClow/IEEE802154Ecsl.c **** - it's for me (unicast or broadcast)
2309:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2310:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in] ieee802514_header IEEE802.15.4 header of the packet I just received
2311:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2312:openstack/02a-MAClow/IEEE802154Ecsl.c **** \returns TRUE if packet is valid received frame, FALSE otherwise
2313:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2314:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE bool isValidRxFrame(ieee802154_header_iht* ieee802514_header) {
 4983              		.loc 1 2314 0
 4984              		.cfi_startproc
 4985              		@ args = 0, pretend = 0, frame = 8
 4986              		@ frame_needed = 1, uses_anonymous_args = 0
 4987 2218 90B5     		push	{r4, r7, lr}
 4988              	.LCFI130:
 4989              		.cfi_def_cfa_offset 12
 4990              		.cfi_offset 4, -12
 4991              		.cfi_offset 7, -8
 4992              		.cfi_offset 14, -4
 4993 221a 83B0     		sub	sp, sp, #12
 4994              	.LCFI131:
 4995              		.cfi_def_cfa_offset 24
 4996 221c 00AF     		add	r7, sp, #0
 4997              	.LCFI132:
 4998              		.cfi_def_cfa_register 7
 4999 221e 7860     		str	r0, [r7, #4]
2315:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee802514_header->valid==TRUE                                                           
 5000              		.loc 1 2315 0
 5001 2220 7B68     		ldr	r3, [r7, #4]
 5002 2222 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
2316:openstack/02a-MAClow/IEEE802154Ecsl.c ****           (
2317:openstack/02a-MAClow/IEEE802154Ecsl.c ****              ieee802514_header->frameType==IEEE154_TYPE_DATA                   ||
2318:openstack/02a-MAClow/IEEE802154Ecsl.c ****              ieee802514_header->frameType==IEEE154_TYPE_BEACON
2319:openstack/02a-MAClow/IEEE802154Ecsl.c ****           )                                                                                        
2320:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
 5003              		.loc 1 2320 0
 5004 2224 002B     		cmp	r3, #0
 5005 2226 2BD0     		beq	.L239
2317:openstack/02a-MAClow/IEEE802154Ecsl.c ****              ieee802514_header->frameType==IEEE154_TYPE_DATA                   ||
 5006              		.loc 1 2317 0
 5007 2228 7B68     		ldr	r3, [r7, #4]
 5008 222a 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
2315:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee802514_header->valid==TRUE                                                           
 5009              		.loc 1 2315 0
 5010 222c 012B     		cmp	r3, #1
 5011 222e 03D0     		beq	.L240
2318:openstack/02a-MAClow/IEEE802154Ecsl.c ****              ieee802514_header->frameType==IEEE154_TYPE_BEACON
 5012              		.loc 1 2318 0
 5013 2230 7B68     		ldr	r3, [r7, #4]
 5014 2232 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
2317:openstack/02a-MAClow/IEEE802154Ecsl.c ****              ieee802514_header->frameType==IEEE154_TYPE_DATA                   ||
 5015              		.loc 1 2317 0
 5016 2234 002B     		cmp	r3, #0
 5017 2236 23D1     		bne	.L239
 5018              	.L240:
 5019              		.loc 1 2320 0
 5020 2238 7B68     		ldr	r3, [r7, #4]
 5021 223a 03F10A04 		add	r4, r3, #10
 5022 223e 4FF00400 		mov	r0, #4
 5023 2242 FFF7FEFF 		bl	idmanager_getMyID
 5024 2246 0346     		mov	r3, r0
 5025 2248 2046     		mov	r0, r4
 5026 224a 1946     		mov	r1, r3
 5027 224c FFF7FEFF 		bl	packetfunctions_sameAddress
 5028 2250 0346     		mov	r3, r0
2319:openstack/02a-MAClow/IEEE802154Ecsl.c ****           )                                                                                        
 5029              		.loc 1 2319 0
 5030 2252 002B     		cmp	r3, #0
 5031 2254 14D0     		beq	.L239
2321:openstack/02a-MAClow/IEEE802154Ecsl.c ****           (
2322:openstack/02a-MAClow/IEEE802154Ecsl.c ****              idmanager_isMyAddress(&ieee802514_header->dest)                   ||
 5032              		.loc 1 2322 0
 5033 2256 7B68     		ldr	r3, [r7, #4]
 5034 2258 03F11B03 		add	r3, r3, #27
 5035 225c 1846     		mov	r0, r3
 5036 225e FFF7FEFF 		bl	idmanager_isMyAddress
 5037 2262 0346     		mov	r3, r0
2320:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
 5038              		.loc 1 2320 0
 5039 2264 002B     		cmp	r3, #0
 5040 2266 08D1     		bne	.L241
2323:openstack/02a-MAClow/IEEE802154Ecsl.c ****              packetfunctions_isBroadcastMulticast(&ieee802514_header->dest)
 5041              		.loc 1 2323 0
 5042 2268 7B68     		ldr	r3, [r7, #4]
 5043 226a 03F11B03 		add	r3, r3, #27
 5044 226e 1846     		mov	r0, r3
 5045 2270 FFF7FEFF 		bl	packetfunctions_isBroadcastMulticast
 5046 2274 0346     		mov	r3, r0
2322:openstack/02a-MAClow/IEEE802154Ecsl.c ****              idmanager_isMyAddress(&ieee802514_header->dest)                   ||
 5047              		.loc 1 2322 0
 5048 2276 002B     		cmp	r3, #0
 5049 2278 02D0     		beq	.L239
 5050              	.L241:
2320:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
 5051              		.loc 1 2320 0 discriminator 2
 5052 227a 4FF00103 		mov	r3, #1
 5053 227e 01E0     		b	.L242
 5054              	.L239:
2320:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
 5055              		.loc 1 2320 0 is_stmt 0 discriminator 1
 5056 2280 4FF00003 		mov	r3, #0
 5057              	.L242:
2315:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee802514_header->valid==TRUE                                                           
 5058              		.loc 1 2315 0 is_stmt 1
 5059 2284 03F00103 		and	r3, r3, #1
 5060 2288 DBB2     		uxtb	r3, r3
2324:openstack/02a-MAClow/IEEE802154Ecsl.c ****           );
2325:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5061              		.loc 1 2325 0
 5062 228a 1846     		mov	r0, r3
 5063 228c 07F10C07 		add	r7, r7, #12
 5064 2290 BD46     		mov	sp, r7
 5065 2292 90BD     		pop	{r4, r7, pc}
 5066              		.cfi_endproc
 5067              	.LFE55:
 5069              		.align	2
 5070              		.global	isValidAck
 5071              		.thumb
 5072              		.thumb_func
 5074              	isValidAck:
 5075              	.LFB56:
2326:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2327:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2328:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Decides whether the packet I just received is a valid ACK.
2329:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2330:openstack/02a-MAClow/IEEE802154Ecsl.c **** A packet is a valid ACK if it satisfies the following conditions:
2331:openstack/02a-MAClow/IEEE802154Ecsl.c **** - the IEEE802.15.4 header is valid
2332:openstack/02a-MAClow/IEEE802154Ecsl.c **** - the frame type is 'ACK'
2333:openstack/02a-MAClow/IEEE802154Ecsl.c **** - the sequence number in the ACK matches the sequence number of the packet sent
2334:openstack/02a-MAClow/IEEE802154Ecsl.c **** - the ACK contains my PANid
2335:openstack/02a-MAClow/IEEE802154Ecsl.c **** - the packet is unicast to me
2336:openstack/02a-MAClow/IEEE802154Ecsl.c **** - the packet comes from the neighbor I sent the data to
2337:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2338:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in] ieee802514_header IEEE802.15.4 header of the packet I just received
2339:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in] packetSent points to the packet I just sent
2340:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2341:openstack/02a-MAClow/IEEE802154Ecsl.c **** \returns TRUE if packet is a valid ACK, FALSE otherwise.
2342:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2343:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE bool isValidAck(ieee802154_header_iht* ieee802514_header, OpenQueueEntry_t* packetSent)
 5076              		.loc 1 2343 0
 5077              		.cfi_startproc
 5078              		@ args = 0, pretend = 0, frame = 8
 5079              		@ frame_needed = 1, uses_anonymous_args = 0
 5080 2294 90B5     		push	{r4, r7, lr}
 5081              	.LCFI133:
 5082              		.cfi_def_cfa_offset 12
 5083              		.cfi_offset 4, -12
 5084              		.cfi_offset 7, -8
 5085              		.cfi_offset 14, -4
 5086 2296 83B0     		sub	sp, sp, #12
 5087              	.LCFI134:
 5088              		.cfi_def_cfa_offset 24
 5089 2298 00AF     		add	r7, sp, #0
 5090              	.LCFI135:
 5091              		.cfi_def_cfa_register 7
 5092 229a 7860     		str	r0, [r7, #4]
 5093 229c 3960     		str	r1, [r7, #0]
2344:openstack/02a-MAClow/IEEE802154Ecsl.c ****    /*
2345:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee802514_header->valid==TRUE                                                           
2346:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header->frameType==IEEE154_TYPE_ACK                                           
2347:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header->dsn==packetSent->l2_dsn                                               
2348:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
2349:openstack/02a-MAClow/IEEE802154Ecsl.c ****           idmanager_isMyAddress(&ieee802514_header->dest)                                          
2350:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->src,&packetSent->l2_nextORpreviousHop);
2351:openstack/02a-MAClow/IEEE802154Ecsl.c ****    */
2352:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // poipoi don't check for seq num
2353:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee802514_header->valid==TRUE                                                           
 5094              		.loc 1 2353 0
 5095 229e 7B68     		ldr	r3, [r7, #4]
 5096 22a0 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
2354:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header->frameType==IEEE154_TYPE_ACK                                           
2355:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
2356:openstack/02a-MAClow/IEEE802154Ecsl.c ****           idmanager_isMyAddress(&ieee802514_header->dest)                                          
 5097              		.loc 1 2356 0
 5098 22a2 002B     		cmp	r3, #0
 5099 22a4 2BD0     		beq	.L245
2354:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header->frameType==IEEE154_TYPE_ACK                                           
 5100              		.loc 1 2354 0
 5101 22a6 7B68     		ldr	r3, [r7, #4]
 5102 22a8 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
2353:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee802514_header->valid==TRUE                                                           
 5103              		.loc 1 2353 0
 5104 22aa 022B     		cmp	r3, #2
 5105 22ac 27D1     		bne	.L245
2355:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
 5106              		.loc 1 2355 0
 5107 22ae 7B68     		ldr	r3, [r7, #4]
 5108 22b0 03F10A04 		add	r4, r3, #10
 5109 22b4 4FF00400 		mov	r0, #4
 5110 22b8 FFF7FEFF 		bl	idmanager_getMyID
 5111 22bc 0346     		mov	r3, r0
 5112 22be 2046     		mov	r0, r4
 5113 22c0 1946     		mov	r1, r3
 5114 22c2 FFF7FEFF 		bl	packetfunctions_sameAddress
 5115 22c6 0346     		mov	r3, r0
2354:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header->frameType==IEEE154_TYPE_ACK                                           
 5116              		.loc 1 2354 0
 5117 22c8 002B     		cmp	r3, #0
 5118 22ca 18D0     		beq	.L245
 5119              		.loc 1 2356 0
 5120 22cc 7B68     		ldr	r3, [r7, #4]
 5121 22ce 03F11B03 		add	r3, r3, #27
 5122 22d2 1846     		mov	r0, r3
 5123 22d4 FFF7FEFF 		bl	idmanager_isMyAddress
 5124 22d8 0346     		mov	r3, r0
2355:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
 5125              		.loc 1 2355 0
 5126 22da 002B     		cmp	r3, #0
 5127 22dc 0FD0     		beq	.L245
2357:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->src,&packetSent->l2_nextORpreviousHop);
 5128              		.loc 1 2357 0
 5129 22de 7B68     		ldr	r3, [r7, #4]
 5130 22e0 03F12C02 		add	r2, r3, #44
 5131 22e4 3B68     		ldr	r3, [r7, #0]
 5132 22e6 03F13803 		add	r3, r3, #56
 5133 22ea 1046     		mov	r0, r2
 5134 22ec 1946     		mov	r1, r3
 5135 22ee FFF7FEFF 		bl	packetfunctions_sameAddress
 5136 22f2 0346     		mov	r3, r0
2356:openstack/02a-MAClow/IEEE802154Ecsl.c ****           idmanager_isMyAddress(&ieee802514_header->dest)                                          
 5137              		.loc 1 2356 0
 5138 22f4 002B     		cmp	r3, #0
 5139 22f6 02D0     		beq	.L245
2356:openstack/02a-MAClow/IEEE802154Ecsl.c ****           idmanager_isMyAddress(&ieee802514_header->dest)                                          
 5140              		.loc 1 2356 0 is_stmt 0 discriminator 2
 5141 22f8 4FF00103 		mov	r3, #1
 5142 22fc 01E0     		b	.L246
 5143              	.L245:
2356:openstack/02a-MAClow/IEEE802154Ecsl.c ****           idmanager_isMyAddress(&ieee802514_header->dest)                                          
 5144              		.loc 1 2356 0 discriminator 1
 5145 22fe 4FF00003 		mov	r3, #0
 5146              	.L246:
2353:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee802514_header->valid==TRUE                                                           
 5147              		.loc 1 2353 0 is_stmt 1
 5148 2302 03F00103 		and	r3, r3, #1
 5149 2306 DBB2     		uxtb	r3, r3
2358:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5150              		.loc 1 2358 0
 5151 2308 1846     		mov	r0, r3
 5152 230a 07F10C07 		add	r7, r7, #12
 5153 230e BD46     		mov	sp, r7
 5154 2310 90BD     		pop	{r4, r7, pc}
 5155              		.cfi_endproc
 5156              	.LFE56:
 5158 2312 00BF     		.align	2
 5159              		.global	incrementAsnOffset
 5160              		.thumb
 5161              		.thumb_func
 5163              	incrementAsnOffset:
 5164              	.LFB57:
2359:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2360:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2361:openstack/02a-MAClow/IEEE802154Ecsl.c **** //========================  ASN HANDLING ===============================
2362:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2363:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2364:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void incrementAsnOffset() {
 5165              		.loc 1 2364 0
 5166              		.cfi_startproc
 5167              		@ args = 0, pretend = 0, frame = 0
 5168              		@ frame_needed = 1, uses_anonymous_args = 0
 5169 2314 98B5     		push	{r3, r4, r7, lr}
 5170              	.LCFI136:
 5171              		.cfi_def_cfa_offset 16
 5172              		.cfi_offset 3, -16
 5173              		.cfi_offset 4, -12
 5174              		.cfi_offset 7, -8
 5175              		.cfi_offset 14, -4
 5176 2316 00AF     		add	r7, sp, #0
 5177              	.LCFI137:
 5178              		.cfi_def_cfa_register 7
2365:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // increment the asn
2366:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asn.bytes0and1++;
 5179              		.loc 1 2366 0
 5180 2318 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5181 231c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5182 2320 B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 5183 2324 9BB2     		uxth	r3, r3
 5184 2326 03F10103 		add	r3, r3, #1
 5185 232a 9AB2     		uxth	r2, r3
 5186 232c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5187 2330 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5188 2334 A3F80320 		strh	r2, [r3, #3]	@ unaligned
2367:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.asn.bytes0and1==0) {
 5189              		.loc 1 2367 0
 5190 2338 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5191 233c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5192 2340 B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 5193 2344 9BB2     		uxth	r3, r3
 5194 2346 002B     		cmp	r3, #0
 5195 2348 25D1     		bne	.L249
2368:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.asn.bytes2and3++;
 5196              		.loc 1 2368 0
 5197 234a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5198 234e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5199 2352 B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 5200 2356 9BB2     		uxth	r3, r3
 5201 2358 03F10103 		add	r3, r3, #1
 5202 235c 9AB2     		uxth	r2, r3
 5203 235e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5204 2362 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5205 2366 A3F80120 		strh	r2, [r3, #1]	@ unaligned
2369:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.asn.bytes2and3==0) {
 5206              		.loc 1 2369 0
 5207 236a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5208 236e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5209 2372 B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 5210 2376 9BB2     		uxth	r3, r3
 5211 2378 002B     		cmp	r3, #0
 5212 237a 0CD1     		bne	.L249
2370:openstack/02a-MAClow/IEEE802154Ecsl.c ****          ieee154e_vars.asn.byte4++;
 5213              		.loc 1 2370 0
 5214 237c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5215 2380 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5216 2384 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 5217 2386 03F10103 		add	r3, r3, #1
 5218 238a DAB2     		uxtb	r2, r3
 5219 238c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5220 2390 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5221 2394 1A70     		strb	r2, [r3, #0]
 5222              	.L249:
2371:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
2372:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2373:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // increment the offsets: Comment slot offset update.
2374:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.slotOffset  = (ieee154e_vars.slotOffset+1)%schedule_getFrameLength();
 5223              		.loc 1 2374 0
 5224 2396 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5225 239a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5226 239e DB88     		ldrh	r3, [r3, #6]
 5227 23a0 03F10104 		add	r4, r3, #1
 5228 23a4 FFF7FEFF 		bl	schedule_getFrameLength
 5229 23a8 0346     		mov	r3, r0
 5230 23aa 94FBF3F2 		sdiv	r2, r4, r3
 5231 23ae 03FB02F3 		mul	r3, r3, r2
 5232 23b2 E31A     		subs	r3, r4, r3
 5233 23b4 9AB2     		uxth	r2, r3
 5234 23b6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5235 23ba C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5236 23be DA80     		strh	r2, [r3, #6]	@ movhi
2375:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asnOffset   = (ieee154e_vars.asnOffset+1)%16;
 5237              		.loc 1 2375 0
 5238 23c0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5239 23c4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5240 23c8 93F82D30 		ldrb	r3, [r3, #45]	@ zero_extendqisi2
 5241 23cc 03F10102 		add	r2, r3, #1
 5242 23d0 4FF00F03 		mov	r3, #15
 5243 23d4 C8F20003 		movt	r3, 32768
 5244 23d8 1340     		ands	r3, r3, r2
 5245 23da 002B     		cmp	r3, #0
 5246 23dc 05DA     		bge	.L250
 5247 23de 03F1FF33 		add	r3, r3, #-1
 5248 23e2 63F00F03 		orn	r3, r3, #15
 5249 23e6 03F10103 		add	r3, r3, #1
 5250              	.L250:
 5251 23ea DAB2     		uxtb	r2, r3
 5252 23ec 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5253 23f0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5254 23f4 83F82D20 		strb	r2, [r3, #45]
2376:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5255              		.loc 1 2376 0
 5256 23f8 98BD     		pop	{r3, r4, r7, pc}
 5257              		.cfi_endproc
 5258              	.LFE57:
 5260 23fa 00BF     		.align	2
 5261              		.global	ieee154e_getAsn
 5262              		.thumb
 5263              		.thumb_func
 5265              	ieee154e_getAsn:
 5266              	.LFB58:
2377:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2378:openstack/02a-MAClow/IEEE802154Ecsl.c **** //from upper layer that want to send the ASN to compute timing or latency
2379:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void ieee154e_getAsn(uint8_t* array) {
 5267              		.loc 1 2379 0
 5268              		.cfi_startproc
 5269              		@ args = 0, pretend = 0, frame = 8
 5270              		@ frame_needed = 1, uses_anonymous_args = 0
 5271              		@ link register save eliminated.
 5272 23fc 80B4     		push	{r7}
 5273              	.LCFI138:
 5274              		.cfi_def_cfa_offset 4
 5275              		.cfi_offset 7, -4
 5276 23fe 83B0     		sub	sp, sp, #12
 5277              	.LCFI139:
 5278              		.cfi_def_cfa_offset 16
 5279 2400 00AF     		add	r7, sp, #0
 5280              	.LCFI140:
 5281              		.cfi_def_cfa_register 7
 5282 2402 7860     		str	r0, [r7, #4]
2380:openstack/02a-MAClow/IEEE802154Ecsl.c ****    array[0]         = (ieee154e_vars.asn.bytes0and1     & 0xff);
 5283              		.loc 1 2380 0
 5284 2404 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5285 2408 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5286 240c B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 5287 2410 9BB2     		uxth	r3, r3
 5288 2412 DAB2     		uxtb	r2, r3
 5289 2414 7B68     		ldr	r3, [r7, #4]
 5290 2416 1A70     		strb	r2, [r3, #0]
2381:openstack/02a-MAClow/IEEE802154Ecsl.c ****    array[1]         = (ieee154e_vars.asn.bytes0and1/256 & 0xff);
 5291              		.loc 1 2381 0
 5292 2418 7B68     		ldr	r3, [r7, #4]
 5293 241a 03F10102 		add	r2, r3, #1
 5294 241e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5295 2422 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5296 2426 B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 5297 242a 9BB2     		uxth	r3, r3
 5298 242c 4FEA1323 		lsr	r3, r3, #8
 5299 2430 9BB2     		uxth	r3, r3
 5300 2432 DBB2     		uxtb	r3, r3
 5301 2434 1370     		strb	r3, [r2, #0]
2382:openstack/02a-MAClow/IEEE802154Ecsl.c ****    array[2]         = (ieee154e_vars.asn.bytes2and3     & 0xff);
 5302              		.loc 1 2382 0
 5303 2436 7B68     		ldr	r3, [r7, #4]
 5304 2438 03F10202 		add	r2, r3, #2
 5305 243c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5306 2440 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5307 2444 B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 5308 2448 9BB2     		uxth	r3, r3
 5309 244a DBB2     		uxtb	r3, r3
 5310 244c 1370     		strb	r3, [r2, #0]
2383:openstack/02a-MAClow/IEEE802154Ecsl.c ****    array[3]         = (ieee154e_vars.asn.bytes2and3/256 & 0xff);
 5311              		.loc 1 2383 0
 5312 244e 7B68     		ldr	r3, [r7, #4]
 5313 2450 03F10302 		add	r2, r3, #3
 5314 2454 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5315 2458 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5316 245c B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 5317 2460 9BB2     		uxth	r3, r3
 5318 2462 4FEA1323 		lsr	r3, r3, #8
 5319 2466 9BB2     		uxth	r3, r3
 5320 2468 DBB2     		uxtb	r3, r3
 5321 246a 1370     		strb	r3, [r2, #0]
2384:openstack/02a-MAClow/IEEE802154Ecsl.c ****    array[4]         =  ieee154e_vars.asn.byte4;
 5322              		.loc 1 2384 0
 5323 246c 7B68     		ldr	r3, [r7, #4]
 5324 246e 03F10402 		add	r2, r3, #4
 5325 2472 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5326 2476 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5327 247a 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 5328 247c 1370     		strb	r3, [r2, #0]
2385:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5329              		.loc 1 2385 0
 5330 247e 07F10C07 		add	r7, r7, #12
 5331 2482 BD46     		mov	sp, r7
 5332 2484 80BC     		pop	{r7}
 5333 2486 7047     		bx	lr
 5334              		.cfi_endproc
 5335              	.LFE58:
 5337              		.align	2
 5338              		.global	synchronizeAck
 5339              		.thumb
 5340              		.thumb_func
 5342              	synchronizeAck:
 5343              	.LFB59:
2386:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2387:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2388:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================  SYNCHRONIZATION ==============================
2389:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2390:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2391:openstack/02a-MAClow/IEEE802154Ecsl.c **** void synchronizeAck(PORT_SIGNED_INT_WIDTH timeCorrection) {
 5344              		.loc 1 2391 0
 5345              		.cfi_startproc
 5346              		@ args = 0, pretend = 0, frame = 16
 5347              		@ frame_needed = 1, uses_anonymous_args = 0
 5348 2488 90B5     		push	{r4, r7, lr}
 5349              	.LCFI141:
 5350              		.cfi_def_cfa_offset 12
 5351              		.cfi_offset 4, -12
 5352              		.cfi_offset 7, -8
 5353              		.cfi_offset 14, -4
 5354 248a 87B0     		sub	sp, sp, #28
 5355              	.LCFI142:
 5356              		.cfi_def_cfa_offset 40
 5357 248c 02AF     		add	r7, sp, #8
 5358              	.LCFI143:
 5359              		.cfi_def_cfa 7, 32
 5360 248e 7860     		str	r0, [r7, #4]
2392:openstack/02a-MAClow/IEEE802154Ecsl.c ****    PORT_RADIOTIMER_WIDTH newPeriod;
2393:openstack/02a-MAClow/IEEE802154Ecsl.c ****    PORT_RADIOTIMER_WIDTH currentPeriod;
2394:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
2395:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // calculate new period
2396:openstack/02a-MAClow/IEEE802154Ecsl.c ****    currentPeriod                  =  radio_getTimerPeriod();
 5361              		.loc 1 2396 0
 5362 2490 FFF7FEFF 		bl	radio_getTimerPeriod
 5363 2494 F860     		str	r0, [r7, #12]
2397:openstack/02a-MAClow/IEEE802154Ecsl.c ****    newPeriod                      =  (PORT_RADIOTIMER_WIDTH)((PORT_SIGNED_INT_WIDTH)currentPeriod-t
 5364              		.loc 1 2397 0
 5365 2496 FA68     		ldr	r2, [r7, #12]
 5366 2498 7B68     		ldr	r3, [r7, #4]
 5367 249a D31A     		subs	r3, r2, r3
 5368 249c BB60     		str	r3, [r7, #8]
2398:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2399:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // resynchronize by applying the new period
2400:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_setTimerPeriod(newPeriod);
 5369              		.loc 1 2400 0
 5370 249e B868     		ldr	r0, [r7, #8]
 5371 24a0 FFF7FEFF 		bl	radio_setTimerPeriod
2401:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
2402:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // reset the de-synchronization timeout
2403:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.deSyncTimeout    = DESYNCTIMEOUT;
 5372              		.loc 1 2403 0
 5373 24a4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5374 24a8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5375 24ac 40F61D12 		movw	r2, #2333
 5376 24b0 DA60     		str	r2, [r3, #12]
2404:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
2405:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // indicate time correction to adaptive sync module
2406:openstack/02a-MAClow/IEEE802154Ecsl.c ****    adaptive_sync_indicateTimeCorrection((-timeCorrection),ieee154e_vars.ackReceived->l2_nextORprevi
 5377              		.loc 1 2406 0
 5378 24b2 7B68     		ldr	r3, [r7, #4]
 5379 24b4 9BB2     		uxth	r3, r3
 5380 24b6 C3F10003 		rsb	r3, r3, #0
 5381 24ba 9BB2     		uxth	r3, r3
 5382 24bc 99B2     		uxth	r1, r3
 5383 24be 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5384 24c2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5385 24c6 1A6A     		ldr	r2, [r3, #32]
 5386 24c8 0CB2     		sxth	r4, r1
 5387 24ca 6B46     		mov	r3, sp
 5388 24cc 02F14401 		add	r1, r2, #68
 5389 24d0 03C9     		ldmia	r1, {r0, r1}
 5390 24d2 1860     		str	r0, [r3, #0]
 5391 24d4 03F10403 		add	r3, r3, #4
 5392 24d8 1970     		strb	r1, [r3, #0]
 5393 24da 02F13803 		add	r3, r2, #56
 5394 24de 0ECB     		ldmia	r3, {r1, r2, r3}
 5395 24e0 2046     		mov	r0, r4
 5396 24e2 FFF7FEFF 		bl	adaptive_sync_indicateTimeCorrection
2407:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
2408:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log a large timeCorrection
2409:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (
2410:openstack/02a-MAClow/IEEE802154Ecsl.c ****          ieee154e_vars.isSync==TRUE &&
 5397              		.loc 1 2410 0
 5398 24e6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5399 24ea C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5400 24ee 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
2409:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (
 5401              		.loc 1 2409 0
 5402 24f0 002B     		cmp	r3, #0
 5403 24f2 11D0     		beq	.L253
 5404              		.loc 1 2410 0
 5405 24f4 7B68     		ldr	r3, [r7, #4]
 5406 24f6 13F1050F 		cmn	r3, #5
 5407 24fa 02DB     		blt	.L254
2411:openstack/02a-MAClow/IEEE802154Ecsl.c ****          (
2412:openstack/02a-MAClow/IEEE802154Ecsl.c ****             timeCorrection<-LIMITLARGETIMECORRECTION ||
 5408              		.loc 1 2412 0
 5409 24fc 7B68     		ldr	r3, [r7, #4]
 5410 24fe 052B     		cmp	r3, #5
 5411 2500 0ADD     		ble	.L253
 5412              	.L254:
2413:openstack/02a-MAClow/IEEE802154Ecsl.c ****             timeCorrection> LIMITLARGETIMECORRECTION
2414:openstack/02a-MAClow/IEEE802154Ecsl.c ****          )
2415:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ) {
2416:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openserial_printError(COMPONENT_IEEE802154E,ERR_LARGE_TIMECORRECTION,
 5413              		.loc 1 2416 0
 5414 2502 7B68     		ldr	r3, [r7, #4]
 5415 2504 9BB2     		uxth	r3, r3
 5416 2506 4FF00900 		mov	r0, #9
 5417 250a 4FF01C01 		mov	r1, #28
 5418 250e 1A46     		mov	r2, r3
 5419 2510 4FF00103 		mov	r3, #1
 5420 2514 FFF7FEFF 		bl	openserial_printError
 5421              	.L253:
2417:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)timeCorrection,
2418:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)1);
2419:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2420:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // update the stats
2421:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.numSyncAck++;
 5422              		.loc 1 2421 0
 5423 2518 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5424 251c C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5425 2520 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 5426 2522 03F10103 		add	r3, r3, #1
 5427 2526 DAB2     		uxtb	r2, r3
 5428 2528 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5429 252c C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5430 2530 5A70     		strb	r2, [r3, #1]
2422:openstack/02a-MAClow/IEEE802154Ecsl.c ****    updateStats(timeCorrection);
 5431              		.loc 1 2422 0
 5432 2532 7868     		ldr	r0, [r7, #4]
 5433 2534 FFF7FEFF 		bl	updateStats
2423:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
2424:openstack/02a-MAClow/IEEE802154Ecsl.c **** #ifdef OPENSIM
2425:openstack/02a-MAClow/IEEE802154Ecsl.c ****    debugpins_syncAck_set();
2426:openstack/02a-MAClow/IEEE802154Ecsl.c ****    debugpins_syncAck_clr();
2427:openstack/02a-MAClow/IEEE802154Ecsl.c **** #endif
2428:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5434              		.loc 1 2428 0
 5435 2538 07F11407 		add	r7, r7, #20
 5436 253c BD46     		mov	sp, r7
 5437 253e 90BD     		pop	{r4, r7, pc}
 5438              		.cfi_endproc
 5439              	.LFE59:
 5441              		.align	2
 5442              		.global	changeIsSync
 5443              		.thumb
 5444              		.thumb_func
 5446              	changeIsSync:
 5447              	.LFB60:
2429:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2430:openstack/02a-MAClow/IEEE802154Ecsl.c **** void changeIsSync(bool newIsSync) {
 5448              		.loc 1 2430 0
 5449              		.cfi_startproc
 5450              		@ args = 0, pretend = 0, frame = 8
 5451              		@ frame_needed = 1, uses_anonymous_args = 0
 5452 2540 80B5     		push	{r7, lr}
 5453              	.LCFI144:
 5454              		.cfi_def_cfa_offset 8
 5455              		.cfi_offset 7, -8
 5456              		.cfi_offset 14, -4
 5457 2542 82B0     		sub	sp, sp, #8
 5458              	.LCFI145:
 5459              		.cfi_def_cfa_offset 16
 5460 2544 00AF     		add	r7, sp, #0
 5461              	.LCFI146:
 5462              		.cfi_def_cfa_register 7
 5463 2546 0346     		mov	r3, r0
 5464 2548 FB71     		strb	r3, [r7, #7]
2431:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.isSync = newIsSync;
 5465              		.loc 1 2431 0
 5466 254a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5467 254e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5468 2552 FA79     		ldrb	r2, [r7, #7]
 5469 2554 1A74     		strb	r2, [r3, #16]
2432:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
2433:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.isSync==TRUE) {
 5470              		.loc 1 2433 0
 5471 2556 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5472 255a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5473 255e 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
 5474 2560 002B     		cmp	r3, #0
 5475 2562 04D0     		beq	.L256
2434:openstack/02a-MAClow/IEEE802154Ecsl.c ****       leds_sync_on();
 5476              		.loc 1 2434 0
 5477 2564 FFF7FEFF 		bl	leds_sync_on
2435:openstack/02a-MAClow/IEEE802154Ecsl.c ****       resetStats();
 5478              		.loc 1 2435 0
 5479 2568 FFF7FEFF 		bl	resetStats
 5480 256c 03E0     		b	.L255
 5481              	.L256:
2436:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
2437:openstack/02a-MAClow/IEEE802154Ecsl.c ****       leds_sync_off();
 5482              		.loc 1 2437 0
 5483 256e FFF7FEFF 		bl	leds_sync_off
2438:openstack/02a-MAClow/IEEE802154Ecsl.c ****       schedule_resetBackoff();
 5484              		.loc 1 2438 0
 5485 2572 FFF7FEFF 		bl	schedule_resetBackoff
 5486              	.L255:
2439:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2440:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5487              		.loc 1 2440 0
 5488 2576 07F10807 		add	r7, r7, #8
 5489 257a BD46     		mov	sp, r7
 5490 257c 80BD     		pop	{r7, pc}
 5491              		.cfi_endproc
 5492              	.LFE60:
 5494 257e 00BF     		.align	2
 5495              		.global	notif_sendDone
 5496              		.thumb
 5497              		.thumb_func
 5499              	notif_sendDone:
 5500              	.LFB61:
2441:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2442:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2443:openstack/02a-MAClow/IEEE802154Ecsl.c **** //=====================  NOTIFY UPPER LAYER  ===========================
2444:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2445:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2446:openstack/02a-MAClow/IEEE802154Ecsl.c **** void notif_sendDone(OpenQueueEntry_t* packetSent, owerror_t error) {
 5501              		.loc 1 2446 0
 5502              		.cfi_startproc
 5503              		@ args = 0, pretend = 0, frame = 8
 5504              		@ frame_needed = 1, uses_anonymous_args = 0
 5505 2580 80B5     		push	{r7, lr}
 5506              	.LCFI147:
 5507              		.cfi_def_cfa_offset 8
 5508              		.cfi_offset 7, -8
 5509              		.cfi_offset 14, -4
 5510 2582 82B0     		sub	sp, sp, #8
 5511              	.LCFI148:
 5512              		.cfi_def_cfa_offset 16
 5513 2584 00AF     		add	r7, sp, #0
 5514              	.LCFI149:
 5515              		.cfi_def_cfa_register 7
 5516 2586 7860     		str	r0, [r7, #4]
 5517 2588 0B46     		mov	r3, r1
 5518 258a FB70     		strb	r3, [r7, #3]
2447:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the outcome of the trasmission attempt
2448:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packetSent->l2_sendDoneError   = error;
 5519              		.loc 1 2448 0
 5520 258c 7B68     		ldr	r3, [r7, #4]
 5521 258e FA78     		ldrb	r2, [r7, #3]
 5522 2590 83F83720 		strb	r2, [r3, #55]
2449:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the current ASN
2450:openstack/02a-MAClow/IEEE802154Ecsl.c ****    memcpy(&packetSent->l2_asn,&ieee154e_vars.asn,sizeof(asn_t));
 5523              		.loc 1 2450 0
 5524 2594 7B68     		ldr	r3, [r7, #4]
 5525 2596 03F14D02 		add	r2, r3, #77
 5526 259a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5527 259e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5528 25a2 1868     		ldr	r0, [r3, #0]	@ unaligned
 5529 25a4 1060     		str	r0, [r2, #0]	@ unaligned
 5530 25a6 1B79     		ldrb	r3, [r3, #4]
 5531 25a8 1371     		strb	r3, [r2, #4]
2451:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // associate this packet with the virtual component
2452:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // COMPONENT_IEEE802154E_TO_RES so RES can knows it's for it
2453:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packetSent->owner              = COMPONENT_IEEE802154E_TO_SIXTOP;
 5532              		.loc 1 2453 0
 5533 25aa 7B68     		ldr	r3, [r7, #4]
 5534 25ac 4FF00B02 		mov	r2, #11
 5535 25b0 5A70     		strb	r2, [r3, #1]
2454:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // post RES's sendDone task
2455:openstack/02a-MAClow/IEEE802154Ecsl.c ****    scheduler_push_task(task_sixtopNotifSendDone,TASKPRIO_SIXTOP_NOTIF_TXDONE);
 5536              		.loc 1 2455 0
 5537 25b2 40F20000 		movw	r0, #:lower16:task_sixtopNotifSendDone
 5538 25b6 C0F20000 		movt	r0, #:upper16:task_sixtopNotifSendDone
 5539 25ba 4FF00201 		mov	r1, #2
 5540 25be FFF7FEFF 		bl	scheduler_push_task
2456:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // wake up the scheduler
2457:openstack/02a-MAClow/IEEE802154Ecsl.c ****    SCHEDULER_WAKEUP();
2458:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5541              		.loc 1 2458 0
 5542 25c2 07F10807 		add	r7, r7, #8
 5543 25c6 BD46     		mov	sp, r7
 5544 25c8 80BD     		pop	{r7, pc}
 5545              		.cfi_endproc
 5546              	.LFE61:
 5548 25ca 00BF     		.align	2
 5549              		.global	notif_receive
 5550              		.thumb
 5551              		.thumb_func
 5553              	notif_receive:
 5554              	.LFB62:
2459:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2460:openstack/02a-MAClow/IEEE802154Ecsl.c **** // Modified notif_receive signature to add action for CSL testing purposes.
2461:openstack/02a-MAClow/IEEE802154Ecsl.c **** // Packet is removed on endOps in order to not fill all the slots on queue due
2462:openstack/02a-MAClow/IEEE802154Ecsl.c **** // to no sixtop action is defined for receive and process incoming packets.
2463:openstack/02a-MAClow/IEEE802154Ecsl.c **** // Then, we comment this actions here and add remove packet on endOps method.
2464:openstack/02a-MAClow/IEEE802154Ecsl.c **** void notif_receive(OpenQueueEntry_t* packetReceived, uint8_t action) {
 5555              		.loc 1 2464 0
 5556              		.cfi_startproc
 5557              		@ args = 0, pretend = 0, frame = 8
 5558              		@ frame_needed = 1, uses_anonymous_args = 0
 5559 25cc 80B5     		push	{r7, lr}
 5560              	.LCFI150:
 5561              		.cfi_def_cfa_offset 8
 5562              		.cfi_offset 7, -8
 5563              		.cfi_offset 14, -4
 5564 25ce 82B0     		sub	sp, sp, #8
 5565              	.LCFI151:
 5566              		.cfi_def_cfa_offset 16
 5567 25d0 00AF     		add	r7, sp, #0
 5568              	.LCFI152:
 5569              		.cfi_def_cfa_register 7
 5570 25d2 7860     		str	r0, [r7, #4]
 5571 25d4 0B46     		mov	r3, r1
 5572 25d6 FB70     		strb	r3, [r7, #3]
2465:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2466:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // [CSL-TEST]: comment and add led (orange) blink if OK or led (red) toggle if KO.
2467:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2468:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the current ASN
2469:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //memcpy(&packetReceived->l2_asn, &ieee154e_vars.asn, sizeof(asn_t));
2470:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2471:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // indicate reception to the schedule, to keep statistics
2472:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //schedule_indicateRx(&packetReceived->l2_asn);
2473:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2474:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // associate this packet with the virtual component
2475:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // COMPONENT_IEEE802154E_TO_SIXTOP so sixtop can knows it's for it
2476:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //packetReceived->owner          = COMPONENT_IEEE802154E_TO_SIXTOP;
2477:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2478:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // post RES's Receive task
2479:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //scheduler_push_task(task_sixtopNotifReceive,TASKPRIO_SIXTOP_NOTIF_RX);
2480:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2481:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (action == 1)
 5573              		.loc 1 2481 0
 5574 25d8 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 5575 25da 012B     		cmp	r3, #1
 5576 25dc 02D1     		bne	.L260
2482:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	leds_sync_blink();
 5577              		.loc 1 2482 0
 5578 25de FFF7FEFF 		bl	leds_sync_blink
 5579 25e2 01E0     		b	.L259
 5580              	.L260:
2483:openstack/02a-MAClow/IEEE802154Ecsl.c ****    else
2484:openstack/02a-MAClow/IEEE802154Ecsl.c ****     leds_error_toggle();
 5581              		.loc 1 2484 0
 5582 25e4 FFF7FEFF 		bl	leds_error_toggle
 5583              	.L259:
2485:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2486:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // [CSL-TEST]: end test code
2487:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2488:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // wake up the scheduler
2489:openstack/02a-MAClow/IEEE802154Ecsl.c ****    SCHEDULER_WAKEUP();
2490:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5584              		.loc 1 2490 0
 5585 25e8 07F10807 		add	r7, r7, #8
 5586 25ec BD46     		mov	sp, r7
 5587 25ee 80BD     		pop	{r7, pc}
 5588              		.cfi_endproc
 5589              	.LFE62:
 5591              		.align	2
 5592              		.global	resetStats
 5593              		.thumb
 5594              		.thumb_func
 5596              	resetStats:
 5597              	.LFB63:
2491:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2492:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2493:openstack/02a-MAClow/IEEE802154Ecsl.c **** //============================== STATS =================================
2494:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2495:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2496:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void resetStats() {
 5598              		.loc 1 2496 0
 5599              		.cfi_startproc
 5600              		@ args = 0, pretend = 0, frame = 0
 5601              		@ frame_needed = 1, uses_anonymous_args = 0
 5602              		@ link register save eliminated.
 5603 25f0 80B4     		push	{r7}
 5604              	.LCFI153:
 5605              		.cfi_def_cfa_offset 4
 5606              		.cfi_offset 7, -4
 5607 25f2 00AF     		add	r7, sp, #0
 5608              	.LCFI154:
 5609              		.cfi_def_cfa_register 7
2497:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.numSyncPkt      =    0;
 5610              		.loc 1 2497 0
 5611 25f4 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5612 25f8 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5613 25fc 4FF00002 		mov	r2, #0
 5614 2600 1A70     		strb	r2, [r3, #0]
2498:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.numSyncAck      =    0;
 5615              		.loc 1 2498 0
 5616 2602 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5617 2606 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5618 260a 4FF00002 		mov	r2, #0
 5619 260e 5A70     		strb	r2, [r3, #1]
2499:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.minCorrection   =  127;
 5620              		.loc 1 2499 0
 5621 2610 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5622 2614 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5623 2618 4FF07F02 		mov	r2, #127
 5624 261c 5A80     		strh	r2, [r3, #2]	@ movhi
2500:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.maxCorrection   = -127;
 5625              		.loc 1 2500 0
 5626 261e 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5627 2622 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5628 2626 4FF68172 		movw	r2, #65409
 5629 262a 9A80     		strh	r2, [r3, #4]	@ movhi
2501:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.numTicsOn       =    0;
 5630              		.loc 1 2501 0
 5631 262c 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5632 2630 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5633 2634 4FF00002 		mov	r2, #0
 5634 2638 DA71     		strb	r2, [r3, #7]
 5635 263a 9A68     		ldr	r2, [r3, #8]
 5636 263c 02F07F42 		and	r2, r2, #-16777216
 5637 2640 9A60     		str	r2, [r3, #8]
2502:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.numTicsTotal    =    0;
 5638              		.loc 1 2502 0
 5639 2642 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5640 2646 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5641 264a 4FF00002 		mov	r2, #0
 5642 264e DA72     		strb	r2, [r3, #11]
 5643 2650 DA68     		ldr	r2, [r3, #12]
 5644 2652 02F07F42 		and	r2, r2, #-16777216
 5645 2656 DA60     		str	r2, [r3, #12]
2503:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // do not reset the number of de-synchronizations
2504:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5646              		.loc 1 2504 0
 5647 2658 BD46     		mov	sp, r7
 5648 265a 80BC     		pop	{r7}
 5649 265c 7047     		bx	lr
 5650              		.cfi_endproc
 5651              	.LFE63:
 5653 265e 00BF     		.align	2
 5654              		.global	updateStats
 5655              		.thumb
 5656              		.thumb_func
 5658              	updateStats:
 5659              	.LFB64:
2505:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2506:openstack/02a-MAClow/IEEE802154Ecsl.c **** void updateStats(PORT_SIGNED_INT_WIDTH timeCorrection) {
 5660              		.loc 1 2506 0
 5661              		.cfi_startproc
 5662              		@ args = 0, pretend = 0, frame = 8
 5663              		@ frame_needed = 1, uses_anonymous_args = 0
 5664              		@ link register save eliminated.
 5665 2660 80B4     		push	{r7}
 5666              	.LCFI155:
 5667              		.cfi_def_cfa_offset 4
 5668              		.cfi_offset 7, -4
 5669 2662 83B0     		sub	sp, sp, #12
 5670              	.LCFI156:
 5671              		.cfi_def_cfa_offset 16
 5672 2664 00AF     		add	r7, sp, #0
 5673              	.LCFI157:
 5674              		.cfi_def_cfa_register 7
 5675 2666 7860     		str	r0, [r7, #4]
2507:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // update minCorrection
2508:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (timeCorrection<ieee154e_stats.minCorrection) {
 5676              		.loc 1 2508 0
 5677 2668 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5678 266c C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5679 2670 5B88     		ldrh	r3, [r3, #2]
 5680 2672 1AB2     		sxth	r2, r3
 5681 2674 7B68     		ldr	r3, [r7, #4]
 5682 2676 9A42     		cmp	r2, r3
 5683 2678 06DD     		ble	.L264
2509:openstack/02a-MAClow/IEEE802154Ecsl.c ****      ieee154e_stats.minCorrection = timeCorrection;
 5684              		.loc 1 2509 0
 5685 267a 7B68     		ldr	r3, [r7, #4]
 5686 267c 9AB2     		uxth	r2, r3
 5687 267e 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5688 2682 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5689 2686 5A80     		strh	r2, [r3, #2]	@ movhi
 5690              	.L264:
2510:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2511:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // update maxConnection
2512:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if(timeCorrection>ieee154e_stats.maxCorrection) {
 5691              		.loc 1 2512 0
 5692 2688 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5693 268c C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5694 2690 9B88     		ldrh	r3, [r3, #4]
 5695 2692 1AB2     		sxth	r2, r3
 5696 2694 7B68     		ldr	r3, [r7, #4]
 5697 2696 9A42     		cmp	r2, r3
 5698 2698 06DA     		bge	.L263
2513:openstack/02a-MAClow/IEEE802154Ecsl.c ****      ieee154e_stats.maxCorrection = timeCorrection;
 5699              		.loc 1 2513 0
 5700 269a 7B68     		ldr	r3, [r7, #4]
 5701 269c 9AB2     		uxth	r2, r3
 5702 269e 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5703 26a2 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5704 26a6 9A80     		strh	r2, [r3, #4]	@ movhi
 5705              	.L263:
2514:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2515:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5706              		.loc 1 2515 0
 5707 26a8 07F10C07 		add	r7, r7, #12
 5708 26ac BD46     		mov	sp, r7
 5709 26ae 80BC     		pop	{r7}
 5710 26b0 7047     		bx	lr
 5711              		.cfi_endproc
 5712              	.LFE64:
 5714 26b2 00BF     		.align	2
 5715              		.global	changeState
 5716              		.thumb
 5717              		.thumb_func
 5719              	changeState:
 5720              	.LFB65:
2516:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2517:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2518:openstack/02a-MAClow/IEEE802154Ecsl.c **** //============================== MISC ==================================
2519:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2520:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2521:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2522:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Changes the state of the IEEE802.15.4e FSM.
2523:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2524:openstack/02a-MAClow/IEEE802154Ecsl.c **** Besides simply updating the state global variable,
2525:openstack/02a-MAClow/IEEE802154Ecsl.c **** this function toggles the FSM debug pin.
2526:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2527:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in] newstate The state the IEEE802.15.4e FSM is now in.
2528:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2529:openstack/02a-MAClow/IEEE802154Ecsl.c **** void changeState(ieee154e_state_t newstate) {
 5721              		.loc 1 2529 0
 5722              		.cfi_startproc
 5723              		@ args = 0, pretend = 0, frame = 8
 5724              		@ frame_needed = 1, uses_anonymous_args = 0
 5725 26b4 80B5     		push	{r7, lr}
 5726              	.LCFI158:
 5727              		.cfi_def_cfa_offset 8
 5728              		.cfi_offset 7, -8
 5729              		.cfi_offset 14, -4
 5730 26b6 82B0     		sub	sp, sp, #8
 5731              	.LCFI159:
 5732              		.cfi_def_cfa_offset 16
 5733 26b8 00AF     		add	r7, sp, #0
 5734              	.LCFI160:
 5735              		.cfi_def_cfa_register 7
 5736 26ba 0346     		mov	r3, r0
 5737 26bc FB71     		strb	r3, [r7, #7]
2530:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // update the state
2531:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.state = newstate;
 5738              		.loc 1 2531 0
 5739 26be 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5740 26c2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5741 26c6 FA79     		ldrb	r2, [r7, #7]
 5742 26c8 5A74     		strb	r2, [r3, #17]
2532:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // wiggle the FSM debug pin
2533:openstack/02a-MAClow/IEEE802154Ecsl.c ****    switch (ieee154e_vars.state) {
 5743              		.loc 1 2533 0
 5744 26ca 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5745 26ce C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5746 26d2 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 5747 26d4 3B2B     		cmp	r3, #59
 5748 26d6 00F28480 		bhi	.L266
 5749 26da 01A2     		adr	r2, .L271
 5750 26dc 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 5751              		.align	2
 5752              	.L271:
 5753 26e0 D7270000 		.word	.L268+1
 5754 26e4 E3270000 		.word	.L266+1
 5755 26e8 E3270000 		.word	.L266+1
 5756 26ec E3270000 		.word	.L266+1
 5757 26f0 E3270000 		.word	.L266+1
 5758 26f4 E3270000 		.word	.L266+1
 5759 26f8 E3270000 		.word	.L266+1
 5760 26fc E3270000 		.word	.L266+1
 5761 2700 E3270000 		.word	.L266+1
 5762 2704 E3270000 		.word	.L266+1
 5763 2708 E3270000 		.word	.L266+1
 5764 270c E3270000 		.word	.L266+1
 5765 2710 E3270000 		.word	.L266+1
 5766 2714 E3270000 		.word	.L266+1
 5767 2718 E3270000 		.word	.L266+1
 5768 271c E3270000 		.word	.L266+1
 5769 2720 E3270000 		.word	.L266+1
 5770 2724 E3270000 		.word	.L266+1
 5771 2728 E3270000 		.word	.L266+1
 5772 272c E3270000 		.word	.L266+1
 5773 2730 E3270000 		.word	.L266+1
 5774 2734 E3270000 		.word	.L266+1
 5775 2738 E3270000 		.word	.L266+1
 5776 273c E3270000 		.word	.L266+1
 5777 2740 E3270000 		.word	.L266+1
 5778 2744 E3270000 		.word	.L266+1
 5779 2748 D1270000 		.word	.L269+1
 5780 274c DD270000 		.word	.L270+1
 5781 2750 DD270000 		.word	.L270+1
 5782 2754 DD270000 		.word	.L270+1
 5783 2758 DD270000 		.word	.L270+1
 5784 275c D1270000 		.word	.L269+1
 5785 2760 D1270000 		.word	.L269+1
 5786 2764 DD270000 		.word	.L270+1
 5787 2768 DD270000 		.word	.L270+1
 5788 276c DD270000 		.word	.L270+1
 5789 2770 DD270000 		.word	.L270+1
 5790 2774 DD270000 		.word	.L270+1
 5791 2778 DD270000 		.word	.L270+1
 5792 277c DD270000 		.word	.L270+1
 5793 2780 DD270000 		.word	.L270+1
 5794 2784 DD270000 		.word	.L270+1
 5795 2788 DD270000 		.word	.L270+1
 5796 278c D7270000 		.word	.L268+1
 5797 2790 DD270000 		.word	.L270+1
 5798 2794 DD270000 		.word	.L270+1
 5799 2798 DD270000 		.word	.L270+1
 5800 279c DD270000 		.word	.L270+1
 5801 27a0 DD270000 		.word	.L270+1
 5802 27a4 D7270000 		.word	.L268+1
 5803 27a8 DD270000 		.word	.L270+1
 5804 27ac DD270000 		.word	.L270+1
 5805 27b0 DD270000 		.word	.L270+1
 5806 27b4 DD270000 		.word	.L270+1
 5807 27b8 DD270000 		.word	.L270+1
 5808 27bc DD270000 		.word	.L270+1
 5809 27c0 DD270000 		.word	.L270+1
 5810 27c4 DD270000 		.word	.L270+1
 5811 27c8 DD270000 		.word	.L270+1
 5812 27cc DD270000 		.word	.L270+1
 5813              	.L269:
2534:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXWAKEUPOFFSET:
2535:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXDATAPREOFFSET:
2536:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXDATAOFFSET:
2537:openstack/02a-MAClow/IEEE802154Ecsl.c ****          debugpins_fsm_set();
 5814              		.loc 1 2537 0
 5815 27d0 FFF7FEFF 		bl	debugpins_fsm_set
2538:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 5816              		.loc 1 2538 0
 5817 27d4 05E0     		b	.L266
 5818              	.L268:
2539:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_SLEEP:
2540:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXDATAOFFSET:
2541:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXWAKEUPOFFSET:
2542:openstack/02a-MAClow/IEEE802154Ecsl.c ****          debugpins_fsm_clr();
 5819              		.loc 1 2542 0
 5820 27d6 FFF7FEFF 		bl	debugpins_fsm_clr
2543:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 5821              		.loc 1 2543 0
 5822 27da 02E0     		b	.L266
 5823              	.L270:
2544:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2545:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // ------- TX STATES -------
2546:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2547:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Estados usados para la transmisión de tramas WAKE-UP previas a la trama de datos (Wake-Up
2548:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXWAKEUPPREPARE:
2549:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXWAKEUPREADY:
2550:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXWAKEUPDELAY:
2551:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXWAKEUP:
2552:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2553:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Estados usados para la transmisión del paquete de datos y la recepción del ACK.
2554:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXDATAPREPARE:
2555:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXDATAREADY:
2556:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXDATADELAY:
2557:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXDATA:
2558:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2559:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXACKOFFSET:
2560:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXACKPREPARE:
2561:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXACKREADY:
2562:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXACKLISTEN:
2563:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXACK:
2564:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXPROC:
2565:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2566:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // ------- RX STATES -------
2567:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2568:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Estados usados para la recepción y tratamiento de la trama de WAKE-UP.
2569:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXWAKEUPPREPARE:
2570:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXWAKEUPREADY:
2571:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXWAKEUPLISTEN:
2572:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXWAKEUP:
2573:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXWAKEUPVALIDATE:
2574:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2575:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Estados usados para la recepción del paquete de datos y la transmisión del ACK.
2576:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXDATAPREPARE:
2577:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXDATAREADY:
2578:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXDATALISTEN:
2579:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXDATA:
2580:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2581:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXACKOFFSET:
2582:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXACKPREPARE:
2583:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXACKREADY:
2584:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXACKDELAY:
2585:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXACK:
2586:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXPROC:
2587:openstack/02a-MAClow/IEEE802154Ecsl.c ****          debugpins_fsm_toggle();
 5824              		.loc 1 2587 0
 5825 27dc FFF7FEFF 		bl	debugpins_fsm_toggle
2588:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 5826              		.loc 1 2588 0
 5827 27e0 00BF     		nop
 5828              	.L266:
2589:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2590:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5829              		.loc 1 2590 0
 5830 27e2 07F10807 		add	r7, r7, #8
 5831 27e6 BD46     		mov	sp, r7
 5832 27e8 80BD     		pop	{r7, pc}
 5833              		.cfi_endproc
 5834              	.LFE65:
 5836 27ea 00BF     		.align	2
 5837              		.global	debugPrint_asn
 5838              		.thumb
 5839              		.thumb_func
 5841              	debugPrint_asn:
 5842              	.LFB66:
2591:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2592:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2593:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Trigger this module to print status information, over serial.
2594:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2595:openstack/02a-MAClow/IEEE802154Ecsl.c **** debugPrint_* functions are used by the openserial module to continuously print
2596:openstack/02a-MAClow/IEEE802154Ecsl.c **** status information about several modules in the OpenWSN stack.
2597:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2598:openstack/02a-MAClow/IEEE802154Ecsl.c **** \returns TRUE if this function printed something, FALSE otherwise.
2599:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2600:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool debugPrint_asn() {
 5843              		.loc 1 2600 0
 5844              		.cfi_startproc
 5845              		@ args = 0, pretend = 0, frame = 8
 5846              		@ frame_needed = 1, uses_anonymous_args = 0
 5847 27ec 80B5     		push	{r7, lr}
 5848              	.LCFI161:
 5849              		.cfi_def_cfa_offset 8
 5850              		.cfi_offset 7, -8
 5851              		.cfi_offset 14, -4
 5852 27ee 82B0     		sub	sp, sp, #8
 5853              	.LCFI162:
 5854              		.cfi_def_cfa_offset 16
 5855 27f0 00AF     		add	r7, sp, #0
 5856              	.LCFI163:
 5857              		.cfi_def_cfa_register 7
2601:openstack/02a-MAClow/IEEE802154Ecsl.c ****    asn_t output;
2602:openstack/02a-MAClow/IEEE802154Ecsl.c ****    output.byte4         =  ieee154e_vars.asn.byte4;
 5858              		.loc 1 2602 0
 5859 27f2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5860 27f6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5861 27fa 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 5862 27fc 3B70     		strb	r3, [r7, #0]
2603:openstack/02a-MAClow/IEEE802154Ecsl.c ****    output.bytes2and3    =  ieee154e_vars.asn.bytes2and3;
 5863              		.loc 1 2603 0
 5864 27fe 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5865 2802 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5866 2806 B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 5867 280a 9BB2     		uxth	r3, r3
 5868 280c A7F80130 		strh	r3, [r7, #1]	@ unaligned
2604:openstack/02a-MAClow/IEEE802154Ecsl.c ****    output.bytes0and1    =  ieee154e_vars.asn.bytes0and1;
 5869              		.loc 1 2604 0
 5870 2810 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5871 2814 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5872 2818 B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 5873 281c 9BB2     		uxth	r3, r3
 5874 281e A7F80330 		strh	r3, [r7, #3]	@ unaligned
2605:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printStatus(STATUS_ASN,(uint8_t*)&output,sizeof(output));
 5875              		.loc 1 2605 0
 5876 2822 3B46     		mov	r3, r7
 5877 2824 4FF00400 		mov	r0, #4
 5878 2828 1946     		mov	r1, r3
 5879 282a 4FF00502 		mov	r2, #5
 5880 282e FFF7FEFF 		bl	openserial_printStatus
2606:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return TRUE;
 5881              		.loc 1 2606 0
 5882 2832 4FF00103 		mov	r3, #1
2607:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5883              		.loc 1 2607 0
 5884 2836 1846     		mov	r0, r3
 5885 2838 07F10807 		add	r7, r7, #8
 5886 283c BD46     		mov	sp, r7
 5887 283e 80BD     		pop	{r7, pc}
 5888              		.cfi_endproc
 5889              	.LFE66:
 5891              		.align	2
 5892              		.global	debugPrint_isSync
 5893              		.thumb
 5894              		.thumb_func
 5896              	debugPrint_isSync:
 5897              	.LFB67:
2608:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2609:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2610:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Trigger this module to print status information, over serial.
2611:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2612:openstack/02a-MAClow/IEEE802154Ecsl.c **** debugPrint_* functions are used by the openserial module to continuously print
2613:openstack/02a-MAClow/IEEE802154Ecsl.c **** status information about several modules in the OpenWSN stack.
2614:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2615:openstack/02a-MAClow/IEEE802154Ecsl.c **** \returns TRUE if this function printed something, FALSE otherwise.
2616:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2617:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool debugPrint_isSync() {
 5898              		.loc 1 2617 0
 5899              		.cfi_startproc
 5900              		@ args = 0, pretend = 0, frame = 8
 5901              		@ frame_needed = 1, uses_anonymous_args = 0
 5902 2840 80B5     		push	{r7, lr}
 5903              	.LCFI164:
 5904              		.cfi_def_cfa_offset 8
 5905              		.cfi_offset 7, -8
 5906              		.cfi_offset 14, -4
 5907 2842 82B0     		sub	sp, sp, #8
 5908              	.LCFI165:
 5909              		.cfi_def_cfa_offset 16
 5910 2844 00AF     		add	r7, sp, #0
 5911              	.LCFI166:
 5912              		.cfi_def_cfa_register 7
2618:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t output=0;
 5913              		.loc 1 2618 0
 5914 2846 4FF00003 		mov	r3, #0
 5915 284a FB71     		strb	r3, [r7, #7]
2619:openstack/02a-MAClow/IEEE802154Ecsl.c ****    output = ieee154e_vars.isSync;
 5916              		.loc 1 2619 0
 5917 284c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5918 2850 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5919 2854 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
 5920 2856 FB71     		strb	r3, [r7, #7]
2620:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printStatus(STATUS_ISSYNC,(uint8_t*)&output,sizeof(uint8_t));
 5921              		.loc 1 2620 0
 5922 2858 07F10703 		add	r3, r7, #7
 5923 285c 4FF00000 		mov	r0, #0
 5924 2860 1946     		mov	r1, r3
 5925 2862 4FF00102 		mov	r2, #1
 5926 2866 FFF7FEFF 		bl	openserial_printStatus
2621:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return TRUE;
 5927              		.loc 1 2621 0
 5928 286a 4FF00103 		mov	r3, #1
2622:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5929              		.loc 1 2622 0
 5930 286e 1846     		mov	r0, r3
 5931 2870 07F10807 		add	r7, r7, #8
 5932 2874 BD46     		mov	sp, r7
 5933 2876 80BD     		pop	{r7, pc}
 5934              		.cfi_endproc
 5935              	.LFE67:
 5937              		.align	2
 5938              		.global	debugPrint_macStats
 5939              		.thumb
 5940              		.thumb_func
 5942              	debugPrint_macStats:
 5943              	.LFB68:
2623:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2624:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2625:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Trigger this module to print status information, over serial.
2626:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2627:openstack/02a-MAClow/IEEE802154Ecsl.c **** debugPrint_* functions are used by the openserial module to continuously print
2628:openstack/02a-MAClow/IEEE802154Ecsl.c **** status information about several modules in the OpenWSN stack.
2629:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2630:openstack/02a-MAClow/IEEE802154Ecsl.c **** \returns TRUE if this function printed something, FALSE otherwise.
2631:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2632:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool debugPrint_macStats() {
 5944              		.loc 1 2632 0
 5945              		.cfi_startproc
 5946              		@ args = 0, pretend = 0, frame = 0
 5947              		@ frame_needed = 1, uses_anonymous_args = 0
 5948 2878 80B5     		push	{r7, lr}
 5949              	.LCFI167:
 5950              		.cfi_def_cfa_offset 8
 5951              		.cfi_offset 7, -8
 5952              		.cfi_offset 14, -4
 5953 287a 00AF     		add	r7, sp, #0
 5954              	.LCFI168:
 5955              		.cfi_def_cfa_register 7
2633:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // send current stats over serial
2634:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printStatus(STATUS_MACSTATS,(uint8_t*)&ieee154e_stats,sizeof(ieee154e_stats_t));
 5956              		.loc 1 2634 0
 5957 287c 4FF00500 		mov	r0, #5
 5958 2880 40F20001 		movw	r1, #:lower16:ieee154e_stats
 5959 2884 C0F20001 		movt	r1, #:upper16:ieee154e_stats
 5960 2888 4FF00F02 		mov	r2, #15
 5961 288c FFF7FEFF 		bl	openserial_printStatus
2635:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return TRUE;
 5962              		.loc 1 2635 0
 5963 2890 4FF00103 		mov	r3, #1
2636:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5964              		.loc 1 2636 0
 5965 2894 1846     		mov	r0, r3
 5966 2896 80BD     		pop	{r7, pc}
 5967              		.cfi_endproc
 5968              	.LFE68:
 5970              		.align	2
 5971              		.global	endOps
 5972              		.thumb
 5973              		.thumb_func
 5975              	endOps:
 5976              	.LFB69:
2637:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2638:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2639:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2640:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Housekeeping tasks to do at the end of each slot.
2641:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2642:openstack/02a-MAClow/IEEE802154Ecsl.c **** This functions is called once in each slot, when there is nothing more
2643:openstack/02a-MAClow/IEEE802154Ecsl.c **** to do. This might be when an error occured, or when everything went well.
2644:openstack/02a-MAClow/IEEE802154Ecsl.c **** This function resets the state of the FSM so it is ready for the next slot.
2645:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2646:openstack/02a-MAClow/IEEE802154Ecsl.c **** Note that by the time this function is called, any received packet should already
2647:openstack/02a-MAClow/IEEE802154Ecsl.c **** have been sent to the upper layer. Similarly, in a Tx slot, the sendDone
2648:openstack/02a-MAClow/IEEE802154Ecsl.c **** function should already have been done. If this is not the case, this function
2649:openstack/02a-MAClow/IEEE802154Ecsl.c **** will do that for you, but assume that something went wrong.
2650:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2651:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2652:openstack/02a-MAClow/IEEE802154Ecsl.c **** //[CSL] – Modificación de firma del método endSlot.
2653:openstack/02a-MAClow/IEEE802154Ecsl.c **** void endOps() {
 5977              		.loc 1 2653 0
 5978              		.cfi_startproc
 5979              		@ args = 0, pretend = 0, frame = 0
 5980              		@ frame_needed = 1, uses_anonymous_args = 0
 5981 2898 80B5     		push	{r7, lr}
 5982              	.LCFI169:
 5983              		.cfi_def_cfa_offset 8
 5984              		.cfi_offset 7, -8
 5985              		.cfi_offset 14, -4
 5986 289a 00AF     		add	r7, sp, #0
 5987              	.LCFI170:
 5988              		.cfi_def_cfa_register 7
2654:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2655:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // turn off the radio
2656:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rfOff();
 5989              		.loc 1 2656 0
 5990 289c FFF7FEFF 		bl	radio_rfOff
2657:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2658:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clear any pending timer
2659:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 5991              		.loc 1 2659 0
 5992 28a0 FFF7FEFF 		bl	radiotimer_cancel
2660:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2661:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // reset capturedTimes
2662:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.lastCapturedTime = 0;
 5993              		.loc 1 2662 0
 5994 28a4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5995 28a8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5996 28ac 4FF00002 		mov	r2, #0
 5997 28b0 5A62     		str	r2, [r3, #36]
2663:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.syncCapturedTime = 0;
 5998              		.loc 1 2663 0
 5999 28b2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6000 28b6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6001 28ba 4FF00002 		mov	r2, #0
 6002 28be 9A62     		str	r2, [r3, #40]
2664:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2665:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //clear vars for duty cycle on this slot
2666:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnTics=0;
 6003              		.loc 1 2666 0
 6004 28c0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6005 28c4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6006 28c8 4FF00002 		mov	r2, #0
 6007 28cc 5A63     		str	r2, [r3, #52]
2667:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnThisSlot=FALSE;
 6008              		.loc 1 2667 0
 6009 28ce 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6010 28d2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6011 28d6 4FF00002 		mov	r2, #0
 6012 28da 83F83820 		strb	r2, [r3, #56]
2668:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2669:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clean up dataToSend
2670:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.dataToSend!=NULL) {
 6013              		.loc 1 2670 0
 6014 28de 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6015 28e2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6016 28e6 5B69     		ldr	r3, [r3, #20]
 6017 28e8 002B     		cmp	r3, #0
 6018 28ea 33D0     		beq	.L279
2671:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // if everything went well, dataToSend was set to NULL in ti9
2672:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // getting here means transmit failed
2673:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2674:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // indicate Tx fail to schedule to update stats
2675:openstack/02a-MAClow/IEEE802154Ecsl.c ****       schedule_indicateTx(&ieee154e_vars.asn,FALSE);
 6019              		.loc 1 2675 0
 6020 28ec 40F20000 		movw	r0, #:lower16:ieee154e_vars
 6021 28f0 C0F20000 		movt	r0, #:upper16:ieee154e_vars
 6022 28f4 4FF00001 		mov	r1, #0
 6023 28f8 FFF7FEFF 		bl	schedule_indicateTx
2676:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2677:openstack/02a-MAClow/IEEE802154Ecsl.c ****       //decrement transmits left counter
2678:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataToSend->l2_retriesLeft--;
 6024              		.loc 1 2678 0
 6025 28fc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6026 2900 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6027 2904 5B69     		ldr	r3, [r3, #20]
 6028 2906 93F84B20 		ldrb	r2, [r3, #75]	@ zero_extendqisi2
 6029 290a 02F1FF32 		add	r2, r2, #-1
 6030 290e D2B2     		uxtb	r2, r2
 6031 2910 83F84B20 		strb	r2, [r3, #75]
2679:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2680:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.dataToSend->l2_retriesLeft==0) {
 6032              		.loc 1 2680 0
 6033 2914 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6034 2918 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6035 291c 5B69     		ldr	r3, [r3, #20]
 6036 291e 93F84B30 		ldrb	r3, [r3, #75]	@ zero_extendqisi2
 6037 2922 002B     		cmp	r3, #0
 6038 2924 07D0     		beq	.L280
2681:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 // indicate tx fail if no more retries left
2682:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // [CSL-TEST]: comment to avoid led error blinking
2683:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 //notif_sendDone(ieee154e_vars.dataToSend,E_FAIL);
2684:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 // [CSL-TEST]: end test code
2685:openstack/02a-MAClow/IEEE802154Ecsl.c ****       } else {
2686:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // return packet to the virtual COMPONENT_SIXTOP_TO_IEEE802154E component
2687:openstack/02a-MAClow/IEEE802154Ecsl.c ****          ieee154e_vars.dataToSend->owner = COMPONENT_SIXTOP_TO_IEEE802154E;
 6039              		.loc 1 2687 0
 6040 2926 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6041 292a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6042 292e 5B69     		ldr	r3, [r3, #20]
 6043 2930 4FF00A02 		mov	r2, #10
 6044 2934 5A70     		strb	r2, [r3, #1]
 6045              	.L280:
2688:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
2689:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2690:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // CSL - Remove packet for testing because no high entity for packet processing.
2691:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openqueue_freePacketBuffer(ieee154e_vars.dataToSend);
 6046              		.loc 1 2691 0
 6047 2936 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6048 293a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6049 293e 5B69     		ldr	r3, [r3, #20]
 6050 2940 1846     		mov	r0, r3
 6051 2942 FFF7FEFF 		bl	openqueue_freePacketBuffer
2692:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2693:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset local variable
2694:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataToSend = NULL;
 6052              		.loc 1 2694 0
 6053 2946 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6054 294a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6055 294e 4FF00002 		mov	r2, #0
 6056 2952 5A61     		str	r2, [r3, #20]
 6057              	.L279:
2695:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2696:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2697:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clean up dataReceived
2698:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.dataReceived!=NULL) {
 6058              		.loc 1 2698 0
 6059 2954 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6060 2958 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6061 295c 9B69     		ldr	r3, [r3, #24]
 6062 295e 002B     		cmp	r3, #0
 6063 2960 18D0     		beq	.L281
2699:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // assume something went wrong. If everything went well, dataReceived
2700:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // would have been set to NULL in ri9.
2701:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // indicate  "received packet" to upper layer since we don't want to loose packets
2702:openstack/02a-MAClow/IEEE802154Ecsl.c ****       notif_receive(ieee154e_vars.dataReceived,0);
 6064              		.loc 1 2702 0
 6065 2962 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6066 2966 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6067 296a 9B69     		ldr	r3, [r3, #24]
 6068 296c 1846     		mov	r0, r3
 6069 296e 4FF00001 		mov	r1, #0
 6070 2972 FFF7FEFF 		bl	notif_receive
2703:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2704:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // CSL - Remove packet for testing because no high entity for packet processing.
2705:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openqueue_freePacketBuffer(ieee154e_vars.dataReceived);
 6071              		.loc 1 2705 0
 6072 2976 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6073 297a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6074 297e 9B69     		ldr	r3, [r3, #24]
 6075 2980 1846     		mov	r0, r3
 6076 2982 FFF7FEFF 		bl	openqueue_freePacketBuffer
2706:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2707:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset local variable
2708:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataReceived = NULL;
 6077              		.loc 1 2708 0
 6078 2986 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6079 298a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6080 298e 4FF00002 		mov	r2, #0
 6081 2992 9A61     		str	r2, [r3, #24]
 6082              	.L281:
2709:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2710:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2711:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clean up ackToSend
2712:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.ackToSend!=NULL) {
 6083              		.loc 1 2712 0
 6084 2994 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6085 2998 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6086 299c DB69     		ldr	r3, [r3, #28]
 6087 299e 002B     		cmp	r3, #0
 6088 29a0 0ED0     		beq	.L282
2713:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // free ackToSend so corresponding RAM memory can be recycled
2714:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openqueue_freePacketBuffer(ieee154e_vars.ackToSend);
 6089              		.loc 1 2714 0
 6090 29a2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6091 29a6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6092 29aa DB69     		ldr	r3, [r3, #28]
 6093 29ac 1846     		mov	r0, r3
 6094 29ae FFF7FEFF 		bl	openqueue_freePacketBuffer
2715:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset local variable
2716:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.ackToSend = NULL;
 6095              		.loc 1 2716 0
 6096 29b2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6097 29b6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6098 29ba 4FF00002 		mov	r2, #0
 6099 29be DA61     		str	r2, [r3, #28]
 6100              	.L282:
2717:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2718:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2719:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clean up ackReceived
2720:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.ackReceived!=NULL) {
 6101              		.loc 1 2720 0
 6102 29c0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6103 29c4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6104 29c8 1B6A     		ldr	r3, [r3, #32]
 6105 29ca 002B     		cmp	r3, #0
 6106 29cc 0ED0     		beq	.L283
2721:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // free ackReceived so corresponding RAM memory can be recycled
2722:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openqueue_freePacketBuffer(ieee154e_vars.ackReceived);
 6107              		.loc 1 2722 0
 6108 29ce 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6109 29d2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6110 29d6 1B6A     		ldr	r3, [r3, #32]
 6111 29d8 1846     		mov	r0, r3
 6112 29da FFF7FEFF 		bl	openqueue_freePacketBuffer
2723:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset local variable
2724:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.ackReceived = NULL;
 6113              		.loc 1 2724 0
 6114 29de 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6115 29e2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6116 29e6 4FF00002 		mov	r2, #0
 6117 29ea 1A62     		str	r2, [r3, #32]
 6118              	.L283:
2725:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2726:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2727:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clean up wakeupSend
2728:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.wakeupToSend!=NULL) {
 6119              		.loc 1 2728 0
 6120 29ec 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6121 29f0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6122 29f4 DB6B     		ldr	r3, [r3, #60]
 6123 29f6 002B     		cmp	r3, #0
 6124 29f8 0ED0     		beq	.L284
2729:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // free wakeupToSend so corresponding RAM memory can be recycled
2730:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openqueue_freePacketBuffer(ieee154e_vars.wakeupToSend);
 6125              		.loc 1 2730 0
 6126 29fa 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6127 29fe C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6128 2a02 DB6B     		ldr	r3, [r3, #60]
 6129 2a04 1846     		mov	r0, r3
 6130 2a06 FFF7FEFF 		bl	openqueue_freePacketBuffer
2731:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset local variable
2732:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.wakeupToSend = NULL;
 6131              		.loc 1 2732 0
 6132 2a0a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6133 2a0e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6134 2a12 4FF00002 		mov	r2, #0
 6135 2a16 DA63     		str	r2, [r3, #60]
 6136              	.L284:
2733:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2734:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2735:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clean up wakeupReceived
2736:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.wakeupReceived !=NULL) {
 6137              		.loc 1 2736 0
 6138 2a18 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6139 2a1c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6140 2a20 1B6C     		ldr	r3, [r3, #64]
 6141 2a22 002B     		cmp	r3, #0
 6142 2a24 0ED0     		beq	.L285
2737:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // free wakeupReceived so corresponding RAM memory can be recycled
2738:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openqueue_freePacketBuffer(ieee154e_vars.wakeupReceived);
 6143              		.loc 1 2738 0
 6144 2a26 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6145 2a2a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6146 2a2e 1B6C     		ldr	r3, [r3, #64]
 6147 2a30 1846     		mov	r0, r3
 6148 2a32 FFF7FEFF 		bl	openqueue_freePacketBuffer
2739:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset local variable
2740:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.wakeupReceived = NULL;
 6149              		.loc 1 2740 0
 6150 2a36 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6151 2a3a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6152 2a3e 4FF00002 		mov	r2, #0
 6153 2a42 1A64     		str	r2, [r3, #64]
 6154              	.L285:
2741:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2742:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2743:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
2744:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_SLEEP);
 6155              		.loc 1 2744 0
 6156 2a44 4FF00000 		mov	r0, #0
 6157 2a48 FFF7FEFF 		bl	changeState
2745:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2746:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // update CSL Mode to SLEEP in order to allow new TX or RX.
2747:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.cslMode = CSL_SLEEP_MODE;
 6158              		.loc 1 2747 0
 6159 2a4c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6160 2a50 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6161 2a54 4FF00002 		mov	r2, #0
 6162 2a58 83F84520 		strb	r2, [r3, #69]
2748:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2749:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 6163              		.loc 1 2749 0
 6164 2a5c 80BD     		pop	{r7, pc}
 6165              		.cfi_endproc
 6166              	.LFE69:
 6168 2a5e 00BF     		.align	2
 6169              		.global	ieee154e_isSynch
 6170              		.thumb
 6171              		.thumb_func
 6173              	ieee154e_isSynch:
 6174              	.LFB70:
2750:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2751:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool ieee154e_isSynch(){
 6175              		.loc 1 2751 0
 6176              		.cfi_startproc
 6177              		@ args = 0, pretend = 0, frame = 0
 6178              		@ frame_needed = 1, uses_anonymous_args = 0
 6179              		@ link register save eliminated.
 6180 2a60 80B4     		push	{r7}
 6181              	.LCFI171:
 6182              		.cfi_def_cfa_offset 4
 6183              		.cfi_offset 7, -4
 6184 2a62 00AF     		add	r7, sp, #0
 6185              	.LCFI172:
 6186              		.cfi_def_cfa_register 7
2752:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee154e_vars.isSync;
 6187              		.loc 1 2752 0
 6188 2a64 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6189 2a68 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6190 2a6c 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
2753:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 6191              		.loc 1 2753 0
 6192 2a6e 1846     		mov	r0, r3
 6193 2a70 BD46     		mov	sp, r7
 6194 2a72 80BC     		pop	{r7}
 6195 2a74 7047     		bx	lr
 6196              		.cfi_endproc
 6197              	.LFE70:
 6199 2a76 00BF     		.align	2
 6200              		.global	ieee154e_processIEs
 6201              		.thumb
 6202              		.thumb_func
 6204              	ieee154e_processIEs:
 6205              	.LFB71:
2754:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2755:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE bool ieee154e_processIEs(OpenQueueEntry_t* pkt, uint16_t* lenIE) {
 6206              		.loc 1 2755 0
 6207              		.cfi_startproc
 6208              		@ args = 0, pretend = 0, frame = 32
 6209              		@ frame_needed = 1, uses_anonymous_args = 0
 6210 2a78 80B5     		push	{r7, lr}
 6211              	.LCFI173:
 6212              		.cfi_def_cfa_offset 8
 6213              		.cfi_offset 7, -8
 6214              		.cfi_offset 14, -4
 6215 2a7a 88B0     		sub	sp, sp, #32
 6216              	.LCFI174:
 6217              		.cfi_def_cfa_offset 40
 6218 2a7c 00AF     		add	r7, sp, #0
 6219              	.LCFI175:
 6220              		.cfi_def_cfa_register 7
 6221 2a7e 7860     		str	r0, [r7, #4]
 6222 2a80 3960     		str	r1, [r7, #0]
2756:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t               ptr;
2757:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t               byte0;
2758:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t               byte1;
2759:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t               temp_8b;
2760:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t               gr_elem_id;
2761:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t               subid;
2762:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint16_t              temp_16b;
2763:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint16_t              len;
2764:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint16_t              sublen;
2765:openstack/02a-MAClow/IEEE802154Ecsl.c ****    PORT_SIGNED_INT_WIDTH timeCorrection;
2766:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2767:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ptr=0;
 6223              		.loc 1 2767 0
 6224 2a82 4FF00003 		mov	r3, #0
 6225 2a86 FB73     		strb	r3, [r7, #15]
2768:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2769:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //===== header or payload IE header
2770:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2771:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //candidate IE header  if type ==0 header IE if type==1 payload IE
2772:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_8b    = *((uint8_t*)(pkt->payload)+ptr);
 6226              		.loc 1 2772 0
 6227 2a88 7B68     		ldr	r3, [r7, #4]
 6228 2a8a 5A68     		ldr	r2, [r3, #4]
 6229 2a8c FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6230 2a8e D318     		adds	r3, r2, r3
 6231 2a90 1B78     		ldrb	r3, [r3, #0]
 6232 2a92 7B76     		strb	r3, [r7, #25]
2773:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ptr++;
 6233              		.loc 1 2773 0
 6234 2a94 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6235 2a96 03F10103 		add	r3, r3, #1
 6236 2a9a DBB2     		uxtb	r3, r3
 6237 2a9c FB73     		strb	r3, [r7, #15]
2774:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2775:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_16b   = temp_8b + ((*((uint8_t*)(pkt->payload)+ptr))<< 8);
 6238              		.loc 1 2775 0
 6239 2a9e 7B7E     		ldrb	r3, [r7, #25]	@ zero_extendqisi2
 6240 2aa0 9AB2     		uxth	r2, r3
 6241 2aa2 7B68     		ldr	r3, [r7, #4]
 6242 2aa4 5968     		ldr	r1, [r3, #4]
 6243 2aa6 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6244 2aa8 CB18     		adds	r3, r1, r3
 6245 2aaa 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 6246 2aac 4FEA0323 		lsl	r3, r3, #8
 6247 2ab0 9BB2     		uxth	r3, r3
 6248 2ab2 D318     		adds	r3, r2, r3
 6249 2ab4 FB82     		strh	r3, [r7, #22]	@ movhi
2776:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ptr++;
 6250              		.loc 1 2776 0
 6251 2ab6 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6252 2ab8 03F10103 		add	r3, r3, #1
 6253 2abc DBB2     		uxtb	r3, r3
 6254 2abe FB73     		strb	r3, [r7, #15]
2777:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2778:openstack/02a-MAClow/IEEE802154Ecsl.c ****    *lenIE     = ptr;
 6255              		.loc 1 2778 0
 6256 2ac0 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6257 2ac2 1A46     		mov	r2, r3
 6258 2ac4 3B68     		ldr	r3, [r7, #0]
 6259 2ac6 1A80     		strh	r2, [r3, #0]	@ movhi
2779:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2780:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b & IEEE802154E_DESC_TYPE_PAYLOAD_IE) == IEEE802154E_DESC_TYPE_PAYLOAD_IE){
 6260              		.loc 1 2780 0
 6261 2ac8 FB8A     		ldrh	r3, [r7, #22]
 6262 2aca 03F00103 		and	r3, r3, #1
 6263 2ace 002B     		cmp	r3, #0
 6264 2ad0 0AD0     		beq	.L289
2781:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // payload IE
2782:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2783:openstack/02a-MAClow/IEEE802154Ecsl.c ****       len          = (temp_16b & IEEE802154E_DESC_LEN_PAYLOAD_IE_MASK)>>IEEE802154E_DESC_LEN_PAYLOA
 6265              		.loc 1 2783 0
 6266 2ad2 FB8A     		ldrh	r3, [r7, #22]
 6267 2ad4 4FEA5313 		lsr	r3, r3, #5
 6268 2ad8 BB83     		strh	r3, [r7, #28]	@ movhi
2784:openstack/02a-MAClow/IEEE802154Ecsl.c ****       gr_elem_id   = (temp_16b & IEEE802154E_DESC_GROUPID_PAYLOAD_IE_MASK)>>IEEE802154E_DESC_GROUPI
 6269              		.loc 1 2784 0
 6270 2ada FB8A     		ldrh	r3, [r7, #22]
 6271 2adc 03F01E03 		and	r3, r3, #30
 6272 2ae0 4FEA6303 		asr	r3, r3, #1
 6273 2ae4 FB77     		strb	r3, [r7, #31]
 6274 2ae6 09E0     		b	.L290
 6275              	.L289:
2785:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
2786:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // header IE
2787:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2788:openstack/02a-MAClow/IEEE802154Ecsl.c ****       len          = (temp_16b & IEEE802154E_DESC_LEN_HEADER_IE_MASK)>>IEEE802154E_DESC_LEN_HEADER_
 6276              		.loc 1 2788 0
 6277 2ae8 FB8A     		ldrh	r3, [r7, #22]
 6278 2aea 4FEA5323 		lsr	r3, r3, #9
 6279 2aee BB83     		strh	r3, [r7, #28]	@ movhi
2789:openstack/02a-MAClow/IEEE802154Ecsl.c ****       gr_elem_id   = (temp_16b & IEEE802154E_DESC_ELEMENTID_HEADER_IE_MASK)>>IEEE802154E_DESC_ELEME
 6280              		.loc 1 2789 0
 6281 2af0 FB8A     		ldrh	r3, [r7, #22]
 6282 2af2 03F4FF73 		and	r3, r3, #510
 6283 2af6 4FEA6303 		asr	r3, r3, #1
 6284 2afa FB77     		strb	r3, [r7, #31]
 6285              	.L290:
2790:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2791:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2792:openstack/02a-MAClow/IEEE802154Ecsl.c ****    *lenIE         += len;
 6286              		.loc 1 2792 0
 6287 2afc 3B68     		ldr	r3, [r7, #0]
 6288 2afe 1A88     		ldrh	r2, [r3, #0]
 6289 2b00 BB8B     		ldrh	r3, [r7, #28]	@ movhi
 6290 2b02 D318     		adds	r3, r2, r3
 6291 2b04 9AB2     		uxth	r2, r3
 6292 2b06 3B68     		ldr	r3, [r7, #0]
 6293 2b08 1A80     		strh	r2, [r3, #0]	@ movhi
2793:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2794:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //===== sub-elements
2795:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2796:openstack/02a-MAClow/IEEE802154Ecsl.c ****    switch(gr_elem_id){
 6294              		.loc 1 2796 0
 6295 2b0a FB7F     		ldrb	r3, [r7, #31]	@ zero_extendqisi2
 6296 2b0c 012B     		cmp	r3, #1
 6297 2b0e 02D0     		beq	.L292
 6298 2b10 1E2B     		cmp	r3, #30
 6299 2b12 78D0     		beq	.L293
 6300 2b14 BEE0     		b	.L307
 6301              	.L292:
2797:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2798:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case IEEE802154E_MLME_IE_GROUPID:
2799:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // MLME IE
2800:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2801:openstack/02a-MAClow/IEEE802154Ecsl.c ****          do {
2802:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2803:openstack/02a-MAClow/IEEE802154Ecsl.c ****             //read sub IE header
2804:openstack/02a-MAClow/IEEE802154Ecsl.c ****             temp_8b     = *((uint8_t*)(pkt->payload)+ptr);
 6302              		.loc 1 2804 0
 6303 2b16 7B68     		ldr	r3, [r7, #4]
 6304 2b18 5A68     		ldr	r2, [r3, #4]
 6305 2b1a FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6306 2b1c D318     		adds	r3, r2, r3
 6307 2b1e 1B78     		ldrb	r3, [r3, #0]
 6308 2b20 7B76     		strb	r3, [r7, #25]
2805:openstack/02a-MAClow/IEEE802154Ecsl.c ****             ptr         = ptr + 1;
 6309              		.loc 1 2805 0
 6310 2b22 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6311 2b24 03F10103 		add	r3, r3, #1
 6312 2b28 DBB2     		uxtb	r3, r3
 6313 2b2a FB73     		strb	r3, [r7, #15]
2806:openstack/02a-MAClow/IEEE802154Ecsl.c ****             temp_16b    = temp_8b  +(*((uint8_t*)(pkt->payload)+ptr) << 8);
 6314              		.loc 1 2806 0
 6315 2b2c 7B7E     		ldrb	r3, [r7, #25]	@ zero_extendqisi2
 6316 2b2e 9AB2     		uxth	r2, r3
 6317 2b30 7B68     		ldr	r3, [r7, #4]
 6318 2b32 5968     		ldr	r1, [r3, #4]
 6319 2b34 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6320 2b36 CB18     		adds	r3, r1, r3
 6321 2b38 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 6322 2b3a 4FEA0323 		lsl	r3, r3, #8
 6323 2b3e 9BB2     		uxth	r3, r3
 6324 2b40 D318     		adds	r3, r2, r3
 6325 2b42 FB82     		strh	r3, [r7, #22]	@ movhi
2807:openstack/02a-MAClow/IEEE802154Ecsl.c ****             ptr         = ptr + 1;
 6326              		.loc 1 2807 0
 6327 2b44 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6328 2b46 03F10103 		add	r3, r3, #1
 6329 2b4a DBB2     		uxtb	r3, r3
 6330 2b4c FB73     		strb	r3, [r7, #15]
2808:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2809:openstack/02a-MAClow/IEEE802154Ecsl.c ****             len         = len - 2; //remove header fields len
 6331              		.loc 1 2809 0
 6332 2b4e BB8B     		ldrh	r3, [r7, #28]	@ movhi
 6333 2b50 A3F10203 		sub	r3, r3, #2
 6334 2b54 BB83     		strh	r3, [r7, #28]	@ movhi
2810:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2811:openstack/02a-MAClow/IEEE802154Ecsl.c ****             if ((temp_16b & IEEE802154E_DESC_TYPE_LONG) == IEEE802154E_DESC_TYPE_LONG){
 6335              		.loc 1 2811 0
 6336 2b56 FB8A     		ldrh	r3, [r7, #22]
 6337 2b58 03F00103 		and	r3, r3, #1
 6338 2b5c 002B     		cmp	r3, #0
 6339 2b5e 0AD0     		beq	.L294
2812:openstack/02a-MAClow/IEEE802154Ecsl.c ****                // long sub-IE
2813:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2814:openstack/02a-MAClow/IEEE802154Ecsl.c ****                sublen   = (temp_16b & IEEE802154E_DESC_LEN_LONG_MLME_IE_MASK)>>IEEE802154E_DESC_LEN
 6340              		.loc 1 2814 0
 6341 2b60 FB8A     		ldrh	r3, [r7, #22]
 6342 2b62 4FEA5313 		lsr	r3, r3, #5
 6343 2b66 7B83     		strh	r3, [r7, #26]	@ movhi
2815:openstack/02a-MAClow/IEEE802154Ecsl.c ****                subid    = (temp_16b & IEEE802154E_DESC_SUBID_LONG_MLME_IE_MASK)>>IEEE802154E_DESC_S
 6344              		.loc 1 2815 0
 6345 2b68 FB8A     		ldrh	r3, [r7, #22]
 6346 2b6a 03F01E03 		and	r3, r3, #30
 6347 2b6e 4FEA6303 		asr	r3, r3, #1
 6348 2b72 BB77     		strb	r3, [r7, #30]
 6349 2b74 09E0     		b	.L295
 6350              	.L294:
2816:openstack/02a-MAClow/IEEE802154Ecsl.c ****             } else {
2817:openstack/02a-MAClow/IEEE802154Ecsl.c ****                // short sub-IE
2818:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2819:openstack/02a-MAClow/IEEE802154Ecsl.c ****                sublen   = (temp_16b & IEEE802154E_DESC_LEN_SHORT_MLME_IE_MASK)>>IEEE802154E_DESC_LE
 6351              		.loc 1 2819 0
 6352 2b76 FB8A     		ldrh	r3, [r7, #22]
 6353 2b78 4FEA1323 		lsr	r3, r3, #8
 6354 2b7c 7B83     		strh	r3, [r7, #26]	@ movhi
2820:openstack/02a-MAClow/IEEE802154Ecsl.c ****                subid    = (temp_16b & IEEE802154E_DESC_SUBID_SHORT_MLME_IE_MASK)>>IEEE802154E_DESC_
 6355              		.loc 1 2820 0
 6356 2b7e FB8A     		ldrh	r3, [r7, #22]
 6357 2b80 03F0FE03 		and	r3, r3, #254
 6358 2b84 4FEA6303 		asr	r3, r3, #1
 6359 2b88 BB77     		strb	r3, [r7, #30]
 6360              	.L295:
2821:openstack/02a-MAClow/IEEE802154Ecsl.c ****             }
2822:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2823:openstack/02a-MAClow/IEEE802154Ecsl.c ****             switch(subid){
 6361              		.loc 1 2823 0
 6362 2b8a BB7F     		ldrb	r3, [r7, #30]	@ zero_extendqisi2
 6363 2b8c 1B2B     		cmp	r3, #27
 6364 2b8e 25D0     		beq	.L298
 6365 2b90 1C2B     		cmp	r3, #28
 6366 2b92 2DD0     		beq	.L309
 6367 2b94 1A2B     		cmp	r3, #26
 6368 2b96 28D1     		bne	.L308
 6369              	.L297:
2824:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2825:openstack/02a-MAClow/IEEE802154Ecsl.c ****                case IEEE802154E_MLME_SYNC_IE_SUBID:
2826:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   // Sync IE: ASN and Join Priority
2827:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2828:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   if (idmanager_getIsDAGroot()==FALSE) {
 6370              		.loc 1 2828 0
 6371 2b98 FFF7FEFF 		bl	idmanager_getIsDAGroot
 6372 2b9c 0346     		mov	r3, r0
 6373 2b9e 83F00103 		eor	r3, r3, #1
 6374 2ba2 DBB2     		uxtb	r3, r3
 6375 2ba4 002B     		cmp	r3, #0
 6376 2ba6 25D0     		beq	.L310
2829:openstack/02a-MAClow/IEEE802154Ecsl.c ****                      // ASN
2830:openstack/02a-MAClow/IEEE802154Ecsl.c ****                      asnStoreFromAdv((uint8_t*)(pkt->payload)+ptr);
 6377              		.loc 1 2830 0
 6378 2ba8 7B68     		ldr	r3, [r7, #4]
 6379 2baa 5A68     		ldr	r2, [r3, #4]
 6380 2bac FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6381 2bae D318     		adds	r3, r2, r3
 6382 2bb0 1846     		mov	r0, r3
 6383 2bb2 FFF7FEFF 		bl	asnStoreFromAdv
2831:openstack/02a-MAClow/IEEE802154Ecsl.c ****                      ptr = ptr + 5;
 6384              		.loc 1 2831 0
 6385 2bb6 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6386 2bb8 03F10503 		add	r3, r3, #5
 6387 2bbc DBB2     		uxtb	r3, r3
 6388 2bbe FB73     		strb	r3, [r7, #15]
2832:openstack/02a-MAClow/IEEE802154Ecsl.c ****                      // join priority
2833:openstack/02a-MAClow/IEEE802154Ecsl.c ****                      joinPriorityStoreFromAdv(*((uint8_t*)(pkt->payload)+ptr));
 6389              		.loc 1 2833 0
 6390 2bc0 7B68     		ldr	r3, [r7, #4]
 6391 2bc2 5A68     		ldr	r2, [r3, #4]
 6392 2bc4 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6393 2bc6 D318     		adds	r3, r2, r3
 6394 2bc8 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 6395 2bca 1846     		mov	r0, r3
 6396 2bcc FFF7FEFF 		bl	joinPriorityStoreFromAdv
2834:openstack/02a-MAClow/IEEE802154Ecsl.c ****                      ptr = ptr + 1;
 6397              		.loc 1 2834 0
 6398 2bd0 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6399 2bd2 03F10103 		add	r3, r3, #1
 6400 2bd6 DBB2     		uxtb	r3, r3
 6401 2bd8 FB73     		strb	r3, [r7, #15]
2835:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   }
2836:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   break;
 6402              		.loc 1 2836 0
 6403 2bda 0BE0     		b	.L310
 6404              	.L298:
2837:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2838:openstack/02a-MAClow/IEEE802154Ecsl.c ****                case IEEE802154E_MLME_SLOTFRAME_LINK_IE_SUBID:
2839:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   processIE_retrieveSlotframeLinkIE(pkt,&ptr);
 6405              		.loc 1 2839 0
 6406 2bdc 07F10F03 		add	r3, r7, #15
 6407 2be0 7868     		ldr	r0, [r7, #4]
 6408 2be2 1946     		mov	r1, r3
 6409 2be4 FFF7FEFF 		bl	processIE_retrieveSlotframeLinkIE
2840:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   break;
 6410              		.loc 1 2840 0
 6411 2be8 05E0     		b	.L301
 6412              	.L308:
2841:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2842:openstack/02a-MAClow/IEEE802154Ecsl.c ****                case IEEE802154E_MLME_TIMESLOT_IE_SUBID:
2843:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   // to do
2844:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   break;
2845:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2846:openstack/02a-MAClow/IEEE802154Ecsl.c ****                default:
2847:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   return FALSE;
 6413              		.loc 1 2847 0
 6414 2bea 4FF00003 		mov	r3, #0
 6415 2bee 6AE0     		b	.L306
 6416              	.L309:
2844:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   break;
 6417              		.loc 1 2844 0
 6418 2bf0 00BF     		nop
 6419 2bf2 00E0     		b	.L301
 6420              	.L310:
2836:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   break;
 6421              		.loc 1 2836 0
 6422 2bf4 00BF     		nop
 6423              	.L301:
2848:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   break;
2849:openstack/02a-MAClow/IEEE802154Ecsl.c ****             }
2850:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2851:openstack/02a-MAClow/IEEE802154Ecsl.c ****             len = len - sublen;
 6424              		.loc 1 2851 0
 6425 2bf6 BA8B     		ldrh	r2, [r7, #28]	@ movhi
 6426 2bf8 7B8B     		ldrh	r3, [r7, #26]	@ movhi
 6427 2bfa D31A     		subs	r3, r2, r3
 6428 2bfc BB83     		strh	r3, [r7, #28]	@ movhi
2852:openstack/02a-MAClow/IEEE802154Ecsl.c ****          } while(len>0);
 6429              		.loc 1 2852 0
 6430 2bfe BB8B     		ldrh	r3, [r7, #28]
 6431 2c00 002B     		cmp	r3, #0
 6432 2c02 88D1     		bne	.L292
2853:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2854:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 6433              		.loc 1 2854 0
 6434 2c04 4EE0     		b	.L303
 6435              	.L293:
2855:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2856:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case IEEE802154E_ACK_NACK_TIMECORRECTION_ELEMENTID:
2857:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // timecorrection IE
2858:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2859:openstack/02a-MAClow/IEEE802154Ecsl.c ****          if (
2860:openstack/02a-MAClow/IEEE802154Ecsl.c ****                idmanager_getIsDAGroot()==FALSE &&
 6436              		.loc 1 2860 0
 6437 2c06 FFF7FEFF 		bl	idmanager_getIsDAGroot
 6438 2c0a 0346     		mov	r3, r0
 6439 2c0c 83F00103 		eor	r3, r3, #1
 6440 2c10 DBB2     		uxtb	r3, r3
2859:openstack/02a-MAClow/IEEE802154Ecsl.c ****          if (
 6441              		.loc 1 2859 0
 6442 2c12 002B     		cmp	r3, #0
 6443 2c14 45D0     		beq	.L311
2861:openstack/02a-MAClow/IEEE802154Ecsl.c ****                neighbors_isPreferredParent(&(pkt->l2_nextORpreviousHop))
 6444              		.loc 1 2861 0
 6445 2c16 7B68     		ldr	r3, [r7, #4]
 6446 2c18 03F13803 		add	r3, r3, #56
 6447 2c1c 1846     		mov	r0, r3
 6448 2c1e FFF7FEFF 		bl	neighbors_isPreferredParent
 6449 2c22 0346     		mov	r3, r0
2860:openstack/02a-MAClow/IEEE802154Ecsl.c ****                idmanager_getIsDAGroot()==FALSE &&
 6450              		.loc 1 2860 0
 6451 2c24 002B     		cmp	r3, #0
 6452 2c26 3CD0     		beq	.L311
2862:openstack/02a-MAClow/IEEE802154Ecsl.c ****             ) {
2863:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2864:openstack/02a-MAClow/IEEE802154Ecsl.c ****             byte0 = *((uint8_t*)(pkt->payload)+ptr);
 6453              		.loc 1 2864 0
 6454 2c28 7B68     		ldr	r3, [r7, #4]
 6455 2c2a 5A68     		ldr	r2, [r3, #4]
 6456 2c2c FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6457 2c2e D318     		adds	r3, r2, r3
 6458 2c30 1B78     		ldrb	r3, [r3, #0]
 6459 2c32 7B75     		strb	r3, [r7, #21]
2865:openstack/02a-MAClow/IEEE802154Ecsl.c ****             ptr++;
 6460              		.loc 1 2865 0
 6461 2c34 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6462 2c36 03F10103 		add	r3, r3, #1
 6463 2c3a DBB2     		uxtb	r3, r3
 6464 2c3c FB73     		strb	r3, [r7, #15]
2866:openstack/02a-MAClow/IEEE802154Ecsl.c ****             byte1 = *((uint8_t*)(pkt->payload)+ptr);
 6465              		.loc 1 2866 0
 6466 2c3e 7B68     		ldr	r3, [r7, #4]
 6467 2c40 5A68     		ldr	r2, [r3, #4]
 6468 2c42 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6469 2c44 D318     		adds	r3, r2, r3
 6470 2c46 1B78     		ldrb	r3, [r3, #0]
 6471 2c48 3B75     		strb	r3, [r7, #20]
2867:openstack/02a-MAClow/IEEE802154Ecsl.c ****             ptr++;
 6472              		.loc 1 2867 0
 6473 2c4a FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6474 2c4c 03F10103 		add	r3, r3, #1
 6475 2c50 DBB2     		uxtb	r3, r3
 6476 2c52 FB73     		strb	r3, [r7, #15]
2868:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2869:openstack/02a-MAClow/IEEE802154Ecsl.c ****             timeCorrection  = (int16_t)((uint16_t)byte1<<8 | (uint16_t)byte0);
 6477              		.loc 1 2869 0
 6478 2c54 3B7D     		ldrb	r3, [r7, #20]	@ zero_extendqisi2
 6479 2c56 4FEA0323 		lsl	r3, r3, #8
 6480 2c5a 9AB2     		uxth	r2, r3
 6481 2c5c 7B7D     		ldrb	r3, [r7, #21]	@ zero_extendqisi2
 6482 2c5e 9BB2     		uxth	r3, r3
 6483 2c60 1343     		orrs	r3, r3, r2
 6484 2c62 9BB2     		uxth	r3, r3
 6485 2c64 1BB2     		sxth	r3, r3
 6486 2c66 3B61     		str	r3, [r7, #16]
2870:openstack/02a-MAClow/IEEE802154Ecsl.c ****             timeCorrection  = (timeCorrection / (PORT_SIGNED_INT_WIDTH)US_PER_TICK);
 6487              		.loc 1 2870 0
 6488 2c68 3B69     		ldr	r3, [r7, #16]
 6489 2c6a 48F68902 		movw	r2, #34953
 6490 2c6e C8F68802 		movt	r2, 34952
 6491 2c72 82FB0312 		smull	r1, r2, r2, r3
 6492 2c76 D218     		adds	r2, r2, r3
 6493 2c78 4FEA2212 		asr	r2, r2, #4
 6494 2c7c 4FEAE373 		asr	r3, r3, #31
 6495 2c80 D31A     		subs	r3, r2, r3
 6496 2c82 3B61     		str	r3, [r7, #16]
2871:openstack/02a-MAClow/IEEE802154Ecsl.c ****             timeCorrection  = -timeCorrection;
 6497              		.loc 1 2871 0
 6498 2c84 3B69     		ldr	r3, [r7, #16]
 6499 2c86 C3F10003 		rsb	r3, r3, #0
 6500 2c8a 3B61     		str	r3, [r7, #16]
2872:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2873:openstack/02a-MAClow/IEEE802154Ecsl.c ****             synchronizeAck(timeCorrection);
 6501              		.loc 1 2873 0
 6502 2c8c 3869     		ldr	r0, [r7, #16]
 6503 2c8e FFF7FEFF 		bl	synchronizeAck
2874:openstack/02a-MAClow/IEEE802154Ecsl.c ****          }
2875:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 6504              		.loc 1 2875 0
 6505 2c92 06E0     		b	.L311
 6506              	.L307:
2876:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2877:openstack/02a-MAClow/IEEE802154Ecsl.c ****       default:
2878:openstack/02a-MAClow/IEEE802154Ecsl.c ****          *lenIE = 0; //no header or not recognized.
 6507              		.loc 1 2878 0
 6508 2c94 3B68     		ldr	r3, [r7, #0]
 6509 2c96 4FF00002 		mov	r2, #0
 6510 2c9a 1A80     		strh	r2, [r3, #0]	@ movhi
2879:openstack/02a-MAClow/IEEE802154Ecsl.c ****          return FALSE;
 6511              		.loc 1 2879 0
 6512 2c9c 4FF00003 		mov	r3, #0
 6513 2ca0 11E0     		b	.L306
 6514              	.L311:
2875:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 6515              		.loc 1 2875 0
 6516 2ca2 00BF     		nop
 6517              	.L303:
2880:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2881:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2882:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if(*lenIE>127) {
 6518              		.loc 1 2882 0
 6519 2ca4 3B68     		ldr	r3, [r7, #0]
 6520 2ca6 1B88     		ldrh	r3, [r3, #0]
 6521 2ca8 7F2B     		cmp	r3, #127
 6522 2caa 0AD9     		bls	.L305
2883:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // log the error
2884:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openserial_printError(
 6523              		.loc 1 2884 0
 6524 2cac 3B68     		ldr	r3, [r7, #0]
 6525 2cae 1B88     		ldrh	r3, [r3, #0]
 6526 2cb0 4FF00900 		mov	r0, #9
 6527 2cb4 4FF03301 		mov	r1, #51
 6528 2cb8 1A46     		mov	r2, r3
 6529 2cba 4FF00103 		mov	r3, #1
 6530 2cbe FFF7FEFF 		bl	openserial_printError
 6531              	.L305:
2885:openstack/02a-MAClow/IEEE802154Ecsl.c ****          COMPONENT_IEEE802154E,
2886:openstack/02a-MAClow/IEEE802154Ecsl.c ****          ERR_HEADER_TOO_LONG,
2887:openstack/02a-MAClow/IEEE802154Ecsl.c ****          (errorparameter_t)*lenIE,
2888:openstack/02a-MAClow/IEEE802154Ecsl.c ****          (errorparameter_t)1
2889:openstack/02a-MAClow/IEEE802154Ecsl.c ****       );
2890:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2891:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return TRUE;
 6532              		.loc 1 2891 0
 6533 2cc2 4FF00103 		mov	r3, #1
 6534              	.L306:
2892:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 6535              		.loc 1 2892 0
 6536 2cc6 1846     		mov	r0, r3
 6537 2cc8 07F12007 		add	r7, r7, #32
 6538 2ccc BD46     		mov	sp, r7
 6539 2cce 80BD     		pop	{r7, pc}
 6540              		.cfi_endproc
 6541              	.LFE71:
 6543              		.align	2
 6544              		.global	joinPriorityStoreFromAdv
 6545              		.thumb
 6546              		.thumb_func
 6548              	joinPriorityStoreFromAdv:
 6549              	.LFB72:
2893:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2894:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void joinPriorityStoreFromAdv(uint8_t jp){
 6550              		.loc 1 2894 0
 6551              		.cfi_startproc
 6552              		@ args = 0, pretend = 0, frame = 8
 6553              		@ frame_needed = 1, uses_anonymous_args = 0
 6554              		@ link register save eliminated.
 6555 2cd0 80B4     		push	{r7}
 6556              	.LCFI176:
 6557              		.cfi_def_cfa_offset 4
 6558              		.cfi_offset 7, -4
 6559 2cd2 83B0     		sub	sp, sp, #12
 6560              	.LCFI177:
 6561              		.cfi_def_cfa_offset 16
 6562 2cd4 00AF     		add	r7, sp, #0
 6563              	.LCFI178:
 6564              		.cfi_def_cfa_register 7
 6565 2cd6 0346     		mov	r3, r0
 6566 2cd8 FB71     		strb	r3, [r7, #7]
2895:openstack/02a-MAClow/IEEE802154Ecsl.c ****   ieee154e_vars.dataReceived->l2_joinPriority = jp;
 6567              		.loc 1 2895 0
 6568 2cda 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6569 2cde C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6570 2ce2 9B69     		ldr	r3, [r3, #24]
 6571 2ce4 FA79     		ldrb	r2, [r7, #7]
 6572 2ce6 83F86420 		strb	r2, [r3, #100]
2896:openstack/02a-MAClow/IEEE802154Ecsl.c ****   ieee154e_vars.dataReceived->l2_joinPriorityPresent = TRUE;
 6573              		.loc 1 2896 0
 6574 2cea 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6575 2cee C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6576 2cf2 9B69     		ldr	r3, [r3, #24]
 6577 2cf4 4FF00102 		mov	r2, #1
 6578 2cf8 83F86620 		strb	r2, [r3, #102]
2897:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 6579              		.loc 1 2897 0
 6580 2cfc 07F10C07 		add	r7, r7, #12
 6581 2d00 BD46     		mov	sp, r7
 6582 2d02 80BC     		pop	{r7}
 6583 2d04 7047     		bx	lr
 6584              		.cfi_endproc
 6585              	.LFE72:
 6587 2d06 00BF     		.align	2
 6588              		.global	asnStoreFromAdv
 6589              		.thumb
 6590              		.thumb_func
 6592              	asnStoreFromAdv:
 6593              	.LFB73:
2898:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2899:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void asnStoreFromAdv(uint8_t* asn) {
 6594              		.loc 1 2899 0
 6595              		.cfi_startproc
 6596              		@ args = 0, pretend = 0, frame = 8
 6597              		@ frame_needed = 1, uses_anonymous_args = 0
 6598 2d08 90B5     		push	{r4, r7, lr}
 6599              	.LCFI179:
 6600              		.cfi_def_cfa_offset 12
 6601              		.cfi_offset 4, -12
 6602              		.cfi_offset 7, -8
 6603              		.cfi_offset 14, -4
 6604 2d0a 83B0     		sub	sp, sp, #12
 6605              	.LCFI180:
 6606              		.cfi_def_cfa_offset 24
 6607 2d0c 00AF     		add	r7, sp, #0
 6608              	.LCFI181:
 6609              		.cfi_def_cfa_register 7
 6610 2d0e 7860     		str	r0, [r7, #4]
2900:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2901:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // store the ASN
2902:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asn.bytes0and1   =     asn[0]+
 6611              		.loc 1 2902 0
 6612 2d10 7B68     		ldr	r3, [r7, #4]
 6613 2d12 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 6614 2d14 1A46     		mov	r2, r3
2903:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                     256*asn[1];
 6615              		.loc 1 2903 0
 6616 2d16 7B68     		ldr	r3, [r7, #4]
 6617 2d18 03F10103 		add	r3, r3, #1
 6618 2d1c 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
2902:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asn.bytes0and1   =     asn[0]+
 6619              		.loc 1 2902 0
 6620 2d1e 4FEA0323 		lsl	r3, r3, #8
 6621 2d22 9BB2     		uxth	r3, r3
 6622 2d24 D318     		adds	r3, r2, r3
 6623 2d26 9AB2     		uxth	r2, r3
 6624 2d28 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6625 2d2c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6626 2d30 A3F80320 		strh	r2, [r3, #3]	@ unaligned
2904:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asn.bytes2and3   =     asn[2]+
 6627              		.loc 1 2904 0
 6628 2d34 7B68     		ldr	r3, [r7, #4]
 6629 2d36 03F10203 		add	r3, r3, #2
 6630 2d3a 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 6631 2d3c 1A46     		mov	r2, r3
2905:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                     256*asn[3];
 6632              		.loc 1 2905 0
 6633 2d3e 7B68     		ldr	r3, [r7, #4]
 6634 2d40 03F10303 		add	r3, r3, #3
 6635 2d44 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
2904:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asn.bytes2and3   =     asn[2]+
 6636              		.loc 1 2904 0
 6637 2d46 4FEA0323 		lsl	r3, r3, #8
 6638 2d4a 9BB2     		uxth	r3, r3
 6639 2d4c D318     		adds	r3, r2, r3
 6640 2d4e 9AB2     		uxth	r2, r3
 6641 2d50 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6642 2d54 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6643 2d58 A3F80120 		strh	r2, [r3, #1]	@ unaligned
2906:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asn.byte4        =     asn[4];
 6644              		.loc 1 2906 0
 6645 2d5c 7B68     		ldr	r3, [r7, #4]
 6646 2d5e 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 6647 2d60 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6648 2d64 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6649 2d68 1A70     		strb	r2, [r3, #0]
2907:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2908:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // determine the current slotOffset
2909:openstack/02a-MAClow/IEEE802154Ecsl.c ****    /*
2910:openstack/02a-MAClow/IEEE802154Ecsl.c ****    Note: this is a bit of a hack. Normally, slotOffset=ASN%slotlength. But since
2911:openstack/02a-MAClow/IEEE802154Ecsl.c ****    the ADV is exchanged in slot 0, we know that we're currently at slotOffset==0
2912:openstack/02a-MAClow/IEEE802154Ecsl.c ****    */
2913:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.slotOffset       = 0;
 6650              		.loc 1 2913 0
 6651 2d6a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6652 2d6e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6653 2d72 4FF00002 		mov	r2, #0
 6654 2d76 DA80     		strh	r2, [r3, #6]	@ movhi
2914:openstack/02a-MAClow/IEEE802154Ecsl.c ****    schedule_syncSlotOffset(ieee154e_vars.slotOffset);
 6655              		.loc 1 2914 0
 6656 2d78 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6657 2d7c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6658 2d80 DB88     		ldrh	r3, [r3, #6]
 6659 2d82 1846     		mov	r0, r3
 6660 2d84 FFF7FEFF 		bl	schedule_syncSlotOffset
2915:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.nextActiveSlotOffset = schedule_getNextActiveSlotOffset();
 6661              		.loc 1 2915 0
 6662 2d88 FFF7FEFF 		bl	schedule_getNextActiveSlotOffset
 6663 2d8c 0346     		mov	r3, r0
 6664 2d8e 1A46     		mov	r2, r3
 6665 2d90 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6666 2d94 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6667 2d98 1A81     		strh	r2, [r3, #8]	@ movhi
2916:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2917:openstack/02a-MAClow/IEEE802154Ecsl.c ****    /*
2918:openstack/02a-MAClow/IEEE802154Ecsl.c ****    infer the asnOffset based on the fact that
2919:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.freq = 11 + (asnOffset + channelOffset)%16
2920:openstack/02a-MAClow/IEEE802154Ecsl.c ****    */
2921:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asnOffset = ieee154e_vars.freq - 11 - schedule_getChannelOffset();
 6668              		.loc 1 2921 0
 6669 2d9a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6670 2d9e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6671 2da2 93F82C40 		ldrb	r4, [r3, #44]	@ zero_extendqisi2
 6672 2da6 FFF7FEFF 		bl	schedule_getChannelOffset
 6673 2daa 0346     		mov	r3, r0
 6674 2dac E31A     		subs	r3, r4, r3
 6675 2dae DBB2     		uxtb	r3, r3
 6676 2db0 A3F10B03 		sub	r3, r3, #11
 6677 2db4 DAB2     		uxtb	r2, r3
 6678 2db6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6679 2dba C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6680 2dbe 83F82D20 		strb	r2, [r3, #45]
2922:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 6681              		.loc 1 2922 0
 6682 2dc2 07F10C07 		add	r7, r7, #12
 6683 2dc6 BD46     		mov	sp, r7
 6684 2dc8 90BD     		pop	{r4, r7, pc}
 6685              		.cfi_endproc
 6686              	.LFE73:
 6688 2dca 00BF     		.align	2
 6689              		.global	ieee154e_asnDiff
 6690              		.thumb
 6691              		.thumb_func
 6693              	ieee154e_asnDiff:
 6694              	.LFB74:
2923:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2924:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2925:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2926:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2927:openstack/02a-MAClow/IEEE802154Ecsl.c **** /brief Difference between some older ASN and the current ASN.
2928:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2929:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in] someASN some ASN to compare to the current
2930:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2931:openstack/02a-MAClow/IEEE802154Ecsl.c **** \returns The ASN difference, or 0xffff if more than 65535 different
2932:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2933:openstack/02a-MAClow/IEEE802154Ecsl.c **** PORT_RADIOTIMER_WIDTH ieee154e_asnDiff(asn_t* someASN) {
 6695              		.loc 1 2933 0
 6696              		.cfi_startproc
 6697              		@ args = 0, pretend = 0, frame = 16
 6698              		@ frame_needed = 1, uses_anonymous_args = 0
 6699 2dcc 80B5     		push	{r7, lr}
 6700              	.LCFI182:
 6701              		.cfi_def_cfa_offset 8
 6702              		.cfi_offset 7, -8
 6703              		.cfi_offset 14, -4
 6704 2dce 84B0     		sub	sp, sp, #16
 6705              	.LCFI183:
 6706              		.cfi_def_cfa_offset 24
 6707 2dd0 00AF     		add	r7, sp, #0
 6708              	.LCFI184:
 6709              		.cfi_def_cfa_register 7
 6710 2dd2 7860     		str	r0, [r7, #4]
2934:openstack/02a-MAClow/IEEE802154Ecsl.c ****    PORT_RADIOTIMER_WIDTH diff;
2935:openstack/02a-MAClow/IEEE802154Ecsl.c ****    INTERRUPT_DECLARATION();
2936:openstack/02a-MAClow/IEEE802154Ecsl.c ****    DISABLE_INTERRUPTS();
 6711              		.loc 1 2936 0
 6712 2dd4 FFF7FEFF 		bl	IntMasterDisable
2937:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.asn.byte4 != someASN->byte4) {
 6713              		.loc 1 2937 0
 6714 2dd8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6715 2ddc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6716 2de0 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 6717 2de2 7B68     		ldr	r3, [r7, #4]
 6718 2de4 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 6719 2de6 9A42     		cmp	r2, r3
 6720 2de8 04D0     		beq	.L315
2938:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ENABLE_INTERRUPTS();
 6721              		.loc 1 2938 0
 6722 2dea FFF7FEFF 		bl	IntMasterEnable
2939:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return (PORT_RADIOTIMER_WIDTH)0xFFFFFFFF;;
 6723              		.loc 1 2939 0
 6724 2dee 4FF0FF33 		mov	r3, #-1
 6725 2df2 4CE0     		b	.L316
 6726              	.L315:
2940:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2941:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2942:openstack/02a-MAClow/IEEE802154Ecsl.c ****    diff = 0;
 6727              		.loc 1 2942 0
 6728 2df4 4FF00003 		mov	r3, #0
 6729 2df8 FB60     		str	r3, [r7, #12]
2943:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.asn.bytes2and3 == someASN->bytes2and3) {
 6730              		.loc 1 2943 0
 6731 2dfa 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6732 2dfe C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6733 2e02 B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 6734 2e06 9AB2     		uxth	r2, r3
 6735 2e08 7B68     		ldr	r3, [r7, #4]
 6736 2e0a B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 6737 2e0e 9BB2     		uxth	r3, r3
 6738 2e10 9A42     		cmp	r2, r3
 6739 2e12 0FD1     		bne	.L317
2944:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ENABLE_INTERRUPTS();
 6740              		.loc 1 2944 0
 6741 2e14 FFF7FEFF 		bl	IntMasterEnable
2945:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return ieee154e_vars.asn.bytes0and1-someASN->bytes0and1;
 6742              		.loc 1 2945 0
 6743 2e18 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6744 2e1c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6745 2e20 B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 6746 2e24 9BB2     		uxth	r3, r3
 6747 2e26 1A46     		mov	r2, r3
 6748 2e28 7B68     		ldr	r3, [r7, #4]
 6749 2e2a B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 6750 2e2e 9BB2     		uxth	r3, r3
 6751 2e30 D31A     		subs	r3, r2, r3
 6752 2e32 2CE0     		b	.L316
 6753              	.L317:
2946:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else if (ieee154e_vars.asn.bytes2and3-someASN->bytes2and3==1) {
 6754              		.loc 1 2946 0
 6755 2e34 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6756 2e38 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6757 2e3c B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 6758 2e40 9BB2     		uxth	r3, r3
 6759 2e42 1A46     		mov	r2, r3
 6760 2e44 7B68     		ldr	r3, [r7, #4]
 6761 2e46 B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 6762 2e4a 9BB2     		uxth	r3, r3
 6763 2e4c D31A     		subs	r3, r2, r3
 6764 2e4e 012B     		cmp	r3, #1
 6765 2e50 17D1     		bne	.L318
2947:openstack/02a-MAClow/IEEE802154Ecsl.c ****       diff  = ieee154e_vars.asn.bytes0and1;
 6766              		.loc 1 2947 0
 6767 2e52 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6768 2e56 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6769 2e5a B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 6770 2e5e 9BB2     		uxth	r3, r3
 6771 2e60 FB60     		str	r3, [r7, #12]
2948:openstack/02a-MAClow/IEEE802154Ecsl.c ****       diff += 0xffff-someASN->bytes0and1;
 6772              		.loc 1 2948 0
 6773 2e62 7B68     		ldr	r3, [r7, #4]
 6774 2e64 B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 6775 2e68 9BB2     		uxth	r3, r3
 6776 2e6a FA68     		ldr	r2, [r7, #12]
 6777 2e6c D31A     		subs	r3, r2, r3
 6778 2e6e 03F57F43 		add	r3, r3, #65280
 6779 2e72 03F1FF03 		add	r3, r3, #255
 6780 2e76 FB60     		str	r3, [r7, #12]
2949:openstack/02a-MAClow/IEEE802154Ecsl.c ****       diff += 1;
 6781              		.loc 1 2949 0
 6782 2e78 FB68     		ldr	r3, [r7, #12]
 6783 2e7a 03F10103 		add	r3, r3, #1
 6784 2e7e FB60     		str	r3, [r7, #12]
 6785 2e80 02E0     		b	.L319
 6786              	.L318:
2950:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
2951:openstack/02a-MAClow/IEEE802154Ecsl.c ****       diff = (PORT_RADIOTIMER_WIDTH)0xFFFFFFFF;;
 6787              		.loc 1 2951 0
 6788 2e82 4FF0FF33 		mov	r3, #-1
 6789 2e86 FB60     		str	r3, [r7, #12]
 6790              	.L319:
2952:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2953:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ENABLE_INTERRUPTS();
 6791              		.loc 1 2953 0
 6792 2e88 FFF7FEFF 		bl	IntMasterEnable
2954:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return diff;
 6793              		.loc 1 2954 0
 6794 2e8c FB68     		ldr	r3, [r7, #12]
 6795              	.L316:
2955:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 6796              		.loc 1 2955 0
 6797 2e8e 1846     		mov	r0, r3
 6798 2e90 07F11007 		add	r7, r7, #16
 6799 2e94 BD46     		mov	sp, r7
 6800 2e96 80BD     		pop	{r7, pc}
 6801              		.cfi_endproc
 6802              	.LFE74:
 6804              	.Letext0:
 6805              		.file 2 "/opt/gcc-arm-none-eabi-4_7-2013q3/bin/../lib/gcc/arm-none-eabi/4.7.4/../../../../arm-none
 6806              		.file 3 "inc/opendefs.h"
 6807              		.file 4 "openstack/02b-MAChigh/schedule.h"
 6808              		.file 5 "openstack/02b-MAChigh/processIE.h"
 6809              		.file 6 "drivers/common/opentimers.h"
 6810              		.file 7 "openstack/02a-MAClow/IEEE802154Ecsl.h"
 6811              		.file 8 "openstack/02a-MAClow/IEEE802154.h"
 6812              		.file 9 "kernel/scheduler.h"
 6813              		.file 10 "bsp/boards/OpenMote-CC2538/board_info.h"
 6814              		.file 11 "openstack/03b-IPv6/icmpv6rpl.h"
DEFINED SYMBOLS
                            *ABS*:00000000 IEEE802154Ecsl.c
     /tmp/ccpdEVsn.s:19     .rodata:00000000 $d
     /tmp/ccpdEVsn.s:22     .rodata:00000000 rreg_uriquery
     /tmp/ccpdEVsn.s:27     .rodata:00000008 infoBoardname
     /tmp/ccpdEVsn.s:32     .rodata:00000010 infouCName
     /tmp/ccpdEVsn.s:37     .rodata:00000018 infoRadioName
     /tmp/ccpdEVsn.s:42     .rodata:00000024 infoStackName
     /tmp/ccpdEVsn.s:47     .rodata:00000030 all_routers_multicast
                            *COM*:0000004c ieee154e_vars
                            *COM*:0000000f ieee154e_stats
                            *COM*:00000014 ieee154e_dbg
     /tmp/ccpdEVsn.s:68     .text:00000000 $t
     /tmp/ccpdEVsn.s:73     .text:00000000 ieee154e_init
     /tmp/ccpdEVsn.s:5446   .text:00002540 changeIsSync
     /tmp/ccpdEVsn.s:5596   .text:000025f0 resetStats
     /tmp/ccpdEVsn.s:186    .text:00000108 isr_ieee154ecsl_newChannelSample
     /tmp/ccpdEVsn.s:247    .text:0000016c isr_ieee154ecsl_timer
     /tmp/ccpdEVsn.s:516    .text:00000370 ieee154ecsl_startOfFrame
     /tmp/ccpdEVsn.s:670    .text:000004ac ieee154ecsl_endOfFrame
     /tmp/ccpdEVsn.s:813    .text:000005a8 isr_ieee154ecsl_txtimer_cb
     /tmp/ccpdEVsn.s:863    .text:000005ec isr_ieee154ecsl_addPacketToQueueForTestingCslTx_cb
     /tmp/ccpdEVsn.s:2592   .text:00001198 activity_csl_wakeup_ri1
     /tmp/ccpdEVsn.s:278    .text:00000198 $d
     /tmp/ccpdEVsn.s:2660   .text:00001208 activity_csl_wakeup_ri2
     /tmp/ccpdEVsn.s:296    .text:000001d8 $t
     /tmp/ccpdEVsn.s:2710   .text:00001258 activity_csl_wakeup_rie1
     /tmp/ccpdEVsn.s:2751   .text:00001288 activity_csl_wakeup_ri3
     /tmp/ccpdEVsn.s:2783   .text:000012a4 activity_csl_wakeup_rie2
     /tmp/ccpdEVsn.s:2871   .text:00001314 activity_csl_wakeup_rie3
     /tmp/ccpdEVsn.s:3268   .text:00001670 activity_csl_wakeup_rie4
     /tmp/ccpdEVsn.s:3294   .text:0000167c activity_csl_data_ri2
     /tmp/ccpdEVsn.s:3344   .text:000016cc activity_csl_data_rie1
     /tmp/ccpdEVsn.s:3385   .text:000016fc activity_csl_data_ri3
     /tmp/ccpdEVsn.s:3417   .text:00001718 activity_csl_data_rie2
     /tmp/ccpdEVsn.s:3495   .text:0000176c activity_csl_data_rie3
     /tmp/ccpdEVsn.s:3893   .text:00001aa8 activity_csl_data_ri6
     /tmp/ccpdEVsn.s:4126   .text:00001cc4 activity_csl_data_rie4
     /tmp/ccpdEVsn.s:4167   .text:00001cf4 activity_csl_data_ri7
     /tmp/ccpdEVsn.s:4203   .text:00001d1c activity_csl_data_rie5
     /tmp/ccpdEVsn.s:4291   .text:00001d88 activity_csl_data_rie6
     /tmp/ccpdEVsn.s:5975   .text:00002898 endOps
     /tmp/ccpdEVsn.s:397    .text:0000028c $d
     /tmp/ccpdEVsn.s:1161   .text:0000082c activity_csl_wakeup_ti2
     /tmp/ccpdEVsn.s:415    .text:000002cc $t
     /tmp/ccpdEVsn.s:1369   .text:00000a24 activity_csl_wakeup_tie1
     /tmp/ccpdEVsn.s:1407   .text:00000a50 activity_csl_wakeup_ti3
     /tmp/ccpdEVsn.s:1443   .text:00000a78 activity_csl_wakeup_tie2
     /tmp/ccpdEVsn.s:1528   .text:00000ae0 activity_csl_wakeup_tie3
     /tmp/ccpdEVsn.s:1611   .text:00000b44 activity_csl_data_ti1
     /tmp/ccpdEVsn.s:1645   .text:00000b68 activity_csl_data_ti2
     /tmp/ccpdEVsn.s:1709   .text:00000bd8 activity_csl_data_tie1
     /tmp/ccpdEVsn.s:1747   .text:00000c04 activity_csl_data_ti3
     /tmp/ccpdEVsn.s:1783   .text:00000c2c activity_csl_data_tie2
     /tmp/ccpdEVsn.s:1868   .text:00000c94 activity_csl_data_tie3
     /tmp/ccpdEVsn.s:2019   .text:00000d8c activity_csl_data_ti6
     /tmp/ccpdEVsn.s:2069   .text:00000ddc activity_csl_data_tie4
     /tmp/ccpdEVsn.s:2107   .text:00000e08 activity_csl_data_ti7
     /tmp/ccpdEVsn.s:2143   .text:00000e30 activity_csl_data_tie5
     /tmp/ccpdEVsn.s:2243   .text:00000ec4 activity_csl_data_tie6
     /tmp/ccpdEVsn.s:551    .text:000003a0 $d
     /tmp/ccpdEVsn.s:565    .text:000003d0 $t
     /tmp/ccpdEVsn.s:2819   .text:000012cc activity_csl_wakeup_ri4
     /tmp/ccpdEVsn.s:3443   .text:00001724 activity_csl_data_ri4
     /tmp/ccpdEVsn.s:4244   .text:00001d4c activity_csl_data_ri8
     /tmp/ccpdEVsn.s:602    .text:00000418 $d
     /tmp/ccpdEVsn.s:616    .text:00000448 $t
     /tmp/ccpdEVsn.s:2201   .text:00000e94 activity_csl_data_ti8
     /tmp/ccpdEVsn.s:1481   .text:00000aa4 activity_csl_wakeup_ti4
     /tmp/ccpdEVsn.s:1821   .text:00000c58 activity_csl_data_ti4
     /tmp/ccpdEVsn.s:2912   .text:00001344 activity_csl_wakeup_ri5
     /tmp/ccpdEVsn.s:3536   .text:0000179c activity_csl_data_ri5
     /tmp/ccpdEVsn.s:4332   .text:00001db8 activity_csl_data_ri9
     /tmp/ccpdEVsn.s:1566   .text:00000b0c activity_csl_wakeup_ti5
     /tmp/ccpdEVsn.s:1906   .text:00000cc0 activity_csl_data_ti5
     /tmp/ccpdEVsn.s:2269   .text:00000ed0 activity_csl_data_ti9
     /tmp/ccpdEVsn.s:1020   .text:00000718 activity_csl_wakeup_ti1
     /tmp/ccpdEVsn.s:5163   .text:00002314 incrementAsnOffset
     /tmp/ccpdEVsn.s:5719   .text:000026b4 changeState
     /tmp/ccpdEVsn.s:4397   .text:00001e24 ieee802154_createWakeUpFrame
     /tmp/ccpdEVsn.s:5074   .text:00002294 isValidAck
     /tmp/ccpdEVsn.s:6204   .text:00002a78 ieee154e_processIEs
     /tmp/ccpdEVsn.s:5499   .text:00002580 notif_sendDone
     /tmp/ccpdEVsn.s:4513   .text:00001eec ieee802154_retrieveWakeUpFrame
     /tmp/ccpdEVsn.s:4981   .text:00002218 isValidRxFrame
     /tmp/ccpdEVsn.s:5553   .text:000025cc notif_receive
     /tmp/ccpdEVsn.s:5265   .text:000023fc ieee154e_getAsn
     /tmp/ccpdEVsn.s:5342   .text:00002488 synchronizeAck
     /tmp/ccpdEVsn.s:5658   .text:00002660 updateStats
     /tmp/ccpdEVsn.s:5753   .text:000026e0 $d
     /tmp/ccpdEVsn.s:5815   .text:000027d0 $t
     /tmp/ccpdEVsn.s:5841   .text:000027ec debugPrint_asn
     /tmp/ccpdEVsn.s:5896   .text:00002840 debugPrint_isSync
     /tmp/ccpdEVsn.s:5942   .text:00002878 debugPrint_macStats
     /tmp/ccpdEVsn.s:6173   .text:00002a60 ieee154e_isSynch
     /tmp/ccpdEVsn.s:6592   .text:00002d08 asnStoreFromAdv
     /tmp/ccpdEVsn.s:6548   .text:00002cd0 joinPriorityStoreFromAdv
     /tmp/ccpdEVsn.s:6693   .text:00002dcc ieee154e_asnDiff
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.1.e96eee74da26538b12ac9582e3798382
                           .group:00000000 wm4.newlib.h.8.a9901dc52d1357e3e94003403d43f8b5
                           .group:00000000 wm4.features.h.22.b72b3baab2bb2eab3661375590100b6b
                           .group:00000000 wm4.config.h.193.5fb8ef056cdff92dec3dee9552839d8c
                           .group:00000000 wm4._ansi.h.23.b5bb84d7ba97d82b5b1dc1826a7ae811
                           .group:00000000 wm4.stdint.h.20.54ad762faa59e3c05491630641c8d8bf
                           .group:00000000 wm4.toolchain_defs.h.2.e4ebbe6e0a48032a9b79077dc42e1ffd
                           .group:00000000 wm4._default_types.h.6.5e12cd604db8ce00b62bb2f02708eaf3
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4.stddef.h.349.31f4c5baff3fa2689010b32028da9c47
                           .group:00000000 wm4.reent.h.16.9e42f0e588b85e70b2bf6572af57ce64
                           .group:00000000 wm4.stddef.h.187.9e651b6b8b16e149c1353259404973ea
                           .group:00000000 wm4.string.h.17.f8d12df81104836a3f2a5d589ae830d8
                           .group:00000000 wm4.stdbool.h.29.1c9ee6859ce8145f7838a4f2549ccec2
                           .group:00000000 wm4.hw_types.h.67.b10589a0806dcc2d274d6fab6b736519
                           .group:00000000 wm4.interrupt.h.41.272fc4ec0e276feb439e7974d0f77eaf
                           .group:00000000 wm4.board_info.h.21.847e72606a2fc49b1c228f268b8a62aa
                           .group:00000000 wm4.opendefs.h.19.05852eb648ac65e48c7817e5cbf03346
                           .group:00000000 wm4.schedule.h.2.74f699399ee9cbf3b59178f1204d8511
                           .group:00000000 wm4.processIE.h.2.1848f1e3c653035e9779472584ce0441
                           .group:00000000 wm4.opentimers.h.8.044f2d040a134cdb0ddb58adfc2508be
                           .group:00000000 wm4.IEEE802154Ecsl.h.21.4a27f1f1ecd53a3f77f305e2d49a8f4a
                           .group:00000000 wm4.idmanager.h.2.8c0e2159b32ef3125cbb1e984805cbfe
                           .group:00000000 wm4.openserial.h.8.8c63e3800d2936b44b5370ce1aae62b7
                           .group:00000000 wm4.scheduler.h.2.ca320b72942c5204a6e225e3c9c0814e
                           .group:00000000 wm4.icmpv6rpl.h.2.0ce84dbe8c203c7079b39e7e96c7c01e
                           .group:00000000 wm4.neighbors.h.15.9f35f180a0332d1bc442efb0ec51905c
                           .group:00000000 wm4.sixtop.h.2.0b8613e8e48e9109b53e6143f3ed1895

UNDEFINED SYMBOLS
memset
idmanager_getIsDAGroot
radio_rfOn
radio_setOverflowCb
radio_setCompareCb
radio_setStartFrameCb
radio_setEndFrameCb
opentimers_start
radio_startTimer
radio_setTimerPeriod
openserial_printInfo
openserial_printError
leds_all_off
openqueue_macGetDataPacket
openqueue_getFreePacketBuffer
ieee802154_prependHeader
packetfunctions_reserveFooterSize
debugpins_slot_toggle
debugpins_frame_toggle
schedule_advanceSlot
openserial_stop
schedule_getType
schedule_getOkToSend
schedule_getNeighbor
radiotimer_schedule
radio_loadPacket
radio_txEnable
radio_getTimerValue
radio_txNow
radiotimer_cancel
radio_rfOff
packetfunctions_isBroadcastMulticast
leds_sync_blink
schedule_indicateTx
radio_rxEnable
radio_rxNow
radio_getReceivedFrame
packetfunctions_tossFooter
ieee802154_retrieveHeader
packetfunctions_tossHeader
openqueue_freePacketBuffer
packetfunctions_mac64bToMac16b
packetfunctions_sameAddress
idmanager_getMyID
packetfunctions_reserveHeaderSize
packetfunctions_writeAddress
packetfunctions_readAddress
idmanager_isMyAddress
schedule_getFrameLength
radio_getTimerPeriod
adaptive_sync_indicateTimeCorrection
leds_sync_on
leds_sync_off
schedule_resetBackoff
task_sixtopNotifSendDone
scheduler_push_task
leds_error_toggle
debugpins_fsm_set
debugpins_fsm_clr
debugpins_fsm_toggle
openserial_printStatus
processIE_retrieveSlotframeLinkIE
neighbors_isPreferredParent
schedule_syncSlotOffset
schedule_getNextActiveSlotOffset
schedule_getChannelOffset
IntMasterDisable
IntMasterEnable
