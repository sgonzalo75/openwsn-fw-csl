   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"IEEE802154Ecsl.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.rodata
  19              		.align	2
  22              	rreg_uriquery:
  23 0000 683D7563 		.ascii	"h=ucb\000"
  23      6200
  24 0006 0000     		.align	2
  27              	infoBoardname:
  28 0008 43433235 		.ascii	"CC2538\000"
  28      333800
  29 000f 00       		.align	2
  32              	infouCName:
  33 0010 43433235 		.ascii	"CC2538\000"
  33      333800
  34 0017 00       		.align	2
  37              	infoRadioName:
  38 0018 43433235 		.ascii	"CC2538 SoC\000"
  38      33382053 
  38      6F4300
  39 0023 00       		.align	2
  42              	infoStackName:
  43 0024 4F70656E 		.ascii	"OpenWSN \000"
  43      57534E20 
  43      00
  44 002d 000000   		.align	2
  47              	all_routers_multicast:
  48 0030 FF       		.byte	-1
  49 0031 02       		.byte	2
  50 0032 00       		.byte	0
  51 0033 00       		.byte	0
  52 0034 00       		.byte	0
  53 0035 00       		.byte	0
  54 0036 00       		.byte	0
  55 0037 00       		.byte	0
  56 0038 00       		.byte	0
  57 0039 00       		.byte	0
  58 003a 00       		.byte	0
  59 003b 00       		.byte	0
  60 003c 00       		.byte	0
  61 003d 00       		.byte	0
  62 003e 00       		.byte	0
  63 003f 02       		.byte	2
  64              		.comm	ieee154e_vars,76,4
  65              		.comm	ieee154e_stats,15,4
  66              		.comm	ieee154e_dbg,20,4
  67              		.text
  68              		.align	2
  69              		.global	ieee154e_init
  70              		.thumb
  71              		.thumb_func
  73              	ieee154e_init:
  74              	.LFB0:
  75              		.file 1 "openstack/02a-MAClow/IEEE802154Ecsl.c"
   1:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "IEEE802154Ecsl.h"
   2:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
   3:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "opendefs.h"
   4:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "radio.h"
   5:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "radiotimer.h"
   6:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "IEEE802154.h"
   7:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "openqueue.h"
   8:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "idmanager.h"
   9:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "openserial.h"
  10:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "schedule.h"
  11:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "packetfunctions.h"
  12:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "scheduler.h"
  13:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "leds.h"
  14:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "neighbors.h"
  15:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "debugpins.h"
  16:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "sixtop.h"
  17:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "adaptive_sync.h"
  18:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "processIE.h"
  19:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  20:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
  21:openstack/02a-MAClow/IEEE802154Ecsl.c **** //=========================== VARIABLES ================================
  22:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
  23:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  24:openstack/02a-MAClow/IEEE802154Ecsl.c **** ieee154e_vars_t	   ieee154e_vars;
  25:openstack/02a-MAClow/IEEE802154Ecsl.c **** ieee154e_stats_t   ieee154e_stats;
  26:openstack/02a-MAClow/IEEE802154Ecsl.c **** ieee154e_dbg_t     ieee154e_dbg;
  27:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  28:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
  29:openstack/02a-MAClow/IEEE802154Ecsl.c **** //========================== PROTOTYPES ================================
  30:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
  31:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  32:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CSL]: FSM activities prototypes.
  33:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  34:openstack/02a-MAClow/IEEE802154Ecsl.c **** // TX-MODE: CSL Frame sending activities prototypes
  35:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ti1(void);
  36:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ti2(void);
  37:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_tie1(void);
  38:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ti3(void);
  39:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_tie2(void);
  40:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ti4(PORT_RADIOTIMER_WIDTH capturedTime);
  41:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_tie3(void);
  42:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ti5(PORT_RADIOTIMER_WIDTH capturedTime);
  43:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  44:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti1(void);
  45:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti2(void);
  46:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_tie1(void);
  47:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti3(void);
  48:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_tie2(void);
  49:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti4(PORT_RADIOTIMER_WIDTH capturedTime);
  50:openstack/02a-MAClow/IEEE802154Ecsl.c **** void	activity_csl_data_tie3(void);
  51:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti5(PORT_RADIOTIMER_WIDTH capturedTime);
  52:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti6(void);
  53:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_tie4(void);
  54:openstack/02a-MAClow/IEEE802154Ecsl.c **** void	activity_csl_data_ti7(void);
  55:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_tie5(void);
  56:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti8(PORT_RADIOTIMER_WIDTH capturedTime);
  57:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_tie6(void);
  58:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti9(PORT_RADIOTIMER_WIDTH capturedTime);
  59:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  60:openstack/02a-MAClow/IEEE802154Ecsl.c **** // RX-MODE: CSL Sampling activities prototypes
  61:openstack/02a-MAClow/IEEE802154Ecsl.c **** void 	activity_csl_wakeup_ri1(void);
  62:openstack/02a-MAClow/IEEE802154Ecsl.c **** void 	activity_csl_wakeup_ri2(void);
  63:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_rie1(void);
  64:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ri3(void);
  65:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_rie2(void);
  66:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ri4(PORT_RADIOTIMER_WIDTH capturedTime);
  67:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_rie3(void);
  68:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ri5(PORT_RADIOTIMER_WIDTH capturedTime);
  69:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_rie4(void);
  70:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  71:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ri2(void);
  72:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_rie1(void);
  73:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ri3(void);
  74:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_rie2(void);
  75:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ri4(PORT_RADIOTIMER_WIDTH capturedTime);
  76:openstack/02a-MAClow/IEEE802154Ecsl.c **** void	activity_csl_data_rie3(void);
  77:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ri5(PORT_RADIOTIMER_WIDTH capturedTime);
  78:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ri6(void);
  79:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_rie4(void);
  80:openstack/02a-MAClow/IEEE802154Ecsl.c **** void	activity_csl_data_ri7(void);
  81:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_rie5(void);
  82:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ri8(PORT_RADIOTIMER_WIDTH capturedTime);
  83:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_rie6(void);
  84:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ri9(PORT_RADIOTIMER_WIDTH capturedTime);
  85:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  86:openstack/02a-MAClow/IEEE802154Ecsl.c **** // frame validity check
  87:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool     isValidRxFrame(ieee802154_header_iht* ieee802514_header);
  88:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool     isValidAck(ieee802154_header_iht*     ieee802514_header,
  89:openstack/02a-MAClow/IEEE802154Ecsl.c ****                     OpenQueueEntry_t*          packetSent);
  90:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     changeIsSync(bool newIsSync);
  91:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  92:openstack/02a-MAClow/IEEE802154Ecsl.c **** // statistics
  93:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     resetStats(void);
  94:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     updateStats(PORT_SIGNED_INT_WIDTH timeCorrection);
  95:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  96:openstack/02a-MAClow/IEEE802154Ecsl.c **** // notifying upper layer
  97:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     notif_sendDone(OpenQueueEntry_t* packetSent, owerror_t error);
  98:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     notif_receive(OpenQueueEntry_t* packetReceived, uint8_t action);
  99:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 100:openstack/02a-MAClow/IEEE802154Ecsl.c **** // IEs Handling
 101:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool     ieee154e_processIEs(OpenQueueEntry_t* pkt, uint16_t* lenIE);
 102:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 103:openstack/02a-MAClow/IEEE802154Ecsl.c **** // ASN handling
 104:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     incrementAsnOffset(void);
 105:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     asnStoreFromAdv(uint8_t* asn);
 106:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     joinPriorityStoreFromAdv(uint8_t jp);
 107:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 108:openstack/02a-MAClow/IEEE802154Ecsl.c **** // misc
 109:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     changeState(ieee154e_state_t newstate);
 110:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     endOps(void);
 111:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool     debugPrint_asn(void);
 112:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool     debugPrint_isSync(void);
 113:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 114:openstack/02a-MAClow/IEEE802154Ecsl.c **** // CSL Sampling interrupts
 115:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     isr_ieee154ecsl_newChannelSample(void);
 116:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     isr_ieee154ecsl_timer(void);
 117:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 118:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CSL]: queue checking for local transmissions
 119:openstack/02a-MAClow/IEEE802154Ecsl.c **** void 	 isr_ieee154ecsl_txtimer_cb(void);
 120:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 121:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CSL-TEST]: Testing callback to put a packet on queue for testing CSL Tx mode.
 122:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     isr_ieee154ecsl_addPacketToQueueForTestingCslTx_cb (void);
 123:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 124:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CSL]: Wake-up frames prototypes (create and retrieve methods).
 125:openstack/02a-MAClow/IEEE802154Ecsl.c **** void 	ieee802154_retrieveWakeUpFrame(OpenQueueEntry_t* msg, ieee802154_header_iht* ieee802514_heade
 126:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    ieee802154_createWakeUpFrame(OpenQueueEntry_t* msg, uint8_t sequenceNumber, open_addr_t* ne
 127:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 128:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 129:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
 130:openstack/02a-MAClow/IEEE802154Ecsl.c **** //========================== INITIALIZATION ============================
 131:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
 132:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 133:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 134:openstack/02a-MAClow/IEEE802154Ecsl.c ****   \brief This function initializes this module.
 135:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 136:openstack/02a-MAClow/IEEE802154Ecsl.c ****   Call this function once before any other function in this module, possibly during boot-up.
 137:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 138:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CSL]: Modificaciones sobre método inicial referidas a los temporizadores y al estado inicial.
 139:openstack/02a-MAClow/IEEE802154Ecsl.c **** void ieee154e_init() {
  76              		.loc 1 139 0
  77              		.cfi_startproc
  78              		@ args = 0, pretend = 0, frame = 0
  79              		@ frame_needed = 1, uses_anonymous_args = 0
  80 0000 80B5     		push	{r7, lr}
  81              	.LCFI0:
  82              		.cfi_def_cfa_offset 8
  83              		.cfi_offset 7, -8
  84              		.cfi_offset 14, -4
  85 0002 00AF     		add	r7, sp, #0
  86              	.LCFI1:
  87              		.cfi_def_cfa_register 7
 140:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
 141:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // initialize variables
 142:openstack/02a-MAClow/IEEE802154Ecsl.c ****    memset(&ieee154e_vars,0,sizeof(ieee154e_vars_t));
  88              		.loc 1 142 0
  89 0004 40F20000 		movw	r0, #:lower16:ieee154e_vars
  90 0008 C0F20000 		movt	r0, #:upper16:ieee154e_vars
  91 000c 4FF00001 		mov	r1, #0
  92 0010 4FF04C02 		mov	r2, #76
  93 0014 FFF7FEFF 		bl	memset
 143:openstack/02a-MAClow/IEEE802154Ecsl.c ****    memset(&ieee154e_dbg,0,sizeof(ieee154e_dbg_t));
  94              		.loc 1 143 0
  95 0018 40F20000 		movw	r0, #:lower16:ieee154e_dbg
  96 001c C0F20000 		movt	r0, #:upper16:ieee154e_dbg
  97 0020 4FF00001 		mov	r1, #0
  98 0024 4FF01402 		mov	r2, #20
  99 0028 FFF7FEFF 		bl	memset
 144:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
 145:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (idmanager_getIsDAGroot()==TRUE) {
 100              		.loc 1 145 0
 101 002c FFF7FEFF 		bl	idmanager_getIsDAGroot
 102 0030 0346     		mov	r3, r0
 103 0032 002B     		cmp	r3, #0
 104 0034 04D0     		beq	.L2
 146:openstack/02a-MAClow/IEEE802154Ecsl.c ****       changeIsSync(TRUE);
 105              		.loc 1 146 0
 106 0036 4FF00100 		mov	r0, #1
 107 003a FFF7FEFF 		bl	changeIsSync
 108 003e 03E0     		b	.L3
 109              	.L2:
 147:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
 148:openstack/02a-MAClow/IEEE802154Ecsl.c ****       changeIsSync(FALSE);
 110              		.loc 1 148 0
 111 0040 4FF00000 		mov	r0, #0
 112 0044 FFF7FEFF 		bl	changeIsSync
 113              	.L3:
 149:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 150:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
 151:openstack/02a-MAClow/IEEE802154Ecsl.c ****    resetStats();
 114              		.loc 1 151 0
 115 0048 FFF7FEFF 		bl	resetStats
 152:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.numDeSync                 = 0;
 116              		.loc 1 152 0
 117 004c 40F20003 		movw	r3, #:lower16:ieee154e_stats
 118 0050 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 119 0054 4FF00002 		mov	r2, #0
 120 0058 9A71     		strb	r2, [r3, #6]
 153:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
 154:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // [CSL]: update CSL Mode to SLEEP in order to allow RX o TX.
 155:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.cslMode = CSL_SLEEP_MODE;
 121              		.loc 1 155 0
 122 005a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 123 005e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 124 0062 4FF00002 		mov	r2, #0
 125 0066 83F84520 		strb	r2, [r3, #69]
 156:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // [CSL]: Set initial DSN counter for wake-up sequence frames.
 157:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.cslDSN	 = 0;
 126              		.loc 1 157 0
 127 006a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 128 006e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 129 0072 4FF00002 		mov	r2, #0
 130 0076 83F84420 		strb	r2, [r3, #68]
 158:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 159:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // switch radio on - Does this function really do anything?. Its contents are commented...
 160:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rfOn();
 131              		.loc 1 160 0
 132 007a FFF7FEFF 		bl	radio_rfOn
 161:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
 162:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // set callback functions for the radio
 163:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_setOverflowCb(isr_ieee154ecsl_newChannelSample); // CSL - Fires every macCSLPeriod for sam
 133              		.loc 1 163 0
 134 007e 40F20000 		movw	r0, #:lower16:isr_ieee154ecsl_newChannelSample
 135 0082 C0F20000 		movt	r0, #:upper16:isr_ieee154ecsl_newChannelSample
 136 0086 FFF7FEFF 		bl	radio_setOverflowCb
 164:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_setCompareCb(isr_ieee154ecsl_timer);             // CSL - Fires for FSM state changing.
 137              		.loc 1 164 0
 138 008a 40F20000 		movw	r0, #:lower16:isr_ieee154ecsl_timer
 139 008e C0F20000 		movt	r0, #:upper16:isr_ieee154ecsl_timer
 140 0092 FFF7FEFF 		bl	radio_setCompareCb
 165:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_setStartFrameCb(ieee154ecsl_startOfFrame);       // CSL – Fires on start of frame detect
 141              		.loc 1 165 0
 142 0096 40F20000 		movw	r0, #:lower16:ieee154ecsl_startOfFrame
 143 009a C0F20000 		movt	r0, #:upper16:ieee154ecsl_startOfFrame
 144 009e FFF7FEFF 		bl	radio_setStartFrameCb
 166:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_setEndFrameCb(ieee154ecsl_endOfFrame);           // CSL – Fires on end of frame detected
 145              		.loc 1 166 0
 146 00a2 40F20000 		movw	r0, #:lower16:ieee154ecsl_endOfFrame
 147 00a6 C0F20000 		movt	r0, #:upper16:ieee154ecsl_endOfFrame
 148 00aa FFF7FEFF 		bl	radio_setEndFrameCb
 167:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 168:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // [CSL]: set timer for checking frames on local queue to transmit.
 169:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //ieee154e_vars.txTimer = opentimers_start(macCSLTxChkFreq, TIMER_PERIODIC, TIME_TICS, isr_ieee1
 170:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 171:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // [CSL-TEST]: set timer for callback to add packet to queue for testing CSL TX (every 5 seconds
 172:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //ieee154e_vars.cslTxTestTimer = opentimers_start(2000, TIMER_PERIODIC, TIME_MS, isr_ieee154ecsl
 173:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 174:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // [CSL]: have the radio start its timer for channel sampling (macCSLPeriod)
 175:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_startTimer(macCSLPeriod);
 149              		.loc 1 175 0
 150 00ae 41F69A10 		movw	r0, #6554
 151 00b2 FFF7FEFF 		bl	radio_startTimer
 176:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 152              		.loc 1 176 0
 153 00b6 80BD     		pop	{r7, pc}
 154              		.cfi_endproc
 155              	.LFE0:
 157              		.align	2
 158              		.global	isr_ieee154ecsl_newChannelSample
 159              		.thumb
 160              		.thumb_func
 162              	isr_ieee154ecsl_newChannelSample:
 163              	.LFB1:
 177:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 178:openstack/02a-MAClow/IEEE802154Ecsl.c **** //=========================== public ==========================================
 179:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 180:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
 181:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================  EVENTS & CALLBACKS ===========================
 182:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
 183:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 184:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 185:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Indicates a new CSL Channel Sample has just started.
 186:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 187:openstack/02a-MAClow/IEEE802154Ecsl.c **** This function executes in ISR mode, when the new CSÑ Channel Sample timer fires.
 188:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 189:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CSL]: Callback indicating the start of a new CSL channel sample.
 190:openstack/02a-MAClow/IEEE802154Ecsl.c **** void isr_ieee154ecsl_newChannelSample() {
 164              		.loc 1 190 0
 165              		.cfi_startproc
 166              		@ args = 0, pretend = 0, frame = 0
 167              		@ frame_needed = 1, uses_anonymous_args = 0
 168 00b8 80B5     		push	{r7, lr}
 169              	.LCFI2:
 170              		.cfi_def_cfa_offset 8
 171              		.cfi_offset 7, -8
 172              		.cfi_offset 14, -4
 173 00ba 00AF     		add	r7, sp, #0
 174              	.LCFI3:
 175              		.cfi_def_cfa_register 7
 191:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Establish the new timer for the next channel sample
 192:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_setTimerPeriod(macCSLPeriod);
 176              		.loc 1 192 0
 177 00bc 41F69A10 		movw	r0, #6554
 178 00c0 FFF7FEFF 		bl	radio_setTimerPeriod
 193:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 194:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Verificamos que no estamos ya en un proceso de TX o RX previo.
 195:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if(ieee154e_vars.cslMode == CSL_SLEEP_MODE) {
 179              		.loc 1 195 0
 180 00c4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 181 00c8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 182 00cc 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 183 00d0 002B     		cmp	r3, #0
 184 00d2 02D1     		bne	.L5
 196:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // We call the first activity on FSM for channel sampling (CSL FSM RX mode)
 197:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  activity_csl_wakeup_ri1();
 185              		.loc 1 197 0
 186 00d4 FFF7FEFF 		bl	activity_csl_wakeup_ri1
 187 00d8 12E0     		b	.L6
 188              	.L5:
 198:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
 199:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // log the info about a operation in progress
 200:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printInfo(COMPONENT_IEEE802154E,ERR_MAC_OPERATION_IN_PROGRESS,
 201:openstack/02a-MAClow/IEEE802154Ecsl.c **** 						  (errorparameter_t)ieee154e_vars.cslMode, (errorparameter_t)ieee154e_dbg.num_cslSamples);
 189              		.loc 1 201 0
 190 00da 40F20003 		movw	r3, #:lower16:ieee154e_vars
 191 00de C0F20003 		movt	r3, #:upper16:ieee154e_vars
 192 00e2 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 200:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printInfo(COMPONENT_IEEE802154E,ERR_MAC_OPERATION_IN_PROGRESS,
 193              		.loc 1 200 0
 194 00e6 1A46     		mov	r2, r3
 195              		.loc 1 201 0
 196 00e8 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 197 00ec C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 198 00f0 1B69     		ldr	r3, [r3, #16]
 200:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printInfo(COMPONENT_IEEE802154E,ERR_MAC_OPERATION_IN_PROGRESS,
 199              		.loc 1 200 0
 200 00f2 9BB2     		uxth	r3, r3
 201 00f4 4FF00900 		mov	r0, #9
 202 00f8 4FF04001 		mov	r1, #64
 203 00fc FFF7FEFF 		bl	openserial_printInfo
 204              	.L6:
 202:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 203:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 204:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Increment the number of cslSamples.
 205:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_dbg.num_cslSamples++;
 205              		.loc 1 205 0
 206 0100 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 207 0104 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 208 0108 1B69     		ldr	r3, [r3, #16]
 209 010a 03F10102 		add	r2, r3, #1
 210 010e 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 211 0112 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 212 0116 1A61     		str	r2, [r3, #16]
 206:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 213              		.loc 1 206 0
 214 0118 80BD     		pop	{r7, pc}
 215              		.cfi_endproc
 216              	.LFE1:
 218 011a 00BF     		.align	2
 219              		.global	isr_ieee154ecsl_timer
 220              		.thumb
 221              		.thumb_func
 223              	isr_ieee154ecsl_timer:
 224              	.LFB2:
 207:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 208:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 209:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Indicates the FSM timer has fired.
 210:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 211:openstack/02a-MAClow/IEEE802154Ecsl.c **** This function executes in ISR mode, when the FSM timer fires.
 212:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 213:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CSL]: Callback to select the next FSM action.
 214:openstack/02a-MAClow/IEEE802154Ecsl.c **** void isr_ieee154ecsl_timer() {
 225              		.loc 1 214 0
 226              		.cfi_startproc
 227              		@ args = 0, pretend = 0, frame = 0
 228              		@ frame_needed = 1, uses_anonymous_args = 0
 229 011c 80B5     		push	{r7, lr}
 230              	.LCFI4:
 231              		.cfi_def_cfa_offset 8
 232              		.cfi_offset 7, -8
 233              		.cfi_offset 14, -4
 234 011e 00AF     		add	r7, sp, #0
 235              	.LCFI5:
 236              		.cfi_def_cfa_register 7
 215:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.cslMode == CSL_RX_MODE)  { // Current CSL operation mode is channel sampling a
 237              		.loc 1 215 0
 238 0120 40F20003 		movw	r3, #:lower16:ieee154e_vars
 239 0124 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 240 0128 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 241 012c 012B     		cmp	r3, #1
 242 012e 71D1     		bne	.L8
 216:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   switch (ieee154e_vars.state) {
 243              		.loc 1 216 0
 244 0130 40F20003 		movw	r3, #:lower16:ieee154e_vars
 245 0134 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 246 0138 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 247 013a A3F12B03 		sub	r3, r3, #43
 248 013e 0F2B     		cmp	r3, #15
 249 0140 53D8     		bhi	.L9
 250 0142 01A2     		adr	r2, .L26
 251 0144 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 252              		.align	2
 253              	.L26:
 254 0148 89010000 		.word	.L10+1
 255 014c 8F010000 		.word	.L11+1
 256 0150 95010000 		.word	.L12+1
 257 0154 9B010000 		.word	.L13+1
 258 0158 A1010000 		.word	.L14+1
 259 015c A7010000 		.word	.L15+1
 260 0160 AD010000 		.word	.L16+1
 261 0164 B3010000 		.word	.L17+1
 262 0168 B9010000 		.word	.L18+1
 263 016c BF010000 		.word	.L19+1
 264 0170 C5010000 		.word	.L20+1
 265 0174 CB010000 		.word	.L21+1
 266 0178 D1010000 		.word	.L22+1
 267 017c D7010000 		.word	.L23+1
 268 0180 DD010000 		.word	.L24+1
 269 0184 E3010000 		.word	.L25+1
 270              	.L10:
 217:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      // RX-MODE
 218:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUPOFFSET:      activity_csl_wakeup_ri2();  break;
 271              		.loc 1 218 0
 272 0188 FFF7FEFF 		bl	activity_csl_wakeup_ri2
 273 018c BBE0     		b	.L28
 274              	.L11:
 219:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUPPREPARE:     activity_csl_wakeup_rie1(); break;
 275              		.loc 1 219 0
 276 018e FFF7FEFF 		bl	activity_csl_wakeup_rie1
 277 0192 B8E0     		b	.L28
 278              	.L12:
 220:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUPREADY:       activity_csl_wakeup_ri3();  break;
 279              		.loc 1 220 0
 280 0194 FFF7FEFF 		bl	activity_csl_wakeup_ri3
 281 0198 B5E0     		b	.L28
 282              	.L13:
 221:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUPLISTEN:      activity_csl_wakeup_rie2(); break;
 283              		.loc 1 221 0
 284 019a FFF7FEFF 		bl	activity_csl_wakeup_rie2
 285 019e B2E0     		b	.L28
 286              	.L14:
 222:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUP:			 activity_csl_wakeup_rie3(); break;
 287              		.loc 1 222 0
 288 01a0 FFF7FEFF 		bl	activity_csl_wakeup_rie3
 289 01a4 AFE0     		b	.L28
 290              	.L15:
 223:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUPVALIDATE: 	 activity_csl_wakeup_rie4(); break;
 291              		.loc 1 223 0
 292 01a6 FFF7FEFF 		bl	activity_csl_wakeup_rie4
 293 01aa ACE0     		b	.L28
 294              	.L16:
 224:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 225:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXDATAOFFSET:    	 activity_csl_data_ri2();    break;
 295              		.loc 1 225 0
 296 01ac FFF7FEFF 		bl	activity_csl_data_ri2
 297 01b0 A9E0     		b	.L28
 298              	.L17:
 226:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXDATAPREPARE:       activity_csl_data_rie1();   break;
 299              		.loc 1 226 0
 300 01b2 FFF7FEFF 		bl	activity_csl_data_rie1
 301 01b6 A6E0     		b	.L28
 302              	.L18:
 227:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXDATAREADY:         activity_csl_data_ri3();    break;
 303              		.loc 1 227 0
 304 01b8 FFF7FEFF 		bl	activity_csl_data_ri3
 305 01bc A3E0     		b	.L28
 306              	.L19:
 228:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXDATALISTEN:        activity_csl_data_rie2();   break;
 307              		.loc 1 228 0
 308 01be FFF7FEFF 		bl	activity_csl_data_rie2
 309 01c2 A0E0     		b	.L28
 310              	.L20:
 229:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXDATA:			     activity_csl_data_rie3();   break;
 311              		.loc 1 229 0
 312 01c4 FFF7FEFF 		bl	activity_csl_data_rie3
 313 01c8 9DE0     		b	.L28
 314              	.L21:
 230:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 231:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLTXACKOFFSET: 	     activity_csl_data_ri6();    break;
 315              		.loc 1 231 0
 316 01ca FFF7FEFF 		bl	activity_csl_data_ri6
 317 01ce 9AE0     		b	.L28
 318              	.L22:
 232:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLTXACKPREPARE:        activity_csl_data_rie4();   break;
 319              		.loc 1 232 0
 320 01d0 FFF7FEFF 		bl	activity_csl_data_rie4
 321 01d4 97E0     		b	.L28
 322              	.L23:
 233:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLTXACKREADY:          activity_csl_data_ri7();    break;
 323              		.loc 1 233 0
 324 01d6 FFF7FEFF 		bl	activity_csl_data_ri7
 325 01da 94E0     		b	.L28
 326              	.L24:
 234:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLTXACKDELAY:          activity_csl_data_rie5();   break;
 327              		.loc 1 234 0
 328 01dc FFF7FEFF 		bl	activity_csl_data_rie5
 329 01e0 91E0     		b	.L28
 330              	.L25:
 235:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLTXACK:               activity_csl_data_rie6();   break;
 331              		.loc 1 235 0
 332 01e2 FFF7FEFF 		bl	activity_csl_data_rie6
 333 01e6 00BF     		nop
 334 01e8 8DE0     		b	.L28
 335              	.L9:
 236:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  default:
 237:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 // log the error
 238:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_TIMERFIRES,
 239:openstack/02a-MAClow/IEEE802154Ecsl.c **** 								   (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_dbg.num_cslSamples);
 336              		.loc 1 239 0
 337 01ea 40F20003 		movw	r3, #:lower16:ieee154e_vars
 338 01ee C0F20003 		movt	r3, #:upper16:ieee154e_vars
 339 01f2 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 238:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_TIMERFIRES,
 340              		.loc 1 238 0
 341 01f4 1A46     		mov	r2, r3
 342              		.loc 1 239 0
 343 01f6 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 344 01fa C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 345 01fe 1B69     		ldr	r3, [r3, #16]
 238:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_TIMERFIRES,
 346              		.loc 1 238 0
 347 0200 9BB2     		uxth	r3, r3
 348 0202 4FF00900 		mov	r0, #9
 349 0206 4FF03B01 		mov	r1, #59
 350 020a FFF7FEFF 		bl	openserial_printError
 240:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 // abort
 241:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 endOps();
 351              		.loc 1 241 0
 352 020e FFF7FEFF 		bl	endOps
 242:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 break;
 353              		.loc 1 242 0
 354 0212 78E0     		b	.L28
 355              	.L8:
 243:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 244:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else if (ieee154e_vars.cslMode == CSL_TX_MODE)  { // Current CSL operation mode is frame TX.
 356              		.loc 1 244 0
 357 0214 40F20003 		movw	r3, #:lower16:ieee154e_vars
 358 0218 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 359 021c 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 360 0220 022B     		cmp	r3, #2
 361 0222 70D1     		bne	.L28
 245:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   switch (ieee154e_vars.state) {
 362              		.loc 1 245 0
 363 0224 40F20003 		movw	r3, #:lower16:ieee154e_vars
 364 0228 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 365 022c 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 366 022e A3F11A03 		sub	r3, r3, #26
 367 0232 0F2B     		cmp	r3, #15
 368 0234 52D8     		bhi	.L29
 369 0236 01A2     		adr	r2, .L46
 370 0238 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 371              		.align	2
 372              	.L46:
 373 023c 7D020000 		.word	.L30+1
 374 0240 83020000 		.word	.L31+1
 375 0244 89020000 		.word	.L32+1
 376 0248 8F020000 		.word	.L33+1
 377 024c 95020000 		.word	.L34+1
 378 0250 9B020000 		.word	.L35+1
 379 0254 A1020000 		.word	.L36+1
 380 0258 A7020000 		.word	.L37+1
 381 025c AD020000 		.word	.L38+1
 382 0260 B3020000 		.word	.L39+1
 383 0264 B9020000 		.word	.L40+1
 384 0268 BF020000 		.word	.L41+1
 385 026c C5020000 		.word	.L42+1
 386 0270 CB020000 		.word	.L43+1
 387 0274 D1020000 		.word	.L44+1
 388 0278 D7020000 		.word	.L45+1
 389              	.L30:
 246:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      // TX-MODE
 247:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXWAKEUPOFFSET:		 activity_csl_wakeup_ti2();  break;
 390              		.loc 1 247 0
 391 027c FFF7FEFF 		bl	activity_csl_wakeup_ti2
 392 0280 41E0     		b	.L28
 393              	.L31:
 248:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXWAKEUPPREPARE:	 activity_csl_wakeup_tie1(); break;
 394              		.loc 1 248 0
 395 0282 FFF7FEFF 		bl	activity_csl_wakeup_tie1
 396 0286 3EE0     		b	.L28
 397              	.L32:
 249:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXWAKEUPREADY:	     activity_csl_wakeup_ti3();  break;
 398              		.loc 1 249 0
 399 0288 FFF7FEFF 		bl	activity_csl_wakeup_ti3
 400 028c 3BE0     		b	.L28
 401              	.L33:
 250:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXWAKEUPDELAY:	     activity_csl_wakeup_tie2(); break;
 402              		.loc 1 250 0
 403 028e FFF7FEFF 		bl	activity_csl_wakeup_tie2
 404 0292 38E0     		b	.L28
 405              	.L34:
 251:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXWAKEUP: 	         activity_csl_wakeup_tie3(); break;
 406              		.loc 1 251 0
 407 0294 FFF7FEFF 		bl	activity_csl_wakeup_tie3
 408 0298 35E0     		b	.L28
 409              	.L35:
 252:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 253:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXDATAPREOFFSET:	 activity_csl_data_ti1();	 break;
 410              		.loc 1 253 0
 411 029a FFF7FEFF 		bl	activity_csl_data_ti1
 412 029e 32E0     		b	.L28
 413              	.L36:
 254:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXDATAOFFSET:        activity_csl_data_ti2();    break;
 414              		.loc 1 254 0
 415 02a0 FFF7FEFF 		bl	activity_csl_data_ti2
 416 02a4 2FE0     		b	.L28
 417              	.L37:
 255:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXDATAPREPARE:	     activity_csl_data_tie1(); 	 break;
 418              		.loc 1 255 0
 419 02a6 FFF7FEFF 		bl	activity_csl_data_tie1
 420 02aa 2CE0     		b	.L28
 421              	.L38:
 256:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXDATAREADY:	     activity_csl_data_ti3(); 	 break;
 422              		.loc 1 256 0
 423 02ac FFF7FEFF 		bl	activity_csl_data_ti3
 424 02b0 29E0     		b	.L28
 425              	.L39:
 257:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXDATADELAY:	     activity_csl_data_tie2(); 	 break;
 426              		.loc 1 257 0
 427 02b2 FFF7FEFF 		bl	activity_csl_data_tie2
 428 02b6 26E0     		b	.L28
 429              	.L40:
 258:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXDATA: 	         activity_csl_data_tie3();	 break;
 430              		.loc 1 258 0
 431 02b8 FFF7FEFF 		bl	activity_csl_data_tie3
 432 02bc 23E0     		b	.L28
 433              	.L41:
 259:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 260:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLRXACKOFFSET: 	     activity_csl_data_ti6();	 break;
 434              		.loc 1 260 0
 435 02be FFF7FEFF 		bl	activity_csl_data_ti6
 436 02c2 20E0     		b	.L28
 437              	.L42:
 261:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLRXACKPREPARE:	     activity_csl_data_tie4(); 	 break;
 438              		.loc 1 261 0
 439 02c4 FFF7FEFF 		bl	activity_csl_data_tie4
 440 02c8 1DE0     		b	.L28
 441              	.L43:
 262:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLRXACKREADY: 	     activity_csl_data_ti7(); 	 break;
 442              		.loc 1 262 0
 443 02ca FFF7FEFF 		bl	activity_csl_data_ti7
 444 02ce 1AE0     		b	.L28
 445              	.L44:
 263:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLRXACKLISTEN: 	     activity_csl_data_tie5(); 	 break;
 446              		.loc 1 263 0
 447 02d0 FFF7FEFF 		bl	activity_csl_data_tie5
 448 02d4 17E0     		b	.L28
 449              	.L45:
 264:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLRXACK:     	         activity_csl_data_tie6(); 	 break;
 450              		.loc 1 264 0
 451 02d6 FFF7FEFF 		bl	activity_csl_data_tie6
 452 02da 14E0     		b	.L28
 453              	.L29:
 265:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 266:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  default:
 267:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 // log the error
 268:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_TIMERFIRES,
 269:openstack/02a-MAClow/IEEE802154Ecsl.c **** 								   (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_dbg.num_cslSamples);
 454              		.loc 1 269 0
 455 02dc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 456 02e0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 457 02e4 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 268:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_TIMERFIRES,
 458              		.loc 1 268 0
 459 02e6 1A46     		mov	r2, r3
 460              		.loc 1 269 0
 461 02e8 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 462 02ec C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 463 02f0 1B69     		ldr	r3, [r3, #16]
 268:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_TIMERFIRES,
 464              		.loc 1 268 0
 465 02f2 9BB2     		uxth	r3, r3
 466 02f4 4FF00900 		mov	r0, #9
 467 02f8 4FF03B01 		mov	r1, #59
 468 02fc FFF7FEFF 		bl	openserial_printError
 270:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 // abort
 271:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 endOps();
 469              		.loc 1 271 0
 470 0300 FFF7FEFF 		bl	endOps
 272:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 break;
 471              		.loc 1 272 0
 472 0304 00BF     		nop
 473              	.L28:
 273:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 274:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 275:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_dbg.num_timer++;
 474              		.loc 1 275 0
 475 0306 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 476 030a C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 477 030e 5B68     		ldr	r3, [r3, #4]
 478 0310 03F10102 		add	r2, r3, #1
 479 0314 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 480 0318 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 481 031c 5A60     		str	r2, [r3, #4]
 276:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 482              		.loc 1 276 0
 483 031e 80BD     		pop	{r7, pc}
 484              		.cfi_endproc
 485              	.LFE2:
 487              		.align	2
 488              		.global	ieee154ecsl_startOfFrame
 489              		.thumb
 490              		.thumb_func
 492              	ieee154ecsl_startOfFrame:
 493              	.LFB3:
 277:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 278:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CSL] – Callback fired after receive a start of frame on radio.
 279:openstack/02a-MAClow/IEEE802154Ecsl.c **** void ieee154ecsl_startOfFrame(PORT_RADIOTIMER_WIDTH capturedTime) {
 494              		.loc 1 279 0
 495              		.cfi_startproc
 496              		@ args = 0, pretend = 0, frame = 8
 497              		@ frame_needed = 1, uses_anonymous_args = 0
 498 0320 80B5     		push	{r7, lr}
 499              	.LCFI6:
 500              		.cfi_def_cfa_offset 8
 501              		.cfi_offset 7, -8
 502              		.cfi_offset 14, -4
 503 0322 82B0     		sub	sp, sp, #8
 504              	.LCFI7:
 505              		.cfi_def_cfa_offset 16
 506 0324 00AF     		add	r7, sp, #0
 507              	.LCFI8:
 508              		.cfi_def_cfa_register 7
 509 0326 7860     		str	r0, [r7, #4]
 280:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	if(ieee154e_vars.cslMode == CSL_RX_MODE)  { // Current CSL operation mode is channel sampling and 
 510              		.loc 1 280 0
 511 0328 40F20003 		movw	r3, #:lower16:ieee154e_vars
 512 032c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 513 0330 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 514 0334 012B     		cmp	r3, #1
 515 0336 33D1     		bne	.L48
 281:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   switch (ieee154e_vars.state) {
 516              		.loc 1 281 0
 517 0338 40F20003 		movw	r3, #:lower16:ieee154e_vars
 518 033c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 519 0340 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 520 0342 A3F12E03 		sub	r3, r3, #46
 521 0346 0B2B     		cmp	r3, #11
 522 0348 27D8     		bhi	.L49
 523 034a 01A2     		adr	r2, .L53
 524 034c 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 525              		.align	2
 526              	.L53:
 527 0350 81030000 		.word	.L50+1
 528 0354 81030000 		.word	.L50+1
 529 0358 9B030000 		.word	.L49+1
 530 035c 9B030000 		.word	.L49+1
 531 0360 9B030000 		.word	.L49+1
 532 0364 89030000 		.word	.L51+1
 533 0368 89030000 		.word	.L51+1
 534 036c 9B030000 		.word	.L49+1
 535 0370 9B030000 		.word	.L49+1
 536 0374 9B030000 		.word	.L49+1
 537 0378 9B030000 		.word	.L49+1
 538 037c 91030000 		.word	.L52+1
 539              	.L50:
 282:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  // RX MODE
 283:openstack/02a-MAClow/IEEE802154Ecsl.c ****           /*
 284:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   It is possible to receive in this state for radio where there is no way of differentiated betw
 285:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   (e.g. CC2420). We must therefore expect to the start of a packet in this "ready" state.
 286:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  */
 287:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUP:    			 // no break!
 288:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUPLISTEN:	 	     activity_csl_wakeup_ri4(capturedTime); break;
 540              		.loc 1 288 0
 541 0380 7868     		ldr	r0, [r7, #4]
 542 0382 FFF7FEFF 		bl	activity_csl_wakeup_ri4
 543 0386 58E0     		b	.L55
 544              	.L51:
 289:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 290:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXDATAREADY:		     // no break!
 291:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXDATALISTEN:            activity_csl_data_ri4(capturedTime);   break;
 545              		.loc 1 291 0
 546 0388 7868     		ldr	r0, [r7, #4]
 547 038a FFF7FEFF 		bl	activity_csl_data_ri4
 548 038e 54E0     		b	.L55
 549              	.L52:
 292:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 293:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLTXACKDELAY:              activity_csl_data_ri8(capturedTime);   break;
 550              		.loc 1 293 0
 551 0390 7868     		ldr	r0, [r7, #4]
 552 0392 FFF7FEFF 		bl	activity_csl_data_ri8
 553 0396 00BF     		nop
 554 0398 4FE0     		b	.L55
 555              	.L49:
 294:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  default:
 295:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			// log the error
 296:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			//openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_SAMPLE,
 297:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			//					  (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_dbg.num_cslSamples);
 298:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			// abort
 299:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			endOps();
 556              		.loc 1 299 0
 557 039a FFF7FEFF 		bl	endOps
 300:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			break;
 558              		.loc 1 300 0
 559 039e 4CE0     		b	.L55
 560              	.L48:
 301:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		}
 302:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	} else if (ieee154e_vars.cslMode == CSL_TX_MODE)  { // Current CSL operation mode is frame TX.
 561              		.loc 1 302 0
 562 03a0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 563 03a4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 564 03a8 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 565 03ac 022B     		cmp	r3, #2
 566 03ae 44D1     		bne	.L55
 303:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   switch (ieee154e_vars.state) {
 567              		.loc 1 303 0
 568 03b0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 569 03b4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 570 03b8 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 571 03ba A3F11D03 		sub	r3, r3, #29
 572 03be 0B2B     		cmp	r3, #11
 573 03c0 26D8     		bhi	.L56
 574 03c2 01A2     		adr	r2, .L60
 575 03c4 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 576              		.align	2
 577              	.L60:
 578 03c8 01040000 		.word	.L57+1
 579 03cc 11040000 		.word	.L56+1
 580 03d0 11040000 		.word	.L56+1
 581 03d4 11040000 		.word	.L56+1
 582 03d8 11040000 		.word	.L56+1
 583 03dc 11040000 		.word	.L56+1
 584 03e0 09040000 		.word	.L58+1
 585 03e4 11040000 		.word	.L56+1
 586 03e8 11040000 		.word	.L56+1
 587 03ec 11040000 		.word	.L56+1
 588 03f0 F9030000 		.word	.L59+1
 589 03f4 F9030000 		.word	.L59+1
 590              	.L59:
 304:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  // TX MODE
 305:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 306:openstack/02a-MAClow/IEEE802154Ecsl.c ****           /*
 307:openstack/02a-MAClow/IEEE802154Ecsl.c ****           It is possible to receive in this state for radio where there is no way of differentiated
 308:openstack/02a-MAClow/IEEE802154Ecsl.c ****           (e.g. CC2420). We must therefore expect to the start of a packet in this "ready" state.
 309:openstack/02a-MAClow/IEEE802154Ecsl.c ****           */
 310:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLRXACKREADY:               // no break!
 311:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLRXACKLISTEN:              activity_csl_data_ti8(capturedTime);  break;
 591              		.loc 1 311 0
 592 03f8 7868     		ldr	r0, [r7, #4]
 593 03fa FFF7FEFF 		bl	activity_csl_data_ti8
 594 03fe 1CE0     		b	.L55
 595              	.L57:
 312:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 313:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXWAKEUPDELAY:            activity_csl_wakeup_ti4(capturedTime); break;
 596              		.loc 1 313 0
 597 0400 7868     		ldr	r0, [r7, #4]
 598 0402 FFF7FEFF 		bl	activity_csl_wakeup_ti4
 599 0406 18E0     		b	.L55
 600              	.L58:
 314:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXDATADELAY:              activity_csl_data_ti4(capturedTime);   break;
 601              		.loc 1 314 0
 602 0408 7868     		ldr	r0, [r7, #4]
 603 040a FFF7FEFF 		bl	activity_csl_data_ti4
 604 040e 14E0     		b	.L55
 605              	.L56:
 315:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 316:openstack/02a-MAClow/IEEE802154Ecsl.c ****           default:
 317:openstack/02a-MAClow/IEEE802154Ecsl.c ****    			// log the error
 318:openstack/02a-MAClow/IEEE802154Ecsl.c ****    			openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_SAMPLE,
 319:openstack/02a-MAClow/IEEE802154Ecsl.c ****    								  (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_dbg.num_cslSamples);
 606              		.loc 1 319 0
 607 0410 40F20003 		movw	r3, #:lower16:ieee154e_vars
 608 0414 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 609 0418 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 318:openstack/02a-MAClow/IEEE802154Ecsl.c ****    			openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_SAMPLE,
 610              		.loc 1 318 0
 611 041a 1A46     		mov	r2, r3
 612              		.loc 1 319 0
 613 041c 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 614 0420 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 615 0424 1B69     		ldr	r3, [r3, #16]
 318:openstack/02a-MAClow/IEEE802154Ecsl.c ****    			openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_SAMPLE,
 616              		.loc 1 318 0
 617 0426 9BB2     		uxth	r3, r3
 618 0428 4FF00900 		mov	r0, #9
 619 042c 4FF03E01 		mov	r1, #62
 620 0430 FFF7FEFF 		bl	openserial_printError
 320:openstack/02a-MAClow/IEEE802154Ecsl.c ****    			// abort
 321:openstack/02a-MAClow/IEEE802154Ecsl.c ****    			endOps();
 621              		.loc 1 321 0
 622 0434 FFF7FEFF 		bl	endOps
 322:openstack/02a-MAClow/IEEE802154Ecsl.c ****    			break;
 623              		.loc 1 322 0
 624 0438 00BF     		nop
 625              	.L55:
 323:openstack/02a-MAClow/IEEE802154Ecsl.c ****    		}
 324:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	}
 325:openstack/02a-MAClow/IEEE802154Ecsl.c ****   ieee154e_dbg.num_startOfFrame++;
 626              		.loc 1 325 0
 627 043a 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 628 043e C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 629 0442 9B68     		ldr	r3, [r3, #8]
 630 0444 03F10102 		add	r2, r3, #1
 631 0448 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 632 044c C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 633 0450 9A60     		str	r2, [r3, #8]
 326:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 634              		.loc 1 326 0
 635 0452 07F10807 		add	r7, r7, #8
 636 0456 BD46     		mov	sp, r7
 637 0458 80BD     		pop	{r7, pc}
 638              		.cfi_endproc
 639              	.LFE3:
 641 045a 00BF     		.align	2
 642              		.global	ieee154ecsl_endOfFrame
 643              		.thumb
 644              		.thumb_func
 646              	ieee154ecsl_endOfFrame:
 647              	.LFB4:
 327:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 328:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CSL] – Callback fired after receive a end of frame on radio.
 329:openstack/02a-MAClow/IEEE802154Ecsl.c **** void ieee154ecsl_endOfFrame(PORT_RADIOTIMER_WIDTH capturedTime) {
 648              		.loc 1 329 0
 649              		.cfi_startproc
 650              		@ args = 0, pretend = 0, frame = 8
 651              		@ frame_needed = 1, uses_anonymous_args = 0
 652 045c 80B5     		push	{r7, lr}
 653              	.LCFI9:
 654              		.cfi_def_cfa_offset 8
 655              		.cfi_offset 7, -8
 656              		.cfi_offset 14, -4
 657 045e 82B0     		sub	sp, sp, #8
 658              	.LCFI10:
 659              		.cfi_def_cfa_offset 16
 660 0460 00AF     		add	r7, sp, #0
 661              	.LCFI11:
 662              		.cfi_def_cfa_register 7
 663 0462 7860     		str	r0, [r7, #4]
 330:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	if(ieee154e_vars.cslMode == CSL_RX_MODE)  { // Current CSL operation mode is channel sampling and 
 664              		.loc 1 330 0
 665 0464 40F20003 		movw	r3, #:lower16:ieee154e_vars
 666 0468 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 667 046c 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 668 0470 012B     		cmp	r3, #1
 669 0472 4AD1     		bne	.L62
 331:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   switch (ieee154e_vars.state) {
 670              		.loc 1 331 0
 671 0474 40F20003 		movw	r3, #:lower16:ieee154e_vars
 672 0478 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 673 047c 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 674 047e A3F12E03 		sub	r3, r3, #46
 675 0482 0C2B     		cmp	r3, #12
 676 0484 2CD8     		bhi	.L63
 677 0486 01A2     		adr	r2, .L68
 678 0488 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 679              		.align	2
 680              	.L68:
 681 048c D9040000 		.word	.L64+1
 682 0490 C1040000 		.word	.L65+1
 683 0494 E1040000 		.word	.L63+1
 684 0498 E1040000 		.word	.L63+1
 685 049c E1040000 		.word	.L63+1
 686 04a0 E1040000 		.word	.L63+1
 687 04a4 E1040000 		.word	.L63+1
 688 04a8 C9040000 		.word	.L66+1
 689 04ac E1040000 		.word	.L63+1
 690 04b0 E1040000 		.word	.L63+1
 691 04b4 E1040000 		.word	.L63+1
 692 04b8 E1040000 		.word	.L63+1
 693 04bc D1040000 		.word	.L67+1
 694              	.L65:
 332:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		 // RX MODE
 333:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		 case S_CSLRXWAKEUP:           activity_csl_wakeup_ri5(capturedTime);  break;
 695              		.loc 1 333 0
 696 04c0 7868     		ldr	r0, [r7, #4]
 697 04c2 FFF7FEFF 		bl	activity_csl_wakeup_ri5
 698 04c6 54E0     		b	.L70
 699              	.L66:
 334:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		 case S_CSLRXDATA:             activity_csl_data_ri5(capturedTime);    break;
 700              		.loc 1 334 0
 701 04c8 7868     		ldr	r0, [r7, #4]
 702 04ca FFF7FEFF 		bl	activity_csl_data_ri5
 703 04ce 50E0     		b	.L70
 704              	.L67:
 335:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		 case S_CSLTXACK:              activity_csl_data_ri9(capturedTime);    break;
 705              		.loc 1 335 0
 706 04d0 7868     		ldr	r0, [r7, #4]
 707 04d2 FFF7FEFF 		bl	activity_csl_data_ri9
 708 04d6 4CE0     		b	.L70
 709              	.L64:
 336:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		 // [CSL]: En caso que en el periodo de LISTEN solo detectemos el fin de trama al no haber sincro
 337:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		 case S_CSLRXWAKEUPLISTEN:	   activity_csl_wakeup_ri1();			   break;
 710              		.loc 1 337 0
 711 04d8 FFF7FEFF 		bl	activity_csl_wakeup_ri1
 712 04dc 00BF     		nop
 713 04de 48E0     		b	.L70
 714              	.L63:
 338:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		 default:
 339:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			// log the error
 340:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_ENDOFFRAME,
 341:openstack/02a-MAClow/IEEE802154Ecsl.c **** 								  (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_dbg.num_cslSamples);
 715              		.loc 1 341 0
 716 04e0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 717 04e4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 718 04e8 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 340:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_ENDOFFRAME,
 719              		.loc 1 340 0
 720 04ea 1A46     		mov	r2, r3
 721              		.loc 1 341 0
 722 04ec 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 723 04f0 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 724 04f4 1B69     		ldr	r3, [r3, #16]
 340:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_ENDOFFRAME,
 725              		.loc 1 340 0
 726 04f6 9BB2     		uxth	r3, r3
 727 04f8 4FF00900 		mov	r0, #9
 728 04fc 4FF03F01 		mov	r1, #63
 729 0500 FFF7FEFF 		bl	openserial_printError
 342:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			// abort
 343:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			endOps();
 730              		.loc 1 343 0
 731 0504 FFF7FEFF 		bl	endOps
 344:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			break;
 732              		.loc 1 344 0
 733 0508 33E0     		b	.L70
 734              	.L62:
 345:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 346:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	} else if (ieee154e_vars.cslMode == CSL_TX_MODE)  { // Current CSL operation mode is frame TX.
 735              		.loc 1 346 0
 736 050a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 737 050e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 738 0512 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 739 0516 022B     		cmp	r3, #2
 740 0518 2BD1     		bne	.L70
 347:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  switch (ieee154e_vars.state) {
 741              		.loc 1 347 0
 742 051a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 743 051e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 744 0522 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 745 0524 242B     		cmp	r3, #36
 746 0526 07D0     		beq	.L73
 747 0528 292B     		cmp	r3, #41
 748 052a 09D0     		beq	.L74
 749 052c 1E2B     		cmp	r3, #30
 750 052e 0BD1     		bne	.L75
 751              	.L72:
 348:openstack/02a-MAClow/IEEE802154Ecsl.c ****         // TX MODE
 349:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	    case S_CSLTXWAKEUP:            activity_csl_wakeup_ti5(capturedTime); break;
 752              		.loc 1 349 0
 753 0530 7868     		ldr	r0, [r7, #4]
 754 0532 FFF7FEFF 		bl	activity_csl_wakeup_ti5
 755 0536 1CE0     		b	.L70
 756              	.L73:
 350:openstack/02a-MAClow/IEEE802154Ecsl.c ****         case S_CSLTXDATA:              activity_csl_data_ti5(capturedTime);   break;
 757              		.loc 1 350 0
 758 0538 7868     		ldr	r0, [r7, #4]
 759 053a FFF7FEFF 		bl	activity_csl_data_ti5
 760 053e 18E0     		b	.L70
 761              	.L74:
 351:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	    case S_CSLRXACK:               activity_csl_data_ti9(capturedTime);   break;
 762              		.loc 1 351 0
 763 0540 7868     		ldr	r0, [r7, #4]
 764 0542 FFF7FEFF 		bl	activity_csl_data_ti9
 765 0546 14E0     		b	.L70
 766              	.L75:
 352:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	    default:
 353:openstack/02a-MAClow/IEEE802154Ecsl.c ****            // log the error
 354:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_ENDOFFRAME,
 355:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			   				    (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_dbg.num_cslSamples)
 767              		.loc 1 355 0
 768 0548 40F20003 		movw	r3, #:lower16:ieee154e_vars
 769 054c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 770 0550 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 354:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_ENDOFFRAME,
 771              		.loc 1 354 0
 772 0552 1A46     		mov	r2, r3
 773              		.loc 1 355 0
 774 0554 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 775 0558 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 776 055c 1B69     		ldr	r3, [r3, #16]
 354:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_ENDOFFRAME,
 777              		.loc 1 354 0
 778 055e 9BB2     		uxth	r3, r3
 779 0560 4FF00900 		mov	r0, #9
 780 0564 4FF03F01 		mov	r1, #63
 781 0568 FFF7FEFF 		bl	openserial_printError
 356:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	   // abort
 357:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   endOps();
 782              		.loc 1 357 0
 783 056c FFF7FEFF 		bl	endOps
 358:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   break;
 784              		.loc 1 358 0
 785 0570 00BF     		nop
 786              	.L70:
 359:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  }
 360:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	}
 361:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_dbg.num_endOfFrame++;
 787              		.loc 1 361 0
 788 0572 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 789 0576 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 790 057a DB68     		ldr	r3, [r3, #12]
 791 057c 03F10102 		add	r2, r3, #1
 792 0580 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 793 0584 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 794 0588 DA60     		str	r2, [r3, #12]
 362:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 795              		.loc 1 362 0
 796 058a 07F10807 		add	r7, r7, #8
 797 058e BD46     		mov	sp, r7
 798 0590 80BD     		pop	{r7, pc}
 799              		.cfi_endproc
 800              	.LFE4:
 802 0592 00BF     		.align	2
 803              		.global	isr_ieee154ecsl_txtimer_cb
 804              		.thumb
 805              		.thumb_func
 807              	isr_ieee154ecsl_txtimer_cb:
 808              	.LFB5:
 363:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 364:openstack/02a-MAClow/IEEE802154Ecsl.c **** // tx timer interrupt callbacks
 365:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 366:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CSL]: Callback to check pending data to be sent.
 367:openstack/02a-MAClow/IEEE802154Ecsl.c **** void isr_ieee154ecsl_txtimer_cb() {
 809              		.loc 1 367 0
 810              		.cfi_startproc
 811              		@ args = 0, pretend = 0, frame = 0
 812              		@ frame_needed = 1, uses_anonymous_args = 0
 813 0594 80B5     		push	{r7, lr}
 814              	.LCFI12:
 815              		.cfi_def_cfa_offset 8
 816              		.cfi_offset 7, -8
 817              		.cfi_offset 14, -4
 818 0596 00AF     		add	r7, sp, #0
 819              	.LCFI13:
 820              		.cfi_def_cfa_register 7
 368:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 369:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// Verificamos que no estamos ya en un proceso de TX o RX previo.
 370:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if(ieee154e_vars.cslMode == CSL_SLEEP_MODE) {
 821              		.loc 1 370 0
 822 0598 40F20003 		movw	r3, #:lower16:ieee154e_vars
 823 059c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 824 05a0 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 825 05a4 002B     		cmp	r3, #0
 826 05a6 02D1     		bne	.L77
 371:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // We call the first activity on FSM for channel sampling (CSL FSM RX mode)
 372:openstack/02a-MAClow/IEEE802154Ecsl.c ****       activity_csl_wakeup_ti1();
 827              		.loc 1 372 0
 828 05a8 FFF7FEFF 		bl	activity_csl_wakeup_ti1
 829 05ac 12E0     		b	.L76
 830              	.L77:
 373:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 374:openstack/02a-MAClow/IEEE802154Ecsl.c ****    else {
 375:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // log the info about a operation in progress
 376:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printInfo(COMPONENT_IEEE802154E,ERR_MAC_OPERATION_IN_PROGRESS,
 377:openstack/02a-MAClow/IEEE802154Ecsl.c **** 						  (errorparameter_t)ieee154e_vars.cslMode, (errorparameter_t)ieee154e_dbg.num_cslSamples);
 831              		.loc 1 377 0
 832 05ae 40F20003 		movw	r3, #:lower16:ieee154e_vars
 833 05b2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 834 05b6 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 376:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printInfo(COMPONENT_IEEE802154E,ERR_MAC_OPERATION_IN_PROGRESS,
 835              		.loc 1 376 0
 836 05ba 1A46     		mov	r2, r3
 837              		.loc 1 377 0
 838 05bc 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 839 05c0 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 840 05c4 1B69     		ldr	r3, [r3, #16]
 376:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printInfo(COMPONENT_IEEE802154E,ERR_MAC_OPERATION_IN_PROGRESS,
 841              		.loc 1 376 0
 842 05c6 9BB2     		uxth	r3, r3
 843 05c8 4FF00900 		mov	r0, #9
 844 05cc 4FF04001 		mov	r1, #64
 845 05d0 FFF7FEFF 		bl	openserial_printInfo
 846              	.L76:
 378:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 379:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 847              		.loc 1 379 0
 848 05d4 80BD     		pop	{r7, pc}
 849              		.cfi_endproc
 850              	.LFE5:
 852 05d6 00BF     		.align	2
 853              		.global	isr_ieee154ecsl_addPacketToQueueForTestingCslTx_cb
 854              		.thumb
 855              		.thumb_func
 857              	isr_ieee154ecsl_addPacketToQueueForTestingCslTx_cb:
 858              	.LFB6:
 380:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 381:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CST-TEST]: test timer interrupt callback to put a new packet on queue for testing CSL TX mode.
 382:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 383:openstack/02a-MAClow/IEEE802154Ecsl.c **** void isr_ieee154ecsl_addPacketToQueueForTestingCslTx_cb () {
 859              		.loc 1 383 0
 860              		.cfi_startproc
 861              		@ args = 0, pretend = 0, frame = 24
 862              		@ frame_needed = 1, uses_anonymous_args = 0
 863 05d8 B0B5     		push	{r4, r5, r7, lr}
 864              	.LCFI14:
 865              		.cfi_def_cfa_offset 16
 866              		.cfi_offset 4, -16
 867              		.cfi_offset 5, -12
 868              		.cfi_offset 7, -8
 869              		.cfi_offset 14, -4
 870 05da 8AB0     		sub	sp, sp, #40
 871              	.LCFI15:
 872              		.cfi_def_cfa_offset 56
 873 05dc 04AF     		add	r7, sp, #16
 874              	.LCFI16:
 875              		.cfi_def_cfa 7, 40
 384:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 385:openstack/02a-MAClow/IEEE802154Ecsl.c ****   OpenQueueEntry_t* pkt;
 386:openstack/02a-MAClow/IEEE802154Ecsl.c ****   open_addr_t neighbor;
 387:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 388:openstack/02a-MAClow/IEEE802154Ecsl.c ****   // Simulate a ficticious address for CSL testing.
 389:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[0]=0x00;
 876              		.loc 1 389 0
 877 05de 4FF00003 		mov	r3, #0
 878 05e2 7B70     		strb	r3, [r7, #1]
 390:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[1]=0x11;
 879              		.loc 1 390 0
 880 05e4 4FF01103 		mov	r3, #17
 881 05e8 BB70     		strb	r3, [r7, #2]
 391:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[2]=0x22;
 882              		.loc 1 391 0
 883 05ea 4FF02203 		mov	r3, #34
 884 05ee FB70     		strb	r3, [r7, #3]
 392:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[3]=0x33;
 885              		.loc 1 392 0
 886 05f0 4FF03303 		mov	r3, #51
 887 05f4 3B71     		strb	r3, [r7, #4]
 393:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[4]=0x44;
 888              		.loc 1 393 0
 889 05f6 4FF04403 		mov	r3, #68
 890 05fa 7B71     		strb	r3, [r7, #5]
 394:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[5]=0x55;
 891              		.loc 1 394 0
 892 05fc 4FF05503 		mov	r3, #85
 893 0600 BB71     		strb	r3, [r7, #6]
 395:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[6]=0x66;
 894              		.loc 1 395 0
 895 0602 4FF06603 		mov	r3, #102
 896 0606 FB71     		strb	r3, [r7, #7]
 396:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[7]=0x77;
 897              		.loc 1 396 0
 898 0608 4FF07703 		mov	r3, #119
 899 060c 3B72     		strb	r3, [r7, #8]
 397:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 398:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.type=ADDR_64B;
 900              		.loc 1 398 0
 901 060e 4FF00203 		mov	r3, #2
 902 0612 3B70     		strb	r3, [r7, #0]
 399:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 400:openstack/02a-MAClow/IEEE802154Ecsl.c ****   // Switch off all the leds.
 401:openstack/02a-MAClow/IEEE802154Ecsl.c ****   leds_all_off();
 903              		.loc 1 401 0
 904 0614 FFF7FEFF 		bl	leds_all_off
 402:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 403:openstack/02a-MAClow/IEEE802154Ecsl.c ****   // CREATE DATA PACKET ONLY IF NOT ALREADY EXISTS ON QUEUE.
 404:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 405:openstack/02a-MAClow/IEEE802154Ecsl.c ****   if (openqueue_macGetDataPacket(&neighbor) == NULL) {
 905              		.loc 1 405 0
 906 0618 3B46     		mov	r3, r7
 907 061a 1846     		mov	r0, r3
 908 061c FFF7FEFF 		bl	openqueue_macGetDataPacket
 909 0620 0346     		mov	r3, r0
 910 0622 002B     		cmp	r3, #0
 911 0624 6AD1     		bne	.L79
 406:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 407:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // get freebuffer.
 408:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt = openqueue_getFreePacketBuffer(COMPONENT_IEEE802154E);
 912              		.loc 1 408 0
 913 0626 4FF00900 		mov	r0, #9
 914 062a FFF7FEFF 		bl	openqueue_getFreePacketBuffer
 915 062e 7861     		str	r0, [r7, #20]
 409:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  if(pkt==NULL) {
 916              		.loc 1 409 0
 917 0630 7B69     		ldr	r3, [r7, #20]
 918 0632 002B     		cmp	r3, #0
 919 0634 0CD1     		bne	.L81
 410:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		// registro del error & fin de operaciones.
 411:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		openserial_printError(COMPONENT_IEEE802154E,ERR_NO_FREE_PACKET_BUFFER, (errorparameter_t)0, (erro
 920              		.loc 1 411 0
 921 0636 4FF00900 		mov	r0, #9
 922 063a 4FF02C01 		mov	r1, #44
 923 063e 4FF00002 		mov	r2, #0
 924 0642 4FF00003 		mov	r3, #0
 925 0646 FFF7FEFF 		bl	openserial_printError
 412:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		endOps();
 926              		.loc 1 412 0
 927 064a FFF7FEFF 		bl	endOps
 928 064e 55E0     		b	.L79
 929              	.L81:
 413:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		return;
 414:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  }
 415:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 416:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // Declaración de propiedad sobre el paquete.
 417:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->creator = COMPONENT_SIXTOP_TO_IEEE802154E;
 930              		.loc 1 417 0
 931 0650 7B69     		ldr	r3, [r7, #20]
 932 0652 4FF00A02 		mov	r2, #10
 933 0656 1A70     		strb	r2, [r3, #0]
 418:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->owner   = COMPONENT_SIXTOP_TO_IEEE802154E;
 934              		.loc 1 418 0
 935 0658 7B69     		ldr	r3, [r7, #20]
 936 065a 4FF00A02 		mov	r2, #10
 937 065e 5A70     		strb	r2, [r3, #1]
 419:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 420:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // Frame type (data frame).
 421:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->l2_frameType=IEEE154_TYPE_DATA;
 938              		.loc 1 421 0
 939 0660 7B69     		ldr	r3, [r7, #20]
 940 0662 4FF00102 		mov	r2, #1
 941 0666 83F84920 		strb	r2, [r3, #73]
 422:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 423:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // Neighbor address.
 424:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  memcpy(&(pkt->l2_nextORpreviousHop),&neighbor,sizeof(open_addr_t));
 942              		.loc 1 424 0
 943 066a 7B69     		ldr	r3, [r7, #20]
 944 066c 03F13803 		add	r3, r3, #56
 945 0670 1D46     		mov	r5, r3
 946 0672 3C46     		mov	r4, r7
 947 0674 0FCC     		ldmia	r4!, {r0, r1, r2, r3}
 948 0676 2860     		str	r0, [r5, #0]	@ unaligned
 949 0678 6960     		str	r1, [r5, #4]	@ unaligned
 950 067a AA60     		str	r2, [r5, #8]	@ unaligned
 951 067c EB60     		str	r3, [r5, #12]	@ unaligned
 952 067e 2378     		ldrb	r3, [r4, #0]
 953 0680 2B74     		strb	r3, [r5, #16]
 425:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 426:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // TX retries
 427:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->l2_retriesLeft = TXRETRIES;
 954              		.loc 1 427 0
 955 0682 7B69     		ldr	r3, [r7, #20]
 956 0684 4FF00302 		mov	r2, #3
 957 0688 83F84B20 		strb	r2, [r3, #75]
 428:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 429:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // record this packet's dsn (for matching the ACK)
 430:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->l2_dsn = ieee154e_vars.cslDSN++;
 958              		.loc 1 430 0
 959 068c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 960 0690 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 961 0694 93F84430 		ldrb	r3, [r3, #68]	@ zero_extendqisi2
 962 0698 7A69     		ldr	r2, [r7, #20]
 963 069a 1946     		mov	r1, r3
 964 069c 82F84A10 		strb	r1, [r2, #74]
 965 06a0 03F10103 		add	r3, r3, #1
 966 06a4 DAB2     		uxtb	r2, r3
 967 06a6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 968 06aa C0F20003 		movt	r3, #:upper16:ieee154e_vars
 969 06ae 83F84420 		strb	r2, [r3, #68]
 431:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 432:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // this is a new packet which I never attempted to send
 433:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->l2_numTxAttempts = 0;
 970              		.loc 1 433 0
 971 06b2 7B69     		ldr	r3, [r7, #20]
 972 06b4 4FF00002 		mov	r2, #0
 973 06b8 83F84C20 		strb	r2, [r3, #76]
 434:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 435:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // transmit with the default TX power
 436:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->l1_txPower = TX_POWER;
 974              		.loc 1 436 0
 975 06bc 7B69     		ldr	r3, [r7, #20]
 976 06be 4FF01F02 		mov	r2, #31
 977 06c2 83F86720 		strb	r2, [r3, #103]
 437:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 438:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // add a IEEE802.15.4 header
 439:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  ieee802154_prependHeader(pkt,
 440:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							   pkt->l2_frameType,
 978              		.loc 1 440 0
 979 06c6 7B69     		ldr	r3, [r7, #20]
 439:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  ieee802154_prependHeader(pkt,
 980              		.loc 1 439 0
 981 06c8 93F84930 		ldrb	r3, [r3, #73]	@ zero_extendqisi2
 441:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							   IEEE154_IELIST_NO,
 442:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							   IEEE154_FRAMEVERSION,
 443:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							   IEEE154_SEC_NO_SECURITY,
 444:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							   pkt->l2_dsn,
 982              		.loc 1 444 0
 983 06cc 7A69     		ldr	r2, [r7, #20]
 439:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  ieee802154_prependHeader(pkt,
 984              		.loc 1 439 0
 985 06ce 92F84A10 		ldrb	r1, [r2, #74]	@ zero_extendqisi2
 986 06d2 7A69     		ldr	r2, [r7, #20]
 987 06d4 02F13802 		add	r2, r2, #56
 988 06d8 4FF00000 		mov	r0, #0
 989 06dc 0090     		str	r0, [sp, #0]
 990 06de 0191     		str	r1, [sp, #4]
 991 06e0 0292     		str	r2, [sp, #8]
 992 06e2 7869     		ldr	r0, [r7, #20]
 993 06e4 1946     		mov	r1, r3
 994 06e6 4FF00002 		mov	r2, #0
 995 06ea 4FF00203 		mov	r3, #2
 996 06ee FFF7FEFF 		bl	ieee802154_prependHeader
 445:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							   &(pkt->l2_nextORpreviousHop)
 446:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							   );
 447:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 448:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // reserve space for 2-byte CRC
 449:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  packetfunctions_reserveFooterSize(pkt,2);
 997              		.loc 1 449 0
 998 06f2 7869     		ldr	r0, [r7, #20]
 999 06f4 4FF00201 		mov	r1, #2
 1000 06f8 FFF7FEFF 		bl	packetfunctions_reserveFooterSize
 1001              	.L79:
 450:openstack/02a-MAClow/IEEE802154Ecsl.c ****   }
 451:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 452:openstack/02a-MAClow/IEEE802154Ecsl.c ****   return;
 453:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1002              		.loc 1 453 0
 1003 06fc 07F11807 		add	r7, r7, #24
 1004 0700 BD46     		mov	sp, r7
 1005 0702 B0BD     		pop	{r4, r5, r7, pc}
 1006              		.cfi_endproc
 1007              	.LFE6:
 1009              		.align	2
 1010              		.global	activity_csl_wakeup_ti1
 1011              		.thumb
 1012              		.thumb_func
 1014              	activity_csl_wakeup_ti1:
 1015              	.LFB7:
 454:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 455:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 456:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
 457:openstack/02a-MAClow/IEEE802154Ecsl.c **** //========================== CSL TX MODE ===============================
 458:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
 459:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 460:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 461:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [wake-up ti1].
 462:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 463:openstack/02a-MAClow/IEEE802154Ecsl.c ****  This method is invoked in ISR-mode from "isr_ieee154ecsl_txtimer_cb" function when TX Timer is fir
 464:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 465:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 466:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ti1() {
 1016              		.loc 1 466 0
 1017              		.cfi_startproc
 1018              		@ args = 0, pretend = 0, frame = 24
 1019              		@ frame_needed = 1, uses_anonymous_args = 0
 1020 0704 80B5     		push	{r7, lr}
 1021              	.LCFI17:
 1022              		.cfi_def_cfa_offset 8
 1023              		.cfi_offset 7, -8
 1024              		.cfi_offset 14, -4
 1025 0706 86B0     		sub	sp, sp, #24
 1026              	.LCFI18:
 1027              		.cfi_def_cfa_offset 32
 1028 0708 00AF     		add	r7, sp, #0
 1029              	.LCFI19:
 1030              		.cfi_def_cfa_register 7
 467:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   cellType_t  cellType;
 468:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   open_addr_t neighbor;
 469:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 470:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // update CSL Mode to TX in order to avoid problems in FSM.
 471:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   ieee154e_vars.cslMode = CSL_TX_MODE;
 1031              		.loc 1 471 0
 1032 070a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1033 070e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1034 0712 4FF00202 		mov	r2, #2
 1035 0716 83F84520 		strb	r2, [r3, #69]
 472:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 473:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // Las acciones que realizaremos son las siguientes:
 474:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   //  - Avanzar el schedule para posicionar la siguiente posición en éste, el cual marcará la 
 475:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   //  - Verificar el estado actual dentro de la FSM para comprobar que efectivamente nos encontra
 476:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   //  - Si no hay problema en ambos, verificamos el tipo de slot en el schedule y preparamos un p
 477:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   //    destino asociado a dicho slot.
 478:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 479:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // increment ASN (do this first so debug pins are in sync)
 480:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   incrementAsnOffset();
 1036              		.loc 1 480 0
 1037 071a FFF7FEFF 		bl	incrementAsnOffset
 481:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 482:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // wiggle debug pins
 483:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   debugpins_slot_toggle();
 1038              		.loc 1 483 0
 1039 071e FFF7FEFF 		bl	debugpins_slot_toggle
 484:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   if (ieee154e_vars.slotOffset==0) {
 1040              		.loc 1 484 0
 1041 0722 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1042 0726 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1043 072a DB88     		ldrh	r3, [r3, #6]
 1044 072c 002B     		cmp	r3, #0
 1045 072e 01D1     		bne	.L84
 485:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      debugpins_frame_toggle();
 1046              		.loc 1 485 0
 1047 0730 FFF7FEFF 		bl	debugpins_frame_toggle
 1048              	.L84:
 486:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 487:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 488:openstack/02a-MAClow/IEEE802154Ecsl.c ****        // if the previous slot took too long, we will not be in the right state
 489:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   if (ieee154e_vars.state!=S_SLEEP) {
 1049              		.loc 1 489 0
 1050 0734 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1051 0738 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1052 073c 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 1053 073e 002B     		cmp	r3, #0
 1054 0740 14D0     		beq	.L85
 490:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      // log the error
 491:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_STARTSLOT,
 492:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	                            (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_dbg.
 1055              		.loc 1 492 0
 1056 0742 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1057 0746 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1058 074a 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 491:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_STARTSLOT,
 1059              		.loc 1 491 0
 1060 074c 1A46     		mov	r2, r3
 1061              		.loc 1 492 0
 1062 074e 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 1063 0752 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 1064 0756 1B69     		ldr	r3, [r3, #16]
 491:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_STARTSLOT,
 1065              		.loc 1 491 0
 1066 0758 9BB2     		uxth	r3, r3
 1067 075a 4FF00900 		mov	r0, #9
 1068 075e 4FF01E01 		mov	r1, #30
 1069 0762 FFF7FEFF 		bl	openserial_printError
 493:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      // abort
 494:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      endOps();
 1070              		.loc 1 494 0
 1071 0766 FFF7FEFF 		bl	endOps
 1072 076a 51E0     		b	.L83
 1073              	.L85:
 495:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      return;
 496:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 497:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 498:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // advance the schedule
 499:openstack/02a-MAClow/IEEE802154Ecsl.c ****        schedule_advanceSlot();
 1074              		.loc 1 499 0
 1075 076c FFF7FEFF 		bl	schedule_advanceSlot
 500:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 501:openstack/02a-MAClow/IEEE802154Ecsl.c ****        // stop using serial
 502:openstack/02a-MAClow/IEEE802154Ecsl.c ****        openserial_stop();
 1076              		.loc 1 502 0
 1077 0770 FFF7FEFF 		bl	openserial_stop
 503:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 504:openstack/02a-MAClow/IEEE802154Ecsl.c ****        // check the schedule to see what type of slot this is
 505:openstack/02a-MAClow/IEEE802154Ecsl.c ****        cellType = schedule_getType();
 1078              		.loc 1 505 0
 1079 0774 FFF7FEFF 		bl	schedule_getType
 1080 0778 0346     		mov	r3, r0
 1081 077a FB75     		strb	r3, [r7, #23]
 506:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 507:openstack/02a-MAClow/IEEE802154Ecsl.c ****        // check whether we can send
 508:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   if (schedule_getOkToSend()) {
 1082              		.loc 1 508 0
 1083 077c FFF7FEFF 		bl	schedule_getOkToSend
 1084 0780 0346     		mov	r3, r0
 1085 0782 002B     		cmp	r3, #0
 1086 0784 10D0     		beq	.L87
 509:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       schedule_getNeighbor(&neighbor);
 1087              		.loc 1 509 0
 1088 0786 07F10403 		add	r3, r7, #4
 1089 078a 1846     		mov	r0, r3
 1090 078c FFF7FEFF 		bl	schedule_getNeighbor
 510:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       ieee154e_vars.dataToSend = openqueue_macGetDataPacket(&neighbor);
 1091              		.loc 1 510 0
 1092 0790 07F10403 		add	r3, r7, #4
 1093 0794 1846     		mov	r0, r3
 1094 0796 FFF7FEFF 		bl	openqueue_macGetDataPacket
 1095 079a 0246     		mov	r2, r0
 1096 079c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1097 07a0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1098 07a4 5A61     		str	r2, [r3, #20]
 1099 07a6 06E0     		b	.L88
 1100              	.L87:
 511:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   } else {
 512:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       ieee154e_vars.dataToSend = NULL;
 1101              		.loc 1 512 0
 1102 07a8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1103 07ac C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1104 07b0 4FF00002 		mov	r2, #0
 1105 07b4 5A61     		str	r2, [r3, #20]
 1106              	.L88:
 513:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 514:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   if((ieee154e_vars.dataToSend!=NULL) && (cellType == CELLTYPE_TX)) {   // If I have a packet to 
 1107              		.loc 1 514 0
 1108 07b6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1109 07ba C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1110 07be 5B69     		ldr	r3, [r3, #20]
 1111 07c0 002B     		cmp	r3, #0
 1112 07c2 1DD0     		beq	.L89
 1113              		.loc 1 514 0 is_stmt 0 discriminator 1
 1114 07c4 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 1115 07c6 022B     		cmp	r3, #2
 1116 07c8 1AD1     		bne	.L89
 515:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       // change state to start sending CSL preamble before send the data packet.
 516:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       changeState(S_CSLTXWAKEUPOFFSET);
 1117              		.loc 1 516 0 is_stmt 1
 1118 07ca 4FF01A00 		mov	r0, #26
 1119 07ce FFF7FEFF 		bl	changeState
 517:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 518:openstack/02a-MAClow/IEEE802154Ecsl.c ****            // record that I will attempt to transmit this packet
 519:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       ieee154e_vars.dataToSend->l2_numTxAttempts++;
 1120              		.loc 1 519 0
 1121 07d2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1122 07d6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1123 07da 5B69     		ldr	r3, [r3, #20]
 1124 07dc 93F84C20 		ldrb	r2, [r3, #76]	@ zero_extendqisi2
 1125 07e0 02F10102 		add	r2, r2, #1
 1126 07e4 D2B2     		uxtb	r2, r2
 1127 07e6 83F84C20 		strb	r2, [r3, #76]
 520:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 521:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       // arm tt1
 522:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       radiotimer_schedule(DURATION_tt1);
 1128              		.loc 1 522 0
 1129 07ea 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1130 07ee C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1131 07f2 5B6A     		ldr	r3, [r3, #36]
 1132 07f4 03F13A03 		add	r3, r3, #58
 1133 07f8 1846     		mov	r0, r3
 1134 07fa FFF7FEFF 		bl	radiotimer_schedule
 1135 07fe 07E0     		b	.L83
 1136              	.L89:
 523:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   } else {
 524:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       // abort because slot is not TX or there is no data to send, so we reset TX Mode state
 525:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   ieee154e_vars.cslMode = CSL_SLEEP_MODE;
 1137              		.loc 1 525 0
 1138 0800 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1139 0804 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1140 0808 4FF00002 		mov	r2, #0
 1141 080c 83F84520 		strb	r2, [r3, #69]
 1142              	.L83:
 526:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 527:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1143              		.loc 1 527 0
 1144 0810 07F11807 		add	r7, r7, #24
 1145 0814 BD46     		mov	sp, r7
 1146 0816 80BD     		pop	{r7, pc}
 1147              		.cfi_endproc
 1148              	.LFE7:
 1150              		.align	2
 1151              		.global	activity_csl_wakeup_ti2
 1152              		.thumb
 1153              		.thumb_func
 1155              	activity_csl_wakeup_ti2:
 1156              	.LFB8:
 528:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 529:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 530:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 531:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [wake-up ti2].
 532:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 533:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 534:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to prepare the radio for sending packets.
 535:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 536:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ti2() {
 1157              		.loc 1 536 0
 1158              		.cfi_startproc
 1159              		@ args = 0, pretend = 0, frame = 24
 1160              		@ frame_needed = 1, uses_anonymous_args = 0
 1161 0818 80B5     		push	{r7, lr}
 1162              	.LCFI20:
 1163              		.cfi_def_cfa_offset 8
 1164              		.cfi_offset 7, -8
 1165              		.cfi_offset 14, -4
 1166 081a 86B0     		sub	sp, sp, #24
 1167              	.LCFI21:
 1168              		.cfi_def_cfa_offset 32
 1169 081c 00AF     		add	r7, sp, #0
 1170              	.LCFI22:
 1171              		.cfi_def_cfa_register 7
 537:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 538:openstack/02a-MAClow/IEEE802154Ecsl.c ****    open_addr_t neighbor;
 539:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 540:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // El tiempo de rendezvous que será necesario esperar será macCSLMaxPeriod al tratarse de
 541:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // una comunicación en modo TX no sincronizado.
 542:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 543:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Calculamos el valor del rz-time en cada trama wake-up de la secuencia dado que debe ir reduci
 544:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // al extemo remoto el tiempo restante hasta el envío de la trama de datos.
 545:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 546:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // El tiempo lastCapturedTime se ve incrementado tras el envio de cada trama wake-up por lo que 
 547:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // valor más proximo al macCSLMaxPeriod.
 548:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 549:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.remainingRzTime = macCSLMaxPeriod - ieee154e_vars.lastCapturedTime;
 1172              		.loc 1 549 0
 1173 081e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1174 0822 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1175 0826 5B6A     		ldr	r3, [r3, #36]
 1176 0828 9BB2     		uxth	r3, r3
 1177 082a C3F5CC53 		rsb	r3, r3, #6528
 1178 082e 03F11A03 		add	r3, r3, #26
 1179 0832 9AB2     		uxth	r2, r3
 1180 0834 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1181 0838 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1182 083c A3F84820 		strh	r2, [r3, #72]	@ movhi
 550:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 551:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (MaxWakeUpTxTime < ieee154e_vars.remainingRzTime) { // Si da tiempo a enviar una nueva trama 
 1183              		.loc 1 551 0
 1184 0840 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1185 0844 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1186 0848 B3F84820 		ldrh	r2, [r3, #72]
 1187 084c 40F24113 		movw	r3, #321
 1188 0850 9A42     		cmp	r2, r3
 1189 0852 40F2DF80 		bls	.L92
 552:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 553:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // change state
 554:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   changeState(S_CSLTXWAKEUPPREPARE);
 1190              		.loc 1 554 0
 1191 0856 4FF01B00 		mov	r0, #27
 1192 085a FFF7FEFF 		bl	changeState
 555:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 556:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   //
 557:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // Construimos el paquete Wake-Up con su valor RZTime asociado en caso de no existir ya.
 558:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   //
 559:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 560:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   if (ieee154e_vars.wakeupToSend == NULL) { // first time
 1193              		.loc 1 560 0
 1194 085e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1195 0862 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1196 0866 DB6B     		ldr	r3, [r3, #60]
 1197 0868 002B     		cmp	r3, #0
 1198 086a 7FD1     		bne	.L93
 561:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 562:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // obtenemos un buffer en el cual poder guardar los datos recibidos.
 563:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   ieee154e_vars.wakeupToSend = openqueue_getFreePacketBuffer(COMPONENT_IEEE802154E);
 1199              		.loc 1 563 0
 1200 086c 4FF00900 		mov	r0, #9
 1201 0870 FFF7FEFF 		bl	openqueue_getFreePacketBuffer
 1202 0874 0246     		mov	r2, r0
 1203 0876 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1204 087a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1205 087e DA63     		str	r2, [r3, #60]
 564:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   if (ieee154e_vars.wakeupToSend == NULL) {
 1206              		.loc 1 564 0
 1207 0880 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1208 0884 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1209 0888 DB6B     		ldr	r3, [r3, #60]
 1210 088a 002B     		cmp	r3, #0
 1211 088c 0CD1     		bne	.L94
 565:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			  // registro del error & fin de operaciones.
 566:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			  openserial_printError(COMPONENT_IEEE802154E,ERR_NO_FREE_PACKET_BUFFER, (errorparameter_t)0, (e
 1212              		.loc 1 566 0
 1213 088e 4FF00900 		mov	r0, #9
 1214 0892 4FF02C01 		mov	r1, #44
 1215 0896 4FF00002 		mov	r2, #0
 1216 089a 4FF00003 		mov	r3, #0
 1217 089e FFF7FEFF 		bl	openserial_printError
 567:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			  endOps();
 1218              		.loc 1 567 0
 1219 08a2 FFF7FEFF 		bl	endOps
 1220 08a6 D1E0     		b	.L91
 1221              	.L94:
 568:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			  return;
 569:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   }
 570:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 571:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // Declaración de propiedad sobre el paquete.
 572:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   ieee154e_vars.wakeupToSend->creator = COMPONENT_IEEE802154E;
 1222              		.loc 1 572 0
 1223 08a8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1224 08ac C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1225 08b0 DB6B     		ldr	r3, [r3, #60]
 1226 08b2 4FF00902 		mov	r2, #9
 1227 08b6 1A70     		strb	r2, [r3, #0]
 573:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   ieee154e_vars.wakeupToSend->owner   = COMPONENT_IEEE802154E;
 1228              		.loc 1 573 0
 1229 08b8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1230 08bc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1231 08c0 DB6B     		ldr	r3, [r3, #60]
 1232 08c2 4FF00902 		mov	r2, #9
 1233 08c6 5A70     		strb	r2, [r3, #1]
 574:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 575:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // El tipo de trama es Multipurpose.
 576:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   ieee154e_vars.wakeupToSend->l2_frameType = IEEE154_TYPE_MULTIPURPOSE;
 1234              		.loc 1 576 0
 1235 08c8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1236 08cc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1237 08d0 DB6B     		ldr	r3, [r3, #60]
 1238 08d2 4FF00502 		mov	r2, #5
 1239 08d6 83F84920 		strb	r2, [r3, #73]
 577:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 578:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // El dsn del paquete lo obtenemos a partir del actual DSN incrementado en cada paquete de la 
 579:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   ieee154e_vars.wakeupToSend->l2_dsn = ieee154e_vars.cslDSN++;
 1240              		.loc 1 579 0
 1241 08da 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1242 08de C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1243 08e2 DA6B     		ldr	r2, [r3, #60]
 1244 08e4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1245 08e8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1246 08ec 93F84430 		ldrb	r3, [r3, #68]	@ zero_extendqisi2
 1247 08f0 1946     		mov	r1, r3
 1248 08f2 82F84A10 		strb	r1, [r2, #74]
 1249 08f6 03F10103 		add	r3, r3, #1
 1250 08fa DAB2     		uxtb	r2, r3
 1251 08fc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1252 0900 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1253 0904 83F84420 		strb	r2, [r3, #68]
 580:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 581:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // El destinatario es el mismo que el destinatario del mensaje de datos indicado en el schedul
 582:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   schedule_getNeighbor(&neighbor);
 1254              		.loc 1 582 0
 1255 0908 07F10403 		add	r3, r7, #4
 1256 090c 1846     		mov	r0, r3
 1257 090e FFF7FEFF 		bl	schedule_getNeighbor
 583:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 584:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // Verificamos que se trata de una dirección corta (short address). En caso contrario generam
 585:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   if(neighbor.type != ADDR_16B) {
 1258              		.loc 1 585 0
 1259 0912 3B79     		ldrb	r3, [r7, #4]	@ zero_extendqisi2
 1260 0914 012B     		cmp	r3, #1
 1261 0916 08D0     		beq	.L96
 586:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			   // CSL: This is an invalid address because address in wake-up frame must be short address.
 587:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			   // We do not finish operations but we will use later short address getting it from long addre
 588:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			   openserial_printInfo(COMPONENT_IEEE802154,ERR_IEEE154_UNSUPPORTED, (errorparameter_t)1, (erro
 1262              		.loc 1 588 0
 1263 0918 3B79     		ldrb	r3, [r7, #4]	@ zero_extendqisi2
 1264 091a 4FF00800 		mov	r0, #8
 1265 091e 4FF01901 		mov	r1, #25
 1266 0922 4FF00102 		mov	r2, #1
 1267 0926 FFF7FEFF 		bl	openserial_printInfo
 1268              	.L96:
 589:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   }
 590:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 591:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // create frame header.
 592:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   ieee802154_createWakeUpFrame(ieee154e_vars.wakeupToSend,
 1269              		.loc 1 592 0
 1270 092a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1271 092e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1272 0932 D86B     		ldr	r0, [r3, #60]
 593:openstack/02a-MAClow/IEEE802154Ecsl.c **** 										ieee154e_vars.wakeupToSend->l2_dsn,
 1273              		.loc 1 593 0
 1274 0934 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1275 0938 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1276 093c DB6B     		ldr	r3, [r3, #60]
 592:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   ieee802154_createWakeUpFrame(ieee154e_vars.wakeupToSend,
 1277              		.loc 1 592 0
 1278 093e 93F84A10 		ldrb	r1, [r3, #74]	@ zero_extendqisi2
 1279 0942 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1280 0946 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1281 094a B3F84830 		ldrh	r3, [r3, #72]
 1282 094e 07F10402 		add	r2, r7, #4
 1283 0952 FFF7FEFF 		bl	ieee802154_createWakeUpFrame
 594:openstack/02a-MAClow/IEEE802154Ecsl.c **** 										&neighbor,
 595:openstack/02a-MAClow/IEEE802154Ecsl.c **** 										ieee154e_vars.remainingRzTime);
 596:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 597:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // space for 2-byte CRC
 598:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   packetfunctions_reserveFooterSize(ieee154e_vars.wakeupToSend,2);
 1284              		.loc 1 598 0
 1285 0956 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1286 095a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1287 095e DB6B     		ldr	r3, [r3, #60]
 1288 0960 1846     		mov	r0, r3
 1289 0962 4FF00201 		mov	r1, #2
 1290 0966 FFF7FEFF 		bl	packetfunctions_reserveFooterSize
 1291 096a 22E0     		b	.L97
 1292              	.L93:
 599:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 600:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   else {
 601:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // update rztime in header.
 602:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // Se posiciona 8 posiciones antes dado que estamos escribiendo el paquete de atras hacia dela
 603:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // - 1 byte FCF
 604:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // - 1 byte SEQ
 605:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // - 2 bytes PANID
 606:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // - 2 bytes DEST ADDR
 607:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // - 2 bytes RZTIME IE HEADER
 608:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // - 2 bytes RZTIME (el cual se sobrescribirá con el nuevo valor).
 609:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   //*((uint16_t*)(ieee154e_vars.wakeupToSend->payload+8)) = ieee154e_vars.remainingRzTime;
 610:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   *((uint8_t*)(ieee154e_vars.wakeupToSend->payload+8)) = (uint8_t)(ieee154e_vars.remainingRzTime
 1293              		.loc 1 610 0
 1294 096c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1295 0970 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1296 0974 DB6B     		ldr	r3, [r3, #60]
 1297 0976 5B68     		ldr	r3, [r3, #4]
 1298 0978 03F10802 		add	r2, r3, #8
 1299 097c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1300 0980 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1301 0984 B3F84830 		ldrh	r3, [r3, #72]
 1302 0988 DBB2     		uxtb	r3, r3
 1303 098a 1370     		strb	r3, [r2, #0]
 611:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   *((uint8_t*)(ieee154e_vars.wakeupToSend->payload+9)) = (uint8_t)((ieee154e_vars.remainingRzTim
 1304              		.loc 1 611 0
 1305 098c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1306 0990 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1307 0994 DB6B     		ldr	r3, [r3, #60]
 1308 0996 5B68     		ldr	r3, [r3, #4]
 1309 0998 03F10902 		add	r2, r3, #9
 1310 099c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1311 09a0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1312 09a4 B3F84830 		ldrh	r3, [r3, #72]
 1313 09a8 4FEA1323 		lsr	r3, r3, #8
 1314 09ac 9BB2     		uxth	r3, r3
 1315 09ae DBB2     		uxtb	r3, r3
 1316 09b0 1370     		strb	r3, [r2, #0]
 1317              	.L97:
 612:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		}
 613:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 614:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // load the packet in the radio's Tx buffer
 615:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   radio_loadPacket(ieee154e_vars.wakeupToSend->payload, ieee154e_vars.wakeupToSend->length);
 1318              		.loc 1 615 0
 1319 09b2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1320 09b6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1321 09ba DB6B     		ldr	r3, [r3, #60]
 1322 09bc 5A68     		ldr	r2, [r3, #4]
 1323 09be 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1324 09c2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1325 09c6 DB6B     		ldr	r3, [r3, #60]
 1326 09c8 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 1327 09ca 1046     		mov	r0, r2
 1328 09cc 1946     		mov	r1, r3
 1329 09ce FFF7FEFF 		bl	radio_loadPacket
 616:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 617:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // enable the radio in Tx mode. This does not send the packet.
 618:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   radio_txEnable();
 1330              		.loc 1 618 0
 1331 09d2 FFF7FEFF 		bl	radio_txEnable
 619:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   ieee154e_vars.radioOnInit=radio_getTimerValue();
 1332              		.loc 1 619 0
 1333 09d6 FFF7FEFF 		bl	radio_getTimerValue
 1334 09da 0246     		mov	r2, r0
 1335 09dc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1336 09e0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1337 09e4 1A63     		str	r2, [r3, #48]
 620:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   ieee154e_vars.radioOnThisSlot=TRUE;
 1338              		.loc 1 620 0
 1339 09e6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1340 09ea C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1341 09ee 4FF00102 		mov	r2, #1
 1342 09f2 83F83820 		strb	r2, [r3, #56]
 621:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 622:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // arm tt2
 623:openstack/02a-MAClow/IEEE802154Ecsl.c ****        radiotimer_schedule(DURATION_tt2);
 1343              		.loc 1 623 0
 1344 09f6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1345 09fa C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1346 09fe 5B6A     		ldr	r3, [r3, #36]
 1347 0a00 03F17C03 		add	r3, r3, #124
 1348 0a04 1846     		mov	r0, r3
 1349 0a06 FFF7FEFF 		bl	radiotimer_schedule
 624:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 625:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // change state
 626:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   changeState(S_CSLTXWAKEUPREADY);
 1350              		.loc 1 626 0
 1351 0a0a 4FF01C00 		mov	r0, #28
 1352 0a0e FFF7FEFF 		bl	changeState
 1353 0a12 1BE0     		b	.L91
 1354              	.L92:
 627:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 628:openstack/02a-MAClow/IEEE802154Ecsl.c ****    else {
 629:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // Si no da tiempo a enviar una nueva trama, simplemente esperamos un tiempo igual a remainingR
 630:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // el tiempo que queda pendiente hasta el envío de la trama de datos y actualizamos directamen
 631:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // pasar a la transmisión de los datos, a través del estado CSLTXDATAPREOFFSET.
 632:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 633:openstack/02a-MAClow/IEEE802154Ecsl.c ****        // Descartamos el paquete una vez finalizada la transmisión.
 634:openstack/02a-MAClow/IEEE802154Ecsl.c ****        openqueue_freePacketBuffer(ieee154e_vars.wakeupToSend);
 1355              		.loc 1 634 0
 1356 0a14 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1357 0a18 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1358 0a1c DB6B     		ldr	r3, [r3, #60]
 1359 0a1e 1846     		mov	r0, r3
 1360 0a20 FFF7FEFF 		bl	openqueue_freePacketBuffer
 635:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 636:openstack/02a-MAClow/IEEE802154Ecsl.c ****        // clear local variable
 637:openstack/02a-MAClow/IEEE802154Ecsl.c ****        ieee154e_vars.wakeupToSend = NULL;
 1361              		.loc 1 637 0
 1362 0a24 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1363 0a28 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1364 0a2c 4FF00002 		mov	r2, #0
 1365 0a30 DA63     		str	r2, [r3, #60]
 638:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 639:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // change state
 640:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   changeState(S_CSLTXDATAPREOFFSET);
 1366              		.loc 1 640 0
 1367 0a32 4FF01F00 		mov	r0, #31
 1368 0a36 FFF7FEFF 		bl	changeState
 641:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 642:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // arm remaining rendezvous time.
 643:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   radiotimer_schedule(ieee154e_vars.remainingRzTime);
 1369              		.loc 1 643 0
 1370 0a3a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1371 0a3e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1372 0a42 B3F84830 		ldrh	r3, [r3, #72]
 1373 0a46 1846     		mov	r0, r3
 1374 0a48 FFF7FEFF 		bl	radiotimer_schedule
 1375              	.L91:
 644:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 645:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1376              		.loc 1 645 0
 1377 0a4c 07F11807 		add	r7, r7, #24
 1378 0a50 BD46     		mov	sp, r7
 1379 0a52 80BD     		pop	{r7, pc}
 1380              		.cfi_endproc
 1381              	.LFE8:
 1383              		.align	2
 1384              		.global	activity_csl_wakeup_tie1
 1385              		.thumb
 1386              		.thumb_func
 1388              	activity_csl_wakeup_tie1:
 1389              	.LFB9:
 646:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 647:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 648:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [wake-up tie1].
 649:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 650:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #tt2 expiring, i.e. timer fires while state = S_CSLTXWAKEUPPREPARE. This is 
 651:openstack/02a-MAClow/IEEE802154Ecsl.c ****   did not have enough time to execute. Chances are to set maxTxDataPrepare too small. The implement
 652:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 653:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_tie1() {
 1390              		.loc 1 653 0
 1391              		.cfi_startproc
 1392              		@ args = 0, pretend = 0, frame = 0
 1393              		@ frame_needed = 1, uses_anonymous_args = 0
 1394 0a54 80B5     		push	{r7, lr}
 1395              	.LCFI23:
 1396              		.cfi_def_cfa_offset 8
 1397              		.cfi_offset 7, -8
 1398              		.cfi_offset 14, -4
 1399 0a56 00AF     		add	r7, sp, #0
 1400              	.LCFI24:
 1401              		.cfi_def_cfa_register 7
 654:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
 655:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXDATAPREPARE_OVERFLOW,
 656:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_vars.slo
 1402              		.loc 1 656 0
 1403 0a58 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1404 0a5c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1405 0a60 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 655:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXDATAPREPARE_OVERFLOW,
 1406              		.loc 1 655 0
 1407 0a62 1A46     		mov	r2, r3
 1408 0a64 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1409 0a68 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1410 0a6c DB88     		ldrh	r3, [r3, #6]
 1411 0a6e 4FF00900 		mov	r0, #9
 1412 0a72 4FF02201 		mov	r1, #34
 1413 0a76 FFF7FEFF 		bl	openserial_printError
 657:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 658:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
 659:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 1414              		.loc 1 659 0
 1415 0a7a FFF7FEFF 		bl	endOps
 660:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1416              		.loc 1 660 0
 1417 0a7e 80BD     		pop	{r7, pc}
 1418              		.cfi_endproc
 1419              	.LFE9:
 1421              		.align	2
 1422              		.global	activity_csl_wakeup_ti3
 1423              		.thumb
 1424              		.thumb_func
 1426              	activity_csl_wakeup_ti3:
 1427              	.LFB10:
 661:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 662:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 663:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [wake-up ti3].
 664:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 665:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 666:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The radio is configured and this interrupt gives it the "go" signal to start listening.
 667:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 668:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 669:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ti3() {
 1428              		.loc 1 669 0
 1429              		.cfi_startproc
 1430              		@ args = 0, pretend = 0, frame = 0
 1431              		@ frame_needed = 1, uses_anonymous_args = 0
 1432 0a80 80B5     		push	{r7, lr}
 1433              	.LCFI25:
 1434              		.cfi_def_cfa_offset 8
 1435              		.cfi_offset 7, -8
 1436              		.cfi_offset 14, -4
 1437 0a82 00AF     		add	r7, sp, #0
 1438              	.LCFI26:
 1439              		.cfi_def_cfa_register 7
 670:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 671:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXWAKEUPDELAY);
 1440              		.loc 1 671 0
 1441 0a84 4FF01D00 		mov	r0, #29
 1442 0a88 FFF7FEFF 		bl	changeState
 672:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 673:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt3
 674:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt3);
 1443              		.loc 1 674 0
 1444 0a8c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1445 0a90 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1446 0a94 5B6A     		ldr	r3, [r3, #36]
 1447 0a96 03F19D03 		add	r3, r3, #157
 1448 0a9a 1846     		mov	r0, r3
 1449 0a9c FFF7FEFF 		bl	radiotimer_schedule
 675:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 676:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // give the 'go' to transmit
 677:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_txNow();
 1450              		.loc 1 677 0
 1451 0aa0 FFF7FEFF 		bl	radio_txNow
 678:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1452              		.loc 1 678 0
 1453 0aa4 80BD     		pop	{r7, pc}
 1454              		.cfi_endproc
 1455              	.LFE10:
 1457 0aa6 00BF     		.align	2
 1458              		.global	activity_csl_wakeup_tie2
 1459              		.thumb
 1460              		.thumb_func
 1462              	activity_csl_wakeup_tie2:
 1463              	.LFB11:
 679:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 680:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 681:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [wakeup tie2].
 682:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 683:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #tt3 expiring, i.e. timer fires while state = S_CSLTXWAKEUPDELAY. If no pack
 684:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 685:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_tie2() {
 1464              		.loc 1 685 0
 1465              		.cfi_startproc
 1466              		@ args = 0, pretend = 0, frame = 0
 1467              		@ frame_needed = 1, uses_anonymous_args = 0
 1468 0aa8 80B5     		push	{r7, lr}
 1469              	.LCFI27:
 1470              		.cfi_def_cfa_offset 8
 1471              		.cfi_offset 7, -8
 1472              		.cfi_offset 14, -4
 1473 0aaa 00AF     		add	r7, sp, #0
 1474              	.LCFI28:
 1475              		.cfi_def_cfa_register 7
 686:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
 687:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIO_OVERFLOWS,
 688:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_vars.slo
 1476              		.loc 1 688 0
 1477 0aac 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1478 0ab0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1479 0ab4 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 687:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIO_OVERFLOWS,
 1480              		.loc 1 687 0
 1481 0ab6 1A46     		mov	r2, r3
 1482 0ab8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1483 0abc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1484 0ac0 DB88     		ldrh	r3, [r3, #6]
 1485 0ac2 4FF00900 		mov	r0, #9
 1486 0ac6 4FF02701 		mov	r1, #39
 1487 0aca FFF7FEFF 		bl	openserial_printError
 689:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
 690:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 1488              		.loc 1 690 0
 1489 0ace FFF7FEFF 		bl	endOps
 691:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1490              		.loc 1 691 0
 1491 0ad2 80BD     		pop	{r7, pc}
 1492              		.cfi_endproc
 1493              	.LFE11:
 1495              		.align	2
 1496              		.global	activity_csl_wakeup_ti4
 1497              		.thumb
 1498              		.thumb_func
 1500              	activity_csl_wakeup_ti4:
 1501              	.LFB12:
 692:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 693:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 694:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [wake-up ti4].
 695:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 696:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_startOfFrame" function when a start of frame ev
 697:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to capture the time, cancel #tt3 and arm #tt4 (max time to send all the pack
 698:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 699:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ti4(PORT_RADIOTIMER_WIDTH capturedTime) {
 1502              		.loc 1 699 0
 1503              		.cfi_startproc
 1504              		@ args = 0, pretend = 0, frame = 8
 1505              		@ frame_needed = 1, uses_anonymous_args = 0
 1506 0ad4 80B5     		push	{r7, lr}
 1507              	.LCFI29:
 1508              		.cfi_def_cfa_offset 8
 1509              		.cfi_offset 7, -8
 1510              		.cfi_offset 14, -4
 1511 0ad6 82B0     		sub	sp, sp, #8
 1512              	.LCFI30:
 1513              		.cfi_def_cfa_offset 16
 1514 0ad8 00AF     		add	r7, sp, #0
 1515              	.LCFI31:
 1516              		.cfi_def_cfa_register 7
 1517 0ada 7860     		str	r0, [r7, #4]
 700:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 701:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel tt3
 702:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 1518              		.loc 1 702 0
 1519 0adc FFF7FEFF 		bl	radiotimer_cancel
 703:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 704:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
 705:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.lastCapturedTime = capturedTime;
 1520              		.loc 1 705 0
 1521 0ae0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1522 0ae4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1523 0ae8 7A68     		ldr	r2, [r7, #4]
 1524 0aea 5A62     		str	r2, [r3, #36]
 706:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 707:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 708:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXWAKEUP);
 1525              		.loc 1 708 0
 1526 0aec 4FF01E00 		mov	r0, #30
 1527 0af0 FFF7FEFF 		bl	changeState
 709:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 710:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt4
 711:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt4);
 1528              		.loc 1 711 0
 1529 0af4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1530 0af8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1531 0afc 5B6A     		ldr	r3, [r3, #36]
 1532 0afe 03F1A403 		add	r3, r3, #164
 1533 0b02 1846     		mov	r0, r3
 1534 0b04 FFF7FEFF 		bl	radiotimer_schedule
 712:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1535              		.loc 1 712 0
 1536 0b08 07F10807 		add	r7, r7, #8
 1537 0b0c BD46     		mov	sp, r7
 1538 0b0e 80BD     		pop	{r7, pc}
 1539              		.cfi_endproc
 1540              	.LFE12:
 1542              		.align	2
 1543              		.global	activity_csl_wakeup_tie3
 1544              		.thumb
 1545              		.thumb_func
 1547              	activity_csl_wakeup_tie3:
 1548              	.LFB13:
 713:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 714:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 715:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [wake-up tie3].
 716:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 717:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #tt4 expiring, i.e. timer fires while state = S_CSLTXWAKEUP. This is an erro
 718:openstack/02a-MAClow/IEEE802154Ecsl.c ****   took too long to transmit the data packet. The implemented behaviour is to log the error and fini
 719:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 720:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_tie3() {
 1549              		.loc 1 720 0
 1550              		.cfi_startproc
 1551              		@ args = 0, pretend = 0, frame = 0
 1552              		@ frame_needed = 1, uses_anonymous_args = 0
 1553 0b10 80B5     		push	{r7, lr}
 1554              	.LCFI32:
 1555              		.cfi_def_cfa_offset 8
 1556              		.cfi_offset 7, -8
 1557              		.cfi_offset 14, -4
 1558 0b12 00AF     		add	r7, sp, #0
 1559              	.LCFI33:
 1560              		.cfi_def_cfa_register 7
 721:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
 722:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
 723:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_vars.slo
 1561              		.loc 1 723 0
 1562 0b14 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1563 0b18 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1564 0b1c 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 722:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
 1565              		.loc 1 722 0
 1566 0b1e 1A46     		mov	r2, r3
 1567 0b20 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1568 0b24 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1569 0b28 DB88     		ldrh	r3, [r3, #6]
 1570 0b2a 4FF00900 		mov	r0, #9
 1571 0b2e 4FF02601 		mov	r1, #38
 1572 0b32 FFF7FEFF 		bl	openserial_printError
 724:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
 725:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 1573              		.loc 1 725 0
 1574 0b36 FFF7FEFF 		bl	endOps
 726:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1575              		.loc 1 726 0
 1576 0b3a 80BD     		pop	{r7, pc}
 1577              		.cfi_endproc
 1578              	.LFE13:
 1580              		.align	2
 1581              		.global	activity_csl_wakeup_ti5
 1582              		.thumb
 1583              		.thumb_func
 1585              	activity_csl_wakeup_ti5:
 1586              	.LFB14:
 727:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 728:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 729:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 730:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [wake-up ri5].
 731:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 732:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_endOfFrame" function when a end of frame event 
 733:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change state, cancel #rt4, and start sending data frame and wait for ACK.
 734:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 735:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ti5(PORT_RADIOTIMER_WIDTH capturedTime) {
 1587              		.loc 1 735 0
 1588              		.cfi_startproc
 1589              		@ args = 0, pretend = 0, frame = 8
 1590              		@ frame_needed = 1, uses_anonymous_args = 0
 1591 0b3c 80B5     		push	{r7, lr}
 1592              	.LCFI34:
 1593              		.cfi_def_cfa_offset 8
 1594              		.cfi_offset 7, -8
 1595              		.cfi_offset 14, -4
 1596 0b3e 82B0     		sub	sp, sp, #8
 1597              	.LCFI35:
 1598              		.cfi_def_cfa_offset 16
 1599 0b40 00AF     		add	r7, sp, #0
 1600              	.LCFI36:
 1601              		.cfi_def_cfa_register 7
 1602 0b42 7860     		str	r0, [r7, #4]
 736:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 737:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// record the captured time
 738:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	ieee154e_vars.lastCapturedTime = capturedTime;
 1603              		.loc 1 738 0
 1604 0b44 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1605 0b48 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1606 0b4c 7A68     		ldr	r2, [r7, #4]
 1607 0b4e 5A62     		str	r2, [r3, #36]
 739:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 740:openstack/02a-MAClow/IEEE802154Ecsl.c ****     // change state
 741:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	changeState(S_CSLTXWAKEUPOFFSET);
 1608              		.loc 1 741 0
 1609 0b50 4FF01A00 		mov	r0, #26
 1610 0b54 FFF7FEFF 		bl	changeState
 742:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 743:openstack/02a-MAClow/IEEE802154Ecsl.c ****     // arm tt1 (enviemos de nuevo una trama de wake-up o de datos, el tiempo será tt1).
 744:openstack/02a-MAClow/IEEE802154Ecsl.c ****     radiotimer_schedule(DURATION_tt1);
 1611              		.loc 1 744 0
 1612 0b58 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1613 0b5c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1614 0b60 5B6A     		ldr	r3, [r3, #36]
 1615 0b62 03F13A03 		add	r3, r3, #58
 1616 0b66 1846     		mov	r0, r3
 1617 0b68 FFF7FEFF 		bl	radiotimer_schedule
 745:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1618              		.loc 1 745 0
 1619 0b6c 07F10807 		add	r7, r7, #8
 1620 0b70 BD46     		mov	sp, r7
 1621 0b72 80BD     		pop	{r7, pc}
 1622              		.cfi_endproc
 1623              	.LFE14:
 1625              		.align	2
 1626              		.global	activity_csl_data_ti1
 1627              		.thumb
 1628              		.thumb_func
 1630              	activity_csl_data_ti1:
 1631              	.LFB15:
 746:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 747:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 748:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti1].
 749:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 750:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires after 
 751:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to prepare the data to be sent.
 752:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 753:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 754:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti1() {
 1632              		.loc 1 754 0
 1633              		.cfi_startproc
 1634              		@ args = 0, pretend = 0, frame = 0
 1635              		@ frame_needed = 1, uses_anonymous_args = 0
 1636 0b74 80B5     		push	{r7, lr}
 1637              	.LCFI37:
 1638              		.cfi_def_cfa_offset 8
 1639              		.cfi_offset 7, -8
 1640              		.cfi_offset 14, -4
 1641 0b76 00AF     		add	r7, sp, #0
 1642              	.LCFI38:
 1643              		.cfi_def_cfa_register 7
 755:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 756:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// change state
 757:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	changeState(S_CSLTXDATAOFFSET);
 1644              		.loc 1 757 0
 1645 0b78 4FF02000 		mov	r0, #32
 1646 0b7c FFF7FEFF 		bl	changeState
 758:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 759:openstack/02a-MAClow/IEEE802154Ecsl.c ****     // arm tt1 (enviemos de nuevo una trama de wake-up o de datos, el tiempo será tt1).
 760:openstack/02a-MAClow/IEEE802154Ecsl.c ****     radiotimer_schedule(DURATION_tt1);
 1647              		.loc 1 760 0
 1648 0b80 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1649 0b84 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1650 0b88 5B6A     		ldr	r3, [r3, #36]
 1651 0b8a 03F13A03 		add	r3, r3, #58
 1652 0b8e 1846     		mov	r0, r3
 1653 0b90 FFF7FEFF 		bl	radiotimer_schedule
 761:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1654              		.loc 1 761 0
 1655 0b94 80BD     		pop	{r7, pc}
 1656              		.cfi_endproc
 1657              	.LFE15:
 1659 0b96 00BF     		.align	2
 1660              		.global	activity_csl_data_ti2
 1661              		.thumb
 1662              		.thumb_func
 1664              	activity_csl_data_ti2:
 1665              	.LFB16:
 762:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 763:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 764:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 765:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 766:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti2].
 767:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 768:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 769:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to prepare the radio for sending packets.
 770:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 771:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti2() {
 1666              		.loc 1 771 0
 1667              		.cfi_startproc
 1668              		@ args = 0, pretend = 0, frame = 0
 1669              		@ frame_needed = 1, uses_anonymous_args = 0
 1670 0b98 80B5     		push	{r7, lr}
 1671              	.LCFI39:
 1672              		.cfi_def_cfa_offset 8
 1673              		.cfi_offset 7, -8
 1674              		.cfi_offset 14, -4
 1675 0b9a 00AF     		add	r7, sp, #0
 1676              	.LCFI40:
 1677              		.cfi_def_cfa_register 7
 772:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 773:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXDATAPREPARE);
 1678              		.loc 1 773 0
 1679 0b9c 4FF02100 		mov	r0, #33
 1680 0ba0 FFF7FEFF 		bl	changeState
 774:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 775:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // load the packet in the radio's Tx buffer
 776:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_loadPacket(ieee154e_vars.dataToSend->payload,
 1681              		.loc 1 776 0
 1682 0ba4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1683 0ba8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1684 0bac 5B69     		ldr	r3, [r3, #20]
 1685 0bae 5A68     		ldr	r2, [r3, #4]
 777:openstack/02a-MAClow/IEEE802154Ecsl.c ****                     ieee154e_vars.dataToSend->length);
 1686              		.loc 1 777 0
 1687 0bb0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1688 0bb4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1689 0bb8 5B69     		ldr	r3, [r3, #20]
 776:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_loadPacket(ieee154e_vars.dataToSend->payload,
 1690              		.loc 1 776 0
 1691 0bba 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 1692 0bbc 1046     		mov	r0, r2
 1693 0bbe 1946     		mov	r1, r3
 1694 0bc0 FFF7FEFF 		bl	radio_loadPacket
 778:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 779:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // enable the radio in Tx mode. This does not send the packet.
 780:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_txEnable();
 1695              		.loc 1 780 0
 1696 0bc4 FFF7FEFF 		bl	radio_txEnable
 781:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnInit=radio_getTimerValue();
 1697              		.loc 1 781 0
 1698 0bc8 FFF7FEFF 		bl	radio_getTimerValue
 1699 0bcc 0246     		mov	r2, r0
 1700 0bce 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1701 0bd2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1702 0bd6 1A63     		str	r2, [r3, #48]
 782:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnThisSlot=TRUE;
 1703              		.loc 1 782 0
 1704 0bd8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1705 0bdc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1706 0be0 4FF00102 		mov	r2, #1
 1707 0be4 83F83820 		strb	r2, [r3, #56]
 783:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 784:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt2
 785:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt2);
 1708              		.loc 1 785 0
 1709 0be8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1710 0bec C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1711 0bf0 5B6A     		ldr	r3, [r3, #36]
 1712 0bf2 03F17C03 		add	r3, r3, #124
 1713 0bf6 1846     		mov	r0, r3
 1714 0bf8 FFF7FEFF 		bl	radiotimer_schedule
 786:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 787:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 788:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXDATAREADY);
 1715              		.loc 1 788 0
 1716 0bfc 4FF02200 		mov	r0, #34
 1717 0c00 FFF7FEFF 		bl	changeState
 789:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 790:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1718              		.loc 1 790 0
 1719 0c04 80BD     		pop	{r7, pc}
 1720              		.cfi_endproc
 1721              	.LFE16:
 1723 0c06 00BF     		.align	2
 1724              		.global	activity_csl_data_tie1
 1725              		.thumb
 1726              		.thumb_func
 1728              	activity_csl_data_tie1:
 1729              	.LFB17:
 791:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 792:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 793:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data tie1].
 794:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 795:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #tt2 expiring, i.e. timer fires while state = S_CSLTXDATAPREPARE. This is re
 796:openstack/02a-MAClow/IEEE802154Ecsl.c ****   did not have enough time to execute. Chances are to set maxTxDataPrepare too small. The implement
 797:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 798:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_tie1() {
 1730              		.loc 1 798 0
 1731              		.cfi_startproc
 1732              		@ args = 0, pretend = 0, frame = 0
 1733              		@ frame_needed = 1, uses_anonymous_args = 0
 1734 0c08 80B5     		push	{r7, lr}
 1735              	.LCFI41:
 1736              		.cfi_def_cfa_offset 8
 1737              		.cfi_offset 7, -8
 1738              		.cfi_offset 14, -4
 1739 0c0a 00AF     		add	r7, sp, #0
 1740              	.LCFI42:
 1741              		.cfi_def_cfa_register 7
 799:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
 800:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXDATAPREPARE_OVERFLOW,
 801:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_vars.slo
 1742              		.loc 1 801 0
 1743 0c0c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1744 0c10 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1745 0c14 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 800:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXDATAPREPARE_OVERFLOW,
 1746              		.loc 1 800 0
 1747 0c16 1A46     		mov	r2, r3
 1748 0c18 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1749 0c1c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1750 0c20 DB88     		ldrh	r3, [r3, #6]
 1751 0c22 4FF00900 		mov	r0, #9
 1752 0c26 4FF02201 		mov	r1, #34
 1753 0c2a FFF7FEFF 		bl	openserial_printError
 802:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
 803:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 1754              		.loc 1 803 0
 1755 0c2e FFF7FEFF 		bl	endOps
 804:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1756              		.loc 1 804 0
 1757 0c32 80BD     		pop	{r7, pc}
 1758              		.cfi_endproc
 1759              	.LFE17:
 1761              		.align	2
 1762              		.global	activity_csl_data_ti3
 1763              		.thumb
 1764              		.thumb_func
 1766              	activity_csl_data_ti3:
 1767              	.LFB18:
 805:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 806:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 807:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti3].
 808:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 809:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 810:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The radio is configured and this interrupt gives it the "go" signal to start listening.
 811:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 812:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti3() {
 1768              		.loc 1 812 0
 1769              		.cfi_startproc
 1770              		@ args = 0, pretend = 0, frame = 0
 1771              		@ frame_needed = 1, uses_anonymous_args = 0
 1772 0c34 80B5     		push	{r7, lr}
 1773              	.LCFI43:
 1774              		.cfi_def_cfa_offset 8
 1775              		.cfi_offset 7, -8
 1776              		.cfi_offset 14, -4
 1777 0c36 00AF     		add	r7, sp, #0
 1778              	.LCFI44:
 1779              		.cfi_def_cfa_register 7
 813:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 814:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXDATADELAY);
 1780              		.loc 1 814 0
 1781 0c38 4FF02300 		mov	r0, #35
 1782 0c3c FFF7FEFF 		bl	changeState
 815:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 816:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt3
 817:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt3);
 1783              		.loc 1 817 0
 1784 0c40 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1785 0c44 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1786 0c48 5B6A     		ldr	r3, [r3, #36]
 1787 0c4a 03F19D03 		add	r3, r3, #157
 1788 0c4e 1846     		mov	r0, r3
 1789 0c50 FFF7FEFF 		bl	radiotimer_schedule
 818:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 819:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // give the 'go' to transmit
 820:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_txNow();
 1790              		.loc 1 820 0
 1791 0c54 FFF7FEFF 		bl	radio_txNow
 821:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1792              		.loc 1 821 0
 1793 0c58 80BD     		pop	{r7, pc}
 1794              		.cfi_endproc
 1795              	.LFE18:
 1797 0c5a 00BF     		.align	2
 1798              		.global	activity_csl_data_tie2
 1799              		.thumb
 1800              		.thumb_func
 1802              	activity_csl_data_tie2:
 1803              	.LFB19:
 822:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 823:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 824:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 825:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX Sampling error [data tie2].
 826:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 827:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #tt3 expiring, i.e. timer fires while state = S_CSLTXDATADELAY. If no packet
 828:openstack/02a-MAClow/IEEE802154Ecsl.c ****   none will be sent and it is safe to switch off the radio. This timer is set such that the radio w
 829:openstack/02a-MAClow/IEEE802154Ecsl.c ****   duration (#TsLongGT).
 830:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 831:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_tie2() {
 1804              		.loc 1 831 0
 1805              		.cfi_startproc
 1806              		@ args = 0, pretend = 0, frame = 0
 1807              		@ frame_needed = 1, uses_anonymous_args = 0
 1808 0c5c 80B5     		push	{r7, lr}
 1809              	.LCFI45:
 1810              		.cfi_def_cfa_offset 8
 1811              		.cfi_offset 7, -8
 1812              		.cfi_offset 14, -4
 1813 0c5e 00AF     		add	r7, sp, #0
 1814              	.LCFI46:
 1815              		.cfi_def_cfa_register 7
 832:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
 833:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIO_OVERFLOWS,
 834:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_vars.slo
 1816              		.loc 1 834 0
 1817 0c60 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1818 0c64 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1819 0c68 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 833:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIO_OVERFLOWS,
 1820              		.loc 1 833 0
 1821 0c6a 1A46     		mov	r2, r3
 1822 0c6c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1823 0c70 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1824 0c74 DB88     		ldrh	r3, [r3, #6]
 1825 0c76 4FF00900 		mov	r0, #9
 1826 0c7a 4FF02701 		mov	r1, #39
 1827 0c7e FFF7FEFF 		bl	openserial_printError
 835:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
 836:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 1828              		.loc 1 836 0
 1829 0c82 FFF7FEFF 		bl	endOps
 837:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1830              		.loc 1 837 0
 1831 0c86 80BD     		pop	{r7, pc}
 1832              		.cfi_endproc
 1833              	.LFE19:
 1835              		.align	2
 1836              		.global	activity_csl_data_ti4
 1837              		.thumb
 1838              		.thumb_func
 1840              	activity_csl_data_ti4:
 1841              	.LFB20:
 838:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 839:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 840:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 841:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti4].
 842:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 843:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_startOfFrame" function when a start of frame ev
 844:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change state, cancel #tt3 and arm #tt4 (max time to sent all the packet).
 845:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 846:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti4(PORT_RADIOTIMER_WIDTH capturedTime) {
 1842              		.loc 1 846 0
 1843              		.cfi_startproc
 1844              		@ args = 0, pretend = 0, frame = 8
 1845              		@ frame_needed = 1, uses_anonymous_args = 0
 1846 0c88 80B5     		push	{r7, lr}
 1847              	.LCFI47:
 1848              		.cfi_def_cfa_offset 8
 1849              		.cfi_offset 7, -8
 1850              		.cfi_offset 14, -4
 1851 0c8a 82B0     		sub	sp, sp, #8
 1852              	.LCFI48:
 1853              		.cfi_def_cfa_offset 16
 1854 0c8c 00AF     		add	r7, sp, #0
 1855              	.LCFI49:
 1856              		.cfi_def_cfa_register 7
 1857 0c8e 7860     		str	r0, [r7, #4]
 847:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 848:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXDATA);
 1858              		.loc 1 848 0
 1859 0c90 4FF02400 		mov	r0, #36
 1860 0c94 FFF7FEFF 		bl	changeState
 849:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 850:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel tt3
 851:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 1861              		.loc 1 851 0
 1862 0c98 FFF7FEFF 		bl	radiotimer_cancel
 852:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 853:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
 854:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.lastCapturedTime = capturedTime;
 1863              		.loc 1 854 0
 1864 0c9c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1865 0ca0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1866 0ca4 7A68     		ldr	r2, [r7, #4]
 1867 0ca6 5A62     		str	r2, [r3, #36]
 855:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 856:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt4
 857:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt4);
 1868              		.loc 1 857 0
 1869 0ca8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1870 0cac C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1871 0cb0 5B6A     		ldr	r3, [r3, #36]
 1872 0cb2 03F1A403 		add	r3, r3, #164
 1873 0cb6 1846     		mov	r0, r3
 1874 0cb8 FFF7FEFF 		bl	radiotimer_schedule
 858:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1875              		.loc 1 858 0
 1876 0cbc 07F10807 		add	r7, r7, #8
 1877 0cc0 BD46     		mov	sp, r7
 1878 0cc2 80BD     		pop	{r7, pc}
 1879              		.cfi_endproc
 1880              	.LFE20:
 1882              		.align	2
 1883              		.global	activity_csl_data_tie3
 1884              		.thumb
 1885              		.thumb_func
 1887              	activity_csl_data_tie3:
 1888              	.LFB21:
 859:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 860:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 861:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data tie3].
 862:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 863:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #tt4 expiring, i.e. timer fires while state = S_CSLTXDATA. This is an error 
 864:openstack/02a-MAClow/IEEE802154Ecsl.c ****   to transmit the data packet. The implemented behaviour is to log the error and finish.
 865:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 866:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_tie3() {
 1889              		.loc 1 866 0
 1890              		.cfi_startproc
 1891              		@ args = 0, pretend = 0, frame = 0
 1892              		@ frame_needed = 1, uses_anonymous_args = 0
 1893 0cc4 80B5     		push	{r7, lr}
 1894              	.LCFI50:
 1895              		.cfi_def_cfa_offset 8
 1896              		.cfi_offset 7, -8
 1897              		.cfi_offset 14, -4
 1898 0cc6 00AF     		add	r7, sp, #0
 1899              	.LCFI51:
 1900              		.cfi_def_cfa_register 7
 867:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
 868:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
 869:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_vars.slo
 1901              		.loc 1 869 0
 1902 0cc8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1903 0ccc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1904 0cd0 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 868:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
 1905              		.loc 1 868 0
 1906 0cd2 1A46     		mov	r2, r3
 1907 0cd4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1908 0cd8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1909 0cdc DB88     		ldrh	r3, [r3, #6]
 1910 0cde 4FF00900 		mov	r0, #9
 1911 0ce2 4FF02601 		mov	r1, #38
 1912 0ce6 FFF7FEFF 		bl	openserial_printError
 870:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
 871:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 1913              		.loc 1 871 0
 1914 0cea FFF7FEFF 		bl	endOps
 872:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1915              		.loc 1 872 0
 1916 0cee 80BD     		pop	{r7, pc}
 1917              		.cfi_endproc
 1918              	.LFE21:
 1920              		.align	2
 1921              		.global	activity_csl_data_ti5
 1922              		.thumb
 1923              		.thumb_func
 1925              	activity_csl_data_ti5:
 1926              	.LFB22:
 873:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 874:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 875:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ri5].
 876:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 877:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_endOfFrame" function when a end of frame event 
 878:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change state, cancel #tt4, and notify upper layer and schedule about succ
 879:openstack/02a-MAClow/IEEE802154Ecsl.c ****   start process for receive ACK frame (arm #tt5).
 880:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 881:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti5(PORT_RADIOTIMER_WIDTH capturedTime) {
 1927              		.loc 1 881 0
 1928              		.cfi_startproc
 1929              		@ args = 0, pretend = 0, frame = 16
 1930              		@ frame_needed = 1, uses_anonymous_args = 0
 1931 0cf0 90B5     		push	{r4, r7, lr}
 1932              	.LCFI52:
 1933              		.cfi_def_cfa_offset 12
 1934              		.cfi_offset 4, -12
 1935              		.cfi_offset 7, -8
 1936              		.cfi_offset 14, -4
 1937 0cf2 85B0     		sub	sp, sp, #20
 1938              	.LCFI53:
 1939              		.cfi_def_cfa_offset 32
 1940 0cf4 00AF     		add	r7, sp, #0
 1941              	.LCFI54:
 1942              		.cfi_def_cfa_register 7
 1943 0cf6 7860     		str	r0, [r7, #4]
 882:openstack/02a-MAClow/IEEE802154Ecsl.c ****    bool listenForAck;
 883:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 884:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 885:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXACKOFFSET);
 1944              		.loc 1 885 0
 1945 0cf8 4FF02500 		mov	r0, #37
 1946 0cfc FFF7FEFF 		bl	changeState
 886:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 887:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel tt4
 888:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 1947              		.loc 1 888 0
 1948 0d00 FFF7FEFF 		bl	radiotimer_cancel
 889:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 890:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // turn off the radio
 891:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rfOff();
 1949              		.loc 1 891 0
 1950 0d04 FFF7FEFF 		bl	radio_rfOff
 892:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnTics+=(radio_getTimerValue()-ieee154e_vars.radioOnInit);
 1951              		.loc 1 892 0
 1952 0d08 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1953 0d0c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1954 0d10 5C6B     		ldr	r4, [r3, #52]
 1955 0d12 FFF7FEFF 		bl	radio_getTimerValue
 1956 0d16 0246     		mov	r2, r0
 1957 0d18 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1958 0d1c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1959 0d20 1B6B     		ldr	r3, [r3, #48]
 1960 0d22 D31A     		subs	r3, r2, r3
 1961 0d24 E218     		adds	r2, r4, r3
 1962 0d26 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1963 0d2a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1964 0d2e 5A63     		str	r2, [r3, #52]
 893:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 894:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
 895:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //ieee154e_vars.lastCapturedTime = capturedTime;
 896:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 897:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // decides whether to listen for an ACK
 898:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (packetfunctions_isBroadcastMulticast(&ieee154e_vars.dataToSend->l2_nextORpreviousHop)==TRUE)
 1965              		.loc 1 898 0
 1966 0d30 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1967 0d34 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1968 0d38 5B69     		ldr	r3, [r3, #20]
 1969 0d3a 03F13803 		add	r3, r3, #56
 1970 0d3e 1846     		mov	r0, r3
 1971 0d40 FFF7FEFF 		bl	packetfunctions_isBroadcastMulticast
 1972 0d44 0346     		mov	r3, r0
 1973 0d46 002B     		cmp	r3, #0
 1974 0d48 03D0     		beq	.L113
 899:openstack/02a-MAClow/IEEE802154Ecsl.c ****       listenForAck = FALSE;
 1975              		.loc 1 899 0
 1976 0d4a 4FF00003 		mov	r3, #0
 1977 0d4e FB73     		strb	r3, [r7, #15]
 1978 0d50 02E0     		b	.L114
 1979              	.L113:
 900:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
 901:openstack/02a-MAClow/IEEE802154Ecsl.c ****       listenForAck = TRUE;
 1980              		.loc 1 901 0
 1981 0d52 4FF00103 		mov	r3, #1
 1982 0d56 FB73     		strb	r3, [r7, #15]
 1983              	.L114:
 902:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 903:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 904:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // [CSL-TEST]: testing code for toggling orange led to indicate OK TX.
 905:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 906:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if((ieee154e_vars.dataToSend->l2_frameType == IEEE154_TYPE_DATA) &&
 1984              		.loc 1 906 0
 1985 0d58 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1986 0d5c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1987 0d60 5B69     		ldr	r3, [r3, #20]
 1988 0d62 93F84930 		ldrb	r3, [r3, #73]	@ zero_extendqisi2
 1989 0d66 012B     		cmp	r3, #1
 1990 0d68 0CD1     		bne	.L115
 907:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  (ieee154e_vars.dataToSend->owner == COMPONENT_SIXTOP_TO_IEEE802154E)) {
 1991              		.loc 1 907 0 discriminator 1
 1992 0d6a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1993 0d6e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1994 0d72 5B69     		ldr	r3, [r3, #20]
 1995 0d74 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 906:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if((ieee154e_vars.dataToSend->l2_frameType == IEEE154_TYPE_DATA) &&
 1996              		.loc 1 906 0 discriminator 1
 1997 0d76 0A2B     		cmp	r3, #10
 1998 0d78 04D1     		bne	.L115
 908:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	 leds_sync_blink();
 1999              		.loc 1 908 0
 2000 0d7a FFF7FEFF 		bl	leds_sync_blink
 909:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	 listenForAck = FALSE;
 2001              		.loc 1 909 0
 2002 0d7e 4FF00003 		mov	r3, #0
 2003 0d82 FB73     		strb	r3, [r7, #15]
 2004              	.L115:
 910:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 911:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // [CSL-TEST]: end test code
 912:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 913:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 914:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (listenForAck==TRUE) {
 2005              		.loc 1 914 0
 2006 0d84 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 2007 0d86 002B     		cmp	r3, #0
 2008 0d88 0AD0     		beq	.L116
 915:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // arm tt5
 916:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radiotimer_schedule(DURATION_tt5);
 2009              		.loc 1 916 0
 2010 0d8a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2011 0d8e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2012 0d92 5B6A     		ldr	r3, [r3, #36]
 2013 0d94 03F17D03 		add	r3, r3, #125
 2014 0d98 1846     		mov	r0, r3
 2015 0d9a FFF7FEFF 		bl	radiotimer_schedule
 2016 0d9e 09E0     		b	.L112
 2017              	.L116:
 917:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
 918:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // indicate succesful Tx to schedule to keep statistics
 919:openstack/02a-MAClow/IEEE802154Ecsl.c ****       schedule_indicateTx(&ieee154e_vars.asn,TRUE);
 2018              		.loc 1 919 0
 2019 0da0 40F20000 		movw	r0, #:lower16:ieee154e_vars
 2020 0da4 C0F20000 		movt	r0, #:upper16:ieee154e_vars
 2021 0da8 4FF00101 		mov	r1, #1
 2022 0dac FFF7FEFF 		bl	schedule_indicateTx
 920:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 921:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // [CSL-TEST]: comment notification
 922:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 923:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // indicate to upper later the packet was sent successfully
 924:openstack/02a-MAClow/IEEE802154Ecsl.c ****       //notif_sendDone(ieee154e_vars.dataToSend,E_SUCCESS);
 925:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 926:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset local variable
 927:openstack/02a-MAClow/IEEE802154Ecsl.c ****       //ieee154e_vars.dataToSend = NULL;
 928:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 929:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // [CSL-TEST]: end test code
 930:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 931:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // abort
 932:openstack/02a-MAClow/IEEE802154Ecsl.c ****       endOps();
 2023              		.loc 1 932 0
 2024 0db0 FFF7FEFF 		bl	endOps
 2025              	.L112:
 933:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 934:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2026              		.loc 1 934 0
 2027 0db4 07F11407 		add	r7, r7, #20
 2028 0db8 BD46     		mov	sp, r7
 2029 0dba 90BD     		pop	{r4, r7, pc}
 2030              		.cfi_endproc
 2031              	.LFE22:
 2033              		.align	2
 2034              		.global	activity_csl_data_ti6
 2035              		.thumb
 2036              		.thumb_func
 2038              	activity_csl_data_ti6:
 2039              	.LFB23:
 935:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 936:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 937:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti6].
 938:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 939:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 940:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The functionality is to prepare the radio for ACK reception.
 941:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 942:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti6() {
 2040              		.loc 1 942 0
 2041              		.cfi_startproc
 2042              		@ args = 0, pretend = 0, frame = 0
 2043              		@ frame_needed = 1, uses_anonymous_args = 0
 2044 0dbc 80B5     		push	{r7, lr}
 2045              	.LCFI55:
 2046              		.cfi_def_cfa_offset 8
 2047              		.cfi_offset 7, -8
 2048              		.cfi_offset 14, -4
 2049 0dbe 00AF     		add	r7, sp, #0
 2050              	.LCFI56:
 2051              		.cfi_def_cfa_register 7
 943:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 944:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXACKPREPARE);
 2052              		.loc 1 944 0
 2053 0dc0 4FF02600 		mov	r0, #38
 2054 0dc4 FFF7FEFF 		bl	changeState
 945:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 946:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // enable the radio in Rx mode. The radio is not actively listening yet.
 947:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rxEnable();
 2055              		.loc 1 947 0
 2056 0dc8 FFF7FEFF 		bl	radio_rxEnable
 948:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 949:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //caputre init of radio for duty cycle calculation
 950:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnInit=radio_getTimerValue();
 2057              		.loc 1 950 0
 2058 0dcc FFF7FEFF 		bl	radio_getTimerValue
 2059 0dd0 0246     		mov	r2, r0
 2060 0dd2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2061 0dd6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2062 0dda 1A63     		str	r2, [r3, #48]
 951:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnThisSlot=TRUE;
 2063              		.loc 1 951 0
 2064 0ddc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2065 0de0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2066 0de4 4FF00102 		mov	r2, #1
 2067 0de8 83F83820 		strb	r2, [r3, #56]
 952:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 953:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt6
 954:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt6);
 2068              		.loc 1 954 0
 2069 0dec 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2070 0df0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2071 0df4 5B6A     		ldr	r3, [r3, #36]
 2072 0df6 03F18703 		add	r3, r3, #135
 2073 0dfa 1846     		mov	r0, r3
 2074 0dfc FFF7FEFF 		bl	radiotimer_schedule
 955:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 956:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 957:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXACKREADY);
 2075              		.loc 1 957 0
 2076 0e00 4FF02700 		mov	r0, #39
 2077 0e04 FFF7FEFF 		bl	changeState
 958:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2078              		.loc 1 958 0
 2079 0e08 80BD     		pop	{r7, pc}
 2080              		.cfi_endproc
 2081              	.LFE23:
 2083 0e0a 00BF     		.align	2
 2084              		.global	activity_csl_data_tie4
 2085              		.thumb
 2086              		.thumb_func
 2088              	activity_csl_data_tie4:
 2089              	.LFB24:
 959:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 960:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 961:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data tie4].
 962:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 963:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 964:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The functionality is to prepare the radio for ACK sending.
 965:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 966:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_tie4() {
 2090              		.loc 1 966 0
 2091              		.cfi_startproc
 2092              		@ args = 0, pretend = 0, frame = 0
 2093              		@ frame_needed = 1, uses_anonymous_args = 0
 2094 0e0c 80B5     		push	{r7, lr}
 2095              	.LCFI57:
 2096              		.cfi_def_cfa_offset 8
 2097              		.cfi_offset 7, -8
 2098              		.cfi_offset 14, -4
 2099 0e0e 00AF     		add	r7, sp, #0
 2100              	.LCFI58:
 2101              		.cfi_def_cfa_register 7
 967:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
 968:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXACKPREPARE_OVERFLOWS,
 969:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_vars.slo
 2102              		.loc 1 969 0
 2103 0e10 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2104 0e14 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2105 0e18 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 968:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXACKPREPARE_OVERFLOWS,
 2106              		.loc 1 968 0
 2107 0e1a 1A46     		mov	r2, r3
 2108 0e1c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2109 0e20 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2110 0e24 DB88     		ldrh	r3, [r3, #6]
 2111 0e26 4FF00900 		mov	r0, #9
 2112 0e2a 4FF02301 		mov	r1, #35
 2113 0e2e FFF7FEFF 		bl	openserial_printError
 970:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
 971:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 2114              		.loc 1 971 0
 2115 0e32 FFF7FEFF 		bl	endOps
 972:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2116              		.loc 1 972 0
 2117 0e36 80BD     		pop	{r7, pc}
 2118              		.cfi_endproc
 2119              	.LFE24:
 2121              		.align	2
 2122              		.global	activity_csl_data_ti7
 2123              		.thumb
 2124              		.thumb_func
 2126              	activity_csl_data_ti7:
 2127              	.LFB25:
 973:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 974:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 975:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti7].
 976:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 977:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 978:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The radio is configured and this interrupt gives it the "go" signal to start listening.
 979:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 980:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti7() {
 2128              		.loc 1 980 0
 2129              		.cfi_startproc
 2130              		@ args = 0, pretend = 0, frame = 0
 2131              		@ frame_needed = 1, uses_anonymous_args = 0
 2132 0e38 80B5     		push	{r7, lr}
 2133              	.LCFI59:
 2134              		.cfi_def_cfa_offset 8
 2135              		.cfi_offset 7, -8
 2136              		.cfi_offset 14, -4
 2137 0e3a 00AF     		add	r7, sp, #0
 2138              	.LCFI60:
 2139              		.cfi_def_cfa_register 7
 981:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 982:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXACKLISTEN);
 2140              		.loc 1 982 0
 2141 0e3c 4FF02800 		mov	r0, #40
 2142 0e40 FFF7FEFF 		bl	changeState
 983:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 984:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // start listening
 985:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rxNow();
 2143              		.loc 1 985 0
 2144 0e44 FFF7FEFF 		bl	radio_rxNow
 986:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 987:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt7
 988:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt7);
 2145              		.loc 1 988 0
 2146 0e48 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2147 0e4c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2148 0e50 5B6A     		ldr	r3, [r3, #36]
 2149 0e52 03F1A703 		add	r3, r3, #167
 2150 0e56 1846     		mov	r0, r3
 2151 0e58 FFF7FEFF 		bl	radiotimer_schedule
 989:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2152              		.loc 1 989 0
 2153 0e5c 80BD     		pop	{r7, pc}
 2154              		.cfi_endproc
 2155              	.LFE25:
 2157 0e5e 00BF     		.align	2
 2158              		.global	activity_csl_data_tie5
 2159              		.thumb
 2160              		.thumb_func
 2162              	activity_csl_data_tie5:
 2163              	.LFB26:
 990:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 991:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 992:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data tie5].
 993:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 994:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 995:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to notify upper level, updating the number of remaining retries of the packe
 996:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 997:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_tie5() {
 2164              		.loc 1 997 0
 2165              		.cfi_startproc
 2166              		@ args = 0, pretend = 0, frame = 0
 2167              		@ frame_needed = 1, uses_anonymous_args = 0
 2168 0e60 80B5     		push	{r7, lr}
 2169              	.LCFI61:
 2170              		.cfi_def_cfa_offset 8
 2171              		.cfi_offset 7, -8
 2172              		.cfi_offset 14, -4
 2173 0e62 00AF     		add	r7, sp, #0
 2174              	.LCFI62:
 2175              		.cfi_def_cfa_register 7
 998:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // indicate transmit failed to schedule to keep stats
 999:openstack/02a-MAClow/IEEE802154Ecsl.c ****    schedule_indicateTx(&ieee154e_vars.asn,FALSE);
 2176              		.loc 1 999 0
 2177 0e64 40F20000 		movw	r0, #:lower16:ieee154e_vars
 2178 0e68 C0F20000 		movt	r0, #:upper16:ieee154e_vars
 2179 0e6c 4FF00001 		mov	r1, #0
 2180 0e70 FFF7FEFF 		bl	schedule_indicateTx
1000:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1001:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // decrement transmits left counter
1002:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.dataToSend->l2_retriesLeft--;
 2181              		.loc 1 1002 0
 2182 0e74 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2183 0e78 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2184 0e7c 5B69     		ldr	r3, [r3, #20]
 2185 0e7e 93F84B20 		ldrb	r2, [r3, #75]	@ zero_extendqisi2
 2186 0e82 02F1FF32 		add	r2, r2, #-1
 2187 0e86 D2B2     		uxtb	r2, r2
 2188 0e88 83F84B20 		strb	r2, [r3, #75]
1003:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1004:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.dataToSend->l2_retriesLeft==0) {
 2189              		.loc 1 1004 0
 2190 0e8c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2191 0e90 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2192 0e94 5B69     		ldr	r3, [r3, #20]
 2193 0e96 93F84B30 		ldrb	r3, [r3, #75]	@ zero_extendqisi2
 2194 0e9a 002B     		cmp	r3, #0
 2195 0e9c 0AD1     		bne	.L122
1005:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // indicate tx fail if no more retries left
1006:openstack/02a-MAClow/IEEE802154Ecsl.c ****       notif_sendDone(ieee154e_vars.dataToSend,E_FAIL);
 2196              		.loc 1 1006 0
 2197 0e9e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2198 0ea2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2199 0ea6 5B69     		ldr	r3, [r3, #20]
 2200 0ea8 1846     		mov	r0, r3
 2201 0eaa 4FF00101 		mov	r1, #1
 2202 0eae FFF7FEFF 		bl	notif_sendDone
 2203 0eb2 07E0     		b	.L123
 2204              	.L122:
1007:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
1008:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // return packet to the virtual COMPONENT_SIXTOP_TO_IEEE802154E component
1009:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataToSend->owner = COMPONENT_SIXTOP_TO_IEEE802154E;
 2205              		.loc 1 1009 0
 2206 0eb4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2207 0eb8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2208 0ebc 5B69     		ldr	r3, [r3, #20]
 2209 0ebe 4FF00A02 		mov	r2, #10
 2210 0ec2 5A70     		strb	r2, [r3, #1]
 2211              	.L123:
1010:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
1011:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1012:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // reset local variable
1013:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.dataToSend = NULL;
 2212              		.loc 1 1013 0
 2213 0ec4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2214 0ec8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2215 0ecc 4FF00002 		mov	r2, #0
 2216 0ed0 5A61     		str	r2, [r3, #20]
1014:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1015:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1016:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 2217              		.loc 1 1016 0
 2218 0ed2 FFF7FEFF 		bl	endOps
1017:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2219              		.loc 1 1017 0
 2220 0ed6 80BD     		pop	{r7, pc}
 2221              		.cfi_endproc
 2222              	.LFE26:
 2224              		.align	2
 2225              		.global	activity_csl_data_ti8
 2226              		.thumb
 2227              		.thumb_func
 2229              	activity_csl_data_ti8:
 2230              	.LFB27:
1018:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1019:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1020:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti8].
1021:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1022:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_startOfFrame" function when a start of frame ev
1023:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change the state, cancel #tt7 and arm #tt8 (max time to receive the ack p
1024:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1025:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti8(PORT_RADIOTIMER_WIDTH capturedTime) {
 2231              		.loc 1 1025 0
 2232              		.cfi_startproc
 2233              		@ args = 0, pretend = 0, frame = 8
 2234              		@ frame_needed = 1, uses_anonymous_args = 0
 2235 0ed8 80B5     		push	{r7, lr}
 2236              	.LCFI63:
 2237              		.cfi_def_cfa_offset 8
 2238              		.cfi_offset 7, -8
 2239              		.cfi_offset 14, -4
 2240 0eda 82B0     		sub	sp, sp, #8
 2241              	.LCFI64:
 2242              		.cfi_def_cfa_offset 16
 2243 0edc 00AF     		add	r7, sp, #0
 2244              	.LCFI65:
 2245              		.cfi_def_cfa_register 7
 2246 0ede 7860     		str	r0, [r7, #4]
1026:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1027:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXACK);
 2247              		.loc 1 1027 0
 2248 0ee0 4FF02900 		mov	r0, #41
 2249 0ee4 FFF7FEFF 		bl	changeState
1028:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1029:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel tt7
1030:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 2250              		.loc 1 1030 0
 2251 0ee8 FFF7FEFF 		bl	radiotimer_cancel
1031:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1032:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
1033:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //ieee154e_vars.lastCapturedTime = capturedTime;
1034:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1035:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt8
1036:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt8);
 2252              		.loc 1 1036 0
 2253 0eec 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2254 0ef0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2255 0ef4 5B6A     		ldr	r3, [r3, #36]
 2256 0ef6 03F16203 		add	r3, r3, #98
 2257 0efa 1846     		mov	r0, r3
 2258 0efc FFF7FEFF 		bl	radiotimer_schedule
1037:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2259              		.loc 1 1037 0
 2260 0f00 07F10807 		add	r7, r7, #8
 2261 0f04 BD46     		mov	sp, r7
 2262 0f06 80BD     		pop	{r7, pc}
 2263              		.cfi_endproc
 2264              	.LFE27:
 2266              		.align	2
 2267              		.global	activity_csl_data_tie6
 2268              		.thumb
 2269              		.thumb_func
 2271              	activity_csl_data_tie6:
 2272              	.LFB28:
1038:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1039:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1040:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data tie6].
1041:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1042:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1043:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to finish and clean registers.
1044:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1045:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_tie6() {
 2273              		.loc 1 1045 0
 2274              		.cfi_startproc
 2275              		@ args = 0, pretend = 0, frame = 0
 2276              		@ frame_needed = 1, uses_anonymous_args = 0
 2277 0f08 80B5     		push	{r7, lr}
 2278              	.LCFI66:
 2279              		.cfi_def_cfa_offset 8
 2280              		.cfi_offset 7, -8
 2281              		.cfi_offset 14, -4
 2282 0f0a 00AF     		add	r7, sp, #0
 2283              	.LCFI67:
 2284              		.cfi_def_cfa_register 7
1046:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1047:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 2285              		.loc 1 1047 0
 2286 0f0c FFF7FEFF 		bl	endOps
1048:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2287              		.loc 1 1048 0
 2288 0f10 80BD     		pop	{r7, pc}
 2289              		.cfi_endproc
 2290              	.LFE28:
 2292 0f12 00BF     		.align	2
 2293              		.global	activity_csl_data_ti9
 2294              		.thumb
 2295              		.thumb_func
 2297              	activity_csl_data_ti9:
 2298              	.LFB29:
1049:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1050:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1051:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1052:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti9].
1053:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1054:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_endOfFrame" function when a end of frame event 
1055:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change the state, cancel #tt8, analyze ack packet and notify upper layer.
1056:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1057:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti9(PORT_RADIOTIMER_WIDTH capturedTime) {
 2299              		.loc 1 1057 0
 2300              		.cfi_startproc
 2301              		@ args = 0, pretend = 0, frame = 80
 2302              		@ frame_needed = 1, uses_anonymous_args = 0
 2303 0f14 B0B5     		push	{r4, r5, r7, lr}
 2304              	.LCFI68:
 2305              		.cfi_def_cfa_offset 16
 2306              		.cfi_offset 4, -16
 2307              		.cfi_offset 5, -12
 2308              		.cfi_offset 7, -8
 2309              		.cfi_offset 14, -4
 2310 0f16 96B0     		sub	sp, sp, #88
 2311              	.LCFI69:
 2312              		.cfi_def_cfa_offset 104
 2313 0f18 02AF     		add	r7, sp, #8
 2314              	.LCFI70:
 2315              		.cfi_def_cfa 7, 96
 2316 0f1a 7860     		str	r0, [r7, #4]
1058:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802154_header_iht     ieee802514_header;
1059:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint16_t                  lenIE;
1060:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1061:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1062:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXPROC);
 2317              		.loc 1 1062 0
 2318 0f1c 4FF02A00 		mov	r0, #42
 2319 0f20 FFF7FEFF 		bl	changeState
1063:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1064:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel tt8
1065:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 2320              		.loc 1 1065 0
 2321 0f24 FFF7FEFF 		bl	radiotimer_cancel
1066:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1067:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // turn off the radio
1068:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rfOff();
 2322              		.loc 1 1068 0
 2323 0f28 FFF7FEFF 		bl	radio_rfOff
1069:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //compute tics radio on.
1070:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnTics+=(radio_getTimerValue()-ieee154e_vars.radioOnInit);
 2324              		.loc 1 1070 0
 2325 0f2c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2326 0f30 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2327 0f34 5C6B     		ldr	r4, [r3, #52]
 2328 0f36 FFF7FEFF 		bl	radio_getTimerValue
 2329 0f3a 0246     		mov	r2, r0
 2330 0f3c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2331 0f40 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2332 0f44 1B6B     		ldr	r3, [r3, #48]
 2333 0f46 D31A     		subs	r3, r2, r3
 2334 0f48 E218     		adds	r2, r4, r3
 2335 0f4a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2336 0f4e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2337 0f52 5A63     		str	r2, [r3, #52]
1071:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1072:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
1073:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //ieee154e_vars.lastCapturedTime = capturedTime;
1074:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1075:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // get a buffer to put the (received) ACK in
1076:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackReceived = openqueue_getFreePacketBuffer(COMPONENT_IEEE802154E);
 2338              		.loc 1 1076 0
 2339 0f54 4FF00900 		mov	r0, #9
 2340 0f58 FFF7FEFF 		bl	openqueue_getFreePacketBuffer
 2341 0f5c 0246     		mov	r2, r0
 2342 0f5e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2343 0f62 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2344 0f66 1A62     		str	r2, [r3, #32]
1077:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.ackReceived==NULL) {
 2345              		.loc 1 1077 0
 2346 0f68 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2347 0f6c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2348 0f70 1B6A     		ldr	r3, [r3, #32]
 2349 0f72 002B     		cmp	r3, #0
 2350 0f74 0CD1     		bne	.L127
1078:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // log the error
1079:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openserial_printError(COMPONENT_IEEE802154E,ERR_NO_FREE_PACKET_BUFFER,
 2351              		.loc 1 1079 0
 2352 0f76 4FF00900 		mov	r0, #9
 2353 0f7a 4FF02C01 		mov	r1, #44
 2354 0f7e 4FF00002 		mov	r2, #0
 2355 0f82 4FF00003 		mov	r3, #0
 2356 0f86 FFF7FEFF 		bl	openserial_printError
1080:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)0,
1081:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)0);
1082:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // abort
1083:openstack/02a-MAClow/IEEE802154Ecsl.c ****       endOps();
 2357              		.loc 1 1083 0
 2358 0f8a FFF7FEFF 		bl	endOps
 2359 0f8e 20E1     		b	.L126
 2360              	.L127:
1084:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return;
1085:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
1086:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1087:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // declare ownership over that packet
1088:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackReceived->creator = COMPONENT_IEEE802154E;
 2361              		.loc 1 1088 0
 2362 0f90 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2363 0f94 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2364 0f98 1B6A     		ldr	r3, [r3, #32]
 2365 0f9a 4FF00902 		mov	r2, #9
 2366 0f9e 1A70     		strb	r2, [r3, #0]
1089:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackReceived->owner   = COMPONENT_IEEE802154E;
 2367              		.loc 1 1089 0
 2368 0fa0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2369 0fa4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2370 0fa8 1B6A     		ldr	r3, [r3, #32]
 2371 0faa 4FF00902 		mov	r2, #9
 2372 0fae 5A70     		strb	r2, [r3, #1]
1090:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1091:openstack/02a-MAClow/IEEE802154Ecsl.c ****    /*
1092:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The do-while loop that follows is a little parsing trick.
1093:openstack/02a-MAClow/IEEE802154Ecsl.c ****    Because it contains a while(0) condition, it gets executed only once.
1094:openstack/02a-MAClow/IEEE802154Ecsl.c ****    Below the do-while loop is some code to cleans up the ack variable.
1095:openstack/02a-MAClow/IEEE802154Ecsl.c ****    Anywhere in the do-while loop, a break statement can be called to jump to
1096:openstack/02a-MAClow/IEEE802154Ecsl.c ****    the clean up code early. If the loop ends without a break, the received
1097:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packet was correct. If it got aborted early (through a break), the packet
1098:openstack/02a-MAClow/IEEE802154Ecsl.c ****    was faulty.
1099:openstack/02a-MAClow/IEEE802154Ecsl.c ****    */
1100:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1101:openstack/02a-MAClow/IEEE802154Ecsl.c ****    do { // this "loop" is only executed once
1102:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1103:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // retrieve the received ack frame from the radio's Rx buffer
1104:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.ackReceived->payload = &(ieee154e_vars.ackReceived->packet[FIRST_FRAME_BYTE]);
 2373              		.loc 1 1104 0
 2374 0fb0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2375 0fb4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2376 0fb8 1A6A     		ldr	r2, [r3, #32]
 2377 0fba 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2378 0fbe C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2379 0fc2 1B6A     		ldr	r3, [r3, #32]
 2380 0fc4 03F16C03 		add	r3, r3, #108
 2381 0fc8 5360     		str	r3, [r2, #4]
1105:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.ackReceived->payload,
 2382              		.loc 1 1105 0
 2383 0fca 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2384 0fce C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2385 0fd2 1B6A     		ldr	r3, [r3, #32]
 2386 0fd4 5968     		ldr	r1, [r3, #4]
1106:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.ackReceived->length,
 2387              		.loc 1 1106 0
 2388 0fd6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2389 0fda C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2390 0fde 1B6A     		ldr	r3, [r3, #32]
1105:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.ackReceived->payload,
 2391              		.loc 1 1105 0
 2392 0fe0 03F10802 		add	r2, r3, #8
1107:openstack/02a-MAClow/IEEE802154Ecsl.c ****                              sizeof(ieee154e_vars.ackReceived->packet),
1108:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.ackReceived->l1_rssi,
 2393              		.loc 1 1108 0
 2394 0fe4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2395 0fe8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2396 0fec 1B6A     		ldr	r3, [r3, #32]
1105:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.ackReceived->payload,
 2397              		.loc 1 1105 0
 2398 0fee 03F16804 		add	r4, r3, #104
1109:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.ackReceived->l1_lqi,
 2399              		.loc 1 1109 0
 2400 0ff2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2401 0ff6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2402 0ffa 1B6A     		ldr	r3, [r3, #32]
1105:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.ackReceived->payload,
 2403              		.loc 1 1105 0
 2404 0ffc 03F16900 		add	r0, r3, #105
1110:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.ackReceived->l1_crc);
 2405              		.loc 1 1110 0
 2406 1000 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2407 1004 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2408 1008 1B6A     		ldr	r3, [r3, #32]
1105:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.ackReceived->payload,
 2409              		.loc 1 1105 0
 2410 100a 03F16A03 		add	r3, r3, #106
 2411 100e 0090     		str	r0, [sp, #0]
 2412 1010 0193     		str	r3, [sp, #4]
 2413 1012 0846     		mov	r0, r1
 2414 1014 1146     		mov	r1, r2
 2415 1016 4FF08202 		mov	r2, #130
 2416 101a 2346     		mov	r3, r4
 2417 101c FFF7FEFF 		bl	radio_getReceivedFrame
1111:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1112:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // break if wrong length
1113:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.ackReceived->length<LENGTH_CRC || ieee154e_vars.ackReceived->length>LENGTH_
 2418              		.loc 1 1113 0
 2419 1020 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2420 1024 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2421 1028 1B6A     		ldr	r3, [r3, #32]
 2422 102a 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 2423 102c 012B     		cmp	r3, #1
 2424 102e 07D9     		bls	.L129
 2425              		.loc 1 1113 0 is_stmt 0 discriminator 1
 2426 1030 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2427 1034 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2428 1038 1B6A     		ldr	r3, [r3, #32]
 2429 103a 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 2430 103c 802B     		cmp	r3, #128
 2431 103e 0ED9     		bls	.L130
 2432              	.L129:
1114:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // break from the do-while loop and execute the clean-up code below
1115:openstack/02a-MAClow/IEEE802154Ecsl.c ****         openserial_printError(COMPONENT_IEEE802154E,ERR_INVALIDPACKETFROMRADIO,
1116:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)1,
1117:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             ieee154e_vars.ackReceived->length);
 2433              		.loc 1 1117 0 is_stmt 1
 2434 1040 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2435 1044 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2436 1048 1B6A     		ldr	r3, [r3, #32]
 2437 104a 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
1115:openstack/02a-MAClow/IEEE802154Ecsl.c ****         openserial_printError(COMPONENT_IEEE802154E,ERR_INVALIDPACKETFROMRADIO,
 2438              		.loc 1 1115 0
 2439 104c 4FF00900 		mov	r0, #9
 2440 1050 4FF03701 		mov	r1, #55
 2441 1054 4FF00102 		mov	r2, #1
 2442 1058 FFF7FEFF 		bl	openserial_printError
1118:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1119:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 2443              		.loc 1 1119 0
 2444 105c A8E0     		b	.L131
 2445              	.L130:
1120:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1121:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1122:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // toss CRC (2 last bytes)
1123:openstack/02a-MAClow/IEEE802154Ecsl.c ****       packetfunctions_tossFooter(   ieee154e_vars.ackReceived, LENGTH_CRC);
 2446              		.loc 1 1123 0
 2447 105e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2448 1062 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2449 1066 1B6A     		ldr	r3, [r3, #32]
 2450 1068 1846     		mov	r0, r3
 2451 106a 4FF00201 		mov	r1, #2
 2452 106e FFF7FEFF 		bl	packetfunctions_tossFooter
1124:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1125:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // break if invalid CRC
1126:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.ackReceived->l1_crc==FALSE) {
 2453              		.loc 1 1126 0
 2454 1072 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2455 1076 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2456 107a 1B6A     		ldr	r3, [r3, #32]
 2457 107c 93F86A30 		ldrb	r3, [r3, #106]	@ zero_extendqisi2
 2458 1080 83F00103 		eor	r3, r3, #1
 2459 1084 DBB2     		uxtb	r3, r3
 2460 1086 002B     		cmp	r3, #0
 2461 1088 40F08980 		bne	.L137
 2462              	.L132:
1127:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // break from the do-while loop and execute the clean-up code below
1128:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
1129:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1130:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1131:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // parse the IEEE802.15.4 header (RX ACK)
1132:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee802154_retrieveHeader(ieee154e_vars.ackReceived,&ieee802514_header);
 2463              		.loc 1 1132 0
 2464 108c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2465 1090 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2466 1094 1A6A     		ldr	r2, [r3, #32]
 2467 1096 07F11003 		add	r3, r7, #16
 2468 109a 1046     		mov	r0, r2
 2469 109c 1946     		mov	r1, r3
 2470 109e FFF7FEFF 		bl	ieee802154_retrieveHeader
1133:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1134:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // break if invalid IEEE802.15.4 header
1135:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee802514_header.valid==FALSE) {
 2471              		.loc 1 1135 0
 2472 10a2 3B7C     		ldrb	r3, [r7, #16]	@ zero_extendqisi2
 2473 10a4 83F00103 		eor	r3, r3, #1
 2474 10a8 DBB2     		uxtb	r3, r3
 2475 10aa 002B     		cmp	r3, #0
 2476 10ac 79D1     		bne	.L138
 2477              	.L133:
1136:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // break from the do-while loop and execute the clean-up code below
1137:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
1138:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1139:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1140:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // store header details in packet buffer
1141:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.ackReceived->l2_frameType  = ieee802514_header.frameType;
 2478              		.loc 1 1141 0
 2479 10ae 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2480 10b2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2481 10b6 1B6A     		ldr	r3, [r3, #32]
 2482 10b8 BA7C     		ldrb	r2, [r7, #18]	@ zero_extendqisi2
 2483 10ba 83F84920 		strb	r2, [r3, #73]
1142:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.ackReceived->l2_dsn        = ieee802514_header.dsn;
 2484              		.loc 1 1142 0
 2485 10be 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2486 10c2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2487 10c6 1B6A     		ldr	r3, [r3, #32]
 2488 10c8 7A7E     		ldrb	r2, [r7, #25]	@ zero_extendqisi2
 2489 10ca 83F84A20 		strb	r2, [r3, #74]
1143:openstack/02a-MAClow/IEEE802154Ecsl.c ****       memcpy(&(ieee154e_vars.ackReceived->l2_nextORpreviousHop),&(ieee802514_header.src),sizeof(ope
 2490              		.loc 1 1143 0
 2491 10ce 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2492 10d2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2493 10d6 1B6A     		ldr	r3, [r3, #32]
 2494 10d8 03F13803 		add	r3, r3, #56
 2495 10dc 1D46     		mov	r5, r3
 2496 10de 07F13C04 		add	r4, r7, #60
 2497 10e2 0FCC     		ldmia	r4!, {r0, r1, r2, r3}
 2498 10e4 2860     		str	r0, [r5, #0]	@ unaligned
 2499 10e6 6960     		str	r1, [r5, #4]	@ unaligned
 2500 10e8 AA60     		str	r2, [r5, #8]	@ unaligned
 2501 10ea EB60     		str	r3, [r5, #12]	@ unaligned
 2502 10ec 2378     		ldrb	r3, [r4, #0]
 2503 10ee 2B74     		strb	r3, [r5, #16]
1144:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1145:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // toss the IEEE802.15.4 header
1146:openstack/02a-MAClow/IEEE802154Ecsl.c ****       packetfunctions_tossHeader(ieee154e_vars.ackReceived,ieee802514_header.headerLength);
 2504              		.loc 1 1146 0
 2505 10f0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2506 10f4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2507 10f8 1A6A     		ldr	r2, [r3, #32]
 2508 10fa 7B7C     		ldrb	r3, [r7, #17]	@ zero_extendqisi2
 2509 10fc 1046     		mov	r0, r2
 2510 10fe 1946     		mov	r1, r3
 2511 1100 FFF7FEFF 		bl	packetfunctions_tossHeader
1147:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1148:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // break if invalid ACK
1149:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (isValidAck(&ieee802514_header,ieee154e_vars.dataToSend)==FALSE) {
 2512              		.loc 1 1149 0
 2513 1104 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2514 1108 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2515 110c 5B69     		ldr	r3, [r3, #20]
 2516 110e 07F11002 		add	r2, r7, #16
 2517 1112 1046     		mov	r0, r2
 2518 1114 1946     		mov	r1, r3
 2519 1116 FFF7FEFF 		bl	isValidAck
 2520 111a 0346     		mov	r3, r0
 2521 111c 83F00103 		eor	r3, r3, #1
 2522 1120 DBB2     		uxtb	r3, r3
 2523 1122 002B     		cmp	r3, #0
 2524 1124 3FD1     		bne	.L139
 2525              	.L134:
1150:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // break from the do-while loop and execute the clean-up code below
1151:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
1152:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1153:openstack/02a-MAClow/IEEE802154Ecsl.c ****       //hanlde IEs --xv poipoi
1154:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee802514_header.ieListPresent==FALSE){
 2526              		.loc 1 1154 0
 2527 1126 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 2528 1128 83F00103 		eor	r3, r3, #1
 2529 112c DBB2     		uxtb	r3, r3
 2530 112e 002B     		cmp	r3, #0
 2531 1130 3BD1     		bne	.L140
 2532              	.L135:
1155:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break; //ack should contain IEs.
1156:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1157:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1158:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_processIEs(ieee154e_vars.ackReceived,&lenIE)==FALSE){
 2533              		.loc 1 1158 0
 2534 1132 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2535 1136 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2536 113a 1A6A     		ldr	r2, [r3, #32]
 2537 113c 07F10E03 		add	r3, r7, #14
 2538 1140 1046     		mov	r0, r2
 2539 1142 1946     		mov	r1, r3
 2540 1144 FFF7FEFF 		bl	ieee154e_processIEs
 2541 1148 0346     		mov	r3, r0
 2542 114a 83F00103 		eor	r3, r3, #1
 2543 114e DBB2     		uxtb	r3, r3
 2544 1150 002B     		cmp	r3, #0
 2545 1152 2CD1     		bne	.L141
 2546              	.L136:
1159:openstack/02a-MAClow/IEEE802154Ecsl.c ****         // invalid IEs in ACK
1160:openstack/02a-MAClow/IEEE802154Ecsl.c ****         break;
1161:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1162:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1163:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // toss the IEs
1164:openstack/02a-MAClow/IEEE802154Ecsl.c ****       packetfunctions_tossHeader(ieee154e_vars.ackReceived,lenIE);
 2547              		.loc 1 1164 0
 2548 1154 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2549 1158 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2550 115c 1A6A     		ldr	r2, [r3, #32]
 2551 115e FB89     		ldrh	r3, [r7, #14]
 2552 1160 DBB2     		uxtb	r3, r3
 2553 1162 1046     		mov	r0, r2
 2554 1164 1946     		mov	r1, r3
 2555 1166 FFF7FEFF 		bl	packetfunctions_tossHeader
1165:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1166:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // inform schedule of successful transmission
1167:openstack/02a-MAClow/IEEE802154Ecsl.c ****       schedule_indicateTx(&ieee154e_vars.asn,TRUE);
 2556              		.loc 1 1167 0
 2557 116a 40F20000 		movw	r0, #:lower16:ieee154e_vars
 2558 116e C0F20000 		movt	r0, #:upper16:ieee154e_vars
 2559 1172 4FF00101 		mov	r1, #1
 2560 1176 FFF7FEFF 		bl	schedule_indicateTx
1168:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1169:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // inform upper layer
1170:openstack/02a-MAClow/IEEE802154Ecsl.c ****       notif_sendDone(ieee154e_vars.dataToSend,E_SUCCESS);
 2561              		.loc 1 1170 0
 2562 117a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2563 117e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2564 1182 5B69     		ldr	r3, [r3, #20]
 2565 1184 1846     		mov	r0, r3
 2566 1186 4FF00001 		mov	r1, #0
 2567 118a FFF7FEFF 		bl	notif_sendDone
1171:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1172:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataToSend = NULL;
 2568              		.loc 1 1172 0
 2569 118e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2570 1192 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2571 1196 4FF00002 		mov	r2, #0
 2572 119a 5A61     		str	r2, [r3, #20]
 2573 119c 08E0     		b	.L131
 2574              	.L137:
1128:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 2575              		.loc 1 1128 0
 2576 119e 00BF     		nop
 2577 11a0 06E0     		b	.L131
 2578              	.L138:
1137:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 2579              		.loc 1 1137 0
 2580 11a2 00BF     		nop
 2581 11a4 04E0     		b	.L131
 2582              	.L139:
1151:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 2583              		.loc 1 1151 0
 2584 11a6 00BF     		nop
 2585 11a8 02E0     		b	.L131
 2586              	.L140:
1155:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break; //ack should contain IEs.
 2587              		.loc 1 1155 0
 2588 11aa 00BF     		nop
 2589 11ac 00E0     		b	.L131
 2590              	.L141:
1160:openstack/02a-MAClow/IEEE802154Ecsl.c ****         break;
 2591              		.loc 1 1160 0
 2592 11ae 00BF     		nop
 2593              	.L131:
1173:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1174:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // in any case, execute the clean-up code below (processing of ACK done)
1175:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } while (0);
1176:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1177:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // free the received ack so corresponding RAM memory can be recycled
1178:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openqueue_freePacketBuffer(ieee154e_vars.ackReceived);
 2594              		.loc 1 1178 0
 2595 11b0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2596 11b4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2597 11b8 1B6A     		ldr	r3, [r3, #32]
 2598 11ba 1846     		mov	r0, r3
 2599 11bc FFF7FEFF 		bl	openqueue_freePacketBuffer
1179:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1180:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clear local variable
1181:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackReceived = NULL;
 2600              		.loc 1 1181 0
 2601 11c0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2602 11c4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2603 11c8 4FF00002 		mov	r2, #0
 2604 11cc 1A62     		str	r2, [r3, #32]
1182:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1183:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // official end of Tx
1184:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 2605              		.loc 1 1184 0
 2606 11ce FFF7FEFF 		bl	endOps
 2607              	.L126:
1185:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2608              		.loc 1 1185 0
 2609 11d2 07F15007 		add	r7, r7, #80
 2610 11d6 BD46     		mov	sp, r7
 2611 11d8 B0BD     		pop	{r4, r5, r7, pc}
 2612              		.cfi_endproc
 2613              	.LFE29:
 2615 11da 00BF     		.align	2
 2616              		.global	activity_csl_wakeup_ri1
 2617              		.thumb
 2618              		.thumb_func
 2620              	activity_csl_wakeup_ri1:
 2621              	.LFB30:
1186:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1187:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
1188:openstack/02a-MAClow/IEEE802154Ecsl.c **** //========================== CSL RX MODE ===============================
1189:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
1190:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1191:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1192:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1193:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [wake-up ri1].
1194:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1195:openstack/02a-MAClow/IEEE802154Ecsl.c ****  This method is invoked in ISR-mode from "isr_ieee154ecsl_newChannelSample" function when a new CSL
1196:openstack/02a-MAClow/IEEE802154Ecsl.c ****  
1197:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \note The FSM state should be S_SLEEP (initial state), raising an error in otherwise.
1198:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1199:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ri1() { // Activity for stage [ri1] on CSL RX Sampling.
 2622              		.loc 1 1199 0
 2623              		.cfi_startproc
 2624              		@ args = 0, pretend = 0, frame = 0
 2625              		@ frame_needed = 1, uses_anonymous_args = 0
 2626 11dc 80B5     		push	{r7, lr}
 2627              	.LCFI71:
 2628              		.cfi_def_cfa_offset 8
 2629              		.cfi_offset 7, -8
 2630              		.cfi_offset 14, -4
 2631 11de 00AF     		add	r7, sp, #0
 2632              	.LCFI72:
 2633              		.cfi_def_cfa_register 7
1200:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1201:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // if the previous sample took too long or the state is incorrect, we will not be in the right 
1202:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // we register an error indicating the number of CSL sample where the problem have been detecte
1203:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   if (ieee154e_vars.state!=S_SLEEP) {
 2634              		.loc 1 1203 0
 2635 11e0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2636 11e4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2637 11e8 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 2638 11ea 002B     		cmp	r3, #0
 2639 11ec 14D0     		beq	.L143
1204:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  // log the error
1205:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_START_CSL_SAMPLING,
1206:openstack/02a-MAClow/IEEE802154Ecsl.c **** 								(errorparameter_t)ieee154e_vars.state,
 2640              		.loc 1 1206 0
 2641 11ee 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2642 11f2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2643 11f6 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1205:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_START_CSL_SAMPLING,
 2644              		.loc 1 1205 0
 2645 11f8 1A46     		mov	r2, r3
1207:openstack/02a-MAClow/IEEE802154Ecsl.c **** 								(errorparameter_t)ieee154e_dbg.num_cslSamples);
 2646              		.loc 1 1207 0
 2647 11fa 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 2648 11fe C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 2649 1202 1B69     		ldr	r3, [r3, #16]
1205:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_START_CSL_SAMPLING,
 2650              		.loc 1 1205 0
 2651 1204 9BB2     		uxth	r3, r3
 2652 1206 4FF00900 		mov	r0, #9
 2653 120a 4FF03A01 		mov	r1, #58
 2654 120e FFF7FEFF 		bl	openserial_printError
1208:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1209:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  // Abort in case of error. The signature of the function has been changed (instead of endSlot()
1210:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  // functionality. However, this function is equal for CSL and not-CSL.
1211:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  endOps();
 2655              		.loc 1 1211 0
 2656 1212 FFF7FEFF 		bl	endOps
1212:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  return;
 2657              		.loc 1 1212 0
 2658 1216 17E0     		b	.L142
 2659              	.L143:
1213:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
1214:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1215:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // stop using serial
1216:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   openserial_stop();
 2660              		.loc 1 1216 0
 2661 1218 FFF7FEFF 		bl	openserial_stop
1217:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1218:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // change state --> Next State will be S_CSLRXWAKEUPOFFSET in order to prepare for CSL Rx wake-
1219:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   changeState(S_CSLRXWAKEUPOFFSET);
 2662              		.loc 1 1219 0
 2663 121c 4FF02B00 		mov	r0, #43
 2664 1220 FFF7FEFF 		bl	changeState
1220:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1221:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // update CSL Mode to RX in order to avoid problems in FSM.
1222:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   ieee154e_vars.cslMode = CSL_RX_MODE;
 2665              		.loc 1 1222 0
 2666 1224 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2667 1228 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2668 122c 4FF00102 		mov	r2, #1
 2669 1230 83F84520 		strb	r2, [r3, #69]
1223:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1224:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // arm rt1
1225:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   radiotimer_schedule(DURATION_rt1);
 2670              		.loc 1 1225 0
 2671 1234 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2672 1238 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2673 123c 5B6A     		ldr	r3, [r3, #36]
 2674 123e 03F13703 		add	r3, r3, #55
 2675 1242 1846     		mov	r0, r3
 2676 1244 FFF7FEFF 		bl	radiotimer_schedule
 2677              	.L142:
1226:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2678              		.loc 1 1226 0
 2679 1248 80BD     		pop	{r7, pc}
 2680              		.cfi_endproc
 2681              	.LFE30:
 2683 124a 00BF     		.align	2
 2684              		.global	activity_csl_wakeup_ri2
 2685              		.thumb
 2686              		.thumb_func
 2688              	activity_csl_wakeup_ri2:
 2689              	.LFB31:
1227:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1228:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1229:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1230:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [wake-up ri2].
1231:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1232:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1233:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to prepare the radio for receiving packets.
1234:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1235:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ri2() { // Activity for stage [ri2] on CSL RX Sampling.
 2690              		.loc 1 1235 0
 2691              		.cfi_startproc
 2692              		@ args = 0, pretend = 0, frame = 0
 2693              		@ frame_needed = 1, uses_anonymous_args = 0
 2694 124c 80B5     		push	{r7, lr}
 2695              	.LCFI73:
 2696              		.cfi_def_cfa_offset 8
 2697              		.cfi_offset 7, -8
 2698              		.cfi_offset 14, -4
 2699 124e 00AF     		add	r7, sp, #0
 2700              	.LCFI74:
 2701              		.cfi_def_cfa_register 7
1236:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1237:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXWAKEUPPREPARE);
 2702              		.loc 1 1237 0
 2703 1250 4FF02C00 		mov	r0, #44
 2704 1254 FFF7FEFF 		bl	changeState
1238:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1239:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // We use always the same frequency so it is not necessary to change it on radio.
1240:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Enable the radio in Rx mode. The radio does not actively listen yet.
1241:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rxEnable();
 2705              		.loc 1 1241 0
 2706 1258 FFF7FEFF 		bl	radio_rxEnable
1242:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnInit=radio_getTimerValue();
 2707              		.loc 1 1242 0
 2708 125c FFF7FEFF 		bl	radio_getTimerValue
 2709 1260 0246     		mov	r2, r0
 2710 1262 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2711 1266 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2712 126a 1A63     		str	r2, [r3, #48]
1243:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnThisSlot=TRUE;
 2713              		.loc 1 1243 0
 2714 126c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2715 1270 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2716 1274 4FF00102 		mov	r2, #1
 2717 1278 83F83820 		strb	r2, [r3, #56]
1244:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1245:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt2
1246:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt2);
 2718              		.loc 1 1246 0
 2719 127c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2720 1280 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2721 1284 5B6A     		ldr	r3, [r3, #36]
 2722 1286 03F15803 		add	r3, r3, #88
 2723 128a 1846     		mov	r0, r3
 2724 128c FFF7FEFF 		bl	radiotimer_schedule
1247:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1248:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Change state.
1249:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // If this action is not performed before rt2 has expired, we need to manage the error in activi
1250:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // prepare has exceeded the maximum allowed time (duration_rt2).
1251:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXWAKEUPREADY);
 2725              		.loc 1 1251 0
 2726 1290 4FF02D00 		mov	r0, #45
 2727 1294 FFF7FEFF 		bl	changeState
1252:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2728              		.loc 1 1252 0
 2729 1298 80BD     		pop	{r7, pc}
 2730              		.cfi_endproc
 2731              	.LFE31:
 2733 129a 00BF     		.align	2
 2734              		.global	activity_csl_wakeup_rie1
 2735              		.thumb
 2736              		.thumb_func
 2738              	activity_csl_wakeup_rie1:
 2739              	.LFB32:
1253:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1254:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1255:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1256:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling error [wake-up rie1].
1257:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1258:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #rt2 expiring, i.e. timer fires while state = S_CSLRXWAKEUPPREPARE. This is 
1259:openstack/02a-MAClow/IEEE802154Ecsl.c ****   did not have enough time to execute. Chances are to set maxRxDataPrepare too small. The implement
1260:openstack/02a-MAClow/IEEE802154Ecsl.c ****   next CSL sample.
1261:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1262:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_rie1() {  // Activity for error event [rie1] on CSL RX Samplin
 2740              		.loc 1 1262 0
 2741              		.cfi_startproc
 2742              		@ args = 0, pretend = 0, frame = 0
 2743              		@ frame_needed = 1, uses_anonymous_args = 0
 2744 129c 80B5     		push	{r7, lr}
 2745              	.LCFI75:
 2746              		.cfi_def_cfa_offset 8
 2747              		.cfi_offset 7, -8
 2748              		.cfi_offset 14, -4
 2749 129e 00AF     		add	r7, sp, #0
 2750              	.LCFI76:
 2751              		.cfi_def_cfa_register 7
1263:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
1264:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXWAKEUPPREPARE_OVERFLOWS,
1265:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state,
 2752              		.loc 1 1265 0
 2753 12a0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2754 12a4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2755 12a8 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1264:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXWAKEUPPREPARE_OVERFLOWS,
 2756              		.loc 1 1264 0
 2757 12aa 1A46     		mov	r2, r3
1266:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_dbg.num_cslSamples);
 2758              		.loc 1 1266 0
 2759 12ac 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 2760 12b0 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 2761 12b4 1B69     		ldr	r3, [r3, #16]
1264:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXWAKEUPPREPARE_OVERFLOWS,
 2762              		.loc 1 1264 0
 2763 12b6 9BB2     		uxth	r3, r3
 2764 12b8 4FF00900 		mov	r0, #9
 2765 12bc 4FF03C01 		mov	r1, #60
 2766 12c0 FFF7FEFF 		bl	openserial_printError
1267:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1268:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 2767              		.loc 1 1268 0
 2768 12c4 FFF7FEFF 		bl	endOps
1269:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2769              		.loc 1 1269 0
 2770 12c8 80BD     		pop	{r7, pc}
 2771              		.cfi_endproc
 2772              	.LFE32:
 2774 12ca 00BF     		.align	2
 2775              		.global	activity_csl_wakeup_ri3
 2776              		.thumb
 2777              		.thumb_func
 2779              	activity_csl_wakeup_ri3:
 2780              	.LFB33:
1270:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1271:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1272:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1273:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [wake-up ri3].
1274:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1275:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1276:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The radio is configured and this interrupt gives it the "go" signal to start listening.
1277:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1278:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ri3() { // Activity for stage [ri3] on CSL RX Sampling.
 2781              		.loc 1 1278 0
 2782              		.cfi_startproc
 2783              		@ args = 0, pretend = 0, frame = 0
 2784              		@ frame_needed = 1, uses_anonymous_args = 0
 2785 12cc 80B5     		push	{r7, lr}
 2786              	.LCFI77:
 2787              		.cfi_def_cfa_offset 8
 2788              		.cfi_offset 7, -8
 2789              		.cfi_offset 14, -4
 2790 12ce 00AF     		add	r7, sp, #0
 2791              	.LCFI78:
 2792              		.cfi_def_cfa_register 7
1279:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1280:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXWAKEUPLISTEN);
 2793              		.loc 1 1280 0
 2794 12d0 4FF02E00 		mov	r0, #46
 2795 12d4 FFF7FEFF 		bl	changeState
1281:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1282:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // give the 'go' to receive
1283:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rxNow();
 2796              		.loc 1 1283 0
 2797 12d8 FFF7FEFF 		bl	radio_rxNow
1284:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1285:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt3
1286:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt3);
 2798              		.loc 1 1286 0
 2799 12dc 40F24110 		movw	r0, #321
 2800 12e0 FFF7FEFF 		bl	radiotimer_schedule
1287:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2801              		.loc 1 1287 0
 2802 12e4 80BD     		pop	{r7, pc}
 2803              		.cfi_endproc
 2804              	.LFE33:
 2806 12e6 00BF     		.align	2
 2807              		.global	activity_csl_wakeup_rie2
 2808              		.thumb
 2809              		.thumb_func
 2811              	activity_csl_wakeup_rie2:
 2812              	.LFB34:
1288:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1289:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1290:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1291:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling error [wake-up rie2].
1292:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1293:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #rt3 expiring, i.e. timer fires while state = S_CSLRXWAKEUPLISTEN. If no pac
1294:openstack/02a-MAClow/IEEE802154Ecsl.c ****   none will be received ever and it is safe to switch of the radio. This timer is set such that the
1295:openstack/02a-MAClow/IEEE802154Ecsl.c ****   duration (#TsLongGT).
1296:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1297:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_rie2() { // Activity for error event [rie2] on CSL RX Sampling
 2813              		.loc 1 1297 0
 2814              		.cfi_startproc
 2815              		@ args = 0, pretend = 0, frame = 0
 2816              		@ frame_needed = 1, uses_anonymous_args = 0
 2817 12e8 80B5     		push	{r7, lr}
 2818              	.LCFI79:
 2819              		.cfi_def_cfa_offset 8
 2820              		.cfi_offset 7, -8
 2821              		.cfi_offset 14, -4
 2822 12ea 00AF     		add	r7, sp, #0
 2823              	.LCFI80:
 2824              		.cfi_def_cfa_register 7
1298:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state --> Next State will be S_CSLRXWAKEUPOFFSET in order to prepare for CSL Rx wake-u
1299:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXWAKEUPOFFSET);
 2825              		.loc 1 1299 0
 2826 12ec 4FF02B00 		mov	r0, #43
 2827 12f0 FFF7FEFF 		bl	changeState
1300:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1301:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt1
1302:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt1);
 2828              		.loc 1 1302 0
 2829 12f4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2830 12f8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2831 12fc 5B6A     		ldr	r3, [r3, #36]
 2832 12fe 03F13703 		add	r3, r3, #55
 2833 1302 1846     		mov	r0, r3
 2834 1304 FFF7FEFF 		bl	radiotimer_schedule
1303:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1304:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1305:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 2835              		.loc 1 1305 0
 2836 1308 FFF7FEFF 		bl	endOps
1306:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2837              		.loc 1 1306 0
 2838 130c 80BD     		pop	{r7, pc}
 2839              		.cfi_endproc
 2840              	.LFE34:
 2842 130e 00BF     		.align	2
 2843              		.global	activity_csl_wakeup_ri4
 2844              		.thumb
 2845              		.thumb_func
 2847              	activity_csl_wakeup_ri4:
 2848              	.LFB35:
1307:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1308:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1309:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1310:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [wake-up ri4].
1311:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1312:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_startOfFrame" function when a start of frame ev
1313:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to capture the time, cancel #rt3 and arm #rt4 (max time to receive all the p
1314:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1315:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ri4(PORT_RADIOTIMER_WIDTH capturedTime) {  // Activity for sta
 2849              		.loc 1 1315 0
 2850              		.cfi_startproc
 2851              		@ args = 0, pretend = 0, frame = 8
 2852              		@ frame_needed = 1, uses_anonymous_args = 0
 2853 1310 80B5     		push	{r7, lr}
 2854              	.LCFI81:
 2855              		.cfi_def_cfa_offset 8
 2856              		.cfi_offset 7, -8
 2857              		.cfi_offset 14, -4
 2858 1312 82B0     		sub	sp, sp, #8
 2859              	.LCFI82:
 2860              		.cfi_def_cfa_offset 16
 2861 1314 00AF     		add	r7, sp, #0
 2862              	.LCFI83:
 2863              		.cfi_def_cfa_register 7
 2864 1316 7860     		str	r0, [r7, #4]
1316:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1317:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1318:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXWAKEUP);
 2865              		.loc 1 1318 0
 2866 1318 4FF02F00 		mov	r0, #47
 2867 131c FFF7FEFF 		bl	changeState
1319:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1320:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel rt3
1321:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 2868              		.loc 1 1321 0
 2869 1320 FFF7FEFF 		bl	radiotimer_cancel
1322:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1323:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
1324:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.lastCapturedTime = capturedTime;
 2870              		.loc 1 1324 0
 2871 1324 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2872 1328 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2873 132c 7A68     		ldr	r2, [r7, #4]
 2874 132e 5A62     		str	r2, [r3, #36]
1325:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1326:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time to sync
1327:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.syncCapturedTime = capturedTime;
 2875              		.loc 1 1327 0
 2876 1330 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2877 1334 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2878 1338 7A68     		ldr	r2, [r7, #4]
 2879 133a 9A62     		str	r2, [r3, #40]
1328:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1329:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt4);
 2880              		.loc 1 1329 0
 2881 133c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2882 1340 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2883 1344 5B6A     		ldr	r3, [r3, #36]
 2884 1346 03F1A403 		add	r3, r3, #164
 2885 134a 1846     		mov	r0, r3
 2886 134c FFF7FEFF 		bl	radiotimer_schedule
1330:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2887              		.loc 1 1330 0
 2888 1350 07F10807 		add	r7, r7, #8
 2889 1354 BD46     		mov	sp, r7
 2890 1356 80BD     		pop	{r7, pc}
 2891              		.cfi_endproc
 2892              	.LFE35:
 2894              		.align	2
 2895              		.global	activity_csl_wakeup_rie3
 2896              		.thumb
 2897              		.thumb_func
 2899              	activity_csl_wakeup_rie3:
 2900              	.LFB36:
1331:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1332:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1333:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1334:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling error [wake-up rie3].
1335:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1336:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #rt4 expiring, i.e. timer fires while state = S_CSLRXWAKEUP. This is an erro
1337:openstack/02a-MAClow/IEEE802154Ecsl.c ****   transmit the data packet. The implemented behaviour is to log the error and move on the next CSL 
1338:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1339:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_rie3() {
 2901              		.loc 1 1339 0
 2902              		.cfi_startproc
 2903              		@ args = 0, pretend = 0, frame = 0
 2904              		@ frame_needed = 1, uses_anonymous_args = 0
 2905 1358 80B5     		push	{r7, lr}
 2906              	.LCFI84:
 2907              		.cfi_def_cfa_offset 8
 2908              		.cfi_offset 7, -8
 2909              		.cfi_offset 14, -4
 2910 135a 00AF     		add	r7, sp, #0
 2911              	.LCFI85:
 2912              		.cfi_def_cfa_register 7
1340:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1341:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
1342:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDWAKEUPDURATION_OVERFLOWS,
1343:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state,
 2913              		.loc 1 1343 0
 2914 135c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2915 1360 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2916 1364 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1342:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDWAKEUPDURATION_OVERFLOWS,
 2917              		.loc 1 1342 0
 2918 1366 1A46     		mov	r2, r3
1344:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_dbg.num_cslSamples);
 2919              		.loc 1 1344 0
 2920 1368 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 2921 136c C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 2922 1370 1B69     		ldr	r3, [r3, #16]
1342:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDWAKEUPDURATION_OVERFLOWS,
 2923              		.loc 1 1342 0
 2924 1372 9BB2     		uxth	r3, r3
 2925 1374 4FF00900 		mov	r0, #9
 2926 1378 4FF03D01 		mov	r1, #61
 2927 137c FFF7FEFF 		bl	openserial_printError
1345:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1346:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 2928              		.loc 1 1346 0
 2929 1380 FFF7FEFF 		bl	endOps
1347:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2930              		.loc 1 1347 0
 2931 1384 80BD     		pop	{r7, pc}
 2932              		.cfi_endproc
 2933              	.LFE36:
 2935 1386 00BF     		.align	2
 2936              		.global	activity_csl_wakeup_ri5
 2937              		.thumb
 2938              		.thumb_func
 2940              	activity_csl_wakeup_ri5:
 2941              	.LFB37:
1348:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1349:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1350:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1351:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [wake-up ri5].
1352:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1353:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_endOfFrame" function when a end of frame event 
1354:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change state, cancel #rt4, validate wake-up frame and destination, and ar
1355:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1356:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ri5(PORT_RADIOTIMER_WIDTH capturedTime) {
 2942              		.loc 1 1356 0
 2943              		.cfi_startproc
 2944              		@ args = 0, pretend = 0, frame = 120
 2945              		@ frame_needed = 1, uses_anonymous_args = 0
 2946 1388 90B5     		push	{r4, r7, lr}
 2947              	.LCFI86:
 2948              		.cfi_def_cfa_offset 12
 2949              		.cfi_offset 4, -12
 2950              		.cfi_offset 7, -8
 2951              		.cfi_offset 14, -4
 2952 138a A1B0     		sub	sp, sp, #132
 2953              	.LCFI87:
 2954              		.cfi_def_cfa_offset 144
 2955 138c 02AF     		add	r7, sp, #8
 2956              	.LCFI88:
 2957              		.cfi_def_cfa 7, 136
 2958 138e 7860     		str	r0, [r7, #4]
1357:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1358:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	ieee802154_header_iht ieee802514_header;
1359:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	open_addr_t myID, myID16b;
1360:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	uint16_t rztime = 0;
 2959              		.loc 1 1360 0
 2960 1390 4FF00003 		mov	r3, #0
 2961 1394 FB81     		strh	r3, [r7, #14]	@ movhi
1361:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1362:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// [CSL-TEST]: hard-code mac address to match dest address on schedule in tx activity.
1363:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1364:openstack/02a-MAClow/IEEE802154Ecsl.c ****     myID.addr_64b[0]=0x00;
 2962              		.loc 1 1364 0
 2963 1396 4FF00003 		mov	r3, #0
 2964 139a 87F82530 		strb	r3, [r7, #37]
1365:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.addr_64b[1]=0x11;
 2965              		.loc 1 1365 0
 2966 139e 4FF01103 		mov	r3, #17
 2967 13a2 87F82630 		strb	r3, [r7, #38]
1366:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.addr_64b[2]=0x22;
 2968              		.loc 1 1366 0
 2969 13a6 4FF02203 		mov	r3, #34
 2970 13aa 87F82730 		strb	r3, [r7, #39]
1367:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.addr_64b[3]=0x33;
 2971              		.loc 1 1367 0
 2972 13ae 4FF03303 		mov	r3, #51
 2973 13b2 87F82830 		strb	r3, [r7, #40]
1368:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.addr_64b[4]=0x44;
 2974              		.loc 1 1368 0
 2975 13b6 4FF04403 		mov	r3, #68
 2976 13ba 87F82930 		strb	r3, [r7, #41]
1369:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.addr_64b[5]=0x55;
 2977              		.loc 1 1369 0
 2978 13be 4FF05503 		mov	r3, #85
 2979 13c2 87F82A30 		strb	r3, [r7, #42]
1370:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.addr_64b[6]=0x66;
 2980              		.loc 1 1370 0
 2981 13c6 4FF06603 		mov	r3, #102
 2982 13ca 87F82B30 		strb	r3, [r7, #43]
1371:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.addr_64b[7]=0x77;
 2983              		.loc 1 1371 0
 2984 13ce 4FF07703 		mov	r3, #119
 2985 13d2 87F82C30 		strb	r3, [r7, #44]
1372:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1373:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.type=ADDR_64B;
 2986              		.loc 1 1373 0
 2987 13d6 4FF00203 		mov	r3, #2
 2988 13da 87F82430 		strb	r3, [r7, #36]
1374:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1375:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// [CSL-TEST]: end test code
1376:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1377:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// En este punto ya hemos recibido la trama por lo que hay que hacer las siguientes validaciones:
1378:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   1.- Cambiar el estado a S_CSLRXWAKEUPVALIDATE y cancelar el temporizador rt4.
1379:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   2.- Apagar la radio.
1380:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   3.- Analizar el mensaje recibido y parsear su cabecera.
1381:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   4.- Verificar que se trata de una trama de tipo wake-up.
1382:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   5.- Comprobar que el destinatario soy yo mismo.
1383:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//
1384:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// En caso afirmativo, utilizamos el Rendezvous time recibido para saber cuánto tiempo hay que do
1385:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// En caso negativo, desactivamos la radio e iniciamos de nuevo el proceso de channel sampling.
1386:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1387:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // actualizamos el estado.
1388:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXWAKEUPVALIDATE);
 2989              		.loc 1 1388 0
 2990 13de 4FF03000 		mov	r0, #48
 2991 13e2 FFF7FEFF 		bl	changeState
1389:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1390:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancelamos el timer #rt4
1391:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 2992              		.loc 1 1391 0
 2993 13e6 FFF7FEFF 		bl	radiotimer_cancel
1392:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1393:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // apagamos la radio
1394:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rfOff();
 2994              		.loc 1 1394 0
 2995 13ea FFF7FEFF 		bl	radio_rfOff
1395:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1396:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // obtenemos un buffer en el cual poder guardar los datos recibidos.
1397:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.wakeupReceived = openqueue_getFreePacketBuffer(COMPONENT_IEEE802154E);
 2996              		.loc 1 1397 0
 2997 13ee 4FF00900 		mov	r0, #9
 2998 13f2 FFF7FEFF 		bl	openqueue_getFreePacketBuffer
 2999 13f6 0246     		mov	r2, r0
 3000 13f8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3001 13fc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3002 1400 1A64     		str	r2, [r3, #64]
1398:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.wakeupReceived==NULL) {
 3003              		.loc 1 1398 0
 3004 1402 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3005 1406 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3006 140a 1B6C     		ldr	r3, [r3, #64]
 3007 140c 002B     		cmp	r3, #0
 3008 140e 0CD1     		bne	.L152
1399:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // registro del error & fin de operaciones.
1400:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openserial_printError(COMPONENT_IEEE802154E,ERR_NO_FREE_PACKET_BUFFER, (errorparameter_t)0, (
 3009              		.loc 1 1400 0
 3010 1410 4FF00900 		mov	r0, #9
 3011 1414 4FF02C01 		mov	r1, #44
 3012 1418 4FF00002 		mov	r2, #0
 3013 141c 4FF00003 		mov	r3, #0
 3014 1420 FFF7FEFF 		bl	openserial_printError
1401:openstack/02a-MAClow/IEEE802154Ecsl.c ****       endOps();
 3015              		.loc 1 1401 0
 3016 1424 FFF7FEFF 		bl	endOps
 3017 1428 40E1     		b	.L151
 3018              	.L152:
1402:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return;
1403:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
1404:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1405:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Declaración de propiedad sobre el paquete.
1406:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.wakeupReceived->creator = COMPONENT_IEEE802154E;
 3019              		.loc 1 1406 0
 3020 142a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3021 142e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3022 1432 1B6C     		ldr	r3, [r3, #64]
 3023 1434 4FF00902 		mov	r2, #9
 3024 1438 1A70     		strb	r2, [r3, #0]
1407:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.wakeupReceived->owner   = COMPONENT_IEEE802154E;
 3025              		.loc 1 1407 0
 3026 143a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3027 143e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3028 1442 1B6C     		ldr	r3, [r3, #64]
 3029 1444 4FF00902 		mov	r2, #9
 3030 1448 5A70     		strb	r2, [r3, #1]
1408:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1409:openstack/02a-MAClow/IEEE802154Ecsl.c ****    /*
1410:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The do-while loop that follows is a little parsing trick.
1411:openstack/02a-MAClow/IEEE802154Ecsl.c ****    Because it contains a while(0) condition, it gets executed only once.
1412:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The behavior is:
1413:openstack/02a-MAClow/IEEE802154Ecsl.c ****    - if a break occurs inside the do{} body, the error code below the loop gets executed. This indi
1414:openstack/02a-MAClow/IEEE802154Ecsl.c ****    - if a return occurs inside the do{} body, the error code below the loop does not get executed. 
1415:openstack/02a-MAClow/IEEE802154Ecsl.c ****    */
1416:openstack/02a-MAClow/IEEE802154Ecsl.c ****    do { // Este "loop" es ejecutado sólo en una ocasión.
1417:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1418:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Obtenemos la trama con los datos recibidos desde el buffer de recepción de la radio.
1419:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.wakeupReceived->payload = &(ieee154e_vars.wakeupReceived->packet[FIRST_FRAME_BY
 3031              		.loc 1 1419 0
 3032 144a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3033 144e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3034 1452 1A6C     		ldr	r2, [r3, #64]
 3035 1454 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3036 1458 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3037 145c 1B6C     		ldr	r3, [r3, #64]
 3038 145e 03F16C03 		add	r3, r3, #108
 3039 1462 5360     		str	r3, [r2, #4]
1420:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(      ieee154e_vars.wakeupReceived->payload,
 3040              		.loc 1 1420 0
 3041 1464 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3042 1468 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3043 146c 1B6C     		ldr	r3, [r3, #64]
 3044 146e 5968     		ldr	r1, [r3, #4]
1421:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.wakeupReceived->length,
 3045              		.loc 1 1421 0
 3046 1470 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3047 1474 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3048 1478 1B6C     		ldr	r3, [r3, #64]
1420:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(      ieee154e_vars.wakeupReceived->payload,
 3049              		.loc 1 1420 0
 3050 147a 03F10802 		add	r2, r3, #8
1422:openstack/02a-MAClow/IEEE802154Ecsl.c ****                              sizeof(ieee154e_vars.wakeupReceived->packet),
1423:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.wakeupReceived->l1_rssi,
 3051              		.loc 1 1423 0
 3052 147e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3053 1482 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3054 1486 1B6C     		ldr	r3, [r3, #64]
1420:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(      ieee154e_vars.wakeupReceived->payload,
 3055              		.loc 1 1420 0
 3056 1488 03F16804 		add	r4, r3, #104
1424:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.wakeupReceived->l1_lqi,
 3057              		.loc 1 1424 0
 3058 148c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3059 1490 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3060 1494 1B6C     		ldr	r3, [r3, #64]
1420:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(      ieee154e_vars.wakeupReceived->payload,
 3061              		.loc 1 1420 0
 3062 1496 03F16900 		add	r0, r3, #105
1425:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.wakeupReceived->l1_crc);
 3063              		.loc 1 1425 0
 3064 149a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3065 149e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3066 14a2 1B6C     		ldr	r3, [r3, #64]
1420:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(      ieee154e_vars.wakeupReceived->payload,
 3067              		.loc 1 1420 0
 3068 14a4 03F16A03 		add	r3, r3, #106
 3069 14a8 0090     		str	r0, [sp, #0]
 3070 14aa 0193     		str	r3, [sp, #4]
 3071 14ac 0846     		mov	r0, r1
 3072 14ae 1146     		mov	r1, r2
 3073 14b0 4FF08202 		mov	r2, #130
 3074 14b4 2346     		mov	r3, r4
 3075 14b6 FFF7FEFF 		bl	radio_getReceivedFrame
1426:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1427:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Finalizamos si la longitud no es correcta.
1428:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.wakeupReceived->length<LENGTH_CRC || ieee154e_vars.wakeupReceived->length>L
 3076              		.loc 1 1428 0
 3077 14ba 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3078 14be C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3079 14c2 1B6C     		ldr	r3, [r3, #64]
 3080 14c4 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 3081 14c6 012B     		cmp	r3, #1
 3082 14c8 07D9     		bls	.L154
 3083              		.loc 1 1428 0 is_stmt 0 discriminator 1
 3084 14ca 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3085 14ce C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3086 14d2 1B6C     		ldr	r3, [r3, #64]
 3087 14d4 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 3088 14d6 802B     		cmp	r3, #128
 3089 14d8 0ED9     		bls	.L155
 3090              	.L154:
1429:openstack/02a-MAClow/IEEE802154Ecsl.c ****         openserial_printError(COMPONENT_IEEE802154E,ERR_INVALIDPACKETFROMRADIO, (errorparameter_t)2
 3091              		.loc 1 1429 0 is_stmt 1
 3092 14da 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3093 14de C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3094 14e2 1B6C     		ldr	r3, [r3, #64]
 3095 14e4 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 3096 14e6 4FF00900 		mov	r0, #9
 3097 14ea 4FF03701 		mov	r1, #55
 3098 14ee 4FF00202 		mov	r2, #2
 3099 14f2 FFF7FEFF 		bl	openserial_printError
1430:openstack/02a-MAClow/IEEE802154Ecsl.c ****         break;
 3100              		.loc 1 1430 0
 3101 14f6 C8E0     		b	.L156
 3102              	.L155:
1431:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1432:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1433:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // toss CRC (2 últimos bytes)
1434:openstack/02a-MAClow/IEEE802154Ecsl.c ****       packetfunctions_tossFooter(ieee154e_vars.wakeupReceived, LENGTH_CRC);
 3103              		.loc 1 1434 0
 3104 14f8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3105 14fc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3106 1500 1B6C     		ldr	r3, [r3, #64]
 3107 1502 1846     		mov	r0, r3
 3108 1504 4FF00201 		mov	r1, #2
 3109 1508 FFF7FEFF 		bl	packetfunctions_tossFooter
1435:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1436:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // si CRC no es válido, finalizamos el proceso.
1437:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.wakeupReceived->l1_crc==FALSE) { break; }
 3110              		.loc 1 1437 0
 3111 150c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3112 1510 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3113 1514 1B6C     		ldr	r3, [r3, #64]
 3114 1516 93F86A30 		ldrb	r3, [r3, #106]	@ zero_extendqisi2
 3115 151a 83F00103 		eor	r3, r3, #1
 3116 151e DBB2     		uxtb	r3, r3
 3117 1520 002B     		cmp	r3, #0
 3118 1522 40F0AD80 		bne	.L164
 3119              	.L157:
1438:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1439:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // parseamos la trama IEEE802.15.4 WAKE-UP y su cabecera.
1440:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee802154_retrieveWakeUpFrame(ieee154e_vars.wakeupReceived,&ieee802514_header,&rztime);
 3120              		.loc 1 1440 0
 3121 1526 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3122 152a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3123 152e 196C     		ldr	r1, [r3, #64]
 3124 1530 07F13802 		add	r2, r7, #56
 3125 1534 07F10E03 		add	r3, r7, #14
 3126 1538 0846     		mov	r0, r1
 3127 153a 1146     		mov	r1, r2
 3128 153c 1A46     		mov	r2, r3
 3129 153e FFF7FEFF 		bl	ieee802154_retrieveWakeUpFrame
1441:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1442:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // En el caso de que no sea una cabecera IEEE802.15.4 válida, finalizamos el proceso.
1443:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee802514_header.valid==FALSE) { break; }
 3130              		.loc 1 1443 0
 3131 1542 97F83830 		ldrb	r3, [r7, #56]	@ zero_extendqisi2
 3132 1546 83F00103 		eor	r3, r3, #1
 3133 154a DBB2     		uxtb	r3, r3
 3134 154c 002B     		cmp	r3, #0
 3135 154e 40F09980 		bne	.L165
 3136              	.L158:
1444:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1445:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Verificamos que se trata de una trama WAKE-UP, perteneciente a la misma PAN ID, y dirigida
1446:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if(ieee802514_header.frameType==IEEE154_TYPE_MULTIPURPOSE) {
 3137              		.loc 1 1446 0
 3138 1552 97F83A30 		ldrb	r3, [r7, #58]	@ zero_extendqisi2
 3139 1556 052B     		cmp	r3, #5
 3140 1558 40F09680 		bne	.L166
1447:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1448:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	  // [CSL-TEST]: comment and substituted due to mac address is hard-coded in tx and rx for tes
1449:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1450:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	  //if(packetfunctions_sameAddress(&ieee802514_header.dest,idmanager_getMyID(ADDR_16B)) &&
1451:openstack/02a-MAClow/IEEE802154Ecsl.c ****    	      //   packetfunctions_sameAddress(&ieee802514_header.panid,idmanager_getMyID(ADDR_PANID)))
1452:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1453:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	  packetfunctions_mac64bToMac16b(&myID,&myID16b);
 3141              		.loc 1 1453 0
 3142 155c 07F12402 		add	r2, r7, #36
 3143 1560 07F11003 		add	r3, r7, #16
 3144 1564 1046     		mov	r0, r2
 3145 1566 1946     		mov	r1, r3
 3146 1568 FFF7FEFF 		bl	packetfunctions_mac64bToMac16b
1454:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	  if(packetfunctions_sameAddress(&ieee802514_header.dest, &myID16b) &&
 3147              		.loc 1 1454 0
 3148 156c 07F13803 		add	r3, r7, #56
 3149 1570 03F11B02 		add	r2, r3, #27
 3150 1574 07F11003 		add	r3, r7, #16
 3151 1578 1046     		mov	r0, r2
 3152 157a 1946     		mov	r1, r3
 3153 157c FFF7FEFF 		bl	packetfunctions_sameAddress
 3154 1580 0346     		mov	r3, r0
 3155 1582 002B     		cmp	r3, #0
 3156 1584 43D0     		beq	.L160
1455:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     packetfunctions_sameAddress(&ieee802514_header.panid,idmanager_getMyID(ADDR_PANID))) {
 3157              		.loc 1 1455 0 discriminator 1
 3158 1586 4FF00400 		mov	r0, #4
 3159 158a FFF7FEFF 		bl	idmanager_getMyID
 3160 158e 0346     		mov	r3, r0
 3161 1590 07F13802 		add	r2, r7, #56
 3162 1594 02F10A02 		add	r2, r2, #10
 3163 1598 1046     		mov	r0, r2
 3164 159a 1946     		mov	r1, r3
 3165 159c FFF7FEFF 		bl	packetfunctions_sameAddress
 3166 15a0 0346     		mov	r3, r0
1454:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	  if(packetfunctions_sameAddress(&ieee802514_header.dest, &myID16b) &&
 3167              		.loc 1 1454 0 discriminator 1
 3168 15a2 002B     		cmp	r3, #0
 3169 15a4 33D0     		beq	.L160
1456:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1457:openstack/02a-MAClow/IEEE802154Ecsl.c ****    		  // [CSL-TEST]: end test code
1458:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1459:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	   // En este caso, debemos dormir el tiempo indicado por RZ Time, estableciendo el estado a S
1460:openstack/02a-MAClow/IEEE802154Ecsl.c ****  	       changeState(S_CSLRXDATAOFFSET);
 3170              		.loc 1 1460 0
 3171 15a6 4FF03100 		mov	r0, #49
 3172 15aa FFF7FEFF 		bl	changeState
1461:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1462:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	   // registro del tiempo de captura
1463:openstack/02a-MAClow/IEEE802154Ecsl.c ****            ieee154e_vars.lastCapturedTime = capturedTime;
 3173              		.loc 1 1463 0
 3174 15ae 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3175 15b2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3176 15b6 7A68     		ldr	r2, [r7, #4]
 3177 15b8 5A62     		str	r2, [r3, #36]
1464:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1465:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	   // Tratamos el caso en el cual rztime_ie.time sea cero, es decir, sea la ultima trama wake-
1466:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	   if (rztime == 0) {
 3178              		.loc 1 1466 0
 3179 15ba FB89     		ldrh	r3, [r7, #14]
 3180 15bc 002B     		cmp	r3, #0
 3181 15be 0AD1     		bne	.L161
1467:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     // Establecemos el timer rt1 (consideramos el mismo tiempo de offset para la recepción d
1468:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     radiotimer_schedule(DURATION_rt1);
 3182              		.loc 1 1468 0
 3183 15c0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3184 15c4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3185 15c8 5B6A     		ldr	r3, [r3, #36]
 3186 15ca 03F13703 		add	r3, r3, #55
 3187 15ce 1846     		mov	r0, r3
 3188 15d0 FFF7FEFF 		bl	radiotimer_schedule
 3189 15d4 0BE0     		b	.L162
 3190              	.L161:
1469:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	   } else {
1470:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     // Establecemos el timer al valor rt1 pero desplazado el tiempo indicado por rendezvous-t
1471:openstack/02a-MAClow/IEEE802154Ecsl.c ****         	 radiotimer_schedule(DURATION_rt1 + rztime);
 3191              		.loc 1 1471 0
 3192 15d6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3193 15da C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3194 15de 5A6A     		ldr	r2, [r3, #36]
 3195 15e0 FB89     		ldrh	r3, [r7, #14]
 3196 15e2 D318     		adds	r3, r2, r3
 3197 15e4 03F13703 		add	r3, r3, #55
 3198 15e8 1846     		mov	r0, r3
 3199 15ea FFF7FEFF 		bl	radiotimer_schedule
 3200              	.L162:
1472:openstack/02a-MAClow/IEEE802154Ecsl.c ****            }
1473:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1474:openstack/02a-MAClow/IEEE802154Ecsl.c ****            // Descartamos el paquete una vez recibido y tratado.
1475:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1476:openstack/02a-MAClow/IEEE802154Ecsl.c ****            openqueue_freePacketBuffer(ieee154e_vars.wakeupReceived);
 3201              		.loc 1 1476 0
 3202 15ee 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3203 15f2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3204 15f6 1B6C     		ldr	r3, [r3, #64]
 3205 15f8 1846     		mov	r0, r3
 3206 15fa FFF7FEFF 		bl	openqueue_freePacketBuffer
1477:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1478:openstack/02a-MAClow/IEEE802154Ecsl.c ****            // clear local variable
1479:openstack/02a-MAClow/IEEE802154Ecsl.c ****            ieee154e_vars.wakeupReceived = NULL;
 3207              		.loc 1 1479 0
 3208 15fe 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3209 1602 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3210 1606 4FF00002 		mov	r2, #0
 3211 160a 1A64     		str	r2, [r3, #64]
 3212 160c 4EE0     		b	.L151
 3213              	.L160:
1480:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1481:openstack/02a-MAClow/IEEE802154Ecsl.c ****            // retornamos para no ejecutar el codigo inferior y finalizar el proceso.
1482:openstack/02a-MAClow/IEEE802154Ecsl.c ****            return;
1483:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 }
1484:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 // En el caso que sea una trama dentro de mi PANID pero no dirigida a mi, entonces dormimos u
1485:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 //   - RZ time + Maximum length payload frame + secure ack frame (consideraremos un tiempo ig
1486:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 // dado que TsSlotDuration es el tiempo utilizado en OpenWSN-TSCH para enviar y recibir una t
1487:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 // en cualquier caso revisar estos timings mediante medidas y mecanismos más precisos (oscil
1488:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1489:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 else if( ! packetfunctions_sameAddress(&ieee802514_header.dest,idmanager_getMyID(ADDR_16B)) &
 3214              		.loc 1 1489 0
 3215 160e 4FF00100 		mov	r0, #1
 3216 1612 FFF7FEFF 		bl	idmanager_getMyID
 3217 1616 0346     		mov	r3, r0
 3218 1618 07F13802 		add	r2, r7, #56
 3219 161c 02F11B02 		add	r2, r2, #27
 3220 1620 1046     		mov	r0, r2
 3221 1622 1946     		mov	r1, r3
 3222 1624 FFF7FEFF 		bl	packetfunctions_sameAddress
 3223 1628 0346     		mov	r3, r0
 3224 162a 83F00103 		eor	r3, r3, #1
 3225 162e DBB2     		uxtb	r3, r3
 3226 1630 002B     		cmp	r3, #0
 3227 1632 2AD0     		beq	.L156
1490:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	   		    packetfunctions_sameAddress(&ieee802514_header.panid,idmanager_getMyID(ADDR_PANID))) 
 3228              		.loc 1 1490 0 discriminator 1
 3229 1634 4FF00400 		mov	r0, #4
 3230 1638 FFF7FEFF 		bl	idmanager_getMyID
 3231 163c 0346     		mov	r3, r0
 3232 163e 07F13802 		add	r2, r7, #56
 3233 1642 02F10A02 		add	r2, r2, #10
 3234 1646 1046     		mov	r0, r2
 3235 1648 1946     		mov	r1, r3
 3236 164a FFF7FEFF 		bl	packetfunctions_sameAddress
 3237 164e 0346     		mov	r3, r0
1489:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 else if( ! packetfunctions_sameAddress(&ieee802514_header.dest,idmanager_getMyID(ADDR_16B)) &
 3238              		.loc 1 1489 0 discriminator 1
 3239 1650 002B     		cmp	r3, #0
 3240 1652 1AD0     		beq	.L156
1491:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1492:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     // La limpieza del paquete y los datos recibidos será realizada en el metodo activity_cs
1493:openstack/02a-MAClow/IEEE802154Ecsl.c ****     		 radiotimer_schedule(rztime + TsSlotDuration);
 3241              		.loc 1 1493 0
 3242 1654 FB89     		ldrh	r3, [r7, #14]
 3243 1656 03F5F673 		add	r3, r3, #492
 3244 165a 1846     		mov	r0, r3
 3245 165c FFF7FEFF 		bl	radiotimer_schedule
1494:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1495:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     // Descartamos el paquete una vez recibido y tratado.
1496:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1497:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     openqueue_freePacketBuffer(ieee154e_vars.wakeupReceived);
 3246              		.loc 1 1497 0
 3247 1660 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3248 1664 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3249 1668 1B6C     		ldr	r3, [r3, #64]
 3250 166a 1846     		mov	r0, r3
 3251 166c FFF7FEFF 		bl	openqueue_freePacketBuffer
1498:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1499:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     // clear local variable
1500:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     ieee154e_vars.wakeupReceived = NULL;
 3252              		.loc 1 1500 0
 3253 1670 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3254 1674 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3255 1678 4FF00002 		mov	r2, #0
 3256 167c 1A64     		str	r2, [r3, #64]
 3257 167e 15E0     		b	.L151
 3258              	.L164:
1437:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.wakeupReceived->l1_crc==FALSE) { break; }
 3259              		.loc 1 1437 0
 3260 1680 00BF     		nop
 3261 1682 02E0     		b	.L156
 3262              	.L165:
1443:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee802514_header.valid==FALSE) { break; }
 3263              		.loc 1 1443 0
 3264 1684 00BF     		nop
 3265 1686 00E0     		b	.L156
 3266              	.L166:
1501:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1502:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     return;
1503:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 }
1504:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1505:openstack/02a-MAClow/IEEE802154Ecsl.c ****       else {
1506:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	  break; // cualquier otro tipo de trama recibida en este punto de la FSM es descartada.
 3267              		.loc 1 1506 0
 3268 1688 00BF     		nop
 3269              	.L156:
1507:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1508:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1509:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } while(0);
1510:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1511:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // En cualquier otro caso, descartamos el paquete e iniciamos de nuevo el proceso de channel sam
1512:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1513:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openqueue_freePacketBuffer(ieee154e_vars.wakeupReceived);
 3270              		.loc 1 1513 0
 3271 168a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3272 168e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3273 1692 1B6C     		ldr	r3, [r3, #64]
 3274 1694 1846     		mov	r0, r3
 3275 1696 FFF7FEFF 		bl	openqueue_freePacketBuffer
1514:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1515:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clear local variable
1516:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.wakeupReceived = NULL;
 3276              		.loc 1 1516 0
 3277 169a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3278 169e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3279 16a2 4FF00002 		mov	r2, #0
 3280 16a6 1A64     		str	r2, [r3, #64]
1517:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1518:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1519:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 3281              		.loc 1 1519 0
 3282 16a8 FFF7FEFF 		bl	endOps
 3283              	.L151:
1520:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3284              		.loc 1 1520 0
 3285 16ac 07F17C07 		add	r7, r7, #124
 3286 16b0 BD46     		mov	sp, r7
 3287 16b2 90BD     		pop	{r4, r7, pc}
 3288              		.cfi_endproc
 3289              	.LFE37:
 3291              		.align	2
 3292              		.global	activity_csl_wakeup_rie4
 3293              		.thumb
 3294              		.thumb_func
 3296              	activity_csl_wakeup_rie4:
 3297              	.LFB38:
1521:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1522:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1523:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1524:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling error [wake-up rie4].
1525:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1526:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by rztime+TsSlotDuration expiring, i.e. timer fires while state = S_CSLRXWAKEUP
1527:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The behaviour is to free mem used and restart CSL sampling.
1528:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1529:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_rie4() {
 3298              		.loc 1 1529 0
 3299              		.cfi_startproc
 3300              		@ args = 0, pretend = 0, frame = 0
 3301              		@ frame_needed = 1, uses_anonymous_args = 0
 3302 16b4 80B5     		push	{r7, lr}
 3303              	.LCFI89:
 3304              		.cfi_def_cfa_offset 8
 3305              		.cfi_offset 7, -8
 3306              		.cfi_offset 14, -4
 3307 16b6 00AF     		add	r7, sp, #0
 3308              	.LCFI90:
 3309              		.cfi_def_cfa_register 7
1530:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1531:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 3310              		.loc 1 1531 0
 3311 16b8 FFF7FEFF 		bl	endOps
1532:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3312              		.loc 1 1532 0
 3313 16bc 80BD     		pop	{r7, pc}
 3314              		.cfi_endproc
 3315              	.LFE38:
 3317 16be 00BF     		.align	2
 3318              		.global	activity_csl_data_ri2
 3319              		.thumb
 3320              		.thumb_func
 3322              	activity_csl_data_ri2:
 3323              	.LFB39:
1533:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1534:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1535:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1536:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri2].
1537:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1538:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1539:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to prepare the radio for receiving packets.
1540:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1541:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1542:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri2() {
 3324              		.loc 1 1542 0
 3325              		.cfi_startproc
 3326              		@ args = 0, pretend = 0, frame = 0
 3327              		@ frame_needed = 1, uses_anonymous_args = 0
 3328 16c0 80B5     		push	{r7, lr}
 3329              	.LCFI91:
 3330              		.cfi_def_cfa_offset 8
 3331              		.cfi_offset 7, -8
 3332              		.cfi_offset 14, -4
 3333 16c2 00AF     		add	r7, sp, #0
 3334              	.LCFI92:
 3335              		.cfi_def_cfa_register 7
1543:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1544:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXDATAPREPARE);
 3336              		.loc 1 1544 0
 3337 16c4 4FF03200 		mov	r0, #50
 3338 16c8 FFF7FEFF 		bl	changeState
1545:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1546:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // We use always the same frequency so it is not necessary to change it on radio.
1547:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Enable the radio in Rx mode. The radio does not actively listen yet.
1548:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rxEnable();
 3339              		.loc 1 1548 0
 3340 16cc FFF7FEFF 		bl	radio_rxEnable
1549:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnInit=radio_getTimerValue();
 3341              		.loc 1 1549 0
 3342 16d0 FFF7FEFF 		bl	radio_getTimerValue
 3343 16d4 0246     		mov	r2, r0
 3344 16d6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3345 16da C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3346 16de 1A63     		str	r2, [r3, #48]
1550:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnThisSlot=TRUE;
 3347              		.loc 1 1550 0
 3348 16e0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3349 16e4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3350 16e8 4FF00102 		mov	r2, #1
 3351 16ec 83F83820 		strb	r2, [r3, #56]
1551:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1552:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt2
1553:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt2);
 3352              		.loc 1 1553 0
 3353 16f0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3354 16f4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3355 16f8 5B6A     		ldr	r3, [r3, #36]
 3356 16fa 03F15803 		add	r3, r3, #88
 3357 16fe 1846     		mov	r0, r3
 3358 1700 FFF7FEFF 		bl	radiotimer_schedule
1554:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1555:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1556:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // If this action is not performed before rt2 has expired, we need to manage the error in activi
1557:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // prepare has exceeded the maximum allowed time (duration_rt2).
1558:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXDATAREADY);
 3359              		.loc 1 1558 0
 3360 1704 4FF03300 		mov	r0, #51
 3361 1708 FFF7FEFF 		bl	changeState
1559:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3362              		.loc 1 1559 0
 3363 170c 80BD     		pop	{r7, pc}
 3364              		.cfi_endproc
 3365              	.LFE39:
 3367 170e 00BF     		.align	2
 3368              		.global	activity_csl_data_rie1
 3369              		.thumb
 3370              		.thumb_func
 3372              	activity_csl_data_rie1:
 3373              	.LFB40:
1560:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1561:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1562:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1563:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling error [data_rie1].
1564:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1565:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #rt2 expiring, i.e. timer fires while state = S_CSLRXDATAPREPARE. This is re
1566:openstack/02a-MAClow/IEEE802154Ecsl.c ****   did not have enough time to execute. Chances are to set maxRxDataPrepare too small. The implement
1567:openstack/02a-MAClow/IEEE802154Ecsl.c ****   next CSL sample.
1568:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1569:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_rie1() {  // Activity for error event [rie1] on CSL RX Sampling.
 3374              		.loc 1 1569 0
 3375              		.cfi_startproc
 3376              		@ args = 0, pretend = 0, frame = 0
 3377              		@ frame_needed = 1, uses_anonymous_args = 0
 3378 1710 80B5     		push	{r7, lr}
 3379              	.LCFI93:
 3380              		.cfi_def_cfa_offset 8
 3381              		.cfi_offset 7, -8
 3382              		.cfi_offset 14, -4
 3383 1712 00AF     		add	r7, sp, #0
 3384              	.LCFI94:
 3385              		.cfi_def_cfa_register 7
1570:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
1571:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXDATAPREPARE_OVERFLOWS,
1572:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state,
 3386              		.loc 1 1572 0
 3387 1714 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3388 1718 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3389 171c 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1571:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXDATAPREPARE_OVERFLOWS,
 3390              		.loc 1 1571 0
 3391 171e 1A46     		mov	r2, r3
1573:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_dbg.num_cslSamples);
 3392              		.loc 1 1573 0
 3393 1720 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 3394 1724 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 3395 1728 1B69     		ldr	r3, [r3, #16]
1571:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXDATAPREPARE_OVERFLOWS,
 3396              		.loc 1 1571 0
 3397 172a 9BB2     		uxth	r3, r3
 3398 172c 4FF00900 		mov	r0, #9
 3399 1730 4FF02401 		mov	r1, #36
 3400 1734 FFF7FEFF 		bl	openserial_printError
1574:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1575:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 3401              		.loc 1 1575 0
 3402 1738 FFF7FEFF 		bl	endOps
1576:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3403              		.loc 1 1576 0
 3404 173c 80BD     		pop	{r7, pc}
 3405              		.cfi_endproc
 3406              	.LFE40:
 3408 173e 00BF     		.align	2
 3409              		.global	activity_csl_data_ri3
 3410              		.thumb
 3411              		.thumb_func
 3413              	activity_csl_data_ri3:
 3414              	.LFB41:
1577:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1578:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1579:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1580:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri3].
1581:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1582:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1583:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The radio is configured and this interrupt gives it the "go" signal to start listening.
1584:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1585:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri3() { // Activity for stage [data ri3] on CSL RX Sampling.
 3415              		.loc 1 1585 0
 3416              		.cfi_startproc
 3417              		@ args = 0, pretend = 0, frame = 0
 3418              		@ frame_needed = 1, uses_anonymous_args = 0
 3419 1740 80B5     		push	{r7, lr}
 3420              	.LCFI95:
 3421              		.cfi_def_cfa_offset 8
 3422              		.cfi_offset 7, -8
 3423              		.cfi_offset 14, -4
 3424 1742 00AF     		add	r7, sp, #0
 3425              	.LCFI96:
 3426              		.cfi_def_cfa_register 7
1586:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1587:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXDATALISTEN);
 3427              		.loc 1 1587 0
 3428 1744 4FF03400 		mov	r0, #52
 3429 1748 FFF7FEFF 		bl	changeState
1588:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1589:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // give the 'go' to receive
1590:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rxNow();
 3430              		.loc 1 1590 0
 3431 174c FFF7FEFF 		bl	radio_rxNow
1591:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1592:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt3
1593:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt3);
 3432              		.loc 1 1593 0
 3433 1750 40F24110 		movw	r0, #321
 3434 1754 FFF7FEFF 		bl	radiotimer_schedule
1594:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3435              		.loc 1 1594 0
 3436 1758 80BD     		pop	{r7, pc}
 3437              		.cfi_endproc
 3438              	.LFE41:
 3440 175a 00BF     		.align	2
 3441              		.global	activity_csl_data_rie2
 3442              		.thumb
 3443              		.thumb_func
 3445              	activity_csl_data_rie2:
 3446              	.LFB42:
1595:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1596:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1597:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1598:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling error [data rie2].
1599:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1600:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #rt3 expiring, i.e. timer fires while state = S_CSLRXDATALISTEN. If no packe
1601:openstack/02a-MAClow/IEEE802154Ecsl.c ****   none will be received ever and it is safe to switch of the radio. This timer is set such that the
1602:openstack/02a-MAClow/IEEE802154Ecsl.c ****   duration (#TsLongGT).
1603:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1604:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_rie2() { // Activity for error event [data rie2] on CSL RX Sampl
 3447              		.loc 1 1604 0
 3448              		.cfi_startproc
 3449              		@ args = 0, pretend = 0, frame = 0
 3450              		@ frame_needed = 1, uses_anonymous_args = 0
 3451 175c 80B5     		push	{r7, lr}
 3452              	.LCFI97:
 3453              		.cfi_def_cfa_offset 8
 3454              		.cfi_offset 7, -8
 3455              		.cfi_offset 14, -4
 3456 175e 00AF     		add	r7, sp, #0
 3457              	.LCFI98:
 3458              		.cfi_def_cfa_register 7
1605:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1606:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 3459              		.loc 1 1606 0
 3460 1760 FFF7FEFF 		bl	endOps
1607:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3461              		.loc 1 1607 0
 3462 1764 80BD     		pop	{r7, pc}
 3463              		.cfi_endproc
 3464              	.LFE42:
 3466 1766 00BF     		.align	2
 3467              		.global	activity_csl_data_ri4
 3468              		.thumb
 3469              		.thumb_func
 3471              	activity_csl_data_ri4:
 3472              	.LFB43:
1608:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1609:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1610:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri4].
1611:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1612:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_startOfFrame" function when a start of frame ev
1613:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to capture the time, cancel #rt3 and arm #rt4 (max time to receive all the p
1614:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1615:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri4(PORT_RADIOTIMER_WIDTH capturedTime) {  // Activity for stage
 3473              		.loc 1 1615 0
 3474              		.cfi_startproc
 3475              		@ args = 0, pretend = 0, frame = 8
 3476              		@ frame_needed = 1, uses_anonymous_args = 0
 3477 1768 80B5     		push	{r7, lr}
 3478              	.LCFI99:
 3479              		.cfi_def_cfa_offset 8
 3480              		.cfi_offset 7, -8
 3481              		.cfi_offset 14, -4
 3482 176a 82B0     		sub	sp, sp, #8
 3483              	.LCFI100:
 3484              		.cfi_def_cfa_offset 16
 3485 176c 00AF     		add	r7, sp, #0
 3486              	.LCFI101:
 3487              		.cfi_def_cfa_register 7
 3488 176e 7860     		str	r0, [r7, #4]
1616:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1617:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1618:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXDATA);
 3489              		.loc 1 1618 0
 3490 1770 4FF03500 		mov	r0, #53
 3491 1774 FFF7FEFF 		bl	changeState
1619:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1620:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel rt3
1621:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 3492              		.loc 1 1621 0
 3493 1778 FFF7FEFF 		bl	radiotimer_cancel
1622:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1623:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
1624:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.lastCapturedTime = capturedTime;
 3494              		.loc 1 1624 0
 3495 177c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3496 1780 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3497 1784 7A68     		ldr	r2, [r7, #4]
 3498 1786 5A62     		str	r2, [r3, #36]
1625:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1626:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time to sync
1627:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.syncCapturedTime = capturedTime;
 3499              		.loc 1 1627 0
 3500 1788 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3501 178c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3502 1790 7A68     		ldr	r2, [r7, #4]
 3503 1792 9A62     		str	r2, [r3, #40]
1628:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1629:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt4);
 3504              		.loc 1 1629 0
 3505 1794 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3506 1798 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3507 179c 5B6A     		ldr	r3, [r3, #36]
 3508 179e 03F1A403 		add	r3, r3, #164
 3509 17a2 1846     		mov	r0, r3
 3510 17a4 FFF7FEFF 		bl	radiotimer_schedule
1630:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3511              		.loc 1 1630 0
 3512 17a8 07F10807 		add	r7, r7, #8
 3513 17ac BD46     		mov	sp, r7
 3514 17ae 80BD     		pop	{r7, pc}
 3515              		.cfi_endproc
 3516              	.LFE43:
 3518              		.align	2
 3519              		.global	activity_csl_data_rie3
 3520              		.thumb
 3521              		.thumb_func
 3523              	activity_csl_data_rie3:
 3524              	.LFB44:
1631:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1632:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1633:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1634:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling error [data rie3].
1635:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1636:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #rt4 expiring, i.e. timer fires while state = S_CSLRXDATA. This is an error 
1637:openstack/02a-MAClow/IEEE802154Ecsl.c ****   transmit the data packet. The implemented behaviour is to log the error and move on the next CSL 
1638:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1639:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_rie3() {
 3525              		.loc 1 1639 0
 3526              		.cfi_startproc
 3527              		@ args = 0, pretend = 0, frame = 0
 3528              		@ frame_needed = 1, uses_anonymous_args = 0
 3529 17b0 80B5     		push	{r7, lr}
 3530              	.LCFI102:
 3531              		.cfi_def_cfa_offset 8
 3532              		.cfi_offset 7, -8
 3533              		.cfi_offset 14, -4
 3534 17b2 00AF     		add	r7, sp, #0
 3535              	.LCFI103:
 3536              		.cfi_def_cfa_register 7
1640:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1641:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
1642:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
1643:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state,
 3537              		.loc 1 1643 0
 3538 17b4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3539 17b8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3540 17bc 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1642:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
 3541              		.loc 1 1642 0
 3542 17be 1A46     		mov	r2, r3
1644:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_dbg.num_cslSamples);
 3543              		.loc 1 1644 0
 3544 17c0 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 3545 17c4 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 3546 17c8 1B69     		ldr	r3, [r3, #16]
1642:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
 3547              		.loc 1 1642 0
 3548 17ca 9BB2     		uxth	r3, r3
 3549 17cc 4FF00900 		mov	r0, #9
 3550 17d0 4FF02601 		mov	r1, #38
 3551 17d4 FFF7FEFF 		bl	openserial_printError
1645:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1646:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1647:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 3552              		.loc 1 1647 0
 3553 17d8 FFF7FEFF 		bl	endOps
1648:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3554              		.loc 1 1648 0
 3555 17dc 80BD     		pop	{r7, pc}
 3556              		.cfi_endproc
 3557              	.LFE44:
 3559 17de 00BF     		.align	2
 3560              		.global	activity_csl_data_ri5
 3561              		.thumb
 3562              		.thumb_func
 3564              	activity_csl_data_ri5:
 3565              	.LFB45:
1649:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1650:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1651:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri5].
1652:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1653:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_endOfFrame" function when a end of frame event 
1654:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change state, cancel #rt4, validate data frame, and transmit ACK.
1655:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1656:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri5(PORT_RADIOTIMER_WIDTH capturedTime) {
 3566              		.loc 1 1656 0
 3567              		.cfi_startproc
 3568              		@ args = 0, pretend = 0, frame = 80
 3569              		@ frame_needed = 1, uses_anonymous_args = 0
 3570 17e0 B0B5     		push	{r4, r5, r7, lr}
 3571              	.LCFI104:
 3572              		.cfi_def_cfa_offset 16
 3573              		.cfi_offset 4, -16
 3574              		.cfi_offset 5, -12
 3575              		.cfi_offset 7, -8
 3576              		.cfi_offset 14, -4
 3577 17e2 96B0     		sub	sp, sp, #88
 3578              	.LCFI105:
 3579              		.cfi_def_cfa_offset 104
 3580 17e4 02AF     		add	r7, sp, #8
 3581              	.LCFI106:
 3582              		.cfi_def_cfa 7, 96
 3583 17e6 7860     		str	r0, [r7, #4]
1657:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802154_header_iht ieee802514_header;
1658:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint16_t lenIE=0;
 3584              		.loc 1 1658 0
 3585 17e8 4FF00003 		mov	r3, #0
 3586 17ec FB81     		strh	r3, [r7, #14]	@ movhi
1659:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1660:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1661:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXACKOFFSET);
 3587              		.loc 1 1661 0
 3588 17ee 4FF03600 		mov	r0, #54
 3589 17f2 FFF7FEFF 		bl	changeState
1662:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1663:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel rt4
1664:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 3590              		.loc 1 1664 0
 3591 17f6 FFF7FEFF 		bl	radiotimer_cancel
1665:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1666:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // turn off the radio
1667:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rfOff();
 3592              		.loc 1 1667 0
 3593 17fa FFF7FEFF 		bl	radio_rfOff
1668:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnTics+=radio_getTimerValue()-ieee154e_vars.radioOnInit;
 3594              		.loc 1 1668 0
 3595 17fe 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3596 1802 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3597 1806 5C6B     		ldr	r4, [r3, #52]
 3598 1808 FFF7FEFF 		bl	radio_getTimerValue
 3599 180c 0246     		mov	r2, r0
 3600 180e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3601 1812 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3602 1816 1B6B     		ldr	r3, [r3, #48]
 3603 1818 D31A     		subs	r3, r2, r3
 3604 181a E218     		adds	r2, r4, r3
 3605 181c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3606 1820 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3607 1824 5A63     		str	r2, [r3, #52]
1669:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // get a buffer to put the (received) data in
1670:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.dataReceived = openqueue_getFreePacketBuffer(COMPONENT_IEEE802154E);
 3608              		.loc 1 1670 0
 3609 1826 4FF00900 		mov	r0, #9
 3610 182a FFF7FEFF 		bl	openqueue_getFreePacketBuffer
 3611 182e 0246     		mov	r2, r0
 3612 1830 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3613 1834 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3614 1838 9A61     		str	r2, [r3, #24]
1671:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.dataReceived==NULL) {
 3615              		.loc 1 1671 0
 3616 183a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3617 183e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3618 1842 9B69     		ldr	r3, [r3, #24]
 3619 1844 002B     		cmp	r3, #0
 3620 1846 0CD1     		bne	.L175
1672:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // log the error
1673:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openserial_printError(COMPONENT_IEEE802154E,ERR_NO_FREE_PACKET_BUFFER,
 3621              		.loc 1 1673 0
 3622 1848 4FF00900 		mov	r0, #9
 3623 184c 4FF02C01 		mov	r1, #44
 3624 1850 4FF00002 		mov	r2, #0
 3625 1854 4FF00003 		mov	r3, #0
 3626 1858 FFF7FEFF 		bl	openserial_printError
1674:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)0,
1675:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)0);
1676:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // abort
1677:openstack/02a-MAClow/IEEE802154Ecsl.c ****       endOps();
 3627              		.loc 1 1677 0
 3628 185c FFF7FEFF 		bl	endOps
 3629 1860 3FE1     		b	.L174
 3630              	.L175:
1678:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return;
1679:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
1680:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1681:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // declare ownership over that packet
1682:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.dataReceived->creator = COMPONENT_IEEE802154E;
 3631              		.loc 1 1682 0
 3632 1862 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3633 1866 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3634 186a 9B69     		ldr	r3, [r3, #24]
 3635 186c 4FF00902 		mov	r2, #9
 3636 1870 1A70     		strb	r2, [r3, #0]
1683:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.dataReceived->owner   = COMPONENT_IEEE802154E;
 3637              		.loc 1 1683 0
 3638 1872 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3639 1876 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3640 187a 9B69     		ldr	r3, [r3, #24]
 3641 187c 4FF00902 		mov	r2, #9
 3642 1880 5A70     		strb	r2, [r3, #1]
1684:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1685:openstack/02a-MAClow/IEEE802154Ecsl.c ****    /*
1686:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The do-while loop that follows is a little parsing trick.
1687:openstack/02a-MAClow/IEEE802154Ecsl.c ****    Because it contains a while(0) condition, it gets executed only once.
1688:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The behavior is:
1689:openstack/02a-MAClow/IEEE802154Ecsl.c ****    - if a break occurs inside the do{} body, the error code below the loop
1690:openstack/02a-MAClow/IEEE802154Ecsl.c ****      gets executed. This indicates something is wrong with the packet being
1691:openstack/02a-MAClow/IEEE802154Ecsl.c ****      parsed.
1692:openstack/02a-MAClow/IEEE802154Ecsl.c ****    - if a return occurs inside the do{} body, the error code below the loop
1693:openstack/02a-MAClow/IEEE802154Ecsl.c ****      does not get executed. This indicates the received packet is correct.
1694:openstack/02a-MAClow/IEEE802154Ecsl.c ****    */
1695:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1696:openstack/02a-MAClow/IEEE802154Ecsl.c ****    do { // this "loop" is only executed once
1697:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1698:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // retrieve the received data frame from the radio's Rx buffer
1699:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataReceived->payload = &(ieee154e_vars.dataReceived->packet[FIRST_FRAME_BYTE])
 3643              		.loc 1 1699 0
 3644 1882 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3645 1886 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3646 188a 9A69     		ldr	r2, [r3, #24]
 3647 188c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3648 1890 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3649 1894 9B69     		ldr	r3, [r3, #24]
 3650 1896 03F16C03 		add	r3, r3, #108
 3651 189a 5360     		str	r3, [r2, #4]
1700:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.dataReceived->payload,
 3652              		.loc 1 1700 0
 3653 189c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3654 18a0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3655 18a4 9B69     		ldr	r3, [r3, #24]
 3656 18a6 5968     		ldr	r1, [r3, #4]
1701:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.dataReceived->length,
 3657              		.loc 1 1701 0
 3658 18a8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3659 18ac C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3660 18b0 9B69     		ldr	r3, [r3, #24]
1700:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.dataReceived->payload,
 3661              		.loc 1 1700 0
 3662 18b2 03F10802 		add	r2, r3, #8
1702:openstack/02a-MAClow/IEEE802154Ecsl.c ****                              sizeof(ieee154e_vars.dataReceived->packet),
1703:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.dataReceived->l1_rssi,
 3663              		.loc 1 1703 0
 3664 18b6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3665 18ba C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3666 18be 9B69     		ldr	r3, [r3, #24]
1700:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.dataReceived->payload,
 3667              		.loc 1 1700 0
 3668 18c0 03F16804 		add	r4, r3, #104
1704:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.dataReceived->l1_lqi,
 3669              		.loc 1 1704 0
 3670 18c4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3671 18c8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3672 18cc 9B69     		ldr	r3, [r3, #24]
1700:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.dataReceived->payload,
 3673              		.loc 1 1700 0
 3674 18ce 03F16900 		add	r0, r3, #105
1705:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.dataReceived->l1_crc);
 3675              		.loc 1 1705 0
 3676 18d2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3677 18d6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3678 18da 9B69     		ldr	r3, [r3, #24]
1700:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.dataReceived->payload,
 3679              		.loc 1 1700 0
 3680 18dc 03F16A03 		add	r3, r3, #106
 3681 18e0 0090     		str	r0, [sp, #0]
 3682 18e2 0193     		str	r3, [sp, #4]
 3683 18e4 0846     		mov	r0, r1
 3684 18e6 1146     		mov	r1, r2
 3685 18e8 4FF08202 		mov	r2, #130
 3686 18ec 2346     		mov	r3, r4
 3687 18ee FFF7FEFF 		bl	radio_getReceivedFrame
1706:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1707:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // break if wrong length
1708:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.dataReceived->length<LENGTH_CRC || ieee154e_vars.dataReceived->length>LENGT
 3688              		.loc 1 1708 0
 3689 18f2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3690 18f6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3691 18fa 9B69     		ldr	r3, [r3, #24]
 3692 18fc 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 3693 18fe 012B     		cmp	r3, #1
 3694 1900 07D9     		bls	.L177
 3695              		.loc 1 1708 0 is_stmt 0 discriminator 1
 3696 1902 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3697 1906 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3698 190a 9B69     		ldr	r3, [r3, #24]
 3699 190c 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 3700 190e 802B     		cmp	r3, #128
 3701 1910 0ED9     		bls	.L178
 3702              	.L177:
1709:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // jump to the error code below this do-while loop
1710:openstack/02a-MAClow/IEEE802154Ecsl.c ****         openserial_printError(COMPONENT_IEEE802154E,ERR_INVALIDPACKETFROMRADIO,
1711:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)2,
1712:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             ieee154e_vars.dataReceived->length);
 3703              		.loc 1 1712 0 is_stmt 1
 3704 1912 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3705 1916 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3706 191a 9B69     		ldr	r3, [r3, #24]
 3707 191c 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
1710:openstack/02a-MAClow/IEEE802154Ecsl.c ****         openserial_printError(COMPONENT_IEEE802154E,ERR_INVALIDPACKETFROMRADIO,
 3708              		.loc 1 1710 0
 3709 191e 4FF00900 		mov	r0, #9
 3710 1922 4FF03701 		mov	r1, #55
 3711 1926 4FF00202 		mov	r2, #2
 3712 192a FFF7FEFF 		bl	openserial_printError
1713:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 3713              		.loc 1 1713 0
 3714 192e C7E0     		b	.L179
 3715              	.L178:
1714:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1715:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1716:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // toss CRC (2 last bytes)
1717:openstack/02a-MAClow/IEEE802154Ecsl.c ****       packetfunctions_tossFooter(   ieee154e_vars.dataReceived, LENGTH_CRC);
 3716              		.loc 1 1717 0
 3717 1930 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3718 1934 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3719 1938 9B69     		ldr	r3, [r3, #24]
 3720 193a 1846     		mov	r0, r3
 3721 193c 4FF00201 		mov	r1, #2
 3722 1940 FFF7FEFF 		bl	packetfunctions_tossFooter
1718:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1719:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // if CRC doesn't check, stop
1720:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.dataReceived->l1_crc==FALSE) {
 3723              		.loc 1 1720 0
 3724 1944 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3725 1948 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3726 194c 9B69     		ldr	r3, [r3, #24]
 3727 194e 93F86A30 		ldrb	r3, [r3, #106]	@ zero_extendqisi2
 3728 1952 83F00103 		eor	r3, r3, #1
 3729 1956 DBB2     		uxtb	r3, r3
 3730 1958 002B     		cmp	r3, #0
 3731 195a 40F0AC80 		bne	.L187
 3732              	.L180:
1721:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // jump to the error code below this do-while loop
1722:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
1723:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1724:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1725:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // parse the IEEE802.15.4 header (RX DATA)
1726:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee802154_retrieveHeader(ieee154e_vars.dataReceived,&ieee802514_header);
 3733              		.loc 1 1726 0
 3734 195e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3735 1962 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3736 1966 9A69     		ldr	r2, [r3, #24]
 3737 1968 07F11003 		add	r3, r7, #16
 3738 196c 1046     		mov	r0, r2
 3739 196e 1946     		mov	r1, r3
 3740 1970 FFF7FEFF 		bl	ieee802154_retrieveHeader
1727:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1728:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // break if invalid IEEE802.15.4 header
1729:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee802514_header.valid==FALSE) {
 3741              		.loc 1 1729 0
 3742 1974 3B7C     		ldrb	r3, [r7, #16]	@ zero_extendqisi2
 3743 1976 83F00103 		eor	r3, r3, #1
 3744 197a DBB2     		uxtb	r3, r3
 3745 197c 002B     		cmp	r3, #0
 3746 197e 40F09C80 		bne	.L188
 3747              	.L181:
1730:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // break from the do-while loop and execute the clean-up code below
1731:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
1732:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1733:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1734:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // store header details in packet buffer
1735:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataReceived->l2_frameType      = ieee802514_header.frameType;
 3748              		.loc 1 1735 0
 3749 1982 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3750 1986 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3751 198a 9B69     		ldr	r3, [r3, #24]
 3752 198c BA7C     		ldrb	r2, [r7, #18]	@ zero_extendqisi2
 3753 198e 83F84920 		strb	r2, [r3, #73]
1736:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataReceived->l2_dsn            = ieee802514_header.dsn;
 3754              		.loc 1 1736 0
 3755 1992 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3756 1996 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3757 199a 9B69     		ldr	r3, [r3, #24]
 3758 199c 7A7E     		ldrb	r2, [r7, #25]	@ zero_extendqisi2
 3759 199e 83F84A20 		strb	r2, [r3, #74]
1737:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataReceived->l2_IEListPresent  = ieee802514_header.ieListPresent;
 3760              		.loc 1 1737 0
 3761 19a2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3762 19a6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3763 19aa 9B69     		ldr	r3, [r3, #24]
 3764 19ac FA7D     		ldrb	r2, [r7, #23]	@ zero_extendqisi2
 3765 19ae 83F86520 		strb	r2, [r3, #101]
1738:openstack/02a-MAClow/IEEE802154Ecsl.c ****       memcpy(&(ieee154e_vars.dataReceived->l2_nextORpreviousHop),&(ieee802514_header.src),sizeof(op
 3766              		.loc 1 1738 0
 3767 19b2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3768 19b6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3769 19ba 9B69     		ldr	r3, [r3, #24]
 3770 19bc 03F13803 		add	r3, r3, #56
 3771 19c0 1D46     		mov	r5, r3
 3772 19c2 07F13C04 		add	r4, r7, #60
 3773 19c6 0FCC     		ldmia	r4!, {r0, r1, r2, r3}
 3774 19c8 2860     		str	r0, [r5, #0]	@ unaligned
 3775 19ca 6960     		str	r1, [r5, #4]	@ unaligned
 3776 19cc AA60     		str	r2, [r5, #8]	@ unaligned
 3777 19ce EB60     		str	r3, [r5, #12]	@ unaligned
 3778 19d0 2378     		ldrb	r3, [r4, #0]
 3779 19d2 2B74     		strb	r3, [r5, #16]
1739:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1740:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // toss the IEEE802.15.4 header
1741:openstack/02a-MAClow/IEEE802154Ecsl.c ****       packetfunctions_tossHeader(ieee154e_vars.dataReceived,ieee802514_header.headerLength);
 3780              		.loc 1 1741 0
 3781 19d4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3782 19d8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3783 19dc 9A69     		ldr	r2, [r3, #24]
 3784 19de 7B7C     		ldrb	r3, [r7, #17]	@ zero_extendqisi2
 3785 19e0 1046     		mov	r0, r2
 3786 19e2 1946     		mov	r1, r3
 3787 19e4 FFF7FEFF 		bl	packetfunctions_tossHeader
1742:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1743:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // handle IEs xv poipoi
1744:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset join priority
1745:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // retrieve IE in sixtop
1746:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if ((ieee802514_header.valid==TRUE &&
 3788              		.loc 1 1746 0
 3789 19e8 3B7C     		ldrb	r3, [r7, #16]	@ zero_extendqisi2
1747:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header.ieListPresent==TRUE &&
1748:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header.frameType==IEEE154_TYPE_BEACON && // if it is not a beacon and have ie,
1749:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header.panid,idmanager_getMyID(ADDR_PANID)) &&
 3790              		.loc 1 1749 0
 3791 19ea 002B     		cmp	r3, #0
 3792 19ec 22D0     		beq	.L183
1747:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header.ieListPresent==TRUE &&
 3793              		.loc 1 1747 0
 3794 19ee FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
1746:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if ((ieee802514_header.valid==TRUE &&
 3795              		.loc 1 1746 0
 3796 19f0 002B     		cmp	r3, #0
 3797 19f2 1FD0     		beq	.L183
1748:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header.frameType==IEEE154_TYPE_BEACON && // if it is not a beacon and have ie,
 3798              		.loc 1 1748 0
 3799 19f4 BB7C     		ldrb	r3, [r7, #18]	@ zero_extendqisi2
1747:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header.ieListPresent==TRUE &&
 3800              		.loc 1 1747 0
 3801 19f6 002B     		cmp	r3, #0
 3802 19f8 1CD1     		bne	.L183
 3803              		.loc 1 1749 0
 3804 19fa 4FF00400 		mov	r0, #4
 3805 19fe FFF7FEFF 		bl	idmanager_getMyID
 3806 1a02 0346     		mov	r3, r0
 3807 1a04 07F11002 		add	r2, r7, #16
 3808 1a08 02F10A02 		add	r2, r2, #10
 3809 1a0c 1046     		mov	r0, r2
 3810 1a0e 1946     		mov	r1, r3
 3811 1a10 FFF7FEFF 		bl	packetfunctions_sameAddress
 3812 1a14 0346     		mov	r3, r0
1748:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header.frameType==IEEE154_TYPE_BEACON && // if it is not a beacon and have ie,
 3813              		.loc 1 1748 0
 3814 1a16 002B     		cmp	r3, #0
 3815 1a18 0CD0     		beq	.L183
1750:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee154e_processIEs(ieee154e_vars.dataReceived,&lenIE))==FALSE) {
 3816              		.loc 1 1750 0
 3817 1a1a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3818 1a1e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3819 1a22 9A69     		ldr	r2, [r3, #24]
 3820 1a24 07F10E03 		add	r3, r7, #14
 3821 1a28 1046     		mov	r0, r2
 3822 1a2a 1946     		mov	r1, r3
 3823 1a2c FFF7FEFF 		bl	ieee154e_processIEs
 3824 1a30 0346     		mov	r3, r0
1749:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header.panid,idmanager_getMyID(ADDR_PANID)) &&
 3825              		.loc 1 1749 0
 3826 1a32 002B     		cmp	r3, #0
 3827              	.L183:
1751:openstack/02a-MAClow/IEEE802154Ecsl.c ****           //log  that the packet is not carrying IEs
1752:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1753:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1754:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // toss the IEs including Synch
1755:openstack/02a-MAClow/IEEE802154Ecsl.c ****       packetfunctions_tossHeader(ieee154e_vars.dataReceived,lenIE);
 3828              		.loc 1 1755 0
 3829 1a34 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3830 1a38 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3831 1a3c 9A69     		ldr	r2, [r3, #24]
 3832 1a3e FB89     		ldrh	r3, [r7, #14]
 3833 1a40 DBB2     		uxtb	r3, r3
 3834 1a42 1046     		mov	r0, r2
 3835 1a44 1946     		mov	r1, r3
 3836 1a46 FFF7FEFF 		bl	packetfunctions_tossHeader
1756:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1757:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // record the captured time
1758:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.lastCapturedTime = capturedTime;
 3837              		.loc 1 1758 0
 3838 1a4a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3839 1a4e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3840 1a52 7A68     		ldr	r2, [r7, #4]
 3841 1a54 5A62     		str	r2, [r3, #36]
1759:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1760:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // if I just received an invalid frame, stop
1761:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (isValidRxFrame(&ieee802514_header)==FALSE) {
 3842              		.loc 1 1761 0
 3843 1a56 07F11003 		add	r3, r7, #16
 3844 1a5a 1846     		mov	r0, r3
 3845 1a5c FFF7FEFF 		bl	isValidRxFrame
 3846 1a60 0346     		mov	r3, r0
 3847 1a62 83F00103 		eor	r3, r3, #1
 3848 1a66 DBB2     		uxtb	r3, r3
 3849 1a68 002B     		cmp	r3, #0
 3850 1a6a 28D1     		bne	.L189
 3851              	.L184:
1762:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // jump to the error code below this do-while loop
1763:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
1764:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1765:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1766:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // [CSL-TEST]: Force to not send ack packet
1767:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1768:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee802514_header.ackRequested = 0;
 3852              		.loc 1 1768 0
 3853 1a6c 4FF00003 		mov	r3, #0
 3854 1a70 7B75     		strb	r3, [r7, #21]
1769:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1770:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // [CSL-TEST]: end test code
1771:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1772:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // check if ack requested
1773:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee802514_header.ackRequested==1) {
 3855              		.loc 1 1773 0
 3856 1a72 7B7D     		ldrb	r3, [r7, #21]	@ zero_extendqisi2
 3857 1a74 002B     		cmp	r3, #0
 3858 1a76 0AD0     		beq	.L185
1774:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // arm rt5
1775:openstack/02a-MAClow/IEEE802154Ecsl.c ****          radiotimer_schedule(DURATION_rt5);
 3859              		.loc 1 1775 0
 3860 1a78 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3861 1a7c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3862 1a80 5B6A     		ldr	r3, [r3, #36]
 3863 1a82 03F17A03 		add	r3, r3, #122
 3864 1a86 1846     		mov	r0, r3
 3865 1a88 FFF7FEFF 		bl	radiotimer_schedule
 3866 1a8c 29E0     		b	.L174
 3867              	.L185:
1776:openstack/02a-MAClow/IEEE802154Ecsl.c ****       } else {
1777:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // [CSL-TEST]: comment synchronization
1778:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // synchronize to the received packet if I'm not a DAGroot and this is my preferred parent
1779:openstack/02a-MAClow/IEEE802154Ecsl.c ****          //if (idmanager_getIsDAGroot()==FALSE && neighbors_isPreferredParent(&(ieee154e_vars.dataR
1780:openstack/02a-MAClow/IEEE802154Ecsl.c ****          //   synchronizePacket(ieee154e_vars.syncCapturedTime);
1781:openstack/02a-MAClow/IEEE802154Ecsl.c ****          //}
1782:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // [CSL-TEST]: end test code
1783:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1784:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 // indicate reception to upper layer (no ACK asked)
1785:openstack/02a-MAClow/IEEE802154Ecsl.c ****          notif_receive(ieee154e_vars.dataReceived, 1);
 3868              		.loc 1 1785 0
 3869 1a8e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3870 1a92 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3871 1a96 9B69     		ldr	r3, [r3, #24]
 3872 1a98 1846     		mov	r0, r3
 3873 1a9a 4FF00101 		mov	r1, #1
 3874 1a9e FFF7FEFF 		bl	notif_receive
1786:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // reset local variable
1787:openstack/02a-MAClow/IEEE802154Ecsl.c ****          ieee154e_vars.dataReceived = NULL;
 3875              		.loc 1 1787 0
 3876 1aa2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3877 1aa6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3878 1aaa 4FF00002 		mov	r2, #0
 3879 1aae 9A61     		str	r2, [r3, #24]
1788:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // abort
1789:openstack/02a-MAClow/IEEE802154Ecsl.c ****          endOps();
 3880              		.loc 1 1789 0
 3881 1ab0 FFF7FEFF 		bl	endOps
 3882 1ab4 15E0     		b	.L174
 3883              	.L187:
1722:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 3884              		.loc 1 1722 0
 3885 1ab6 00BF     		nop
 3886 1ab8 02E0     		b	.L179
 3887              	.L188:
1731:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 3888              		.loc 1 1731 0
 3889 1aba 00BF     		nop
 3890 1abc 00E0     		b	.L179
 3891              	.L189:
1763:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 3892              		.loc 1 1763 0
 3893 1abe 00BF     		nop
 3894              	.L179:
1790:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1791:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1792:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // everything went well, return here not to execute the error code below
1793:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return;
1794:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1795:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } while(0);
1796:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1797:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // free the (invalid) received data so RAM memory can be recycled
1798:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openqueue_freePacketBuffer(ieee154e_vars.dataReceived);
 3895              		.loc 1 1798 0
 3896 1ac0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3897 1ac4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3898 1ac8 9B69     		ldr	r3, [r3, #24]
 3899 1aca 1846     		mov	r0, r3
 3900 1acc FFF7FEFF 		bl	openqueue_freePacketBuffer
1799:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1800:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clear local variable
1801:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.dataReceived = NULL;
 3901              		.loc 1 1801 0
 3902 1ad0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3903 1ad4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3904 1ad8 4FF00002 		mov	r2, #0
 3905 1adc 9A61     		str	r2, [r3, #24]
1802:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1803:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1804:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 3906              		.loc 1 1804 0
 3907 1ade FFF7FEFF 		bl	endOps
 3908              	.L174:
1805:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3909              		.loc 1 1805 0
 3910 1ae2 07F15007 		add	r7, r7, #80
 3911 1ae6 BD46     		mov	sp, r7
 3912 1ae8 B0BD     		pop	{r4, r5, r7, pc}
 3913              		.cfi_endproc
 3914              	.LFE45:
 3916 1aea 00BF     		.align	2
 3917              		.global	activity_csl_data_ri6
 3918              		.thumb
 3919              		.thumb_func
 3921              	activity_csl_data_ri6:
 3922              	.LFB46:
1806:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1807:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1808:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri6].
1809:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1810:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1811:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The functionality is to prepare the radio for ACK sending.
1812:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1813:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri6() {
 3923              		.loc 1 1813 0
 3924              		.cfi_startproc
 3925              		@ args = 0, pretend = 0, frame = 8
 3926              		@ frame_needed = 1, uses_anonymous_args = 0
 3927 1aec 90B5     		push	{r4, r7, lr}
 3928              	.LCFI107:
 3929              		.cfi_def_cfa_offset 12
 3930              		.cfi_offset 4, -12
 3931              		.cfi_offset 7, -8
 3932              		.cfi_offset 14, -4
 3933 1aee 87B0     		sub	sp, sp, #28
 3934              	.LCFI108:
 3935              		.cfi_def_cfa_offset 40
 3936 1af0 04AF     		add	r7, sp, #16
 3937              	.LCFI109:
 3938              		.cfi_def_cfa 7, 24
1814:openstack/02a-MAClow/IEEE802154Ecsl.c ****    PORT_SIGNED_INT_WIDTH timeCorrection;
1815:openstack/02a-MAClow/IEEE802154Ecsl.c ****    header_IE_ht header_desc;
1816:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1817:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1818:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXACKPREPARE);
 3939              		.loc 1 1818 0
 3940 1af2 4FF03700 		mov	r0, #55
 3941 1af6 FFF7FEFF 		bl	changeState
1819:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1820:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // get a buffer to put the ack to send in
1821:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend = openqueue_getFreePacketBuffer(COMPONENT_IEEE802154E);
 3942              		.loc 1 1821 0
 3943 1afa 4FF00900 		mov	r0, #9
 3944 1afe FFF7FEFF 		bl	openqueue_getFreePacketBuffer
 3945 1b02 0246     		mov	r2, r0
 3946 1b04 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3947 1b08 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3948 1b0c DA61     		str	r2, [r3, #28]
1822:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.ackToSend==NULL) {
 3949              		.loc 1 1822 0
 3950 1b0e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3951 1b12 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3952 1b16 DB69     		ldr	r3, [r3, #28]
 3953 1b18 002B     		cmp	r3, #0
 3954 1b1a 1DD1     		bne	.L191
1823:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // log the error
1824:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openserial_printError(COMPONENT_IEEE802154E,ERR_NO_FREE_PACKET_BUFFER, (errorparameter_t)0, (
 3955              		.loc 1 1824 0
 3956 1b1c 4FF00900 		mov	r0, #9
 3957 1b20 4FF02C01 		mov	r1, #44
 3958 1b24 4FF00002 		mov	r2, #0
 3959 1b28 4FF00003 		mov	r3, #0
 3960 1b2c FFF7FEFF 		bl	openserial_printError
1825:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // indicate we received a packet anyway (we don't want to loose any)
1826:openstack/02a-MAClow/IEEE802154Ecsl.c ****       notif_receive(ieee154e_vars.dataReceived,0);
 3961              		.loc 1 1826 0
 3962 1b30 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3963 1b34 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3964 1b38 9B69     		ldr	r3, [r3, #24]
 3965 1b3a 1846     		mov	r0, r3
 3966 1b3c 4FF00001 		mov	r1, #0
 3967 1b40 FFF7FEFF 		bl	notif_receive
1827:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // free local variable
1828:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataReceived = NULL;
 3968              		.loc 1 1828 0
 3969 1b44 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3970 1b48 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3971 1b4c 4FF00002 		mov	r2, #0
 3972 1b50 9A61     		str	r2, [r3, #24]
1829:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // abort
1830:openstack/02a-MAClow/IEEE802154Ecsl.c ****       endOps();
 3973              		.loc 1 1830 0
 3974 1b52 FFF7FEFF 		bl	endOps
 3975 1b56 D3E0     		b	.L190
 3976              	.L191:
1831:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return;
1832:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
1833:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1834:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // declare ownership over that packet
1835:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend->creator = COMPONENT_IEEE802154E;
 3977              		.loc 1 1835 0
 3978 1b58 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3979 1b5c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3980 1b60 DB69     		ldr	r3, [r3, #28]
 3981 1b62 4FF00902 		mov	r2, #9
 3982 1b66 1A70     		strb	r2, [r3, #0]
1836:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend->owner   = COMPONENT_IEEE802154E;
 3983              		.loc 1 1836 0
 3984 1b68 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3985 1b6c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3986 1b70 DB69     		ldr	r3, [r3, #28]
 3987 1b72 4FF00902 		mov	r2, #9
 3988 1b76 5A70     		strb	r2, [r3, #1]
1837:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1838:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // calculate the time timeCorrection (this is the time when the packet arrive w.r.t the time it 
1839:openstack/02a-MAClow/IEEE802154Ecsl.c ****    timeCorrection = (PORT_SIGNED_INT_WIDTH)((PORT_SIGNED_INT_WIDTH)ieee154e_vars.syncCapturedTime-(
 3989              		.loc 1 1839 0
 3990 1b78 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3991 1b7c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3992 1b80 9B6A     		ldr	r3, [r3, #40]
 3993 1b82 A3F18303 		sub	r3, r3, #131
 3994 1b86 7B60     		str	r3, [r7, #4]
1840:openstack/02a-MAClow/IEEE802154Ecsl.c ****     
1841:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // add the payload to the ACK (i.e. the timeCorrection)
1842:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packetfunctions_reserveHeaderSize(ieee154e_vars.ackToSend,sizeof(timecorrection_IE_ht));
 3995              		.loc 1 1842 0
 3996 1b88 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3997 1b8c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3998 1b90 DB69     		ldr	r3, [r3, #28]
 3999 1b92 1846     		mov	r0, r3
 4000 1b94 4FF00201 		mov	r1, #2
 4001 1b98 FFF7FEFF 		bl	packetfunctions_reserveHeaderSize
1843:openstack/02a-MAClow/IEEE802154Ecsl.c ****    timeCorrection  = -timeCorrection;
 4002              		.loc 1 1843 0
 4003 1b9c 7B68     		ldr	r3, [r7, #4]
 4004 1b9e C3F10003 		rsb	r3, r3, #0
 4005 1ba2 7B60     		str	r3, [r7, #4]
1844:openstack/02a-MAClow/IEEE802154Ecsl.c ****    timeCorrection *= US_PER_TICK;
 4006              		.loc 1 1844 0
 4007 1ba4 7A68     		ldr	r2, [r7, #4]
 4008 1ba6 1346     		mov	r3, r2
 4009 1ba8 4FEA0313 		lsl	r3, r3, #4
 4010 1bac 9B1A     		subs	r3, r3, r2
 4011 1bae 4FEA4303 		lsl	r3, r3, #1
 4012 1bb2 7B60     		str	r3, [r7, #4]
1845:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend->payload[0] = (uint8_t)((((uint16_t)timeCorrection)   ) & 0xff);
 4013              		.loc 1 1845 0
 4014 1bb4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4015 1bb8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4016 1bbc DB69     		ldr	r3, [r3, #28]
 4017 1bbe 5B68     		ldr	r3, [r3, #4]
 4018 1bc0 7A68     		ldr	r2, [r7, #4]
 4019 1bc2 D2B2     		uxtb	r2, r2
 4020 1bc4 1A70     		strb	r2, [r3, #0]
1846:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend->payload[1] = (uint8_t)((((uint16_t)timeCorrection)>>8) & 0xff);
 4021              		.loc 1 1846 0
 4022 1bc6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4023 1bca C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4024 1bce DB69     		ldr	r3, [r3, #28]
 4025 1bd0 5B68     		ldr	r3, [r3, #4]
 4026 1bd2 03F10103 		add	r3, r3, #1
 4027 1bd6 7A68     		ldr	r2, [r7, #4]
 4028 1bd8 92B2     		uxth	r2, r2
 4029 1bda 4FEA1222 		lsr	r2, r2, #8
 4030 1bde 92B2     		uxth	r2, r2
 4031 1be0 D2B2     		uxtb	r2, r2
 4032 1be2 1A70     		strb	r2, [r3, #0]
1847:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1848:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // add header IE header -- xv poipoi -- pkt is filled in reverse order..
1849:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packetfunctions_reserveHeaderSize(ieee154e_vars.ackToSend,sizeof(header_IE_ht));
 4033              		.loc 1 1849 0
 4034 1be4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4035 1be8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4036 1bec DB69     		ldr	r3, [r3, #28]
 4037 1bee 1846     		mov	r0, r3
 4038 1bf0 4FF00201 		mov	r1, #2
 4039 1bf4 FFF7FEFF 		bl	packetfunctions_reserveHeaderSize
1850:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //create the header for ack IE
1851:openstack/02a-MAClow/IEEE802154Ecsl.c ****    header_desc.length_elementid_type=(sizeof(timecorrection_IE_ht)<< IEEE802154E_DESC_LEN_HEADER_IE
 4040              		.loc 1 1851 0
 4041 1bf8 40F23C43 		movw	r3, #1084
 4042 1bfc 3B80     		strh	r3, [r7, #0]	@ movhi
1852:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                      (IEEE802154E_ACK_NACK_TIMECORRECTION_ELEMENTID << IEEE802154E_
1853:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                      IEEE802154E_DESC_TYPE_SHORT; 
1854:openstack/02a-MAClow/IEEE802154Ecsl.c ****    memcpy(ieee154e_vars.ackToSend->payload,&header_desc,sizeof(header_IE_ht));
 4043              		.loc 1 1854 0
 4044 1bfe 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4045 1c02 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4046 1c06 DB69     		ldr	r3, [r3, #28]
 4047 1c08 5B68     		ldr	r3, [r3, #4]
 4048 1c0a 3A46     		mov	r2, r7
 4049 1c0c 1288     		ldrh	r2, [r2, #0]	@ unaligned
 4050 1c0e 1A80     		strh	r2, [r3, #0]	@ unaligned
1855:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1856:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // prepend the IEEE802.15.4 header to the ACK
1857:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend->l2_frameType = IEEE154_TYPE_ACK;
 4051              		.loc 1 1857 0
 4052 1c10 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4053 1c14 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4054 1c18 DB69     		ldr	r3, [r3, #28]
 4055 1c1a 4FF00202 		mov	r2, #2
 4056 1c1e 83F84920 		strb	r2, [r3, #73]
1858:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend->l2_dsn       = ieee154e_vars.dataReceived->l2_dsn;
 4057              		.loc 1 1858 0
 4058 1c22 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4059 1c26 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4060 1c2a DA69     		ldr	r2, [r3, #28]
 4061 1c2c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4062 1c30 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4063 1c34 9B69     		ldr	r3, [r3, #24]
 4064 1c36 93F84A30 		ldrb	r3, [r3, #74]	@ zero_extendqisi2
 4065 1c3a 82F84A30 		strb	r3, [r2, #74]
1859:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802154_prependHeader(ieee154e_vars.ackToSend,
 4066              		.loc 1 1859 0
 4067 1c3e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4068 1c42 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4069 1c46 D969     		ldr	r1, [r3, #28]
1860:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             ieee154e_vars.ackToSend->l2_frameType,
 4070              		.loc 1 1860 0
 4071 1c48 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4072 1c4c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4073 1c50 DB69     		ldr	r3, [r3, #28]
1859:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802154_prependHeader(ieee154e_vars.ackToSend,
 4074              		.loc 1 1859 0
 4075 1c52 93F84920 		ldrb	r2, [r3, #73]	@ zero_extendqisi2
1861:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             IEEE154_IELIST_YES,//ie in ack
1862:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             IEEE154_FRAMEVERSION,//enhanced ack
1863:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             IEEE154_SEC_NO_SECURITY,
1864:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             ieee154e_vars.dataReceived->l2_dsn,
 4076              		.loc 1 1864 0
 4077 1c56 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4078 1c5a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4079 1c5e 9B69     		ldr	r3, [r3, #24]
1859:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802154_prependHeader(ieee154e_vars.ackToSend,
 4080              		.loc 1 1859 0
 4081 1c60 93F84A00 		ldrb	r0, [r3, #74]	@ zero_extendqisi2
1865:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             &(ieee154e_vars.dataReceived->l2_nextORpreviousHop)
 4082              		.loc 1 1865 0
 4083 1c64 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4084 1c68 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4085 1c6c 9B69     		ldr	r3, [r3, #24]
1859:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802154_prependHeader(ieee154e_vars.ackToSend,
 4086              		.loc 1 1859 0
 4087 1c6e 03F13803 		add	r3, r3, #56
 4088 1c72 4FF00004 		mov	r4, #0
 4089 1c76 0094     		str	r4, [sp, #0]
 4090 1c78 0190     		str	r0, [sp, #4]
 4091 1c7a 0293     		str	r3, [sp, #8]
 4092 1c7c 0846     		mov	r0, r1
 4093 1c7e 1146     		mov	r1, r2
 4094 1c80 4FF00102 		mov	r2, #1
 4095 1c84 4FF00203 		mov	r3, #2
 4096 1c88 FFF7FEFF 		bl	ieee802154_prependHeader
1866:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             );
1867:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1868:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // space for 2-byte CRC
1869:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packetfunctions_reserveFooterSize(ieee154e_vars.ackToSend,2);
 4097              		.loc 1 1869 0
 4098 1c8c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4099 1c90 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4100 1c94 DB69     		ldr	r3, [r3, #28]
 4101 1c96 1846     		mov	r0, r3
 4102 1c98 4FF00201 		mov	r1, #2
 4103 1c9c FFF7FEFF 		bl	packetfunctions_reserveFooterSize
1870:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1871:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // load the packet in the radio's Tx buffer
1872:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_loadPacket(ieee154e_vars.ackToSend->payload,
 4104              		.loc 1 1872 0
 4105 1ca0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4106 1ca4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4107 1ca8 DB69     		ldr	r3, [r3, #28]
 4108 1caa 5A68     		ldr	r2, [r3, #4]
1873:openstack/02a-MAClow/IEEE802154Ecsl.c ****                     ieee154e_vars.ackToSend->length);
 4109              		.loc 1 1873 0
 4110 1cac 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4111 1cb0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4112 1cb4 DB69     		ldr	r3, [r3, #28]
1872:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_loadPacket(ieee154e_vars.ackToSend->payload,
 4113              		.loc 1 1872 0
 4114 1cb6 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4115 1cb8 1046     		mov	r0, r2
 4116 1cba 1946     		mov	r1, r3
 4117 1cbc FFF7FEFF 		bl	radio_loadPacket
1874:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1875:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // enable the radio in Tx mode. This does not send that packet.
1876:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_txEnable();
 4118              		.loc 1 1876 0
 4119 1cc0 FFF7FEFF 		bl	radio_txEnable
1877:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnInit=radio_getTimerValue();
 4120              		.loc 1 1877 0
 4121 1cc4 FFF7FEFF 		bl	radio_getTimerValue
 4122 1cc8 0246     		mov	r2, r0
 4123 1cca 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4124 1cce C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4125 1cd2 1A63     		str	r2, [r3, #48]
1878:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnThisSlot=TRUE;
 4126              		.loc 1 1878 0
 4127 1cd4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4128 1cd8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4129 1cdc 4FF00102 		mov	r2, #1
 4130 1ce0 83F83820 		strb	r2, [r3, #56]
1879:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt6
1880:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt6);
 4131              		.loc 1 1880 0
 4132 1ce4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4133 1ce8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4134 1cec 5B6A     		ldr	r3, [r3, #36]
 4135 1cee 03F19003 		add	r3, r3, #144
 4136 1cf2 1846     		mov	r0, r3
 4137 1cf4 FFF7FEFF 		bl	radiotimer_schedule
1881:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1882:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1883:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXACKREADY);
 4138              		.loc 1 1883 0
 4139 1cf8 4FF03800 		mov	r0, #56
 4140 1cfc FFF7FEFF 		bl	changeState
 4141              	.L190:
1884:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4142              		.loc 1 1884 0
 4143 1d00 07F10C07 		add	r7, r7, #12
 4144 1d04 BD46     		mov	sp, r7
 4145 1d06 90BD     		pop	{r4, r7, pc}
 4146              		.cfi_endproc
 4147              	.LFE46:
 4149              		.align	2
 4150              		.global	activity_csl_data_rie4
 4151              		.thumb
 4152              		.thumb_func
 4154              	activity_csl_data_rie4:
 4155              	.LFB47:
1885:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1886:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1887:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data rie4].
1888:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1889:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1890:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The functionality is to prepare the radio for ACK sending.
1891:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1892:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_rie4() {
 4156              		.loc 1 1892 0
 4157              		.cfi_startproc
 4158              		@ args = 0, pretend = 0, frame = 0
 4159              		@ frame_needed = 1, uses_anonymous_args = 0
 4160 1d08 80B5     		push	{r7, lr}
 4161              	.LCFI110:
 4162              		.cfi_def_cfa_offset 8
 4163              		.cfi_offset 7, -8
 4164              		.cfi_offset 14, -4
 4165 1d0a 00AF     		add	r7, sp, #0
 4166              	.LCFI111:
 4167              		.cfi_def_cfa_register 7
1893:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
1894:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXACKPREPARE_OVERFLOWS,
1895:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		                 (errorparameter_t)ieee154e_vars.state,
 4168              		.loc 1 1895 0
 4169 1d0c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4170 1d10 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4171 1d14 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1894:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXACKPREPARE_OVERFLOWS,
 4172              		.loc 1 1894 0
 4173 1d16 1A46     		mov	r2, r3
1896:openstack/02a-MAClow/IEEE802154Ecsl.c **** 						 (errorparameter_t)ieee154e_dbg.num_cslSamples);
 4174              		.loc 1 1896 0
 4175 1d18 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 4176 1d1c C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 4177 1d20 1B69     		ldr	r3, [r3, #16]
1894:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXACKPREPARE_OVERFLOWS,
 4178              		.loc 1 1894 0
 4179 1d22 9BB2     		uxth	r3, r3
 4180 1d24 4FF00900 		mov	r0, #9
 4181 1d28 4FF02501 		mov	r1, #37
 4182 1d2c FFF7FEFF 		bl	openserial_printError
1897:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1898:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1899:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 4183              		.loc 1 1899 0
 4184 1d30 FFF7FEFF 		bl	endOps
1900:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4185              		.loc 1 1900 0
 4186 1d34 80BD     		pop	{r7, pc}
 4187              		.cfi_endproc
 4188              	.LFE47:
 4190 1d36 00BF     		.align	2
 4191              		.global	activity_csl_data_ri7
 4192              		.thumb
 4193              		.thumb_func
 4195              	activity_csl_data_ri7:
 4196              	.LFB48:
1901:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1902:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1903:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri7].
1904:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1905:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1906:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The radio is configured and this interrupt gives it the "go" signal to start listening.
1907:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1908:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri7() {
 4197              		.loc 1 1908 0
 4198              		.cfi_startproc
 4199              		@ args = 0, pretend = 0, frame = 0
 4200              		@ frame_needed = 1, uses_anonymous_args = 0
 4201 1d38 80B5     		push	{r7, lr}
 4202              	.LCFI112:
 4203              		.cfi_def_cfa_offset 8
 4204              		.cfi_offset 7, -8
 4205              		.cfi_offset 14, -4
 4206 1d3a 00AF     		add	r7, sp, #0
 4207              	.LCFI113:
 4208              		.cfi_def_cfa_register 7
1909:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1910:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXACKDELAY);
 4209              		.loc 1 1910 0
 4210 1d3c 4FF03900 		mov	r0, #57
 4211 1d40 FFF7FEFF 		bl	changeState
1911:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1912:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt7
1913:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt7);
 4212              		.loc 1 1913 0
 4213 1d44 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4214 1d48 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4215 1d4c 5B6A     		ldr	r3, [r3, #36]
 4216 1d4e 03F1B103 		add	r3, r3, #177
 4217 1d52 1846     		mov	r0, r3
 4218 1d54 FFF7FEFF 		bl	radiotimer_schedule
1914:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1915:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // give the 'go' to transmit
1916:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_txNow(); 
 4219              		.loc 1 1916 0
 4220 1d58 FFF7FEFF 		bl	radio_txNow
1917:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4221              		.loc 1 1917 0
 4222 1d5c 80BD     		pop	{r7, pc}
 4223              		.cfi_endproc
 4224              	.LFE48:
 4226 1d5e 00BF     		.align	2
 4227              		.global	activity_csl_data_rie5
 4228              		.thumb
 4229              		.thumb_func
 4231              	activity_csl_data_rie5:
 4232              	.LFB49:
1918:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1919:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1920:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data rie5].
1921:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1922:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1923:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The functionality is to prepare the radio for ACK sending.
1924:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1925:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_rie5() {
 4233              		.loc 1 1925 0
 4234              		.cfi_startproc
 4235              		@ args = 0, pretend = 0, frame = 0
 4236              		@ frame_needed = 1, uses_anonymous_args = 0
 4237 1d60 80B5     		push	{r7, lr}
 4238              	.LCFI114:
 4239              		.cfi_def_cfa_offset 8
 4240              		.cfi_offset 7, -8
 4241              		.cfi_offset 14, -4
 4242 1d62 00AF     		add	r7, sp, #0
 4243              	.LCFI115:
 4244              		.cfi_def_cfa_register 7
1926:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
1927:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIOTX_OVERFLOWS,
1928:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state,
 4245              		.loc 1 1928 0
 4246 1d64 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4247 1d68 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4248 1d6c 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1927:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIOTX_OVERFLOWS,
 4249              		.loc 1 1927 0
 4250 1d6e 1A46     		mov	r2, r3
1929:openstack/02a-MAClow/IEEE802154Ecsl.c **** 						 (errorparameter_t)ieee154e_dbg.num_cslSamples);
 4251              		.loc 1 1929 0
 4252 1d70 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 4253 1d74 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 4254 1d78 1B69     		ldr	r3, [r3, #16]
1927:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIOTX_OVERFLOWS,
 4255              		.loc 1 1927 0
 4256 1d7a 9BB2     		uxth	r3, r3
 4257 1d7c 4FF00900 		mov	r0, #9
 4258 1d80 4FF02801 		mov	r1, #40
 4259 1d84 FFF7FEFF 		bl	openserial_printError
1930:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1931:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 4260              		.loc 1 1931 0
 4261 1d88 FFF7FEFF 		bl	endOps
1932:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4262              		.loc 1 1932 0
 4263 1d8c 80BD     		pop	{r7, pc}
 4264              		.cfi_endproc
 4265              	.LFE49:
 4267 1d8e 00BF     		.align	2
 4268              		.global	activity_csl_data_ri8
 4269              		.thumb
 4270              		.thumb_func
 4272              	activity_csl_data_ri8:
 4273              	.LFB50:
1933:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1934:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1935:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri8].
1936:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1937:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_startOfFrame" function when a start of frame ev
1938:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change the state to set transmission, cancel #rt7 and arm #rt8 (max time 
1939:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1940:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri8(PORT_RADIOTIMER_WIDTH capturedTime) {
 4274              		.loc 1 1940 0
 4275              		.cfi_startproc
 4276              		@ args = 0, pretend = 0, frame = 8
 4277              		@ frame_needed = 1, uses_anonymous_args = 0
 4278 1d90 80B5     		push	{r7, lr}
 4279              	.LCFI116:
 4280              		.cfi_def_cfa_offset 8
 4281              		.cfi_offset 7, -8
 4282              		.cfi_offset 14, -4
 4283 1d92 82B0     		sub	sp, sp, #8
 4284              	.LCFI117:
 4285              		.cfi_def_cfa_offset 16
 4286 1d94 00AF     		add	r7, sp, #0
 4287              	.LCFI118:
 4288              		.cfi_def_cfa_register 7
 4289 1d96 7860     		str	r0, [r7, #4]
1941:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1942:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXACK);
 4290              		.loc 1 1942 0
 4291 1d98 4FF03A00 		mov	r0, #58
 4292 1d9c FFF7FEFF 		bl	changeState
1943:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1944:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel rt7
1945:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 4293              		.loc 1 1945 0
 4294 1da0 FFF7FEFF 		bl	radiotimer_cancel
1946:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1947:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
1948:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.lastCapturedTime = capturedTime;
 4295              		.loc 1 1948 0
 4296 1da4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4297 1da8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4298 1dac 7A68     		ldr	r2, [r7, #4]
 4299 1dae 5A62     		str	r2, [r3, #36]
1949:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1950:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt8
1951:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt8);
 4300              		.loc 1 1951 0
 4301 1db0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4302 1db4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4303 1db8 5B6A     		ldr	r3, [r3, #36]
 4304 1dba 03F16203 		add	r3, r3, #98
 4305 1dbe 1846     		mov	r0, r3
 4306 1dc0 FFF7FEFF 		bl	radiotimer_schedule
1952:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4307              		.loc 1 1952 0
 4308 1dc4 07F10807 		add	r7, r7, #8
 4309 1dc8 BD46     		mov	sp, r7
 4310 1dca 80BD     		pop	{r7, pc}
 4311              		.cfi_endproc
 4312              	.LFE50:
 4314              		.align	2
 4315              		.global	activity_csl_data_rie6
 4316              		.thumb
 4317              		.thumb_func
 4319              	activity_csl_data_rie6:
 4320              	.LFB51:
1953:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1954:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1955:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data rie6].
1956:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1957:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1958:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to register an error when timer for sent ACK has expired.
1959:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1960:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_rie6() {
 4321              		.loc 1 1960 0
 4322              		.cfi_startproc
 4323              		@ args = 0, pretend = 0, frame = 0
 4324              		@ frame_needed = 1, uses_anonymous_args = 0
 4325 1dcc 80B5     		push	{r7, lr}
 4326              	.LCFI119:
 4327              		.cfi_def_cfa_offset 8
 4328              		.cfi_offset 7, -8
 4329              		.cfi_offset 14, -4
 4330 1dce 00AF     		add	r7, sp, #0
 4331              	.LCFI120:
 4332              		.cfi_def_cfa_register 7
1961:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
1962:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDACKDURATION_OVERFLOWS,
1963:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state,
 4333              		.loc 1 1963 0
 4334 1dd0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4335 1dd4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4336 1dd8 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1962:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDACKDURATION_OVERFLOWS,
 4337              		.loc 1 1962 0
 4338 1dda 1A46     		mov	r2, r3
1964:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_dbg.num_cslSamples);
 4339              		.loc 1 1964 0
 4340 1ddc 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 4341 1de0 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 4342 1de4 1B69     		ldr	r3, [r3, #16]
1962:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDACKDURATION_OVERFLOWS,
 4343              		.loc 1 1962 0
 4344 1de6 9BB2     		uxth	r3, r3
 4345 1de8 4FF00900 		mov	r0, #9
 4346 1dec 4FF02901 		mov	r1, #41
 4347 1df0 FFF7FEFF 		bl	openserial_printError
1965:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1966:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 4348              		.loc 1 1966 0
 4349 1df4 FFF7FEFF 		bl	endOps
1967:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4350              		.loc 1 1967 0
 4351 1df8 80BD     		pop	{r7, pc}
 4352              		.cfi_endproc
 4353              	.LFE51:
 4355 1dfa 00BF     		.align	2
 4356              		.global	activity_csl_data_ri9
 4357              		.thumb
 4358              		.thumb_func
 4360              	activity_csl_data_ri9:
 4361              	.LFB52:
1968:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1969:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1970:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri9].
1971:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1972:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_endOfFrame" function when a end of frame event 
1973:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change the state, cancel #rt8, free ack packet and notify upper layer.
1974:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1975:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri9(PORT_RADIOTIMER_WIDTH capturedTime) {
 4362              		.loc 1 1975 0
 4363              		.cfi_startproc
 4364              		@ args = 0, pretend = 0, frame = 8
 4365              		@ frame_needed = 1, uses_anonymous_args = 0
 4366 1dfc 80B5     		push	{r7, lr}
 4367              	.LCFI121:
 4368              		.cfi_def_cfa_offset 8
 4369              		.cfi_offset 7, -8
 4370              		.cfi_offset 14, -4
 4371 1dfe 82B0     		sub	sp, sp, #8
 4372              	.LCFI122:
 4373              		.cfi_def_cfa_offset 16
 4374 1e00 00AF     		add	r7, sp, #0
 4375              	.LCFI123:
 4376              		.cfi_def_cfa_register 7
 4377 1e02 7860     		str	r0, [r7, #4]
1976:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1977:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXPROC);
 4378              		.loc 1 1977 0
 4379 1e04 4FF03B00 		mov	r0, #59
 4380 1e08 FFF7FEFF 		bl	changeState
1978:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1979:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel rt8
1980:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 4381              		.loc 1 1980 0
 4382 1e0c FFF7FEFF 		bl	radiotimer_cancel
1981:openstack/02a-MAClow/IEEE802154Ecsl.c ****   
1982:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
1983:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.lastCapturedTime = capturedTime;
 4383              		.loc 1 1983 0
 4384 1e10 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4385 1e14 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4386 1e18 7A68     		ldr	r2, [r7, #4]
 4387 1e1a 5A62     		str	r2, [r3, #36]
1984:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1985:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // free the ack we just sent so corresponding RAM memory can be recycled
1986:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openqueue_freePacketBuffer(ieee154e_vars.ackToSend);
 4388              		.loc 1 1986 0
 4389 1e1c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4390 1e20 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4391 1e24 DB69     		ldr	r3, [r3, #28]
 4392 1e26 1846     		mov	r0, r3
 4393 1e28 FFF7FEFF 		bl	openqueue_freePacketBuffer
1987:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1988:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clear local variable
1989:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend = NULL;
 4394              		.loc 1 1989 0
 4395 1e2c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4396 1e30 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4397 1e34 4FF00002 		mov	r2, #0
 4398 1e38 DA61     		str	r2, [r3, #28]
1990:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1991:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // synchronize to the received packet
1992:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //if (idmanager_getIsDAGroot()==FALSE && neighbors_isPreferredParent(&(ieee154e_vars.dataReceive
1993:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   synchronizePacket(ieee154e_vars.syncCapturedTime);
1994:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //}
1995:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1996:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // inform upper layer of reception (after ACK sent)
1997:openstack/02a-MAClow/IEEE802154Ecsl.c ****    notif_receive(ieee154e_vars.dataReceived,1);
 4399              		.loc 1 1997 0
 4400 1e3a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4401 1e3e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4402 1e42 9B69     		ldr	r3, [r3, #24]
 4403 1e44 1846     		mov	r0, r3
 4404 1e46 4FF00101 		mov	r1, #1
 4405 1e4a FFF7FEFF 		bl	notif_receive
1998:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1999:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clear local variable
2000:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.dataReceived = NULL;
 4406              		.loc 1 2000 0
 4407 1e4e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4408 1e52 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4409 1e56 4FF00002 		mov	r2, #0
 4410 1e5a 9A61     		str	r2, [r3, #24]
2001:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
2002:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // official end of Rx slot
2003:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 4411              		.loc 1 2003 0
 4412 1e5c FFF7FEFF 		bl	endOps
2004:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4413              		.loc 1 2004 0
 4414 1e60 07F10807 		add	r7, r7, #8
 4415 1e64 BD46     		mov	sp, r7
 4416 1e66 80BD     		pop	{r7, pc}
 4417              		.cfi_endproc
 4418              	.LFE52:
 4420              		.align	2
 4421              		.global	ieee802154_createWakeUpFrame
 4422              		.thumb
 4423              		.thumb_func
 4425              	ieee802154_createWakeUpFrame:
 4426              	.LFB53:
2005:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2006:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2007:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2008:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================= WAKE-UP FRAMES ===============================
2009:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2010:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2011:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2012:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Prepend the IEEE802.15.4 MAC Wake-Up header to a (to be transmitted) packet.
2013:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2014:openstack/02a-MAClow/IEEE802154Ecsl.c **** Note that we are writing the field from the end of the header to the beginning.
2015:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2016:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in,out] msg              The message to append the header to.
2017:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in]     sequenceNumber   Sequence number of this frame.
2018:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in]     nextHop          Address of the next hop
2019:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in]     rztime           Rendezvoud time
2020:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2021:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2022:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CSL]: Prepend  a wake-up header to a packet.
2023:openstack/02a-MAClow/IEEE802154Ecsl.c **** void ieee802154_createWakeUpFrame(OpenQueueEntry_t*		msg,
2024:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                   uint8_t           	sequenceNumber,
2025:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                   open_addr_t*        	nextHop,
2026:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							      uint16_t				rz_time) {
 4427              		.loc 1 2026 0
 4428              		.cfi_startproc
 4429              		@ args = 0, pretend = 0, frame = 40
 4430              		@ frame_needed = 1, uses_anonymous_args = 0
 4431 1e68 80B5     		push	{r7, lr}
 4432              	.LCFI124:
 4433              		.cfi_def_cfa_offset 8
 4434              		.cfi_offset 7, -8
 4435              		.cfi_offset 14, -4
 4436 1e6a 8AB0     		sub	sp, sp, #40
 4437              	.LCFI125:
 4438              		.cfi_def_cfa_offset 48
 4439 1e6c 00AF     		add	r7, sp, #0
 4440              	.LCFI126:
 4441              		.cfi_def_cfa_register 7
 4442 1e6e F860     		str	r0, [r7, #12]
 4443 1e70 7A60     		str	r2, [r7, #4]
 4444 1e72 0A46     		mov	r2, r1
 4445 1e74 FA72     		strb	r2, [r7, #11]
 4446 1e76 3B81     		strh	r3, [r7, #8]	@ movhi
2027:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2028:openstack/02a-MAClow/IEEE802154Ecsl.c ****     open_addr_t	nextHop16b;
2029:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2030:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// La estructura de una trama Wake-Up es la siguiente:
2031:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//
2032:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   - FRAME CONTROL: 1 byte
2033:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   - SEQ NUMBER (macDSN): 1 byte
2034:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   - PAN ID: 2 bytes
2035:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   - DEST ADDR: 2 bytes
2036:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   - RZ TIME IE: 2 bytes (header) + 2 bytes (body)
2037:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   - IE LIST TERMINATOR: 2 bytes
2038:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//
2039:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//  | FRAME   |  SEQ   | PAN | DEST | RZ TIME  | IE LIST    |
2040:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//  | CONTROL | NUMBER |  ID | ADDR |  HDR IE  | TERMINATOR |
2041:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//
2042:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2043:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// Empezamos a escribir el payload de la trama wake-up empezando del final hacia adelante.
2044:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2045:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// IE LIST TERMINATOR, formado por 2 bytes con la siguiente estructura (0x3F80 o 0x3F00)
2046:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  - b0-b6 (Length) = 0
2047:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  - b7-b14 (Element ID) = 0x7e o 0x7f
2048:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  - b15 (Type) = 0
2049:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //
2050:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  b15 | b14 | b13 | b12 | b11 | b10 | b9 | b8 | b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 |
2051:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //   0  |  0  |  1  |  1  |  1  |  1  | 1  | 1  |  0 |  0 |  0 |  0 |  0 |  0 |  0 |  0 |
2052:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	packetfunctions_reserveHeaderSize(msg,sizeof(uint16_t));
 4447              		.loc 1 2052 0
 4448 1e78 F868     		ldr	r0, [r7, #12]
 4449 1e7a 4FF00201 		mov	r1, #2
 4450 1e7e FFF7FEFF 		bl	packetfunctions_reserveHeaderSize
2053:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	*((uint16_t*)(msg->payload)) = 0x3F00;  // Element ID = 0x7e
 4451              		.loc 1 2053 0
 4452 1e82 FB68     		ldr	r3, [r7, #12]
 4453 1e84 5B68     		ldr	r3, [r3, #4]
 4454 1e86 4FF47C52 		mov	r2, #16128
 4455 1e8a 1A80     		strh	r2, [r3, #0]	@ movhi
2054:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2055:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// RZ TIME IE, formado por 4 bytes con la siguiente estructura (0x0E82). La cabecera es igual a:
2056:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  - b0-b6 (Length) = 2
2057:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  - b7-b14 (Element ID) = 0x1D
2058:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  - b15 (Type) = 0
2059:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  - b16-b31 (IE Content) = time (2 bytes)
2060:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //
2061:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  b15 | b14 | b13 | b12 | b11 | b10 | b9 | b8 | b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 |
2062:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //   0  |  0  |  0  |  0  |  1  |  1  |  1 |  0 |  1 |  0 |  0 |  0 |  0 |  0 |  1 |  0 |
2063:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2064:openstack/02a-MAClow/IEEE802154Ecsl.c ****  	// rz time ie body (time)
2065:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	packetfunctions_reserveHeaderSize(msg,sizeof(uint8_t));
 4456              		.loc 1 2065 0
 4457 1e8c F868     		ldr	r0, [r7, #12]
 4458 1e8e 4FF00101 		mov	r1, #1
 4459 1e92 FFF7FEFF 		bl	packetfunctions_reserveHeaderSize
2066:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	*((uint8_t*)(msg->payload)) = (uint8_t)((rz_time >> 8) & 0xFF);
 4460              		.loc 1 2066 0
 4461 1e96 FB68     		ldr	r3, [r7, #12]
 4462 1e98 5B68     		ldr	r3, [r3, #4]
 4463 1e9a 3A89     		ldrh	r2, [r7, #8]
 4464 1e9c 4FEA1222 		lsr	r2, r2, #8
 4465 1ea0 92B2     		uxth	r2, r2
 4466 1ea2 D2B2     		uxtb	r2, r2
 4467 1ea4 1A70     		strb	r2, [r3, #0]
2067:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2068:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	packetfunctions_reserveHeaderSize(msg,sizeof(uint8_t));
 4468              		.loc 1 2068 0
 4469 1ea6 F868     		ldr	r0, [r7, #12]
 4470 1ea8 4FF00101 		mov	r1, #1
 4471 1eac FFF7FEFF 		bl	packetfunctions_reserveHeaderSize
2069:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	*((uint8_t*)(msg->payload)) = (uint8_t)(rz_time & 0xFF);
 4472              		.loc 1 2069 0
 4473 1eb0 FB68     		ldr	r3, [r7, #12]
 4474 1eb2 5B68     		ldr	r3, [r3, #4]
 4475 1eb4 3A89     		ldrh	r2, [r7, #8]	@ movhi
 4476 1eb6 D2B2     		uxtb	r2, r2
 4477 1eb8 1A70     		strb	r2, [r3, #0]
2070:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2071:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//packetfunctions_reserveHeaderSize(msg,sizeof(uint16_t));
2072:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//*((uint16_t*)(msg->payload)) = rz_time;
2073:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2074:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// rz time ie header
2075:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	packetfunctions_reserveHeaderSize(msg,sizeof(uint16_t));
 4478              		.loc 1 2075 0
 4479 1eba F868     		ldr	r0, [r7, #12]
 4480 1ebc 4FF00201 		mov	r1, #2
 4481 1ec0 FFF7FEFF 		bl	packetfunctions_reserveHeaderSize
2076:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	*((uint16_t*)(msg->payload)) = 0x0E82;
 4482              		.loc 1 2076 0
 4483 1ec4 FB68     		ldr	r3, [r7, #12]
 4484 1ec6 5B68     		ldr	r3, [r3, #4]
 4485 1ec8 40F68262 		movw	r2, #3714
 4486 1ecc 1A80     		strh	r2, [r3, #0]	@ movhi
2077:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2078:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// DEST ADDR
2079:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	if (nextHop->type == ADDR_16B) {
 4487              		.loc 1 2079 0
 4488 1ece 7B68     		ldr	r3, [r7, #4]
 4489 1ed0 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 4490 1ed2 012B     		cmp	r3, #1
 4491 1ed4 06D1     		bne	.L200
2080:openstack/02a-MAClow/IEEE802154Ecsl.c ****   	   packetfunctions_writeAddress(msg,nextHop,OW_LITTLE_ENDIAN);
 4492              		.loc 1 2080 0
 4493 1ed6 F868     		ldr	r0, [r7, #12]
 4494 1ed8 7968     		ldr	r1, [r7, #4]
 4495 1eda 4FF00102 		mov	r2, #1
 4496 1ede FFF7FEFF 		bl	packetfunctions_writeAddress
 4497 1ee2 11E0     		b	.L201
 4498              	.L200:
2081:openstack/02a-MAClow/IEEE802154Ecsl.c ****     } else if (nextHop->type == ADDR_64B) {
 4499              		.loc 1 2081 0
 4500 1ee4 7B68     		ldr	r3, [r7, #4]
 4501 1ee6 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 4502 1ee8 022B     		cmp	r3, #2
 4503 1eea 0DD1     		bne	.L201
2082:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   packetfunctions_mac64bToMac16b(nextHop, &nextHop16b);
 4504              		.loc 1 2082 0
 4505 1eec 07F11403 		add	r3, r7, #20
 4506 1ef0 7868     		ldr	r0, [r7, #4]
 4507 1ef2 1946     		mov	r1, r3
 4508 1ef4 FFF7FEFF 		bl	packetfunctions_mac64bToMac16b
2083:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   packetfunctions_writeAddress(msg,&nextHop16b,OW_LITTLE_ENDIAN);
 4509              		.loc 1 2083 0
 4510 1ef8 07F11403 		add	r3, r7, #20
 4511 1efc F868     		ldr	r0, [r7, #12]
 4512 1efe 1946     		mov	r1, r3
 4513 1f00 4FF00102 		mov	r2, #1
 4514 1f04 FFF7FEFF 		bl	packetfunctions_writeAddress
 4515              	.L201:
2084:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	}
2085:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2086:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// PAN ID
2087:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	packetfunctions_writeAddress(msg,idmanager_getMyID(ADDR_PANID),OW_LITTLE_ENDIAN);
 4516              		.loc 1 2087 0
 4517 1f08 4FF00400 		mov	r0, #4
 4518 1f0c FFF7FEFF 		bl	idmanager_getMyID
 4519 1f10 0346     		mov	r3, r0
 4520 1f12 F868     		ldr	r0, [r7, #12]
 4521 1f14 1946     		mov	r1, r3
 4522 1f16 4FF00102 		mov	r2, #1
 4523 1f1a FFF7FEFF 		bl	packetfunctions_writeAddress
2088:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2089:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// SEQ NUMBER
2090:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	packetfunctions_reserveHeaderSize(msg,sizeof(uint8_t));
 4524              		.loc 1 2090 0
 4525 1f1e F868     		ldr	r0, [r7, #12]
 4526 1f20 4FF00101 		mov	r1, #1
 4527 1f24 FFF7FEFF 		bl	packetfunctions_reserveHeaderSize
2091:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	*((uint8_t*)(msg->payload)) = sequenceNumber;
 4528              		.loc 1 2091 0
 4529 1f28 FB68     		ldr	r3, [r7, #12]
 4530 1f2a 5B68     		ldr	r3, [r3, #4]
 4531 1f2c FA7A     		ldrb	r2, [r7, #11]
 4532 1f2e 1A70     		strb	r2, [r3, #0]
2092:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2093:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// La estructura del FCF en la trama de wake-up es 0x55 = 01010101b:
2094:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// b0-b2 -- Frame Type (debe ser 101 para trama wake-up)
2095:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// b3 ----- Long Frame Control (debe ser 0 para indicar que se trata de un FCF de 1 byte como es e
2096:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// b4-b5 -- Dest Addr Mode (en este caso, short address por lo que tiene que valer 10).
2097:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// b6-b7 -- Src Addr Mode (en este caso, short address por lo que tiene que valer 10).
2098:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2099:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//  b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 |
2100:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   0 |  1 |  0 |  1 |  0 |  1 |  0 |  1 |
2101:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2102:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// FCF
2103:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	packetfunctions_reserveHeaderSize(msg,sizeof(uint8_t));
 4533              		.loc 1 2103 0
 4534 1f30 F868     		ldr	r0, [r7, #12]
 4535 1f32 4FF00101 		mov	r1, #1
 4536 1f36 FFF7FEFF 		bl	packetfunctions_reserveHeaderSize
2104:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	*((uint8_t*)(msg->payload)) = 0x55;
 4537              		.loc 1 2104 0
 4538 1f3a FB68     		ldr	r3, [r7, #12]
 4539 1f3c 5B68     		ldr	r3, [r3, #4]
 4540 1f3e 4FF05502 		mov	r2, #85
 4541 1f42 1A70     		strb	r2, [r3, #0]
2105:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2106:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4542              		.loc 1 2106 0
 4543 1f44 07F12807 		add	r7, r7, #40
 4544 1f48 BD46     		mov	sp, r7
 4545 1f4a 80BD     		pop	{r7, pc}
 4546              		.cfi_endproc
 4547              	.LFE53:
 4549              		.align	2
 4550              		.global	ieee802154_retrieveWakeUpFrame
 4551              		.thumb
 4552              		.thumb_func
 4554              	ieee802154_retrieveWakeUpFrame:
 4555              	.LFB54:
2107:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2108:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2109:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Retrieve the IEEE802.15.4 MAC Wake-Up Frame header from a (just received) packet.
2110:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2111:openstack/02a-MAClow/IEEE802154Ecsl.c **** Note We are writing the fields from the beginning of the header to the end.
2112:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2113:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in,out] msg            The message just received.
2114:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[out] ieee802514_header The internal header to write the data to.
2115:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[out] rztime  		  Rendezvous time to wait for data packet.
2116:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2117:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2118:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CSL]: Retrieve a wake-up header from the received packet.
2119:openstack/02a-MAClow/IEEE802154Ecsl.c **** void ieee802154_retrieveWakeUpFrame(OpenQueueEntry_t*      msg,
2120:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                     ieee802154_header_iht* ieee802514_header,
2121:openstack/02a-MAClow/IEEE802154Ecsl.c **** 									uint16_t* rztime) {
 4556              		.loc 1 2121 0
 4557              		.cfi_startproc
 4558              		@ args = 0, pretend = 0, frame = 24
 4559              		@ frame_needed = 1, uses_anonymous_args = 0
 4560 1f4c 80B5     		push	{r7, lr}
 4561              	.LCFI127:
 4562              		.cfi_def_cfa_offset 8
 4563              		.cfi_offset 7, -8
 4564              		.cfi_offset 14, -4
 4565 1f4e 86B0     		sub	sp, sp, #24
 4566              	.LCFI128:
 4567              		.cfi_def_cfa_offset 32
 4568 1f50 00AF     		add	r7, sp, #0
 4569              	.LCFI129:
 4570              		.cfi_def_cfa_register 7
 4571 1f52 F860     		str	r0, [r7, #12]
 4572 1f54 B960     		str	r1, [r7, #8]
 4573 1f56 7A60     		str	r2, [r7, #4]
2122:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t temp_8b, temp_8b1, temp_8b2;
2123:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t src_addr_mode, dst_addr_mode;
2124:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint16_t temp_16b;
2125:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2126:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2127:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // La estructura de una trama Wake-Up es la siguiente:
2128:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2129:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - FRAME CONTROL: 1 byte
2130:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - SEQ NUMBER (macDSN): 1 byte
2131:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - PAN ID: 2 bytes
2132:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - DEST ADDR: 2 bytes
2133:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - RZ TIME IE: 2 bytes
2134:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - IE LIST TERMINATOR: 2 bytes
2135:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2136:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  | FRAME   |  SEQ   | PAN | DEST | RZ TIME  | IE LIST    |
2137:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  | CONTROL | NUMBER |  ID | ADDR |  HDR IE  | TERMINATOR |
2138:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2139:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2140:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Por defecto, se asume que la cabecera no es válida en el caso de
2141:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abandonar la función al ser el paquete más corto que la cabecera.
2142:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->valid=FALSE;
 4574              		.loc 1 2142 0
 4575 1f58 BB68     		ldr	r3, [r7, #8]
 4576 1f5a 4FF00002 		mov	r2, #0
 4577 1f5e 1A70     		strb	r2, [r3, #0]
2143:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength = 0;
 4578              		.loc 1 2143 0
 4579 1f60 BB68     		ldr	r3, [r7, #8]
 4580 1f62 4FF00002 		mov	r2, #0
 4581 1f66 5A70     		strb	r2, [r3, #1]
2144:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2145:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Validamos la existencia de datos que leer.
2146:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; }
 4582              		.loc 1 2146 0
 4583 1f68 BB68     		ldr	r3, [r7, #8]
 4584 1f6a 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 4585 1f6c FB68     		ldr	r3, [r7, #12]
 4586 1f6e 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4587 1f70 9A42     		cmp	r2, r3
 4588 1f72 00F25F81 		bhi	.L225
 4589              	.L203:
2147:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2148:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Frame Control Field (1 byte)
2149:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_8b = *((uint8_t*)(msg->payload)+ieee802514_header->headerLength);
 4590              		.loc 1 2149 0
 4591 1f76 FB68     		ldr	r3, [r7, #12]
 4592 1f78 5A68     		ldr	r2, [r3, #4]
 4593 1f7a BB68     		ldr	r3, [r7, #8]
 4594 1f7c 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4595 1f7e D318     		adds	r3, r2, r3
 4596 1f80 1B78     		ldrb	r3, [r3, #0]
 4597 1f82 FB75     		strb	r3, [r7, #23]
2150:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2151:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // La estructura del FCF en la trama de wake-up es 0x55 = 01010101b:
2152:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // b0-b2 -- Frame Type (debe ser 101 para trama wake-up)
2153:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // b3 ----- Long Frame Control (debe ser 0 para indicar que se trata de un FCF de 1 byte como es
2154:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // b4-b5 -- Dest Addr Mode (en este caso, short address por lo que tiene que valer 10).
2155:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // b6-b7 -- Src Addr Mode (en este caso, short address por lo que tiene que valer 10).
2156:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2157:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 |
2158:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   0 |  1 |  0 |  1 |  0 |  1 |  0 |  1 |
2159:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2160:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->frameType = (temp_8b >> IEEE154_FCF_FRAME_TYPE) & 0x07;//3b
 4598              		.loc 1 2160 0
 4599 1f84 FB7D     		ldrb	r3, [r7, #23]
 4600 1f86 03F00703 		and	r3, r3, #7
 4601 1f8a DAB2     		uxtb	r2, r3
 4602 1f8c BB68     		ldr	r3, [r7, #8]
 4603 1f8e 9A70     		strb	r2, [r3, #2]
2161:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2162:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Comprobamos que efectivamente se trata de una trama de tipo MULTIPURPOSE.
2163:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->frameType != IEEE154_TYPE_MULTIPURPOSE) {return; }
 4604              		.loc 1 2163 0
 4605 1f90 BB68     		ldr	r3, [r7, #8]
 4606 1f92 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 4607 1f94 052B     		cmp	r3, #5
 4608 1f96 40F04F81 		bne	.L226
 4609              	.L205:
2164:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2165:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Verificamos que efectivamente el campo Long Frame Control tiene valor cero para indicar que e
2166:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_8b >> 3) & 0x01) { return; }
 4610              		.loc 1 2166 0
 4611 1f9a FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 4612 1f9c 4FEAD303 		lsr	r3, r3, #3
 4613 1fa0 DBB2     		uxtb	r3, r3
 4614 1fa2 03F00103 		and	r3, r3, #1
 4615 1fa6 002B     		cmp	r3, #0
 4616 1fa8 40F04881 		bne	.L227
 4617              	.L206:
2167:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2168:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Recuperamos los Destination y Source Address Mode
2169:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2170:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Destination Address Mode
2171:openstack/02a-MAClow/IEEE802154Ecsl.c ****    dst_addr_mode = (temp_8b >> 4) & 0x03;
 4618              		.loc 1 2171 0
 4619 1fac FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 4620 1fae 4FEA1313 		lsr	r3, r3, #4
 4621 1fb2 DBB2     		uxtb	r3, r3
 4622 1fb4 03F00303 		and	r3, r3, #3
 4623 1fb8 BB75     		strb	r3, [r7, #22]
2172:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if(dst_addr_mode == 1) { // 01 en binario en bits b5-b4
 4624              		.loc 1 2172 0
 4625 1fba BB7D     		ldrb	r3, [r7, #22]	@ zero_extendqisi2
 4626 1fbc 012B     		cmp	r3, #1
 4627 1fbe 0BD1     		bne	.L207
2173:openstack/02a-MAClow/IEEE802154Ecsl.c ****      // Debería ser siempre este caso en las tramas wake-up por lo que se trata como error cualqui
2174:openstack/02a-MAClow/IEEE802154Ecsl.c ****      ieee802514_header->dest.type = ADDR_16B;
 4628              		.loc 1 2174 0
 4629 1fc0 BB68     		ldr	r3, [r7, #8]
 4630 1fc2 4FF00102 		mov	r2, #1
 4631 1fc6 DA76     		strb	r2, [r3, #27]
2175:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2176:openstack/02a-MAClow/IEEE802154Ecsl.c ****    else {
2177:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	 openserial_printError(COMPONENT_IEEE802154,ERR_IEEE154_UNSUPPORTED, (errorparameter_t)1, (errorpa
2178:openstack/02a-MAClow/IEEE802154Ecsl.c ****      return; // this is an invalid packet, return
2179:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2180:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2181:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Source Address Mode
2182:openstack/02a-MAClow/IEEE802154Ecsl.c ****    src_addr_mode = (temp_8b >> 6) & 0x03;
 4632              		.loc 1 2182 0
 4633 1fc8 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 4634 1fca 4FEA9313 		lsr	r3, r3, #6
 4635 1fce 7B75     		strb	r3, [r7, #21]
2183:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if(src_addr_mode == 1) { // 01 en binario en bits b7-b6
 4636              		.loc 1 2183 0
 4637 1fd0 7B7D     		ldrb	r3, [r7, #21]	@ zero_extendqisi2
 4638 1fd2 012B     		cmp	r3, #1
 4639 1fd4 0BD0     		beq	.L208
 4640 1fd6 1EE0     		b	.L223
 4641              	.L207:
2177:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	 openserial_printError(COMPONENT_IEEE802154,ERR_IEEE154_UNSUPPORTED, (errorparameter_t)1, (errorpa
 4642              		.loc 1 2177 0
 4643 1fd8 BB7D     		ldrb	r3, [r7, #22]	@ zero_extendqisi2
 4644 1fda 9BB2     		uxth	r3, r3
 4645 1fdc 4FF00800 		mov	r0, #8
 4646 1fe0 4FF01901 		mov	r1, #25
 4647 1fe4 4FF00102 		mov	r2, #1
 4648 1fe8 FFF7FEFF 		bl	openserial_printError
2178:openstack/02a-MAClow/IEEE802154Ecsl.c ****      return; // this is an invalid packet, return
 4649              		.loc 1 2178 0
 4650 1fec 3FE1     		b	.L202
 4651              	.L208:
2184:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Debería ser siempre este caso en las tramas wake-up por lo que se trata como error cualqu
2185:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee802514_header->src.type = ADDR_16B;
 4652              		.loc 1 2185 0
 4653 1fee BB68     		ldr	r3, [r7, #8]
 4654 1ff0 4FF00102 		mov	r2, #1
 4655 1ff4 83F82C20 		strb	r2, [r3, #44]
2186:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2187:openstack/02a-MAClow/IEEE802154Ecsl.c ****    else {
2188:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printError(COMPONENT_IEEE802154,ERR_IEEE154_UNSUPPORTED, (errorparameter_t)2, (errorp
2189:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return; // this is an invalid packet, return
2190:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2191:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2192:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2193:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // En este punto ya hemos analizado el contenido del primer byte de la cabecera correspondiente 
2194:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2195:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2196:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // A partir de este punto, la estructura del paquete es la siguiente:
2197:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - SEQ NUMBER (macDSN): 1 byte
2198:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - PAN ID: 2 bytes
2199:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - DEST ADDR: 2 bytes
2200:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - RZ TIME IE: 2 bytes
2201:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - IE LIST TERMINATOR: 2 bytes
2202:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2203:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2204:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Avanzamos 1 byte en el procesamiento de la cabecera.
2205:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 1;
 4656              		.loc 1 2205 0
 4657 1ff8 BB68     		ldr	r3, [r7, #8]
 4658 1ffa 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4659 1ffc 03F10103 		add	r3, r3, #1
 4660 2000 DAB2     		uxtb	r2, r3
 4661 2002 BB68     		ldr	r3, [r7, #8]
 4662 2004 5A70     		strb	r2, [r3, #1]
2206:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2207:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Posicionamos dentro del paquete para leer el resto de elementos.
2208:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2209:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // 1.- SequenceNumber
2210:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4663              		.loc 1 2210 0
 4664 2006 BB68     		ldr	r3, [r7, #8]
 4665 2008 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 4666 200a FB68     		ldr	r3, [r7, #12]
 4667 200c 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4668 200e 9A42     		cmp	r2, r3
 4669 2010 00F21681 		bhi	.L228
 4670 2014 0AE0     		b	.L224
 4671              	.L223:
2188:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printError(COMPONENT_IEEE802154,ERR_IEEE154_UNSUPPORTED, (errorparameter_t)2, (errorp
 4672              		.loc 1 2188 0
 4673 2016 7B7D     		ldrb	r3, [r7, #21]	@ zero_extendqisi2
 4674 2018 9BB2     		uxth	r3, r3
 4675 201a 4FF00800 		mov	r0, #8
 4676 201e 4FF01901 		mov	r1, #25
 4677 2022 4FF00202 		mov	r2, #2
 4678 2026 FFF7FEFF 		bl	openserial_printError
2189:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return; // this is an invalid packet, return
 4679              		.loc 1 2189 0
 4680 202a 20E1     		b	.L202
 4681              	.L224:
2211:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->dsn  = *((uint8_t*)(msg->payload)+ieee802514_header->headerLength);
 4682              		.loc 1 2211 0
 4683 202c FB68     		ldr	r3, [r7, #12]
 4684 202e 5A68     		ldr	r2, [r3, #4]
 4685 2030 BB68     		ldr	r3, [r7, #8]
 4686 2032 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4687 2034 D318     		adds	r3, r2, r3
 4688 2036 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 4689 2038 BB68     		ldr	r3, [r7, #8]
 4690 203a 5A72     		strb	r2, [r3, #9]
2212:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 1;
 4691              		.loc 1 2212 0
 4692 203c BB68     		ldr	r3, [r7, #8]
 4693 203e 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4694 2040 03F10103 		add	r3, r3, #1
 4695 2044 DAB2     		uxtb	r2, r3
 4696 2046 BB68     		ldr	r3, [r7, #8]
 4697 2048 5A70     		strb	r2, [r3, #1]
2213:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2214:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // 2.- panID
2215:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4698              		.loc 1 2215 0
 4699 204a BB68     		ldr	r3, [r7, #8]
 4700 204c 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 4701 204e FB68     		ldr	r3, [r7, #12]
 4702 2050 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4703 2052 9A42     		cmp	r2, r3
 4704 2054 00F2F680 		bhi	.L229
 4705              	.L212:
2216:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packetfunctions_readAddress(((uint8_t*)(msg->payload)+ieee802514_header->headerLength), ADDR_PAN
 4706              		.loc 1 2216 0
 4707 2058 FB68     		ldr	r3, [r7, #12]
 4708 205a 5A68     		ldr	r2, [r3, #4]
 4709 205c BB68     		ldr	r3, [r7, #8]
 4710 205e 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4711 2060 D218     		adds	r2, r2, r3
 4712 2062 BB68     		ldr	r3, [r7, #8]
 4713 2064 03F10A03 		add	r3, r3, #10
 4714 2068 1046     		mov	r0, r2
 4715 206a 4FF00401 		mov	r1, #4
 4716 206e 1A46     		mov	r2, r3
 4717 2070 4FF00103 		mov	r3, #1
 4718 2074 FFF7FEFF 		bl	packetfunctions_readAddress
2217:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 2;
 4719              		.loc 1 2217 0
 4720 2078 BB68     		ldr	r3, [r7, #8]
 4721 207a 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4722 207c 03F10203 		add	r3, r3, #2
 4723 2080 DAB2     		uxtb	r2, r3
 4724 2082 BB68     		ldr	r3, [r7, #8]
 4725 2084 5A70     		strb	r2, [r3, #1]
2218:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2219:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // 3.- Dest Addr
2220:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4726              		.loc 1 2220 0
 4727 2086 BB68     		ldr	r3, [r7, #8]
 4728 2088 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 4729 208a FB68     		ldr	r3, [r7, #12]
 4730 208c 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4731 208e 9A42     		cmp	r2, r3
 4732 2090 00F2DA80 		bhi	.L230
 4733              	.L213:
2221:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2222:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // En este punto ya sabemos que el tipo de dirección tiene que ser ADDR_16B dado que cualquier 
2223:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // en la lectura del frame control field por lo que leemos los 2 bytes de la dirección del dest
2224:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packetfunctions_readAddress(((uint8_t*)(msg->payload)+ieee802514_header->headerLength), ADDR_16B
 4734              		.loc 1 2224 0
 4735 2094 FB68     		ldr	r3, [r7, #12]
 4736 2096 5A68     		ldr	r2, [r3, #4]
 4737 2098 BB68     		ldr	r3, [r7, #8]
 4738 209a 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4739 209c D218     		adds	r2, r2, r3
 4740 209e BB68     		ldr	r3, [r7, #8]
 4741 20a0 03F11B03 		add	r3, r3, #27
 4742 20a4 1046     		mov	r0, r2
 4743 20a6 4FF00101 		mov	r1, #1
 4744 20aa 1A46     		mov	r2, r3
 4745 20ac 4FF00103 		mov	r3, #1
 4746 20b0 FFF7FEFF 		bl	packetfunctions_readAddress
2225:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 2;
 4747              		.loc 1 2225 0
 4748 20b4 BB68     		ldr	r3, [r7, #8]
 4749 20b6 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4750 20b8 03F10203 		add	r3, r3, #2
 4751 20bc DAB2     		uxtb	r2, r3
 4752 20be BB68     		ldr	r3, [r7, #8]
 4753 20c0 5A70     		strb	r2, [r3, #1]
2226:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2227:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // 4.- RZ Time Header IE, formado por 4 bytes con la siguiente estructura (0x0E82)
2228:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  - b0-b6 (Length) = 2
2229:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  - b7-b14 (Element ID) = 0x1D
2230:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  - b15 (Type) = 0
2231:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  - b16-b31 (IE Content) = time (2 bytes)
2232:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2233:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  b15 | b14 | b13 | b12 | b11 | b10 | b9 | b8 | b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 |
2234:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   0  |  0  |  0  |  0  |  1  |  1  |  1 |  0 |  1 |  0 |  0 |  0 |  0 |  0 |  1 |  0 |
2235:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2236:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) {  return; } // no more to read!
 4754              		.loc 1 2236 0
 4755 20c2 BB68     		ldr	r3, [r7, #8]
 4756 20c4 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 4757 20c6 FB68     		ldr	r3, [r7, #12]
 4758 20c8 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4759 20ca 9A42     		cmp	r2, r3
 4760 20cc 00F2BE80 		bhi	.L231
 4761              	.L214:
2237:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2238:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Verificamos longitud a valor 2 y el elementID a valor 0x1D. Lo hacemos leyendo los primeros 2
2239:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_8b1 = *((uint8_t*)(msg->payload)+ieee802514_header->headerLength);
 4762              		.loc 1 2239 0
 4763 20d0 FB68     		ldr	r3, [r7, #12]
 4764 20d2 5A68     		ldr	r2, [r3, #4]
 4765 20d4 BB68     		ldr	r3, [r7, #8]
 4766 20d6 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4767 20d8 D318     		adds	r3, r2, r3
 4768 20da 1B78     		ldrb	r3, [r3, #0]
 4769 20dc 3B75     		strb	r3, [r7, #20]
2240:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 1;
 4770              		.loc 1 2240 0
 4771 20de BB68     		ldr	r3, [r7, #8]
 4772 20e0 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4773 20e2 03F10103 		add	r3, r3, #1
 4774 20e6 DAB2     		uxtb	r2, r3
 4775 20e8 BB68     		ldr	r3, [r7, #8]
 4776 20ea 5A70     		strb	r2, [r3, #1]
2241:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2242:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_8b2 = *((uint8_t*)(msg->payload)+ieee802514_header->headerLength);
 4777              		.loc 1 2242 0
 4778 20ec FB68     		ldr	r3, [r7, #12]
 4779 20ee 5A68     		ldr	r2, [r3, #4]
 4780 20f0 BB68     		ldr	r3, [r7, #8]
 4781 20f2 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4782 20f4 D318     		adds	r3, r2, r3
 4783 20f6 1B78     		ldrb	r3, [r3, #0]
 4784 20f8 FB74     		strb	r3, [r7, #19]
2243:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 1;
 4785              		.loc 1 2243 0
 4786 20fa BB68     		ldr	r3, [r7, #8]
 4787 20fc 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4788 20fe 03F10103 		add	r3, r3, #1
 4789 2102 DAB2     		uxtb	r2, r3
 4790 2104 BB68     		ldr	r3, [r7, #8]
 4791 2106 5A70     		strb	r2, [r3, #1]
2244:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2245:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_16b = (temp_8b2 << 8) | temp_8b1;
 4792              		.loc 1 2245 0
 4793 2108 FB7C     		ldrb	r3, [r7, #19]	@ zero_extendqisi2
 4794 210a 4FEA0323 		lsl	r3, r3, #8
 4795 210e 9AB2     		uxth	r2, r3
 4796 2110 3B7D     		ldrb	r3, [r7, #20]	@ zero_extendqisi2
 4797 2112 9BB2     		uxth	r3, r3
 4798 2114 1343     		orrs	r3, r3, r2
 4799 2116 9BB2     		uxth	r3, r3
 4800 2118 3B82     		strh	r3, [r7, #16]	@ movhi
2246:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2247:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Comprobación de longitud a valor 2.
2248:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b & 0x007f) != 2) { return; }
 4801              		.loc 1 2248 0
 4802 211a 3B8A     		ldrh	r3, [r7, #16]
 4803 211c 03F07F03 		and	r3, r3, #127
 4804 2120 022B     		cmp	r3, #2
 4805 2122 40F09580 		bne	.L232
 4806              	.L215:
2249:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2250:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Comprobación de element ID = 0x1D.
2251:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b >> 7) != 0x001d) { return; }
 4807              		.loc 1 2251 0
 4808 2126 3B8A     		ldrh	r3, [r7, #16]
 4809 2128 4FEAD313 		lsr	r3, r3, #7
 4810 212c 9BB2     		uxth	r3, r3
 4811 212e 1D2B     		cmp	r3, #29
 4812 2130 40F09080 		bne	.L233
 4813              	.L216:
2252:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2253:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Comprobación del type = 0.
2254:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b >> 15) & 0x0001) { return; }
 4814              		.loc 1 2254 0
 4815 2134 3B8A     		ldrh	r3, [r7, #16]
 4816 2136 4FEAD333 		lsr	r3, r3, #15
 4817 213a 9BB2     		uxth	r3, r3
 4818 213c 03F00103 		and	r3, r3, #1
 4819 2140 002B     		cmp	r3, #0
 4820 2142 40F08980 		bne	.L234
 4821              	.L217:
2255:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2256:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Obtención del IE Content (rztime).
2257:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4822              		.loc 1 2257 0
 4823 2146 BB68     		ldr	r3, [r7, #8]
 4824 2148 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 4825 214a FB68     		ldr	r3, [r7, #12]
 4826 214c 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4827 214e 9A42     		cmp	r2, r3
 4828 2150 00F28480 		bhi	.L235
 4829              	.L218:
2258:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2259:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_8b1 = *((uint8_t*)(msg->payload)+ieee802514_header->headerLength);
 4830              		.loc 1 2259 0
 4831 2154 FB68     		ldr	r3, [r7, #12]
 4832 2156 5A68     		ldr	r2, [r3, #4]
 4833 2158 BB68     		ldr	r3, [r7, #8]
 4834 215a 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4835 215c D318     		adds	r3, r2, r3
 4836 215e 1B78     		ldrb	r3, [r3, #0]
 4837 2160 3B75     		strb	r3, [r7, #20]
2260:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 1;
 4838              		.loc 1 2260 0
 4839 2162 BB68     		ldr	r3, [r7, #8]
 4840 2164 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4841 2166 03F10103 		add	r3, r3, #1
 4842 216a DAB2     		uxtb	r2, r3
 4843 216c BB68     		ldr	r3, [r7, #8]
 4844 216e 5A70     		strb	r2, [r3, #1]
2261:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2262:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_8b2 = *((uint8_t*)(msg->payload)+ieee802514_header->headerLength);
 4845              		.loc 1 2262 0
 4846 2170 FB68     		ldr	r3, [r7, #12]
 4847 2172 5A68     		ldr	r2, [r3, #4]
 4848 2174 BB68     		ldr	r3, [r7, #8]
 4849 2176 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4850 2178 D318     		adds	r3, r2, r3
 4851 217a 1B78     		ldrb	r3, [r3, #0]
 4852 217c FB74     		strb	r3, [r7, #19]
2263:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 1;
 4853              		.loc 1 2263 0
 4854 217e BB68     		ldr	r3, [r7, #8]
 4855 2180 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4856 2182 03F10103 		add	r3, r3, #1
 4857 2186 DAB2     		uxtb	r2, r3
 4858 2188 BB68     		ldr	r3, [r7, #8]
 4859 218a 5A70     		strb	r2, [r3, #1]
2264:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2265:openstack/02a-MAClow/IEEE802154Ecsl.c ****    (*rztime) = (temp_8b2 << 8) | temp_8b1;
 4860              		.loc 1 2265 0
 4861 218c FB7C     		ldrb	r3, [r7, #19]	@ zero_extendqisi2
 4862 218e 4FEA0323 		lsl	r3, r3, #8
 4863 2192 9AB2     		uxth	r2, r3
 4864 2194 3B7D     		ldrb	r3, [r7, #20]	@ zero_extendqisi2
 4865 2196 9BB2     		uxth	r3, r3
 4866 2198 1343     		orrs	r3, r3, r2
 4867 219a 9BB2     		uxth	r3, r3
 4868 219c 9AB2     		uxth	r2, r3
 4869 219e 7B68     		ldr	r3, [r7, #4]
 4870 21a0 1A80     		strh	r2, [r3, #0]	@ movhi
2266:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2267:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // 5.- IE List Terminator, formado por 2 bytes con la siguiente estructura (0x3F80 o 0x3F00)
2268:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  - b0-b6 (Length) = 0
2269:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  - b7-b14 (Element ID) = 0x7e o 0x7f
2270:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  - b15 (Type) = 0
2271:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2272:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  b15 | b14 | b13 | b12 | b11 | b10 | b9 | b8 | b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 |
2273:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   0  |  0  |  1  |  1  |  1  |  1  | 1  | 1  |  0 |  0 |  0 |  0 |  0 |  0 |  0 |  0 |
2274:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2275:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4871              		.loc 1 2275 0
 4872 21a2 BB68     		ldr	r3, [r7, #8]
 4873 21a4 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 4874 21a6 FB68     		ldr	r3, [r7, #12]
 4875 21a8 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4876 21aa 9A42     		cmp	r2, r3
 4877 21ac 58D8     		bhi	.L236
 4878              	.L219:
2276:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2277:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Verificamos longitud a valor 0 y el elementID a valor 0x7E o 0x7F. Lo hacemos leyendo los 2 b
2278:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_8b1 = *((uint8_t*)(msg->payload)+ieee802514_header->headerLength);
 4879              		.loc 1 2278 0
 4880 21ae FB68     		ldr	r3, [r7, #12]
 4881 21b0 5A68     		ldr	r2, [r3, #4]
 4882 21b2 BB68     		ldr	r3, [r7, #8]
 4883 21b4 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4884 21b6 D318     		adds	r3, r2, r3
 4885 21b8 1B78     		ldrb	r3, [r3, #0]
 4886 21ba 3B75     		strb	r3, [r7, #20]
2279:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 1;
 4887              		.loc 1 2279 0
 4888 21bc BB68     		ldr	r3, [r7, #8]
 4889 21be 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4890 21c0 03F10103 		add	r3, r3, #1
 4891 21c4 DAB2     		uxtb	r2, r3
 4892 21c6 BB68     		ldr	r3, [r7, #8]
 4893 21c8 5A70     		strb	r2, [r3, #1]
2280:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2281:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_8b2 = *((uint8_t*)(msg->payload)+ieee802514_header->headerLength);
 4894              		.loc 1 2281 0
 4895 21ca FB68     		ldr	r3, [r7, #12]
 4896 21cc 5A68     		ldr	r2, [r3, #4]
 4897 21ce BB68     		ldr	r3, [r7, #8]
 4898 21d0 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4899 21d2 D318     		adds	r3, r2, r3
 4900 21d4 1B78     		ldrb	r3, [r3, #0]
 4901 21d6 FB74     		strb	r3, [r7, #19]
2282:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 1;
 4902              		.loc 1 2282 0
 4903 21d8 BB68     		ldr	r3, [r7, #8]
 4904 21da 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4905 21dc 03F10103 		add	r3, r3, #1
 4906 21e0 DAB2     		uxtb	r2, r3
 4907 21e2 BB68     		ldr	r3, [r7, #8]
 4908 21e4 5A70     		strb	r2, [r3, #1]
2283:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2284:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_16b = (temp_8b2 << 8) | temp_8b1;
 4909              		.loc 1 2284 0
 4910 21e6 FB7C     		ldrb	r3, [r7, #19]	@ zero_extendqisi2
 4911 21e8 4FEA0323 		lsl	r3, r3, #8
 4912 21ec 9AB2     		uxth	r2, r3
 4913 21ee 3B7D     		ldrb	r3, [r7, #20]	@ zero_extendqisi2
 4914 21f0 9BB2     		uxth	r3, r3
 4915 21f2 1343     		orrs	r3, r3, r2
 4916 21f4 9BB2     		uxth	r3, r3
 4917 21f6 3B82     		strh	r3, [r7, #16]	@ movhi
2285:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2286:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Comprobación de longitud a valor 0.
2287:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (temp_16b & 0x007f) { return; }
 4918              		.loc 1 2287 0
 4919 21f8 3B8A     		ldrh	r3, [r7, #16]
 4920 21fa 03F07F03 		and	r3, r3, #127
 4921 21fe 002B     		cmp	r3, #0
 4922 2200 30D1     		bne	.L237
 4923              	.L220:
2288:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2289:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Comprobación de element ID = 0x7E o 0x7F.
2290:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (((temp_16b >> 7) != 0x7e) && ((temp_16b >> 7) != 0x7f)) { return; }
 4924              		.loc 1 2290 0
 4925 2202 3B8A     		ldrh	r3, [r7, #16]
 4926 2204 4FEAD313 		lsr	r3, r3, #7
 4927 2208 9BB2     		uxth	r3, r3
 4928 220a 7E2B     		cmp	r3, #126
 4929 220c 05D0     		beq	.L221
 4930              		.loc 1 2290 0 is_stmt 0 discriminator 1
 4931 220e 3B8A     		ldrh	r3, [r7, #16]
 4932 2210 4FEAD313 		lsr	r3, r3, #7
 4933 2214 9BB2     		uxth	r3, r3
 4934 2216 7F2B     		cmp	r3, #127
 4935 2218 26D1     		bne	.L238
 4936              	.L221:
2291:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2292:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Comprobación del type = 0.
2293:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b >> 15) & 0x0001) { return; }
 4937              		.loc 1 2293 0 is_stmt 1
 4938 221a 3B8A     		ldrh	r3, [r7, #16]
 4939 221c 4FEAD333 		lsr	r3, r3, #15
 4940 2220 9BB2     		uxth	r3, r3
 4941 2222 03F00103 		and	r3, r3, #1
 4942 2226 002B     		cmp	r3, #0
 4943 2228 20D1     		bne	.L239
 4944              	.L222:
2294:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2295:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Por ultimo y en el caso de haber llegado aquí, consideramos la cabecera como válida.
2296:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->valid=TRUE;
 4945              		.loc 1 2296 0
 4946 222a BB68     		ldr	r3, [r7, #8]
 4947 222c 4FF00102 		mov	r2, #1
 4948 2230 1A70     		strb	r2, [r3, #0]
 4949 2232 1CE0     		b	.L202
 4950              	.L225:
2146:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; }
 4951              		.loc 1 2146 0
 4952 2234 00BF     		nop
 4953 2236 1AE0     		b	.L202
 4954              	.L226:
2163:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->frameType != IEEE154_TYPE_MULTIPURPOSE) {return; }
 4955              		.loc 1 2163 0
 4956 2238 00BF     		nop
 4957 223a 18E0     		b	.L202
 4958              	.L227:
2166:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_8b >> 3) & 0x01) { return; }
 4959              		.loc 1 2166 0
 4960 223c 00BF     		nop
 4961 223e 16E0     		b	.L202
 4962              	.L228:
2210:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4963              		.loc 1 2210 0
 4964 2240 00BF     		nop
 4965 2242 14E0     		b	.L202
 4966              	.L229:
2215:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4967              		.loc 1 2215 0
 4968 2244 00BF     		nop
 4969 2246 12E0     		b	.L202
 4970              	.L230:
2220:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4971              		.loc 1 2220 0
 4972 2248 00BF     		nop
 4973 224a 10E0     		b	.L202
 4974              	.L231:
2236:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) {  return; } // no more to read!
 4975              		.loc 1 2236 0
 4976 224c 00BF     		nop
 4977 224e 0EE0     		b	.L202
 4978              	.L232:
2248:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b & 0x007f) != 2) { return; }
 4979              		.loc 1 2248 0
 4980 2250 00BF     		nop
 4981 2252 0CE0     		b	.L202
 4982              	.L233:
2251:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b >> 7) != 0x001d) { return; }
 4983              		.loc 1 2251 0
 4984 2254 00BF     		nop
 4985 2256 0AE0     		b	.L202
 4986              	.L234:
2254:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b >> 15) & 0x0001) { return; }
 4987              		.loc 1 2254 0
 4988 2258 00BF     		nop
 4989 225a 08E0     		b	.L202
 4990              	.L235:
2257:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4991              		.loc 1 2257 0
 4992 225c 00BF     		nop
 4993 225e 06E0     		b	.L202
 4994              	.L236:
2275:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4995              		.loc 1 2275 0
 4996 2260 00BF     		nop
 4997 2262 04E0     		b	.L202
 4998              	.L237:
2287:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (temp_16b & 0x007f) { return; }
 4999              		.loc 1 2287 0
 5000 2264 00BF     		nop
 5001 2266 02E0     		b	.L202
 5002              	.L238:
2290:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (((temp_16b >> 7) != 0x7e) && ((temp_16b >> 7) != 0x7f)) { return; }
 5003              		.loc 1 2290 0
 5004 2268 00BF     		nop
 5005 226a 00E0     		b	.L202
 5006              	.L239:
2293:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b >> 15) & 0x0001) { return; }
 5007              		.loc 1 2293 0
 5008 226c 00BF     		nop
 5009              	.L202:
2297:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5010              		.loc 1 2297 0
 5011 226e 07F11807 		add	r7, r7, #24
 5012 2272 BD46     		mov	sp, r7
 5013 2274 80BD     		pop	{r7, pc}
 5014              		.cfi_endproc
 5015              	.LFE54:
 5017 2276 00BF     		.align	2
 5018              		.global	isValidRxFrame
 5019              		.thumb
 5020              		.thumb_func
 5022              	isValidRxFrame:
 5023              	.LFB55:
2298:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2299:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2300:openstack/02a-MAClow/IEEE802154Ecsl.c **** //====================  FRAME VALIDITY CHECK ===========================
2301:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2302:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2303:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2304:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Decides whether the packet I just received is valid received frame.
2305:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2306:openstack/02a-MAClow/IEEE802154Ecsl.c **** A valid Rx frame satisfies the following constraints:
2307:openstack/02a-MAClow/IEEE802154Ecsl.c **** - its IEEE802.15.4 header is well formatted
2308:openstack/02a-MAClow/IEEE802154Ecsl.c **** - it's a DATA of BEACON frame (i.e. not ACK and not COMMAND)
2309:openstack/02a-MAClow/IEEE802154Ecsl.c **** - it's sent on the same PANid as mine
2310:openstack/02a-MAClow/IEEE802154Ecsl.c **** - it's for me (unicast or broadcast)
2311:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2312:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in] ieee802514_header IEEE802.15.4 header of the packet I just received
2313:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2314:openstack/02a-MAClow/IEEE802154Ecsl.c **** \returns TRUE if packet is valid received frame, FALSE otherwise
2315:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2316:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE bool isValidRxFrame(ieee802154_header_iht* ieee802514_header) {
 5024              		.loc 1 2316 0
 5025              		.cfi_startproc
 5026              		@ args = 0, pretend = 0, frame = 8
 5027              		@ frame_needed = 1, uses_anonymous_args = 0
 5028 2278 90B5     		push	{r4, r7, lr}
 5029              	.LCFI130:
 5030              		.cfi_def_cfa_offset 12
 5031              		.cfi_offset 4, -12
 5032              		.cfi_offset 7, -8
 5033              		.cfi_offset 14, -4
 5034 227a 83B0     		sub	sp, sp, #12
 5035              	.LCFI131:
 5036              		.cfi_def_cfa_offset 24
 5037 227c 00AF     		add	r7, sp, #0
 5038              	.LCFI132:
 5039              		.cfi_def_cfa_register 7
 5040 227e 7860     		str	r0, [r7, #4]
2317:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee802514_header->valid==TRUE                                                           
 5041              		.loc 1 2317 0
 5042 2280 7B68     		ldr	r3, [r7, #4]
 5043 2282 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
2318:openstack/02a-MAClow/IEEE802154Ecsl.c ****           (
2319:openstack/02a-MAClow/IEEE802154Ecsl.c ****              ieee802514_header->frameType==IEEE154_TYPE_DATA                   ||
2320:openstack/02a-MAClow/IEEE802154Ecsl.c ****              ieee802514_header->frameType==IEEE154_TYPE_BEACON
2321:openstack/02a-MAClow/IEEE802154Ecsl.c ****           )                                                                                        
2322:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
 5044              		.loc 1 2322 0
 5045 2284 002B     		cmp	r3, #0
 5046 2286 2BD0     		beq	.L241
2319:openstack/02a-MAClow/IEEE802154Ecsl.c ****              ieee802514_header->frameType==IEEE154_TYPE_DATA                   ||
 5047              		.loc 1 2319 0
 5048 2288 7B68     		ldr	r3, [r7, #4]
 5049 228a 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
2317:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee802514_header->valid==TRUE                                                           
 5050              		.loc 1 2317 0
 5051 228c 012B     		cmp	r3, #1
 5052 228e 03D0     		beq	.L242
2320:openstack/02a-MAClow/IEEE802154Ecsl.c ****              ieee802514_header->frameType==IEEE154_TYPE_BEACON
 5053              		.loc 1 2320 0
 5054 2290 7B68     		ldr	r3, [r7, #4]
 5055 2292 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
2319:openstack/02a-MAClow/IEEE802154Ecsl.c ****              ieee802514_header->frameType==IEEE154_TYPE_DATA                   ||
 5056              		.loc 1 2319 0
 5057 2294 002B     		cmp	r3, #0
 5058 2296 23D1     		bne	.L241
 5059              	.L242:
 5060              		.loc 1 2322 0
 5061 2298 7B68     		ldr	r3, [r7, #4]
 5062 229a 03F10A04 		add	r4, r3, #10
 5063 229e 4FF00400 		mov	r0, #4
 5064 22a2 FFF7FEFF 		bl	idmanager_getMyID
 5065 22a6 0346     		mov	r3, r0
 5066 22a8 2046     		mov	r0, r4
 5067 22aa 1946     		mov	r1, r3
 5068 22ac FFF7FEFF 		bl	packetfunctions_sameAddress
 5069 22b0 0346     		mov	r3, r0
2321:openstack/02a-MAClow/IEEE802154Ecsl.c ****           )                                                                                        
 5070              		.loc 1 2321 0
 5071 22b2 002B     		cmp	r3, #0
 5072 22b4 14D0     		beq	.L241
2323:openstack/02a-MAClow/IEEE802154Ecsl.c ****           (
2324:openstack/02a-MAClow/IEEE802154Ecsl.c ****              idmanager_isMyAddress(&ieee802514_header->dest)                   ||
 5073              		.loc 1 2324 0
 5074 22b6 7B68     		ldr	r3, [r7, #4]
 5075 22b8 03F11B03 		add	r3, r3, #27
 5076 22bc 1846     		mov	r0, r3
 5077 22be FFF7FEFF 		bl	idmanager_isMyAddress
 5078 22c2 0346     		mov	r3, r0
2322:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
 5079              		.loc 1 2322 0
 5080 22c4 002B     		cmp	r3, #0
 5081 22c6 08D1     		bne	.L243
2325:openstack/02a-MAClow/IEEE802154Ecsl.c ****              packetfunctions_isBroadcastMulticast(&ieee802514_header->dest)
 5082              		.loc 1 2325 0
 5083 22c8 7B68     		ldr	r3, [r7, #4]
 5084 22ca 03F11B03 		add	r3, r3, #27
 5085 22ce 1846     		mov	r0, r3
 5086 22d0 FFF7FEFF 		bl	packetfunctions_isBroadcastMulticast
 5087 22d4 0346     		mov	r3, r0
2324:openstack/02a-MAClow/IEEE802154Ecsl.c ****              idmanager_isMyAddress(&ieee802514_header->dest)                   ||
 5088              		.loc 1 2324 0
 5089 22d6 002B     		cmp	r3, #0
 5090 22d8 02D0     		beq	.L241
 5091              	.L243:
2322:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
 5092              		.loc 1 2322 0 discriminator 2
 5093 22da 4FF00103 		mov	r3, #1
 5094 22de 01E0     		b	.L244
 5095              	.L241:
2322:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
 5096              		.loc 1 2322 0 is_stmt 0 discriminator 1
 5097 22e0 4FF00003 		mov	r3, #0
 5098              	.L244:
2317:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee802514_header->valid==TRUE                                                           
 5099              		.loc 1 2317 0 is_stmt 1
 5100 22e4 03F00103 		and	r3, r3, #1
 5101 22e8 DBB2     		uxtb	r3, r3
2326:openstack/02a-MAClow/IEEE802154Ecsl.c ****           );
2327:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5102              		.loc 1 2327 0
 5103 22ea 1846     		mov	r0, r3
 5104 22ec 07F10C07 		add	r7, r7, #12
 5105 22f0 BD46     		mov	sp, r7
 5106 22f2 90BD     		pop	{r4, r7, pc}
 5107              		.cfi_endproc
 5108              	.LFE55:
 5110              		.align	2
 5111              		.global	isValidAck
 5112              		.thumb
 5113              		.thumb_func
 5115              	isValidAck:
 5116              	.LFB56:
2328:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2329:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2330:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Decides whether the packet I just received is a valid ACK.
2331:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2332:openstack/02a-MAClow/IEEE802154Ecsl.c **** A packet is a valid ACK if it satisfies the following conditions:
2333:openstack/02a-MAClow/IEEE802154Ecsl.c **** - the IEEE802.15.4 header is valid
2334:openstack/02a-MAClow/IEEE802154Ecsl.c **** - the frame type is 'ACK'
2335:openstack/02a-MAClow/IEEE802154Ecsl.c **** - the sequence number in the ACK matches the sequence number of the packet sent
2336:openstack/02a-MAClow/IEEE802154Ecsl.c **** - the ACK contains my PANid
2337:openstack/02a-MAClow/IEEE802154Ecsl.c **** - the packet is unicast to me
2338:openstack/02a-MAClow/IEEE802154Ecsl.c **** - the packet comes from the neighbor I sent the data to
2339:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2340:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in] ieee802514_header IEEE802.15.4 header of the packet I just received
2341:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in] packetSent points to the packet I just sent
2342:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2343:openstack/02a-MAClow/IEEE802154Ecsl.c **** \returns TRUE if packet is a valid ACK, FALSE otherwise.
2344:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2345:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE bool isValidAck(ieee802154_header_iht* ieee802514_header, OpenQueueEntry_t* packetSent)
 5117              		.loc 1 2345 0
 5118              		.cfi_startproc
 5119              		@ args = 0, pretend = 0, frame = 8
 5120              		@ frame_needed = 1, uses_anonymous_args = 0
 5121 22f4 90B5     		push	{r4, r7, lr}
 5122              	.LCFI133:
 5123              		.cfi_def_cfa_offset 12
 5124              		.cfi_offset 4, -12
 5125              		.cfi_offset 7, -8
 5126              		.cfi_offset 14, -4
 5127 22f6 83B0     		sub	sp, sp, #12
 5128              	.LCFI134:
 5129              		.cfi_def_cfa_offset 24
 5130 22f8 00AF     		add	r7, sp, #0
 5131              	.LCFI135:
 5132              		.cfi_def_cfa_register 7
 5133 22fa 7860     		str	r0, [r7, #4]
 5134 22fc 3960     		str	r1, [r7, #0]
2346:openstack/02a-MAClow/IEEE802154Ecsl.c ****    /*
2347:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee802514_header->valid==TRUE                                                           
2348:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header->frameType==IEEE154_TYPE_ACK                                           
2349:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header->dsn==packetSent->l2_dsn                                               
2350:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
2351:openstack/02a-MAClow/IEEE802154Ecsl.c ****           idmanager_isMyAddress(&ieee802514_header->dest)                                          
2352:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->src,&packetSent->l2_nextORpreviousHop);
2353:openstack/02a-MAClow/IEEE802154Ecsl.c ****    */
2354:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // poipoi don't check for seq num
2355:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee802514_header->valid==TRUE                                                           
 5135              		.loc 1 2355 0
 5136 22fe 7B68     		ldr	r3, [r7, #4]
 5137 2300 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
2356:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header->frameType==IEEE154_TYPE_ACK                                           
2357:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
2358:openstack/02a-MAClow/IEEE802154Ecsl.c ****           idmanager_isMyAddress(&ieee802514_header->dest)                                          
 5138              		.loc 1 2358 0
 5139 2302 002B     		cmp	r3, #0
 5140 2304 2BD0     		beq	.L247
2356:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header->frameType==IEEE154_TYPE_ACK                                           
 5141              		.loc 1 2356 0
 5142 2306 7B68     		ldr	r3, [r7, #4]
 5143 2308 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
2355:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee802514_header->valid==TRUE                                                           
 5144              		.loc 1 2355 0
 5145 230a 022B     		cmp	r3, #2
 5146 230c 27D1     		bne	.L247
2357:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
 5147              		.loc 1 2357 0
 5148 230e 7B68     		ldr	r3, [r7, #4]
 5149 2310 03F10A04 		add	r4, r3, #10
 5150 2314 4FF00400 		mov	r0, #4
 5151 2318 FFF7FEFF 		bl	idmanager_getMyID
 5152 231c 0346     		mov	r3, r0
 5153 231e 2046     		mov	r0, r4
 5154 2320 1946     		mov	r1, r3
 5155 2322 FFF7FEFF 		bl	packetfunctions_sameAddress
 5156 2326 0346     		mov	r3, r0
2356:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header->frameType==IEEE154_TYPE_ACK                                           
 5157              		.loc 1 2356 0
 5158 2328 002B     		cmp	r3, #0
 5159 232a 18D0     		beq	.L247
 5160              		.loc 1 2358 0
 5161 232c 7B68     		ldr	r3, [r7, #4]
 5162 232e 03F11B03 		add	r3, r3, #27
 5163 2332 1846     		mov	r0, r3
 5164 2334 FFF7FEFF 		bl	idmanager_isMyAddress
 5165 2338 0346     		mov	r3, r0
2357:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
 5166              		.loc 1 2357 0
 5167 233a 002B     		cmp	r3, #0
 5168 233c 0FD0     		beq	.L247
2359:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->src,&packetSent->l2_nextORpreviousHop);
 5169              		.loc 1 2359 0
 5170 233e 7B68     		ldr	r3, [r7, #4]
 5171 2340 03F12C02 		add	r2, r3, #44
 5172 2344 3B68     		ldr	r3, [r7, #0]
 5173 2346 03F13803 		add	r3, r3, #56
 5174 234a 1046     		mov	r0, r2
 5175 234c 1946     		mov	r1, r3
 5176 234e FFF7FEFF 		bl	packetfunctions_sameAddress
 5177 2352 0346     		mov	r3, r0
2358:openstack/02a-MAClow/IEEE802154Ecsl.c ****           idmanager_isMyAddress(&ieee802514_header->dest)                                          
 5178              		.loc 1 2358 0
 5179 2354 002B     		cmp	r3, #0
 5180 2356 02D0     		beq	.L247
2358:openstack/02a-MAClow/IEEE802154Ecsl.c ****           idmanager_isMyAddress(&ieee802514_header->dest)                                          
 5181              		.loc 1 2358 0 is_stmt 0 discriminator 2
 5182 2358 4FF00103 		mov	r3, #1
 5183 235c 01E0     		b	.L248
 5184              	.L247:
2358:openstack/02a-MAClow/IEEE802154Ecsl.c ****           idmanager_isMyAddress(&ieee802514_header->dest)                                          
 5185              		.loc 1 2358 0 discriminator 1
 5186 235e 4FF00003 		mov	r3, #0
 5187              	.L248:
2355:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee802514_header->valid==TRUE                                                           
 5188              		.loc 1 2355 0 is_stmt 1
 5189 2362 03F00103 		and	r3, r3, #1
 5190 2366 DBB2     		uxtb	r3, r3
2360:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5191              		.loc 1 2360 0
 5192 2368 1846     		mov	r0, r3
 5193 236a 07F10C07 		add	r7, r7, #12
 5194 236e BD46     		mov	sp, r7
 5195 2370 90BD     		pop	{r4, r7, pc}
 5196              		.cfi_endproc
 5197              	.LFE56:
 5199 2372 00BF     		.align	2
 5200              		.global	incrementAsnOffset
 5201              		.thumb
 5202              		.thumb_func
 5204              	incrementAsnOffset:
 5205              	.LFB57:
2361:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2362:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2363:openstack/02a-MAClow/IEEE802154Ecsl.c **** //========================  ASN HANDLING ===============================
2364:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2365:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2366:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void incrementAsnOffset() {
 5206              		.loc 1 2366 0
 5207              		.cfi_startproc
 5208              		@ args = 0, pretend = 0, frame = 0
 5209              		@ frame_needed = 1, uses_anonymous_args = 0
 5210 2374 98B5     		push	{r3, r4, r7, lr}
 5211              	.LCFI136:
 5212              		.cfi_def_cfa_offset 16
 5213              		.cfi_offset 3, -16
 5214              		.cfi_offset 4, -12
 5215              		.cfi_offset 7, -8
 5216              		.cfi_offset 14, -4
 5217 2376 00AF     		add	r7, sp, #0
 5218              	.LCFI137:
 5219              		.cfi_def_cfa_register 7
2367:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // increment the asn
2368:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asn.bytes0and1++;
 5220              		.loc 1 2368 0
 5221 2378 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5222 237c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5223 2380 B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 5224 2384 9BB2     		uxth	r3, r3
 5225 2386 03F10103 		add	r3, r3, #1
 5226 238a 9AB2     		uxth	r2, r3
 5227 238c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5228 2390 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5229 2394 A3F80320 		strh	r2, [r3, #3]	@ unaligned
2369:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.asn.bytes0and1==0) {
 5230              		.loc 1 2369 0
 5231 2398 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5232 239c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5233 23a0 B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 5234 23a4 9BB2     		uxth	r3, r3
 5235 23a6 002B     		cmp	r3, #0
 5236 23a8 25D1     		bne	.L251
2370:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.asn.bytes2and3++;
 5237              		.loc 1 2370 0
 5238 23aa 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5239 23ae C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5240 23b2 B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 5241 23b6 9BB2     		uxth	r3, r3
 5242 23b8 03F10103 		add	r3, r3, #1
 5243 23bc 9AB2     		uxth	r2, r3
 5244 23be 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5245 23c2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5246 23c6 A3F80120 		strh	r2, [r3, #1]	@ unaligned
2371:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.asn.bytes2and3==0) {
 5247              		.loc 1 2371 0
 5248 23ca 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5249 23ce C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5250 23d2 B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 5251 23d6 9BB2     		uxth	r3, r3
 5252 23d8 002B     		cmp	r3, #0
 5253 23da 0CD1     		bne	.L251
2372:openstack/02a-MAClow/IEEE802154Ecsl.c ****          ieee154e_vars.asn.byte4++;
 5254              		.loc 1 2372 0
 5255 23dc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5256 23e0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5257 23e4 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 5258 23e6 03F10103 		add	r3, r3, #1
 5259 23ea DAB2     		uxtb	r2, r3
 5260 23ec 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5261 23f0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5262 23f4 1A70     		strb	r2, [r3, #0]
 5263              	.L251:
2373:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
2374:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2375:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // increment the offsets: Comment slot offset update.
2376:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.slotOffset  = (ieee154e_vars.slotOffset+1)%schedule_getFrameLength();
 5264              		.loc 1 2376 0
 5265 23f6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5266 23fa C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5267 23fe DB88     		ldrh	r3, [r3, #6]
 5268 2400 03F10104 		add	r4, r3, #1
 5269 2404 FFF7FEFF 		bl	schedule_getFrameLength
 5270 2408 0346     		mov	r3, r0
 5271 240a 94FBF3F2 		sdiv	r2, r4, r3
 5272 240e 03FB02F3 		mul	r3, r3, r2
 5273 2412 E31A     		subs	r3, r4, r3
 5274 2414 9AB2     		uxth	r2, r3
 5275 2416 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5276 241a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5277 241e DA80     		strh	r2, [r3, #6]	@ movhi
2377:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asnOffset   = (ieee154e_vars.asnOffset+1)%16;
 5278              		.loc 1 2377 0
 5279 2420 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5280 2424 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5281 2428 93F82D30 		ldrb	r3, [r3, #45]	@ zero_extendqisi2
 5282 242c 03F10102 		add	r2, r3, #1
 5283 2430 4FF00F03 		mov	r3, #15
 5284 2434 C8F20003 		movt	r3, 32768
 5285 2438 1340     		ands	r3, r3, r2
 5286 243a 002B     		cmp	r3, #0
 5287 243c 05DA     		bge	.L252
 5288 243e 03F1FF33 		add	r3, r3, #-1
 5289 2442 63F00F03 		orn	r3, r3, #15
 5290 2446 03F10103 		add	r3, r3, #1
 5291              	.L252:
 5292 244a DAB2     		uxtb	r2, r3
 5293 244c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5294 2450 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5295 2454 83F82D20 		strb	r2, [r3, #45]
2378:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5296              		.loc 1 2378 0
 5297 2458 98BD     		pop	{r3, r4, r7, pc}
 5298              		.cfi_endproc
 5299              	.LFE57:
 5301 245a 00BF     		.align	2
 5302              		.global	ieee154e_getAsn
 5303              		.thumb
 5304              		.thumb_func
 5306              	ieee154e_getAsn:
 5307              	.LFB58:
2379:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2380:openstack/02a-MAClow/IEEE802154Ecsl.c **** //from upper layer that want to send the ASN to compute timing or latency
2381:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void ieee154e_getAsn(uint8_t* array) {
 5308              		.loc 1 2381 0
 5309              		.cfi_startproc
 5310              		@ args = 0, pretend = 0, frame = 8
 5311              		@ frame_needed = 1, uses_anonymous_args = 0
 5312              		@ link register save eliminated.
 5313 245c 80B4     		push	{r7}
 5314              	.LCFI138:
 5315              		.cfi_def_cfa_offset 4
 5316              		.cfi_offset 7, -4
 5317 245e 83B0     		sub	sp, sp, #12
 5318              	.LCFI139:
 5319              		.cfi_def_cfa_offset 16
 5320 2460 00AF     		add	r7, sp, #0
 5321              	.LCFI140:
 5322              		.cfi_def_cfa_register 7
 5323 2462 7860     		str	r0, [r7, #4]
2382:openstack/02a-MAClow/IEEE802154Ecsl.c ****    array[0]         = (ieee154e_vars.asn.bytes0and1     & 0xff);
 5324              		.loc 1 2382 0
 5325 2464 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5326 2468 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5327 246c B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 5328 2470 9BB2     		uxth	r3, r3
 5329 2472 DAB2     		uxtb	r2, r3
 5330 2474 7B68     		ldr	r3, [r7, #4]
 5331 2476 1A70     		strb	r2, [r3, #0]
2383:openstack/02a-MAClow/IEEE802154Ecsl.c ****    array[1]         = (ieee154e_vars.asn.bytes0and1/256 & 0xff);
 5332              		.loc 1 2383 0
 5333 2478 7B68     		ldr	r3, [r7, #4]
 5334 247a 03F10102 		add	r2, r3, #1
 5335 247e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5336 2482 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5337 2486 B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 5338 248a 9BB2     		uxth	r3, r3
 5339 248c 4FEA1323 		lsr	r3, r3, #8
 5340 2490 9BB2     		uxth	r3, r3
 5341 2492 DBB2     		uxtb	r3, r3
 5342 2494 1370     		strb	r3, [r2, #0]
2384:openstack/02a-MAClow/IEEE802154Ecsl.c ****    array[2]         = (ieee154e_vars.asn.bytes2and3     & 0xff);
 5343              		.loc 1 2384 0
 5344 2496 7B68     		ldr	r3, [r7, #4]
 5345 2498 03F10202 		add	r2, r3, #2
 5346 249c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5347 24a0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5348 24a4 B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 5349 24a8 9BB2     		uxth	r3, r3
 5350 24aa DBB2     		uxtb	r3, r3
 5351 24ac 1370     		strb	r3, [r2, #0]
2385:openstack/02a-MAClow/IEEE802154Ecsl.c ****    array[3]         = (ieee154e_vars.asn.bytes2and3/256 & 0xff);
 5352              		.loc 1 2385 0
 5353 24ae 7B68     		ldr	r3, [r7, #4]
 5354 24b0 03F10302 		add	r2, r3, #3
 5355 24b4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5356 24b8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5357 24bc B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 5358 24c0 9BB2     		uxth	r3, r3
 5359 24c2 4FEA1323 		lsr	r3, r3, #8
 5360 24c6 9BB2     		uxth	r3, r3
 5361 24c8 DBB2     		uxtb	r3, r3
 5362 24ca 1370     		strb	r3, [r2, #0]
2386:openstack/02a-MAClow/IEEE802154Ecsl.c ****    array[4]         =  ieee154e_vars.asn.byte4;
 5363              		.loc 1 2386 0
 5364 24cc 7B68     		ldr	r3, [r7, #4]
 5365 24ce 03F10402 		add	r2, r3, #4
 5366 24d2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5367 24d6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5368 24da 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 5369 24dc 1370     		strb	r3, [r2, #0]
2387:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5370              		.loc 1 2387 0
 5371 24de 07F10C07 		add	r7, r7, #12
 5372 24e2 BD46     		mov	sp, r7
 5373 24e4 80BC     		pop	{r7}
 5374 24e6 7047     		bx	lr
 5375              		.cfi_endproc
 5376              	.LFE58:
 5378              		.align	2
 5379              		.global	synchronizeAck
 5380              		.thumb
 5381              		.thumb_func
 5383              	synchronizeAck:
 5384              	.LFB59:
2388:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2389:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2390:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================  SYNCHRONIZATION ==============================
2391:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2392:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2393:openstack/02a-MAClow/IEEE802154Ecsl.c **** void synchronizeAck(PORT_SIGNED_INT_WIDTH timeCorrection) {
 5385              		.loc 1 2393 0
 5386              		.cfi_startproc
 5387              		@ args = 0, pretend = 0, frame = 16
 5388              		@ frame_needed = 1, uses_anonymous_args = 0
 5389 24e8 90B5     		push	{r4, r7, lr}
 5390              	.LCFI141:
 5391              		.cfi_def_cfa_offset 12
 5392              		.cfi_offset 4, -12
 5393              		.cfi_offset 7, -8
 5394              		.cfi_offset 14, -4
 5395 24ea 87B0     		sub	sp, sp, #28
 5396              	.LCFI142:
 5397              		.cfi_def_cfa_offset 40
 5398 24ec 02AF     		add	r7, sp, #8
 5399              	.LCFI143:
 5400              		.cfi_def_cfa 7, 32
 5401 24ee 7860     		str	r0, [r7, #4]
2394:openstack/02a-MAClow/IEEE802154Ecsl.c ****    PORT_RADIOTIMER_WIDTH newPeriod;
2395:openstack/02a-MAClow/IEEE802154Ecsl.c ****    PORT_RADIOTIMER_WIDTH currentPeriod;
2396:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
2397:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // calculate new period
2398:openstack/02a-MAClow/IEEE802154Ecsl.c ****    currentPeriod                  =  radio_getTimerPeriod();
 5402              		.loc 1 2398 0
 5403 24f0 FFF7FEFF 		bl	radio_getTimerPeriod
 5404 24f4 F860     		str	r0, [r7, #12]
2399:openstack/02a-MAClow/IEEE802154Ecsl.c ****    newPeriod                      =  (PORT_RADIOTIMER_WIDTH)((PORT_SIGNED_INT_WIDTH)currentPeriod-t
 5405              		.loc 1 2399 0
 5406 24f6 FA68     		ldr	r2, [r7, #12]
 5407 24f8 7B68     		ldr	r3, [r7, #4]
 5408 24fa D31A     		subs	r3, r2, r3
 5409 24fc BB60     		str	r3, [r7, #8]
2400:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2401:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // resynchronize by applying the new period
2402:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_setTimerPeriod(newPeriod);
 5410              		.loc 1 2402 0
 5411 24fe B868     		ldr	r0, [r7, #8]
 5412 2500 FFF7FEFF 		bl	radio_setTimerPeriod
2403:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
2404:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // reset the de-synchronization timeout
2405:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.deSyncTimeout    = DESYNCTIMEOUT;
 5413              		.loc 1 2405 0
 5414 2504 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5415 2508 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5416 250c 40F61D12 		movw	r2, #2333
 5417 2510 DA60     		str	r2, [r3, #12]
2406:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
2407:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // indicate time correction to adaptive sync module
2408:openstack/02a-MAClow/IEEE802154Ecsl.c ****    adaptive_sync_indicateTimeCorrection((-timeCorrection),ieee154e_vars.ackReceived->l2_nextORprevi
 5418              		.loc 1 2408 0
 5419 2512 7B68     		ldr	r3, [r7, #4]
 5420 2514 9BB2     		uxth	r3, r3
 5421 2516 C3F10003 		rsb	r3, r3, #0
 5422 251a 9BB2     		uxth	r3, r3
 5423 251c 99B2     		uxth	r1, r3
 5424 251e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5425 2522 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5426 2526 1A6A     		ldr	r2, [r3, #32]
 5427 2528 0CB2     		sxth	r4, r1
 5428 252a 6B46     		mov	r3, sp
 5429 252c 02F14401 		add	r1, r2, #68
 5430 2530 03C9     		ldmia	r1, {r0, r1}
 5431 2532 1860     		str	r0, [r3, #0]
 5432 2534 03F10403 		add	r3, r3, #4
 5433 2538 1970     		strb	r1, [r3, #0]
 5434 253a 02F13803 		add	r3, r2, #56
 5435 253e 0ECB     		ldmia	r3, {r1, r2, r3}
 5436 2540 2046     		mov	r0, r4
 5437 2542 FFF7FEFF 		bl	adaptive_sync_indicateTimeCorrection
2409:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
2410:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log a large timeCorrection
2411:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (
2412:openstack/02a-MAClow/IEEE802154Ecsl.c ****          ieee154e_vars.isSync==TRUE &&
 5438              		.loc 1 2412 0
 5439 2546 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5440 254a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5441 254e 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
2411:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (
 5442              		.loc 1 2411 0
 5443 2550 002B     		cmp	r3, #0
 5444 2552 11D0     		beq	.L255
 5445              		.loc 1 2412 0
 5446 2554 7B68     		ldr	r3, [r7, #4]
 5447 2556 13F1050F 		cmn	r3, #5
 5448 255a 02DB     		blt	.L256
2413:openstack/02a-MAClow/IEEE802154Ecsl.c ****          (
2414:openstack/02a-MAClow/IEEE802154Ecsl.c ****             timeCorrection<-LIMITLARGETIMECORRECTION ||
 5449              		.loc 1 2414 0
 5450 255c 7B68     		ldr	r3, [r7, #4]
 5451 255e 052B     		cmp	r3, #5
 5452 2560 0ADD     		ble	.L255
 5453              	.L256:
2415:openstack/02a-MAClow/IEEE802154Ecsl.c ****             timeCorrection> LIMITLARGETIMECORRECTION
2416:openstack/02a-MAClow/IEEE802154Ecsl.c ****          )
2417:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ) {
2418:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openserial_printError(COMPONENT_IEEE802154E,ERR_LARGE_TIMECORRECTION,
 5454              		.loc 1 2418 0
 5455 2562 7B68     		ldr	r3, [r7, #4]
 5456 2564 9BB2     		uxth	r3, r3
 5457 2566 4FF00900 		mov	r0, #9
 5458 256a 4FF01C01 		mov	r1, #28
 5459 256e 1A46     		mov	r2, r3
 5460 2570 4FF00103 		mov	r3, #1
 5461 2574 FFF7FEFF 		bl	openserial_printError
 5462              	.L255:
2419:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)timeCorrection,
2420:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)1);
2421:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2422:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // update the stats
2423:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.numSyncAck++;
 5463              		.loc 1 2423 0
 5464 2578 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5465 257c C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5466 2580 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 5467 2582 03F10103 		add	r3, r3, #1
 5468 2586 DAB2     		uxtb	r2, r3
 5469 2588 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5470 258c C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5471 2590 5A70     		strb	r2, [r3, #1]
2424:openstack/02a-MAClow/IEEE802154Ecsl.c ****    updateStats(timeCorrection);
 5472              		.loc 1 2424 0
 5473 2592 7868     		ldr	r0, [r7, #4]
 5474 2594 FFF7FEFF 		bl	updateStats
2425:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
2426:openstack/02a-MAClow/IEEE802154Ecsl.c **** #ifdef OPENSIM
2427:openstack/02a-MAClow/IEEE802154Ecsl.c ****    debugpins_syncAck_set();
2428:openstack/02a-MAClow/IEEE802154Ecsl.c ****    debugpins_syncAck_clr();
2429:openstack/02a-MAClow/IEEE802154Ecsl.c **** #endif
2430:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5475              		.loc 1 2430 0
 5476 2598 07F11407 		add	r7, r7, #20
 5477 259c BD46     		mov	sp, r7
 5478 259e 90BD     		pop	{r4, r7, pc}
 5479              		.cfi_endproc
 5480              	.LFE59:
 5482              		.align	2
 5483              		.global	changeIsSync
 5484              		.thumb
 5485              		.thumb_func
 5487              	changeIsSync:
 5488              	.LFB60:
2431:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2432:openstack/02a-MAClow/IEEE802154Ecsl.c **** void changeIsSync(bool newIsSync) {
 5489              		.loc 1 2432 0
 5490              		.cfi_startproc
 5491              		@ args = 0, pretend = 0, frame = 8
 5492              		@ frame_needed = 1, uses_anonymous_args = 0
 5493 25a0 80B5     		push	{r7, lr}
 5494              	.LCFI144:
 5495              		.cfi_def_cfa_offset 8
 5496              		.cfi_offset 7, -8
 5497              		.cfi_offset 14, -4
 5498 25a2 82B0     		sub	sp, sp, #8
 5499              	.LCFI145:
 5500              		.cfi_def_cfa_offset 16
 5501 25a4 00AF     		add	r7, sp, #0
 5502              	.LCFI146:
 5503              		.cfi_def_cfa_register 7
 5504 25a6 0346     		mov	r3, r0
 5505 25a8 FB71     		strb	r3, [r7, #7]
2433:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.isSync = newIsSync;
 5506              		.loc 1 2433 0
 5507 25aa 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5508 25ae C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5509 25b2 FA79     		ldrb	r2, [r7, #7]
 5510 25b4 1A74     		strb	r2, [r3, #16]
2434:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
2435:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.isSync==TRUE) {
 5511              		.loc 1 2435 0
 5512 25b6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5513 25ba C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5514 25be 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
 5515 25c0 002B     		cmp	r3, #0
 5516 25c2 04D0     		beq	.L258
2436:openstack/02a-MAClow/IEEE802154Ecsl.c ****       leds_sync_on();
 5517              		.loc 1 2436 0
 5518 25c4 FFF7FEFF 		bl	leds_sync_on
2437:openstack/02a-MAClow/IEEE802154Ecsl.c ****       resetStats();
 5519              		.loc 1 2437 0
 5520 25c8 FFF7FEFF 		bl	resetStats
 5521 25cc 03E0     		b	.L257
 5522              	.L258:
2438:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
2439:openstack/02a-MAClow/IEEE802154Ecsl.c ****       leds_sync_off();
 5523              		.loc 1 2439 0
 5524 25ce FFF7FEFF 		bl	leds_sync_off
2440:openstack/02a-MAClow/IEEE802154Ecsl.c ****       schedule_resetBackoff();
 5525              		.loc 1 2440 0
 5526 25d2 FFF7FEFF 		bl	schedule_resetBackoff
 5527              	.L257:
2441:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2442:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5528              		.loc 1 2442 0
 5529 25d6 07F10807 		add	r7, r7, #8
 5530 25da BD46     		mov	sp, r7
 5531 25dc 80BD     		pop	{r7, pc}
 5532              		.cfi_endproc
 5533              	.LFE60:
 5535 25de 00BF     		.align	2
 5536              		.global	notif_sendDone
 5537              		.thumb
 5538              		.thumb_func
 5540              	notif_sendDone:
 5541              	.LFB61:
2443:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2444:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2445:openstack/02a-MAClow/IEEE802154Ecsl.c **** //=====================  NOTIFY UPPER LAYER  ===========================
2446:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2447:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2448:openstack/02a-MAClow/IEEE802154Ecsl.c **** void notif_sendDone(OpenQueueEntry_t* packetSent, owerror_t error) {
 5542              		.loc 1 2448 0
 5543              		.cfi_startproc
 5544              		@ args = 0, pretend = 0, frame = 8
 5545              		@ frame_needed = 1, uses_anonymous_args = 0
 5546 25e0 80B5     		push	{r7, lr}
 5547              	.LCFI147:
 5548              		.cfi_def_cfa_offset 8
 5549              		.cfi_offset 7, -8
 5550              		.cfi_offset 14, -4
 5551 25e2 82B0     		sub	sp, sp, #8
 5552              	.LCFI148:
 5553              		.cfi_def_cfa_offset 16
 5554 25e4 00AF     		add	r7, sp, #0
 5555              	.LCFI149:
 5556              		.cfi_def_cfa_register 7
 5557 25e6 7860     		str	r0, [r7, #4]
 5558 25e8 0B46     		mov	r3, r1
 5559 25ea FB70     		strb	r3, [r7, #3]
2449:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the outcome of the trasmission attempt
2450:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packetSent->l2_sendDoneError   = error;
 5560              		.loc 1 2450 0
 5561 25ec 7B68     		ldr	r3, [r7, #4]
 5562 25ee FA78     		ldrb	r2, [r7, #3]
 5563 25f0 83F83720 		strb	r2, [r3, #55]
2451:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the current ASN
2452:openstack/02a-MAClow/IEEE802154Ecsl.c ****    memcpy(&packetSent->l2_asn,&ieee154e_vars.asn,sizeof(asn_t));
 5564              		.loc 1 2452 0
 5565 25f4 7B68     		ldr	r3, [r7, #4]
 5566 25f6 03F14D02 		add	r2, r3, #77
 5567 25fa 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5568 25fe C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5569 2602 1868     		ldr	r0, [r3, #0]	@ unaligned
 5570 2604 1060     		str	r0, [r2, #0]	@ unaligned
 5571 2606 1B79     		ldrb	r3, [r3, #4]
 5572 2608 1371     		strb	r3, [r2, #4]
2453:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // associate this packet with the virtual component
2454:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // COMPONENT_IEEE802154E_TO_RES so RES can knows it's for it
2455:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packetSent->owner              = COMPONENT_IEEE802154E_TO_SIXTOP;
 5573              		.loc 1 2455 0
 5574 260a 7B68     		ldr	r3, [r7, #4]
 5575 260c 4FF00B02 		mov	r2, #11
 5576 2610 5A70     		strb	r2, [r3, #1]
2456:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // post RES's sendDone task
2457:openstack/02a-MAClow/IEEE802154Ecsl.c ****    scheduler_push_task(task_sixtopNotifSendDone,TASKPRIO_SIXTOP_NOTIF_TXDONE);
 5577              		.loc 1 2457 0
 5578 2612 40F20000 		movw	r0, #:lower16:task_sixtopNotifSendDone
 5579 2616 C0F20000 		movt	r0, #:upper16:task_sixtopNotifSendDone
 5580 261a 4FF00201 		mov	r1, #2
 5581 261e FFF7FEFF 		bl	scheduler_push_task
2458:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // wake up the scheduler
2459:openstack/02a-MAClow/IEEE802154Ecsl.c ****    SCHEDULER_WAKEUP();
2460:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5582              		.loc 1 2460 0
 5583 2622 07F10807 		add	r7, r7, #8
 5584 2626 BD46     		mov	sp, r7
 5585 2628 80BD     		pop	{r7, pc}
 5586              		.cfi_endproc
 5587              	.LFE61:
 5589 262a 00BF     		.align	2
 5590              		.global	notif_receive
 5591              		.thumb
 5592              		.thumb_func
 5594              	notif_receive:
 5595              	.LFB62:
2461:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2462:openstack/02a-MAClow/IEEE802154Ecsl.c **** // Modified notif_receive signature to add action for CSL testing purposes.
2463:openstack/02a-MAClow/IEEE802154Ecsl.c **** // Packet is removed on endOps in order to not fill all the slots on queue due
2464:openstack/02a-MAClow/IEEE802154Ecsl.c **** // to no sixtop action is defined for receive and process incoming packets.
2465:openstack/02a-MAClow/IEEE802154Ecsl.c **** // Then, we comment this actions here and add remove packet on endOps method.
2466:openstack/02a-MAClow/IEEE802154Ecsl.c **** void notif_receive(OpenQueueEntry_t* packetReceived, uint8_t action) {
 5596              		.loc 1 2466 0
 5597              		.cfi_startproc
 5598              		@ args = 0, pretend = 0, frame = 8
 5599              		@ frame_needed = 1, uses_anonymous_args = 0
 5600 262c 80B5     		push	{r7, lr}
 5601              	.LCFI150:
 5602              		.cfi_def_cfa_offset 8
 5603              		.cfi_offset 7, -8
 5604              		.cfi_offset 14, -4
 5605 262e 82B0     		sub	sp, sp, #8
 5606              	.LCFI151:
 5607              		.cfi_def_cfa_offset 16
 5608 2630 00AF     		add	r7, sp, #0
 5609              	.LCFI152:
 5610              		.cfi_def_cfa_register 7
 5611 2632 7860     		str	r0, [r7, #4]
 5612 2634 0B46     		mov	r3, r1
 5613 2636 FB70     		strb	r3, [r7, #3]
2467:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2468:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // [CSL-TEST]: comment and add led (orange) blink if OK or led (red) toggle if KO.
2469:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2470:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the current ASN
2471:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //memcpy(&packetReceived->l2_asn, &ieee154e_vars.asn, sizeof(asn_t));
2472:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2473:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // indicate reception to the schedule, to keep statistics
2474:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //schedule_indicateRx(&packetReceived->l2_asn);
2475:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2476:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // associate this packet with the virtual component
2477:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // COMPONENT_IEEE802154E_TO_SIXTOP so sixtop can knows it's for it
2478:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //packetReceived->owner          = COMPONENT_IEEE802154E_TO_SIXTOP;
2479:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2480:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // post RES's Receive task
2481:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //scheduler_push_task(task_sixtopNotifReceive,TASKPRIO_SIXTOP_NOTIF_RX);
2482:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2483:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (action == 1)
 5614              		.loc 1 2483 0
 5615 2638 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 5616 263a 012B     		cmp	r3, #1
 5617 263c 02D1     		bne	.L262
2484:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	leds_sync_blink();
 5618              		.loc 1 2484 0
 5619 263e FFF7FEFF 		bl	leds_sync_blink
 5620 2642 01E0     		b	.L261
 5621              	.L262:
2485:openstack/02a-MAClow/IEEE802154Ecsl.c ****    else
2486:openstack/02a-MAClow/IEEE802154Ecsl.c ****     leds_error_toggle();
 5622              		.loc 1 2486 0
 5623 2644 FFF7FEFF 		bl	leds_error_toggle
 5624              	.L261:
2487:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2488:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // [CSL-TEST]: end test code
2489:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2490:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // wake up the scheduler
2491:openstack/02a-MAClow/IEEE802154Ecsl.c ****    SCHEDULER_WAKEUP();
2492:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5625              		.loc 1 2492 0
 5626 2648 07F10807 		add	r7, r7, #8
 5627 264c BD46     		mov	sp, r7
 5628 264e 80BD     		pop	{r7, pc}
 5629              		.cfi_endproc
 5630              	.LFE62:
 5632              		.align	2
 5633              		.global	resetStats
 5634              		.thumb
 5635              		.thumb_func
 5637              	resetStats:
 5638              	.LFB63:
2493:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2494:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2495:openstack/02a-MAClow/IEEE802154Ecsl.c **** //============================== STATS =================================
2496:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2497:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2498:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void resetStats() {
 5639              		.loc 1 2498 0
 5640              		.cfi_startproc
 5641              		@ args = 0, pretend = 0, frame = 0
 5642              		@ frame_needed = 1, uses_anonymous_args = 0
 5643              		@ link register save eliminated.
 5644 2650 80B4     		push	{r7}
 5645              	.LCFI153:
 5646              		.cfi_def_cfa_offset 4
 5647              		.cfi_offset 7, -4
 5648 2652 00AF     		add	r7, sp, #0
 5649              	.LCFI154:
 5650              		.cfi_def_cfa_register 7
2499:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.numSyncPkt      =    0;
 5651              		.loc 1 2499 0
 5652 2654 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5653 2658 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5654 265c 4FF00002 		mov	r2, #0
 5655 2660 1A70     		strb	r2, [r3, #0]
2500:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.numSyncAck      =    0;
 5656              		.loc 1 2500 0
 5657 2662 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5658 2666 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5659 266a 4FF00002 		mov	r2, #0
 5660 266e 5A70     		strb	r2, [r3, #1]
2501:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.minCorrection   =  127;
 5661              		.loc 1 2501 0
 5662 2670 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5663 2674 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5664 2678 4FF07F02 		mov	r2, #127
 5665 267c 5A80     		strh	r2, [r3, #2]	@ movhi
2502:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.maxCorrection   = -127;
 5666              		.loc 1 2502 0
 5667 267e 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5668 2682 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5669 2686 4FF68172 		movw	r2, #65409
 5670 268a 9A80     		strh	r2, [r3, #4]	@ movhi
2503:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.numTicsOn       =    0;
 5671              		.loc 1 2503 0
 5672 268c 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5673 2690 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5674 2694 4FF00002 		mov	r2, #0
 5675 2698 DA71     		strb	r2, [r3, #7]
 5676 269a 9A68     		ldr	r2, [r3, #8]
 5677 269c 02F07F42 		and	r2, r2, #-16777216
 5678 26a0 9A60     		str	r2, [r3, #8]
2504:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.numTicsTotal    =    0;
 5679              		.loc 1 2504 0
 5680 26a2 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5681 26a6 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5682 26aa 4FF00002 		mov	r2, #0
 5683 26ae DA72     		strb	r2, [r3, #11]
 5684 26b0 DA68     		ldr	r2, [r3, #12]
 5685 26b2 02F07F42 		and	r2, r2, #-16777216
 5686 26b6 DA60     		str	r2, [r3, #12]
2505:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // do not reset the number of de-synchronizations
2506:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5687              		.loc 1 2506 0
 5688 26b8 BD46     		mov	sp, r7
 5689 26ba 80BC     		pop	{r7}
 5690 26bc 7047     		bx	lr
 5691              		.cfi_endproc
 5692              	.LFE63:
 5694 26be 00BF     		.align	2
 5695              		.global	updateStats
 5696              		.thumb
 5697              		.thumb_func
 5699              	updateStats:
 5700              	.LFB64:
2507:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2508:openstack/02a-MAClow/IEEE802154Ecsl.c **** void updateStats(PORT_SIGNED_INT_WIDTH timeCorrection) {
 5701              		.loc 1 2508 0
 5702              		.cfi_startproc
 5703              		@ args = 0, pretend = 0, frame = 8
 5704              		@ frame_needed = 1, uses_anonymous_args = 0
 5705              		@ link register save eliminated.
 5706 26c0 80B4     		push	{r7}
 5707              	.LCFI155:
 5708              		.cfi_def_cfa_offset 4
 5709              		.cfi_offset 7, -4
 5710 26c2 83B0     		sub	sp, sp, #12
 5711              	.LCFI156:
 5712              		.cfi_def_cfa_offset 16
 5713 26c4 00AF     		add	r7, sp, #0
 5714              	.LCFI157:
 5715              		.cfi_def_cfa_register 7
 5716 26c6 7860     		str	r0, [r7, #4]
2509:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // update minCorrection
2510:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (timeCorrection<ieee154e_stats.minCorrection) {
 5717              		.loc 1 2510 0
 5718 26c8 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5719 26cc C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5720 26d0 5B88     		ldrh	r3, [r3, #2]
 5721 26d2 1AB2     		sxth	r2, r3
 5722 26d4 7B68     		ldr	r3, [r7, #4]
 5723 26d6 9A42     		cmp	r2, r3
 5724 26d8 06DD     		ble	.L266
2511:openstack/02a-MAClow/IEEE802154Ecsl.c ****      ieee154e_stats.minCorrection = timeCorrection;
 5725              		.loc 1 2511 0
 5726 26da 7B68     		ldr	r3, [r7, #4]
 5727 26dc 9AB2     		uxth	r2, r3
 5728 26de 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5729 26e2 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5730 26e6 5A80     		strh	r2, [r3, #2]	@ movhi
 5731              	.L266:
2512:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2513:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // update maxConnection
2514:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if(timeCorrection>ieee154e_stats.maxCorrection) {
 5732              		.loc 1 2514 0
 5733 26e8 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5734 26ec C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5735 26f0 9B88     		ldrh	r3, [r3, #4]
 5736 26f2 1AB2     		sxth	r2, r3
 5737 26f4 7B68     		ldr	r3, [r7, #4]
 5738 26f6 9A42     		cmp	r2, r3
 5739 26f8 06DA     		bge	.L265
2515:openstack/02a-MAClow/IEEE802154Ecsl.c ****      ieee154e_stats.maxCorrection = timeCorrection;
 5740              		.loc 1 2515 0
 5741 26fa 7B68     		ldr	r3, [r7, #4]
 5742 26fc 9AB2     		uxth	r2, r3
 5743 26fe 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5744 2702 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5745 2706 9A80     		strh	r2, [r3, #4]	@ movhi
 5746              	.L265:
2516:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2517:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5747              		.loc 1 2517 0
 5748 2708 07F10C07 		add	r7, r7, #12
 5749 270c BD46     		mov	sp, r7
 5750 270e 80BC     		pop	{r7}
 5751 2710 7047     		bx	lr
 5752              		.cfi_endproc
 5753              	.LFE64:
 5755 2712 00BF     		.align	2
 5756              		.global	changeState
 5757              		.thumb
 5758              		.thumb_func
 5760              	changeState:
 5761              	.LFB65:
2518:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2519:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2520:openstack/02a-MAClow/IEEE802154Ecsl.c **** //============================== MISC ==================================
2521:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2522:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2523:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2524:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Changes the state of the IEEE802.15.4e FSM.
2525:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2526:openstack/02a-MAClow/IEEE802154Ecsl.c **** Besides simply updating the state global variable,
2527:openstack/02a-MAClow/IEEE802154Ecsl.c **** this function toggles the FSM debug pin.
2528:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2529:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in] newstate The state the IEEE802.15.4e FSM is now in.
2530:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2531:openstack/02a-MAClow/IEEE802154Ecsl.c **** void changeState(ieee154e_state_t newstate) {
 5762              		.loc 1 2531 0
 5763              		.cfi_startproc
 5764              		@ args = 0, pretend = 0, frame = 8
 5765              		@ frame_needed = 1, uses_anonymous_args = 0
 5766 2714 80B5     		push	{r7, lr}
 5767              	.LCFI158:
 5768              		.cfi_def_cfa_offset 8
 5769              		.cfi_offset 7, -8
 5770              		.cfi_offset 14, -4
 5771 2716 82B0     		sub	sp, sp, #8
 5772              	.LCFI159:
 5773              		.cfi_def_cfa_offset 16
 5774 2718 00AF     		add	r7, sp, #0
 5775              	.LCFI160:
 5776              		.cfi_def_cfa_register 7
 5777 271a 0346     		mov	r3, r0
 5778 271c FB71     		strb	r3, [r7, #7]
2532:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // update the state
2533:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.state = newstate;
 5779              		.loc 1 2533 0
 5780 271e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5781 2722 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5782 2726 FA79     		ldrb	r2, [r7, #7]
 5783 2728 5A74     		strb	r2, [r3, #17]
2534:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // wiggle the FSM debug pin
2535:openstack/02a-MAClow/IEEE802154Ecsl.c ****    switch (ieee154e_vars.state) {
 5784              		.loc 1 2535 0
 5785 272a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5786 272e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5787 2732 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 5788 2734 3B2B     		cmp	r3, #59
 5789 2736 00F28480 		bhi	.L268
 5790 273a 01A2     		adr	r2, .L273
 5791 273c 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 5792              		.align	2
 5793              	.L273:
 5794 2740 37280000 		.word	.L270+1
 5795 2744 43280000 		.word	.L268+1
 5796 2748 43280000 		.word	.L268+1
 5797 274c 43280000 		.word	.L268+1
 5798 2750 43280000 		.word	.L268+1
 5799 2754 43280000 		.word	.L268+1
 5800 2758 43280000 		.word	.L268+1
 5801 275c 43280000 		.word	.L268+1
 5802 2760 43280000 		.word	.L268+1
 5803 2764 43280000 		.word	.L268+1
 5804 2768 43280000 		.word	.L268+1
 5805 276c 43280000 		.word	.L268+1
 5806 2770 43280000 		.word	.L268+1
 5807 2774 43280000 		.word	.L268+1
 5808 2778 43280000 		.word	.L268+1
 5809 277c 43280000 		.word	.L268+1
 5810 2780 43280000 		.word	.L268+1
 5811 2784 43280000 		.word	.L268+1
 5812 2788 43280000 		.word	.L268+1
 5813 278c 43280000 		.word	.L268+1
 5814 2790 43280000 		.word	.L268+1
 5815 2794 43280000 		.word	.L268+1
 5816 2798 43280000 		.word	.L268+1
 5817 279c 43280000 		.word	.L268+1
 5818 27a0 43280000 		.word	.L268+1
 5819 27a4 43280000 		.word	.L268+1
 5820 27a8 31280000 		.word	.L271+1
 5821 27ac 3D280000 		.word	.L272+1
 5822 27b0 3D280000 		.word	.L272+1
 5823 27b4 3D280000 		.word	.L272+1
 5824 27b8 3D280000 		.word	.L272+1
 5825 27bc 31280000 		.word	.L271+1
 5826 27c0 31280000 		.word	.L271+1
 5827 27c4 3D280000 		.word	.L272+1
 5828 27c8 3D280000 		.word	.L272+1
 5829 27cc 3D280000 		.word	.L272+1
 5830 27d0 3D280000 		.word	.L272+1
 5831 27d4 3D280000 		.word	.L272+1
 5832 27d8 3D280000 		.word	.L272+1
 5833 27dc 3D280000 		.word	.L272+1
 5834 27e0 3D280000 		.word	.L272+1
 5835 27e4 3D280000 		.word	.L272+1
 5836 27e8 3D280000 		.word	.L272+1
 5837 27ec 37280000 		.word	.L270+1
 5838 27f0 3D280000 		.word	.L272+1
 5839 27f4 3D280000 		.word	.L272+1
 5840 27f8 3D280000 		.word	.L272+1
 5841 27fc 3D280000 		.word	.L272+1
 5842 2800 3D280000 		.word	.L272+1
 5843 2804 37280000 		.word	.L270+1
 5844 2808 3D280000 		.word	.L272+1
 5845 280c 3D280000 		.word	.L272+1
 5846 2810 3D280000 		.word	.L272+1
 5847 2814 3D280000 		.word	.L272+1
 5848 2818 3D280000 		.word	.L272+1
 5849 281c 3D280000 		.word	.L272+1
 5850 2820 3D280000 		.word	.L272+1
 5851 2824 3D280000 		.word	.L272+1
 5852 2828 3D280000 		.word	.L272+1
 5853 282c 3D280000 		.word	.L272+1
 5854              	.L271:
2536:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXWAKEUPOFFSET:
2537:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXDATAPREOFFSET:
2538:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXDATAOFFSET:
2539:openstack/02a-MAClow/IEEE802154Ecsl.c ****          debugpins_fsm_set();
 5855              		.loc 1 2539 0
 5856 2830 FFF7FEFF 		bl	debugpins_fsm_set
2540:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 5857              		.loc 1 2540 0
 5858 2834 05E0     		b	.L268
 5859              	.L270:
2541:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_SLEEP:
2542:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXDATAOFFSET:
2543:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXWAKEUPOFFSET:
2544:openstack/02a-MAClow/IEEE802154Ecsl.c ****          debugpins_fsm_clr();
 5860              		.loc 1 2544 0
 5861 2836 FFF7FEFF 		bl	debugpins_fsm_clr
2545:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 5862              		.loc 1 2545 0
 5863 283a 02E0     		b	.L268
 5864              	.L272:
2546:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2547:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // ------- TX STATES -------
2548:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2549:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Estados usados para la transmisión de tramas WAKE-UP previas a la trama de datos (Wake-Up
2550:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXWAKEUPPREPARE:
2551:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXWAKEUPREADY:
2552:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXWAKEUPDELAY:
2553:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXWAKEUP:
2554:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2555:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Estados usados para la transmisión del paquete de datos y la recepción del ACK.
2556:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXDATAPREPARE:
2557:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXDATAREADY:
2558:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXDATADELAY:
2559:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXDATA:
2560:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2561:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXACKOFFSET:
2562:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXACKPREPARE:
2563:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXACKREADY:
2564:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXACKLISTEN:
2565:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXACK:
2566:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXPROC:
2567:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2568:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // ------- RX STATES -------
2569:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2570:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Estados usados para la recepción y tratamiento de la trama de WAKE-UP.
2571:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXWAKEUPPREPARE:
2572:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXWAKEUPREADY:
2573:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXWAKEUPLISTEN:
2574:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXWAKEUP:
2575:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXWAKEUPVALIDATE:
2576:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2577:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Estados usados para la recepción del paquete de datos y la transmisión del ACK.
2578:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXDATAPREPARE:
2579:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXDATAREADY:
2580:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXDATALISTEN:
2581:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXDATA:
2582:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2583:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXACKOFFSET:
2584:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXACKPREPARE:
2585:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXACKREADY:
2586:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXACKDELAY:
2587:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXACK:
2588:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXPROC:
2589:openstack/02a-MAClow/IEEE802154Ecsl.c ****          debugpins_fsm_toggle();
 5865              		.loc 1 2589 0
 5866 283c FFF7FEFF 		bl	debugpins_fsm_toggle
2590:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 5867              		.loc 1 2590 0
 5868 2840 00BF     		nop
 5869              	.L268:
2591:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2592:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5870              		.loc 1 2592 0
 5871 2842 07F10807 		add	r7, r7, #8
 5872 2846 BD46     		mov	sp, r7
 5873 2848 80BD     		pop	{r7, pc}
 5874              		.cfi_endproc
 5875              	.LFE65:
 5877 284a 00BF     		.align	2
 5878              		.global	debugPrint_asn
 5879              		.thumb
 5880              		.thumb_func
 5882              	debugPrint_asn:
 5883              	.LFB66:
2593:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2594:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2595:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Trigger this module to print status information, over serial.
2596:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2597:openstack/02a-MAClow/IEEE802154Ecsl.c **** debugPrint_* functions are used by the openserial module to continuously print
2598:openstack/02a-MAClow/IEEE802154Ecsl.c **** status information about several modules in the OpenWSN stack.
2599:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2600:openstack/02a-MAClow/IEEE802154Ecsl.c **** \returns TRUE if this function printed something, FALSE otherwise.
2601:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2602:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool debugPrint_asn() {
 5884              		.loc 1 2602 0
 5885              		.cfi_startproc
 5886              		@ args = 0, pretend = 0, frame = 8
 5887              		@ frame_needed = 1, uses_anonymous_args = 0
 5888 284c 80B5     		push	{r7, lr}
 5889              	.LCFI161:
 5890              		.cfi_def_cfa_offset 8
 5891              		.cfi_offset 7, -8
 5892              		.cfi_offset 14, -4
 5893 284e 82B0     		sub	sp, sp, #8
 5894              	.LCFI162:
 5895              		.cfi_def_cfa_offset 16
 5896 2850 00AF     		add	r7, sp, #0
 5897              	.LCFI163:
 5898              		.cfi_def_cfa_register 7
2603:openstack/02a-MAClow/IEEE802154Ecsl.c ****    asn_t output;
2604:openstack/02a-MAClow/IEEE802154Ecsl.c ****    output.byte4         =  ieee154e_vars.asn.byte4;
 5899              		.loc 1 2604 0
 5900 2852 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5901 2856 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5902 285a 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 5903 285c 3B70     		strb	r3, [r7, #0]
2605:openstack/02a-MAClow/IEEE802154Ecsl.c ****    output.bytes2and3    =  ieee154e_vars.asn.bytes2and3;
 5904              		.loc 1 2605 0
 5905 285e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5906 2862 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5907 2866 B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 5908 286a 9BB2     		uxth	r3, r3
 5909 286c A7F80130 		strh	r3, [r7, #1]	@ unaligned
2606:openstack/02a-MAClow/IEEE802154Ecsl.c ****    output.bytes0and1    =  ieee154e_vars.asn.bytes0and1;
 5910              		.loc 1 2606 0
 5911 2870 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5912 2874 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5913 2878 B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 5914 287c 9BB2     		uxth	r3, r3
 5915 287e A7F80330 		strh	r3, [r7, #3]	@ unaligned
2607:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printStatus(STATUS_ASN,(uint8_t*)&output,sizeof(output));
 5916              		.loc 1 2607 0
 5917 2882 3B46     		mov	r3, r7
 5918 2884 4FF00400 		mov	r0, #4
 5919 2888 1946     		mov	r1, r3
 5920 288a 4FF00502 		mov	r2, #5
 5921 288e FFF7FEFF 		bl	openserial_printStatus
2608:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return TRUE;
 5922              		.loc 1 2608 0
 5923 2892 4FF00103 		mov	r3, #1
2609:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5924              		.loc 1 2609 0
 5925 2896 1846     		mov	r0, r3
 5926 2898 07F10807 		add	r7, r7, #8
 5927 289c BD46     		mov	sp, r7
 5928 289e 80BD     		pop	{r7, pc}
 5929              		.cfi_endproc
 5930              	.LFE66:
 5932              		.align	2
 5933              		.global	debugPrint_isSync
 5934              		.thumb
 5935              		.thumb_func
 5937              	debugPrint_isSync:
 5938              	.LFB67:
2610:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2611:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2612:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Trigger this module to print status information, over serial.
2613:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2614:openstack/02a-MAClow/IEEE802154Ecsl.c **** debugPrint_* functions are used by the openserial module to continuously print
2615:openstack/02a-MAClow/IEEE802154Ecsl.c **** status information about several modules in the OpenWSN stack.
2616:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2617:openstack/02a-MAClow/IEEE802154Ecsl.c **** \returns TRUE if this function printed something, FALSE otherwise.
2618:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2619:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool debugPrint_isSync() {
 5939              		.loc 1 2619 0
 5940              		.cfi_startproc
 5941              		@ args = 0, pretend = 0, frame = 8
 5942              		@ frame_needed = 1, uses_anonymous_args = 0
 5943 28a0 80B5     		push	{r7, lr}
 5944              	.LCFI164:
 5945              		.cfi_def_cfa_offset 8
 5946              		.cfi_offset 7, -8
 5947              		.cfi_offset 14, -4
 5948 28a2 82B0     		sub	sp, sp, #8
 5949              	.LCFI165:
 5950              		.cfi_def_cfa_offset 16
 5951 28a4 00AF     		add	r7, sp, #0
 5952              	.LCFI166:
 5953              		.cfi_def_cfa_register 7
2620:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t output=0;
 5954              		.loc 1 2620 0
 5955 28a6 4FF00003 		mov	r3, #0
 5956 28aa FB71     		strb	r3, [r7, #7]
2621:openstack/02a-MAClow/IEEE802154Ecsl.c ****    output = ieee154e_vars.isSync;
 5957              		.loc 1 2621 0
 5958 28ac 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5959 28b0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5960 28b4 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
 5961 28b6 FB71     		strb	r3, [r7, #7]
2622:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printStatus(STATUS_ISSYNC,(uint8_t*)&output,sizeof(uint8_t));
 5962              		.loc 1 2622 0
 5963 28b8 07F10703 		add	r3, r7, #7
 5964 28bc 4FF00000 		mov	r0, #0
 5965 28c0 1946     		mov	r1, r3
 5966 28c2 4FF00102 		mov	r2, #1
 5967 28c6 FFF7FEFF 		bl	openserial_printStatus
2623:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return TRUE;
 5968              		.loc 1 2623 0
 5969 28ca 4FF00103 		mov	r3, #1
2624:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5970              		.loc 1 2624 0
 5971 28ce 1846     		mov	r0, r3
 5972 28d0 07F10807 		add	r7, r7, #8
 5973 28d4 BD46     		mov	sp, r7
 5974 28d6 80BD     		pop	{r7, pc}
 5975              		.cfi_endproc
 5976              	.LFE67:
 5978              		.align	2
 5979              		.global	debugPrint_macStats
 5980              		.thumb
 5981              		.thumb_func
 5983              	debugPrint_macStats:
 5984              	.LFB68:
2625:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2626:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2627:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Trigger this module to print status information, over serial.
2628:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2629:openstack/02a-MAClow/IEEE802154Ecsl.c **** debugPrint_* functions are used by the openserial module to continuously print
2630:openstack/02a-MAClow/IEEE802154Ecsl.c **** status information about several modules in the OpenWSN stack.
2631:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2632:openstack/02a-MAClow/IEEE802154Ecsl.c **** \returns TRUE if this function printed something, FALSE otherwise.
2633:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2634:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool debugPrint_macStats() {
 5985              		.loc 1 2634 0
 5986              		.cfi_startproc
 5987              		@ args = 0, pretend = 0, frame = 0
 5988              		@ frame_needed = 1, uses_anonymous_args = 0
 5989 28d8 80B5     		push	{r7, lr}
 5990              	.LCFI167:
 5991              		.cfi_def_cfa_offset 8
 5992              		.cfi_offset 7, -8
 5993              		.cfi_offset 14, -4
 5994 28da 00AF     		add	r7, sp, #0
 5995              	.LCFI168:
 5996              		.cfi_def_cfa_register 7
2635:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // send current stats over serial
2636:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printStatus(STATUS_MACSTATS,(uint8_t*)&ieee154e_stats,sizeof(ieee154e_stats_t));
 5997              		.loc 1 2636 0
 5998 28dc 4FF00500 		mov	r0, #5
 5999 28e0 40F20001 		movw	r1, #:lower16:ieee154e_stats
 6000 28e4 C0F20001 		movt	r1, #:upper16:ieee154e_stats
 6001 28e8 4FF00F02 		mov	r2, #15
 6002 28ec FFF7FEFF 		bl	openserial_printStatus
2637:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return TRUE;
 6003              		.loc 1 2637 0
 6004 28f0 4FF00103 		mov	r3, #1
2638:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 6005              		.loc 1 2638 0
 6006 28f4 1846     		mov	r0, r3
 6007 28f6 80BD     		pop	{r7, pc}
 6008              		.cfi_endproc
 6009              	.LFE68:
 6011              		.align	2
 6012              		.global	endOps
 6013              		.thumb
 6014              		.thumb_func
 6016              	endOps:
 6017              	.LFB69:
2639:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2640:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2641:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2642:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Housekeeping tasks to do at the end of each slot.
2643:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2644:openstack/02a-MAClow/IEEE802154Ecsl.c **** This functions is called once in each slot, when there is nothing more
2645:openstack/02a-MAClow/IEEE802154Ecsl.c **** to do. This might be when an error occured, or when everything went well.
2646:openstack/02a-MAClow/IEEE802154Ecsl.c **** This function resets the state of the FSM so it is ready for the next slot.
2647:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2648:openstack/02a-MAClow/IEEE802154Ecsl.c **** Note that by the time this function is called, any received packet should already
2649:openstack/02a-MAClow/IEEE802154Ecsl.c **** have been sent to the upper layer. Similarly, in a Tx slot, the sendDone
2650:openstack/02a-MAClow/IEEE802154Ecsl.c **** function should already have been done. If this is not the case, this function
2651:openstack/02a-MAClow/IEEE802154Ecsl.c **** will do that for you, but assume that something went wrong.
2652:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2653:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2654:openstack/02a-MAClow/IEEE802154Ecsl.c **** //[CSL] – Modificación de firma del método endSlot.
2655:openstack/02a-MAClow/IEEE802154Ecsl.c **** void endOps() {
 6018              		.loc 1 2655 0
 6019              		.cfi_startproc
 6020              		@ args = 0, pretend = 0, frame = 0
 6021              		@ frame_needed = 1, uses_anonymous_args = 0
 6022 28f8 80B5     		push	{r7, lr}
 6023              	.LCFI169:
 6024              		.cfi_def_cfa_offset 8
 6025              		.cfi_offset 7, -8
 6026              		.cfi_offset 14, -4
 6027 28fa 00AF     		add	r7, sp, #0
 6028              	.LCFI170:
 6029              		.cfi_def_cfa_register 7
2656:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2657:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // turn off the radio
2658:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rfOff();
 6030              		.loc 1 2658 0
 6031 28fc FFF7FEFF 		bl	radio_rfOff
2659:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2660:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clear any pending timer
2661:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 6032              		.loc 1 2661 0
 6033 2900 FFF7FEFF 		bl	radiotimer_cancel
2662:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2663:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // reset capturedTimes
2664:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.lastCapturedTime = 0;
 6034              		.loc 1 2664 0
 6035 2904 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6036 2908 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6037 290c 4FF00002 		mov	r2, #0
 6038 2910 5A62     		str	r2, [r3, #36]
2665:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.syncCapturedTime = 0;
 6039              		.loc 1 2665 0
 6040 2912 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6041 2916 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6042 291a 4FF00002 		mov	r2, #0
 6043 291e 9A62     		str	r2, [r3, #40]
2666:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2667:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //clear vars for duty cycle on this slot
2668:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnTics=0;
 6044              		.loc 1 2668 0
 6045 2920 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6046 2924 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6047 2928 4FF00002 		mov	r2, #0
 6048 292c 5A63     		str	r2, [r3, #52]
2669:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnThisSlot=FALSE;
 6049              		.loc 1 2669 0
 6050 292e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6051 2932 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6052 2936 4FF00002 		mov	r2, #0
 6053 293a 83F83820 		strb	r2, [r3, #56]
2670:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2671:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clean up dataToSend
2672:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.dataToSend!=NULL) {
 6054              		.loc 1 2672 0
 6055 293e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6056 2942 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6057 2946 5B69     		ldr	r3, [r3, #20]
 6058 2948 002B     		cmp	r3, #0
 6059 294a 33D0     		beq	.L281
2673:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // if everything went well, dataToSend was set to NULL in ti9
2674:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // getting here means transmit failed
2675:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2676:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // indicate Tx fail to schedule to update stats
2677:openstack/02a-MAClow/IEEE802154Ecsl.c ****       schedule_indicateTx(&ieee154e_vars.asn,FALSE);
 6060              		.loc 1 2677 0
 6061 294c 40F20000 		movw	r0, #:lower16:ieee154e_vars
 6062 2950 C0F20000 		movt	r0, #:upper16:ieee154e_vars
 6063 2954 4FF00001 		mov	r1, #0
 6064 2958 FFF7FEFF 		bl	schedule_indicateTx
2678:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2679:openstack/02a-MAClow/IEEE802154Ecsl.c ****       //decrement transmits left counter
2680:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataToSend->l2_retriesLeft--;
 6065              		.loc 1 2680 0
 6066 295c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6067 2960 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6068 2964 5B69     		ldr	r3, [r3, #20]
 6069 2966 93F84B20 		ldrb	r2, [r3, #75]	@ zero_extendqisi2
 6070 296a 02F1FF32 		add	r2, r2, #-1
 6071 296e D2B2     		uxtb	r2, r2
 6072 2970 83F84B20 		strb	r2, [r3, #75]
2681:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2682:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.dataToSend->l2_retriesLeft==0) {
 6073              		.loc 1 2682 0
 6074 2974 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6075 2978 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6076 297c 5B69     		ldr	r3, [r3, #20]
 6077 297e 93F84B30 		ldrb	r3, [r3, #75]	@ zero_extendqisi2
 6078 2982 002B     		cmp	r3, #0
 6079 2984 07D0     		beq	.L282
2683:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 // indicate tx fail if no more retries left
2684:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // [CSL-TEST]: comment to avoid led error blinking
2685:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 //notif_sendDone(ieee154e_vars.dataToSend,E_FAIL);
2686:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 // [CSL-TEST]: end test code
2687:openstack/02a-MAClow/IEEE802154Ecsl.c ****       } else {
2688:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // return packet to the virtual COMPONENT_SIXTOP_TO_IEEE802154E component
2689:openstack/02a-MAClow/IEEE802154Ecsl.c ****          ieee154e_vars.dataToSend->owner = COMPONENT_SIXTOP_TO_IEEE802154E;
 6080              		.loc 1 2689 0
 6081 2986 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6082 298a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6083 298e 5B69     		ldr	r3, [r3, #20]
 6084 2990 4FF00A02 		mov	r2, #10
 6085 2994 5A70     		strb	r2, [r3, #1]
 6086              	.L282:
2690:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
2691:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2692:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // CSL - Remove packet for testing because no high entity for packet processing.
2693:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openqueue_freePacketBuffer(ieee154e_vars.dataToSend);
 6087              		.loc 1 2693 0
 6088 2996 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6089 299a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6090 299e 5B69     		ldr	r3, [r3, #20]
 6091 29a0 1846     		mov	r0, r3
 6092 29a2 FFF7FEFF 		bl	openqueue_freePacketBuffer
2694:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2695:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset local variable
2696:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataToSend = NULL;
 6093              		.loc 1 2696 0
 6094 29a6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6095 29aa C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6096 29ae 4FF00002 		mov	r2, #0
 6097 29b2 5A61     		str	r2, [r3, #20]
 6098              	.L281:
2697:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2698:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2699:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clean up dataReceived
2700:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.dataReceived!=NULL) {
 6099              		.loc 1 2700 0
 6100 29b4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6101 29b8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6102 29bc 9B69     		ldr	r3, [r3, #24]
 6103 29be 002B     		cmp	r3, #0
 6104 29c0 18D0     		beq	.L283
2701:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // assume something went wrong. If everything went well, dataReceived
2702:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // would have been set to NULL in ri9.
2703:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // indicate  "received packet" to upper layer since we don't want to loose packets
2704:openstack/02a-MAClow/IEEE802154Ecsl.c ****       notif_receive(ieee154e_vars.dataReceived,0);
 6105              		.loc 1 2704 0
 6106 29c2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6107 29c6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6108 29ca 9B69     		ldr	r3, [r3, #24]
 6109 29cc 1846     		mov	r0, r3
 6110 29ce 4FF00001 		mov	r1, #0
 6111 29d2 FFF7FEFF 		bl	notif_receive
2705:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2706:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // CSL - Remove packet for testing because no high entity for packet processing.
2707:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openqueue_freePacketBuffer(ieee154e_vars.dataReceived);
 6112              		.loc 1 2707 0
 6113 29d6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6114 29da C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6115 29de 9B69     		ldr	r3, [r3, #24]
 6116 29e0 1846     		mov	r0, r3
 6117 29e2 FFF7FEFF 		bl	openqueue_freePacketBuffer
2708:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2709:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset local variable
2710:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataReceived = NULL;
 6118              		.loc 1 2710 0
 6119 29e6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6120 29ea C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6121 29ee 4FF00002 		mov	r2, #0
 6122 29f2 9A61     		str	r2, [r3, #24]
 6123              	.L283:
2711:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2712:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2713:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clean up ackToSend
2714:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.ackToSend!=NULL) {
 6124              		.loc 1 2714 0
 6125 29f4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6126 29f8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6127 29fc DB69     		ldr	r3, [r3, #28]
 6128 29fe 002B     		cmp	r3, #0
 6129 2a00 0ED0     		beq	.L284
2715:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // free ackToSend so corresponding RAM memory can be recycled
2716:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openqueue_freePacketBuffer(ieee154e_vars.ackToSend);
 6130              		.loc 1 2716 0
 6131 2a02 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6132 2a06 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6133 2a0a DB69     		ldr	r3, [r3, #28]
 6134 2a0c 1846     		mov	r0, r3
 6135 2a0e FFF7FEFF 		bl	openqueue_freePacketBuffer
2717:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset local variable
2718:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.ackToSend = NULL;
 6136              		.loc 1 2718 0
 6137 2a12 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6138 2a16 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6139 2a1a 4FF00002 		mov	r2, #0
 6140 2a1e DA61     		str	r2, [r3, #28]
 6141              	.L284:
2719:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2720:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2721:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clean up ackReceived
2722:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.ackReceived!=NULL) {
 6142              		.loc 1 2722 0
 6143 2a20 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6144 2a24 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6145 2a28 1B6A     		ldr	r3, [r3, #32]
 6146 2a2a 002B     		cmp	r3, #0
 6147 2a2c 0ED0     		beq	.L285
2723:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // free ackReceived so corresponding RAM memory can be recycled
2724:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openqueue_freePacketBuffer(ieee154e_vars.ackReceived);
 6148              		.loc 1 2724 0
 6149 2a2e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6150 2a32 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6151 2a36 1B6A     		ldr	r3, [r3, #32]
 6152 2a38 1846     		mov	r0, r3
 6153 2a3a FFF7FEFF 		bl	openqueue_freePacketBuffer
2725:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset local variable
2726:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.ackReceived = NULL;
 6154              		.loc 1 2726 0
 6155 2a3e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6156 2a42 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6157 2a46 4FF00002 		mov	r2, #0
 6158 2a4a 1A62     		str	r2, [r3, #32]
 6159              	.L285:
2727:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2728:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2729:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clean up wakeupSend
2730:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.wakeupToSend!=NULL) {
 6160              		.loc 1 2730 0
 6161 2a4c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6162 2a50 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6163 2a54 DB6B     		ldr	r3, [r3, #60]
 6164 2a56 002B     		cmp	r3, #0
 6165 2a58 0ED0     		beq	.L286
2731:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // free wakeupToSend so corresponding RAM memory can be recycled
2732:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openqueue_freePacketBuffer(ieee154e_vars.wakeupToSend);
 6166              		.loc 1 2732 0
 6167 2a5a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6168 2a5e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6169 2a62 DB6B     		ldr	r3, [r3, #60]
 6170 2a64 1846     		mov	r0, r3
 6171 2a66 FFF7FEFF 		bl	openqueue_freePacketBuffer
2733:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset local variable
2734:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.wakeupToSend = NULL;
 6172              		.loc 1 2734 0
 6173 2a6a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6174 2a6e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6175 2a72 4FF00002 		mov	r2, #0
 6176 2a76 DA63     		str	r2, [r3, #60]
 6177              	.L286:
2735:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2736:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2737:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clean up wakeupReceived
2738:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.wakeupReceived !=NULL) {
 6178              		.loc 1 2738 0
 6179 2a78 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6180 2a7c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6181 2a80 1B6C     		ldr	r3, [r3, #64]
 6182 2a82 002B     		cmp	r3, #0
 6183 2a84 0ED0     		beq	.L287
2739:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // free wakeupReceived so corresponding RAM memory can be recycled
2740:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openqueue_freePacketBuffer(ieee154e_vars.wakeupReceived);
 6184              		.loc 1 2740 0
 6185 2a86 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6186 2a8a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6187 2a8e 1B6C     		ldr	r3, [r3, #64]
 6188 2a90 1846     		mov	r0, r3
 6189 2a92 FFF7FEFF 		bl	openqueue_freePacketBuffer
2741:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset local variable
2742:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.wakeupReceived = NULL;
 6190              		.loc 1 2742 0
 6191 2a96 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6192 2a9a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6193 2a9e 4FF00002 		mov	r2, #0
 6194 2aa2 1A64     		str	r2, [r3, #64]
 6195              	.L287:
2743:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2744:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2745:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
2746:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_SLEEP);
 6196              		.loc 1 2746 0
 6197 2aa4 4FF00000 		mov	r0, #0
 6198 2aa8 FFF7FEFF 		bl	changeState
2747:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2748:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // update CSL Mode to SLEEP in order to allow new TX or RX.
2749:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.cslMode = CSL_SLEEP_MODE;
 6199              		.loc 1 2749 0
 6200 2aac 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6201 2ab0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6202 2ab4 4FF00002 		mov	r2, #0
 6203 2ab8 83F84520 		strb	r2, [r3, #69]
2750:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2751:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 6204              		.loc 1 2751 0
 6205 2abc 80BD     		pop	{r7, pc}
 6206              		.cfi_endproc
 6207              	.LFE69:
 6209 2abe 00BF     		.align	2
 6210              		.global	ieee154e_isSynch
 6211              		.thumb
 6212              		.thumb_func
 6214              	ieee154e_isSynch:
 6215              	.LFB70:
2752:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2753:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool ieee154e_isSynch(){
 6216              		.loc 1 2753 0
 6217              		.cfi_startproc
 6218              		@ args = 0, pretend = 0, frame = 0
 6219              		@ frame_needed = 1, uses_anonymous_args = 0
 6220              		@ link register save eliminated.
 6221 2ac0 80B4     		push	{r7}
 6222              	.LCFI171:
 6223              		.cfi_def_cfa_offset 4
 6224              		.cfi_offset 7, -4
 6225 2ac2 00AF     		add	r7, sp, #0
 6226              	.LCFI172:
 6227              		.cfi_def_cfa_register 7
2754:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee154e_vars.isSync;
 6228              		.loc 1 2754 0
 6229 2ac4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6230 2ac8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6231 2acc 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
2755:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 6232              		.loc 1 2755 0
 6233 2ace 1846     		mov	r0, r3
 6234 2ad0 BD46     		mov	sp, r7
 6235 2ad2 80BC     		pop	{r7}
 6236 2ad4 7047     		bx	lr
 6237              		.cfi_endproc
 6238              	.LFE70:
 6240 2ad6 00BF     		.align	2
 6241              		.global	ieee154e_processIEs
 6242              		.thumb
 6243              		.thumb_func
 6245              	ieee154e_processIEs:
 6246              	.LFB71:
2756:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2757:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE bool ieee154e_processIEs(OpenQueueEntry_t* pkt, uint16_t* lenIE) {
 6247              		.loc 1 2757 0
 6248              		.cfi_startproc
 6249              		@ args = 0, pretend = 0, frame = 32
 6250              		@ frame_needed = 1, uses_anonymous_args = 0
 6251 2ad8 80B5     		push	{r7, lr}
 6252              	.LCFI173:
 6253              		.cfi_def_cfa_offset 8
 6254              		.cfi_offset 7, -8
 6255              		.cfi_offset 14, -4
 6256 2ada 88B0     		sub	sp, sp, #32
 6257              	.LCFI174:
 6258              		.cfi_def_cfa_offset 40
 6259 2adc 00AF     		add	r7, sp, #0
 6260              	.LCFI175:
 6261              		.cfi_def_cfa_register 7
 6262 2ade 7860     		str	r0, [r7, #4]
 6263 2ae0 3960     		str	r1, [r7, #0]
2758:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t               ptr;
2759:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t               byte0;
2760:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t               byte1;
2761:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t               temp_8b;
2762:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t               gr_elem_id;
2763:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t               subid;
2764:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint16_t              temp_16b;
2765:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint16_t              len;
2766:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint16_t              sublen;
2767:openstack/02a-MAClow/IEEE802154Ecsl.c ****    PORT_SIGNED_INT_WIDTH timeCorrection;
2768:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2769:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ptr=0;
 6264              		.loc 1 2769 0
 6265 2ae2 4FF00003 		mov	r3, #0
 6266 2ae6 FB73     		strb	r3, [r7, #15]
2770:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2771:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //===== header or payload IE header
2772:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2773:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //candidate IE header  if type ==0 header IE if type==1 payload IE
2774:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_8b    = *((uint8_t*)(pkt->payload)+ptr);
 6267              		.loc 1 2774 0
 6268 2ae8 7B68     		ldr	r3, [r7, #4]
 6269 2aea 5A68     		ldr	r2, [r3, #4]
 6270 2aec FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6271 2aee D318     		adds	r3, r2, r3
 6272 2af0 1B78     		ldrb	r3, [r3, #0]
 6273 2af2 7B76     		strb	r3, [r7, #25]
2775:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ptr++;
 6274              		.loc 1 2775 0
 6275 2af4 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6276 2af6 03F10103 		add	r3, r3, #1
 6277 2afa DBB2     		uxtb	r3, r3
 6278 2afc FB73     		strb	r3, [r7, #15]
2776:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2777:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_16b   = temp_8b + ((*((uint8_t*)(pkt->payload)+ptr))<< 8);
 6279              		.loc 1 2777 0
 6280 2afe 7B7E     		ldrb	r3, [r7, #25]	@ zero_extendqisi2
 6281 2b00 9AB2     		uxth	r2, r3
 6282 2b02 7B68     		ldr	r3, [r7, #4]
 6283 2b04 5968     		ldr	r1, [r3, #4]
 6284 2b06 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6285 2b08 CB18     		adds	r3, r1, r3
 6286 2b0a 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 6287 2b0c 4FEA0323 		lsl	r3, r3, #8
 6288 2b10 9BB2     		uxth	r3, r3
 6289 2b12 D318     		adds	r3, r2, r3
 6290 2b14 FB82     		strh	r3, [r7, #22]	@ movhi
2778:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ptr++;
 6291              		.loc 1 2778 0
 6292 2b16 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6293 2b18 03F10103 		add	r3, r3, #1
 6294 2b1c DBB2     		uxtb	r3, r3
 6295 2b1e FB73     		strb	r3, [r7, #15]
2779:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2780:openstack/02a-MAClow/IEEE802154Ecsl.c ****    *lenIE     = ptr;
 6296              		.loc 1 2780 0
 6297 2b20 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6298 2b22 1A46     		mov	r2, r3
 6299 2b24 3B68     		ldr	r3, [r7, #0]
 6300 2b26 1A80     		strh	r2, [r3, #0]	@ movhi
2781:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2782:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b & IEEE802154E_DESC_TYPE_PAYLOAD_IE) == IEEE802154E_DESC_TYPE_PAYLOAD_IE){
 6301              		.loc 1 2782 0
 6302 2b28 FB8A     		ldrh	r3, [r7, #22]
 6303 2b2a 03F00103 		and	r3, r3, #1
 6304 2b2e 002B     		cmp	r3, #0
 6305 2b30 0AD0     		beq	.L291
2783:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // payload IE
2784:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2785:openstack/02a-MAClow/IEEE802154Ecsl.c ****       len          = (temp_16b & IEEE802154E_DESC_LEN_PAYLOAD_IE_MASK)>>IEEE802154E_DESC_LEN_PAYLOA
 6306              		.loc 1 2785 0
 6307 2b32 FB8A     		ldrh	r3, [r7, #22]
 6308 2b34 4FEA5313 		lsr	r3, r3, #5
 6309 2b38 BB83     		strh	r3, [r7, #28]	@ movhi
2786:openstack/02a-MAClow/IEEE802154Ecsl.c ****       gr_elem_id   = (temp_16b & IEEE802154E_DESC_GROUPID_PAYLOAD_IE_MASK)>>IEEE802154E_DESC_GROUPI
 6310              		.loc 1 2786 0
 6311 2b3a FB8A     		ldrh	r3, [r7, #22]
 6312 2b3c 03F01E03 		and	r3, r3, #30
 6313 2b40 4FEA6303 		asr	r3, r3, #1
 6314 2b44 FB77     		strb	r3, [r7, #31]
 6315 2b46 09E0     		b	.L292
 6316              	.L291:
2787:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
2788:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // header IE
2789:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2790:openstack/02a-MAClow/IEEE802154Ecsl.c ****       len          = (temp_16b & IEEE802154E_DESC_LEN_HEADER_IE_MASK)>>IEEE802154E_DESC_LEN_HEADER_
 6317              		.loc 1 2790 0
 6318 2b48 FB8A     		ldrh	r3, [r7, #22]
 6319 2b4a 4FEA5323 		lsr	r3, r3, #9
 6320 2b4e BB83     		strh	r3, [r7, #28]	@ movhi
2791:openstack/02a-MAClow/IEEE802154Ecsl.c ****       gr_elem_id   = (temp_16b & IEEE802154E_DESC_ELEMENTID_HEADER_IE_MASK)>>IEEE802154E_DESC_ELEME
 6321              		.loc 1 2791 0
 6322 2b50 FB8A     		ldrh	r3, [r7, #22]
 6323 2b52 03F4FF73 		and	r3, r3, #510
 6324 2b56 4FEA6303 		asr	r3, r3, #1
 6325 2b5a FB77     		strb	r3, [r7, #31]
 6326              	.L292:
2792:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2793:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2794:openstack/02a-MAClow/IEEE802154Ecsl.c ****    *lenIE         += len;
 6327              		.loc 1 2794 0
 6328 2b5c 3B68     		ldr	r3, [r7, #0]
 6329 2b5e 1A88     		ldrh	r2, [r3, #0]
 6330 2b60 BB8B     		ldrh	r3, [r7, #28]	@ movhi
 6331 2b62 D318     		adds	r3, r2, r3
 6332 2b64 9AB2     		uxth	r2, r3
 6333 2b66 3B68     		ldr	r3, [r7, #0]
 6334 2b68 1A80     		strh	r2, [r3, #0]	@ movhi
2795:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2796:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //===== sub-elements
2797:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2798:openstack/02a-MAClow/IEEE802154Ecsl.c ****    switch(gr_elem_id){
 6335              		.loc 1 2798 0
 6336 2b6a FB7F     		ldrb	r3, [r7, #31]	@ zero_extendqisi2
 6337 2b6c 012B     		cmp	r3, #1
 6338 2b6e 02D0     		beq	.L294
 6339 2b70 1E2B     		cmp	r3, #30
 6340 2b72 78D0     		beq	.L295
 6341 2b74 BEE0     		b	.L309
 6342              	.L294:
2799:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2800:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case IEEE802154E_MLME_IE_GROUPID:
2801:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // MLME IE
2802:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2803:openstack/02a-MAClow/IEEE802154Ecsl.c ****          do {
2804:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2805:openstack/02a-MAClow/IEEE802154Ecsl.c ****             //read sub IE header
2806:openstack/02a-MAClow/IEEE802154Ecsl.c ****             temp_8b     = *((uint8_t*)(pkt->payload)+ptr);
 6343              		.loc 1 2806 0
 6344 2b76 7B68     		ldr	r3, [r7, #4]
 6345 2b78 5A68     		ldr	r2, [r3, #4]
 6346 2b7a FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6347 2b7c D318     		adds	r3, r2, r3
 6348 2b7e 1B78     		ldrb	r3, [r3, #0]
 6349 2b80 7B76     		strb	r3, [r7, #25]
2807:openstack/02a-MAClow/IEEE802154Ecsl.c ****             ptr         = ptr + 1;
 6350              		.loc 1 2807 0
 6351 2b82 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6352 2b84 03F10103 		add	r3, r3, #1
 6353 2b88 DBB2     		uxtb	r3, r3
 6354 2b8a FB73     		strb	r3, [r7, #15]
2808:openstack/02a-MAClow/IEEE802154Ecsl.c ****             temp_16b    = temp_8b  +(*((uint8_t*)(pkt->payload)+ptr) << 8);
 6355              		.loc 1 2808 0
 6356 2b8c 7B7E     		ldrb	r3, [r7, #25]	@ zero_extendqisi2
 6357 2b8e 9AB2     		uxth	r2, r3
 6358 2b90 7B68     		ldr	r3, [r7, #4]
 6359 2b92 5968     		ldr	r1, [r3, #4]
 6360 2b94 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6361 2b96 CB18     		adds	r3, r1, r3
 6362 2b98 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 6363 2b9a 4FEA0323 		lsl	r3, r3, #8
 6364 2b9e 9BB2     		uxth	r3, r3
 6365 2ba0 D318     		adds	r3, r2, r3
 6366 2ba2 FB82     		strh	r3, [r7, #22]	@ movhi
2809:openstack/02a-MAClow/IEEE802154Ecsl.c ****             ptr         = ptr + 1;
 6367              		.loc 1 2809 0
 6368 2ba4 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6369 2ba6 03F10103 		add	r3, r3, #1
 6370 2baa DBB2     		uxtb	r3, r3
 6371 2bac FB73     		strb	r3, [r7, #15]
2810:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2811:openstack/02a-MAClow/IEEE802154Ecsl.c ****             len         = len - 2; //remove header fields len
 6372              		.loc 1 2811 0
 6373 2bae BB8B     		ldrh	r3, [r7, #28]	@ movhi
 6374 2bb0 A3F10203 		sub	r3, r3, #2
 6375 2bb4 BB83     		strh	r3, [r7, #28]	@ movhi
2812:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2813:openstack/02a-MAClow/IEEE802154Ecsl.c ****             if ((temp_16b & IEEE802154E_DESC_TYPE_LONG) == IEEE802154E_DESC_TYPE_LONG){
 6376              		.loc 1 2813 0
 6377 2bb6 FB8A     		ldrh	r3, [r7, #22]
 6378 2bb8 03F00103 		and	r3, r3, #1
 6379 2bbc 002B     		cmp	r3, #0
 6380 2bbe 0AD0     		beq	.L296
2814:openstack/02a-MAClow/IEEE802154Ecsl.c ****                // long sub-IE
2815:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2816:openstack/02a-MAClow/IEEE802154Ecsl.c ****                sublen   = (temp_16b & IEEE802154E_DESC_LEN_LONG_MLME_IE_MASK)>>IEEE802154E_DESC_LEN
 6381              		.loc 1 2816 0
 6382 2bc0 FB8A     		ldrh	r3, [r7, #22]
 6383 2bc2 4FEA5313 		lsr	r3, r3, #5
 6384 2bc6 7B83     		strh	r3, [r7, #26]	@ movhi
2817:openstack/02a-MAClow/IEEE802154Ecsl.c ****                subid    = (temp_16b & IEEE802154E_DESC_SUBID_LONG_MLME_IE_MASK)>>IEEE802154E_DESC_S
 6385              		.loc 1 2817 0
 6386 2bc8 FB8A     		ldrh	r3, [r7, #22]
 6387 2bca 03F01E03 		and	r3, r3, #30
 6388 2bce 4FEA6303 		asr	r3, r3, #1
 6389 2bd2 BB77     		strb	r3, [r7, #30]
 6390 2bd4 09E0     		b	.L297
 6391              	.L296:
2818:openstack/02a-MAClow/IEEE802154Ecsl.c ****             } else {
2819:openstack/02a-MAClow/IEEE802154Ecsl.c ****                // short sub-IE
2820:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2821:openstack/02a-MAClow/IEEE802154Ecsl.c ****                sublen   = (temp_16b & IEEE802154E_DESC_LEN_SHORT_MLME_IE_MASK)>>IEEE802154E_DESC_LE
 6392              		.loc 1 2821 0
 6393 2bd6 FB8A     		ldrh	r3, [r7, #22]
 6394 2bd8 4FEA1323 		lsr	r3, r3, #8
 6395 2bdc 7B83     		strh	r3, [r7, #26]	@ movhi
2822:openstack/02a-MAClow/IEEE802154Ecsl.c ****                subid    = (temp_16b & IEEE802154E_DESC_SUBID_SHORT_MLME_IE_MASK)>>IEEE802154E_DESC_
 6396              		.loc 1 2822 0
 6397 2bde FB8A     		ldrh	r3, [r7, #22]
 6398 2be0 03F0FE03 		and	r3, r3, #254
 6399 2be4 4FEA6303 		asr	r3, r3, #1
 6400 2be8 BB77     		strb	r3, [r7, #30]
 6401              	.L297:
2823:openstack/02a-MAClow/IEEE802154Ecsl.c ****             }
2824:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2825:openstack/02a-MAClow/IEEE802154Ecsl.c ****             switch(subid){
 6402              		.loc 1 2825 0
 6403 2bea BB7F     		ldrb	r3, [r7, #30]	@ zero_extendqisi2
 6404 2bec 1B2B     		cmp	r3, #27
 6405 2bee 25D0     		beq	.L300
 6406 2bf0 1C2B     		cmp	r3, #28
 6407 2bf2 2DD0     		beq	.L311
 6408 2bf4 1A2B     		cmp	r3, #26
 6409 2bf6 28D1     		bne	.L310
 6410              	.L299:
2826:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2827:openstack/02a-MAClow/IEEE802154Ecsl.c ****                case IEEE802154E_MLME_SYNC_IE_SUBID:
2828:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   // Sync IE: ASN and Join Priority
2829:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2830:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   if (idmanager_getIsDAGroot()==FALSE) {
 6411              		.loc 1 2830 0
 6412 2bf8 FFF7FEFF 		bl	idmanager_getIsDAGroot
 6413 2bfc 0346     		mov	r3, r0
 6414 2bfe 83F00103 		eor	r3, r3, #1
 6415 2c02 DBB2     		uxtb	r3, r3
 6416 2c04 002B     		cmp	r3, #0
 6417 2c06 25D0     		beq	.L312
2831:openstack/02a-MAClow/IEEE802154Ecsl.c ****                      // ASN
2832:openstack/02a-MAClow/IEEE802154Ecsl.c ****                      asnStoreFromAdv((uint8_t*)(pkt->payload)+ptr);
 6418              		.loc 1 2832 0
 6419 2c08 7B68     		ldr	r3, [r7, #4]
 6420 2c0a 5A68     		ldr	r2, [r3, #4]
 6421 2c0c FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6422 2c0e D318     		adds	r3, r2, r3
 6423 2c10 1846     		mov	r0, r3
 6424 2c12 FFF7FEFF 		bl	asnStoreFromAdv
2833:openstack/02a-MAClow/IEEE802154Ecsl.c ****                      ptr = ptr + 5;
 6425              		.loc 1 2833 0
 6426 2c16 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6427 2c18 03F10503 		add	r3, r3, #5
 6428 2c1c DBB2     		uxtb	r3, r3
 6429 2c1e FB73     		strb	r3, [r7, #15]
2834:openstack/02a-MAClow/IEEE802154Ecsl.c ****                      // join priority
2835:openstack/02a-MAClow/IEEE802154Ecsl.c ****                      joinPriorityStoreFromAdv(*((uint8_t*)(pkt->payload)+ptr));
 6430              		.loc 1 2835 0
 6431 2c20 7B68     		ldr	r3, [r7, #4]
 6432 2c22 5A68     		ldr	r2, [r3, #4]
 6433 2c24 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6434 2c26 D318     		adds	r3, r2, r3
 6435 2c28 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 6436 2c2a 1846     		mov	r0, r3
 6437 2c2c FFF7FEFF 		bl	joinPriorityStoreFromAdv
2836:openstack/02a-MAClow/IEEE802154Ecsl.c ****                      ptr = ptr + 1;
 6438              		.loc 1 2836 0
 6439 2c30 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6440 2c32 03F10103 		add	r3, r3, #1
 6441 2c36 DBB2     		uxtb	r3, r3
 6442 2c38 FB73     		strb	r3, [r7, #15]
2837:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   }
2838:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   break;
 6443              		.loc 1 2838 0
 6444 2c3a 0BE0     		b	.L312
 6445              	.L300:
2839:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2840:openstack/02a-MAClow/IEEE802154Ecsl.c ****                case IEEE802154E_MLME_SLOTFRAME_LINK_IE_SUBID:
2841:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   processIE_retrieveSlotframeLinkIE(pkt,&ptr);
 6446              		.loc 1 2841 0
 6447 2c3c 07F10F03 		add	r3, r7, #15
 6448 2c40 7868     		ldr	r0, [r7, #4]
 6449 2c42 1946     		mov	r1, r3
 6450 2c44 FFF7FEFF 		bl	processIE_retrieveSlotframeLinkIE
2842:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   break;
 6451              		.loc 1 2842 0
 6452 2c48 05E0     		b	.L303
 6453              	.L310:
2843:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2844:openstack/02a-MAClow/IEEE802154Ecsl.c ****                case IEEE802154E_MLME_TIMESLOT_IE_SUBID:
2845:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   // to do
2846:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   break;
2847:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2848:openstack/02a-MAClow/IEEE802154Ecsl.c ****                default:
2849:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   return FALSE;
 6454              		.loc 1 2849 0
 6455 2c4a 4FF00003 		mov	r3, #0
 6456 2c4e 6AE0     		b	.L308
 6457              	.L311:
2846:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   break;
 6458              		.loc 1 2846 0
 6459 2c50 00BF     		nop
 6460 2c52 00E0     		b	.L303
 6461              	.L312:
2838:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   break;
 6462              		.loc 1 2838 0
 6463 2c54 00BF     		nop
 6464              	.L303:
2850:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   break;
2851:openstack/02a-MAClow/IEEE802154Ecsl.c ****             }
2852:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2853:openstack/02a-MAClow/IEEE802154Ecsl.c ****             len = len - sublen;
 6465              		.loc 1 2853 0
 6466 2c56 BA8B     		ldrh	r2, [r7, #28]	@ movhi
 6467 2c58 7B8B     		ldrh	r3, [r7, #26]	@ movhi
 6468 2c5a D31A     		subs	r3, r2, r3
 6469 2c5c BB83     		strh	r3, [r7, #28]	@ movhi
2854:openstack/02a-MAClow/IEEE802154Ecsl.c ****          } while(len>0);
 6470              		.loc 1 2854 0
 6471 2c5e BB8B     		ldrh	r3, [r7, #28]
 6472 2c60 002B     		cmp	r3, #0
 6473 2c62 88D1     		bne	.L294
2855:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2856:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 6474              		.loc 1 2856 0
 6475 2c64 4EE0     		b	.L305
 6476              	.L295:
2857:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2858:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case IEEE802154E_ACK_NACK_TIMECORRECTION_ELEMENTID:
2859:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // timecorrection IE
2860:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2861:openstack/02a-MAClow/IEEE802154Ecsl.c ****          if (
2862:openstack/02a-MAClow/IEEE802154Ecsl.c ****                idmanager_getIsDAGroot()==FALSE &&
 6477              		.loc 1 2862 0
 6478 2c66 FFF7FEFF 		bl	idmanager_getIsDAGroot
 6479 2c6a 0346     		mov	r3, r0
 6480 2c6c 83F00103 		eor	r3, r3, #1
 6481 2c70 DBB2     		uxtb	r3, r3
2861:openstack/02a-MAClow/IEEE802154Ecsl.c ****          if (
 6482              		.loc 1 2861 0
 6483 2c72 002B     		cmp	r3, #0
 6484 2c74 45D0     		beq	.L313
2863:openstack/02a-MAClow/IEEE802154Ecsl.c ****                neighbors_isPreferredParent(&(pkt->l2_nextORpreviousHop))
 6485              		.loc 1 2863 0
 6486 2c76 7B68     		ldr	r3, [r7, #4]
 6487 2c78 03F13803 		add	r3, r3, #56
 6488 2c7c 1846     		mov	r0, r3
 6489 2c7e FFF7FEFF 		bl	neighbors_isPreferredParent
 6490 2c82 0346     		mov	r3, r0
2862:openstack/02a-MAClow/IEEE802154Ecsl.c ****                idmanager_getIsDAGroot()==FALSE &&
 6491              		.loc 1 2862 0
 6492 2c84 002B     		cmp	r3, #0
 6493 2c86 3CD0     		beq	.L313
2864:openstack/02a-MAClow/IEEE802154Ecsl.c ****             ) {
2865:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2866:openstack/02a-MAClow/IEEE802154Ecsl.c ****             byte0 = *((uint8_t*)(pkt->payload)+ptr);
 6494              		.loc 1 2866 0
 6495 2c88 7B68     		ldr	r3, [r7, #4]
 6496 2c8a 5A68     		ldr	r2, [r3, #4]
 6497 2c8c FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6498 2c8e D318     		adds	r3, r2, r3
 6499 2c90 1B78     		ldrb	r3, [r3, #0]
 6500 2c92 7B75     		strb	r3, [r7, #21]
2867:openstack/02a-MAClow/IEEE802154Ecsl.c ****             ptr++;
 6501              		.loc 1 2867 0
 6502 2c94 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6503 2c96 03F10103 		add	r3, r3, #1
 6504 2c9a DBB2     		uxtb	r3, r3
 6505 2c9c FB73     		strb	r3, [r7, #15]
2868:openstack/02a-MAClow/IEEE802154Ecsl.c ****             byte1 = *((uint8_t*)(pkt->payload)+ptr);
 6506              		.loc 1 2868 0
 6507 2c9e 7B68     		ldr	r3, [r7, #4]
 6508 2ca0 5A68     		ldr	r2, [r3, #4]
 6509 2ca2 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6510 2ca4 D318     		adds	r3, r2, r3
 6511 2ca6 1B78     		ldrb	r3, [r3, #0]
 6512 2ca8 3B75     		strb	r3, [r7, #20]
2869:openstack/02a-MAClow/IEEE802154Ecsl.c ****             ptr++;
 6513              		.loc 1 2869 0
 6514 2caa FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6515 2cac 03F10103 		add	r3, r3, #1
 6516 2cb0 DBB2     		uxtb	r3, r3
 6517 2cb2 FB73     		strb	r3, [r7, #15]
2870:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2871:openstack/02a-MAClow/IEEE802154Ecsl.c ****             timeCorrection  = (int16_t)((uint16_t)byte1<<8 | (uint16_t)byte0);
 6518              		.loc 1 2871 0
 6519 2cb4 3B7D     		ldrb	r3, [r7, #20]	@ zero_extendqisi2
 6520 2cb6 4FEA0323 		lsl	r3, r3, #8
 6521 2cba 9AB2     		uxth	r2, r3
 6522 2cbc 7B7D     		ldrb	r3, [r7, #21]	@ zero_extendqisi2
 6523 2cbe 9BB2     		uxth	r3, r3
 6524 2cc0 1343     		orrs	r3, r3, r2
 6525 2cc2 9BB2     		uxth	r3, r3
 6526 2cc4 1BB2     		sxth	r3, r3
 6527 2cc6 3B61     		str	r3, [r7, #16]
2872:openstack/02a-MAClow/IEEE802154Ecsl.c ****             timeCorrection  = (timeCorrection / (PORT_SIGNED_INT_WIDTH)US_PER_TICK);
 6528              		.loc 1 2872 0
 6529 2cc8 3B69     		ldr	r3, [r7, #16]
 6530 2cca 48F68902 		movw	r2, #34953
 6531 2cce C8F68802 		movt	r2, 34952
 6532 2cd2 82FB0312 		smull	r1, r2, r2, r3
 6533 2cd6 D218     		adds	r2, r2, r3
 6534 2cd8 4FEA2212 		asr	r2, r2, #4
 6535 2cdc 4FEAE373 		asr	r3, r3, #31
 6536 2ce0 D31A     		subs	r3, r2, r3
 6537 2ce2 3B61     		str	r3, [r7, #16]
2873:openstack/02a-MAClow/IEEE802154Ecsl.c ****             timeCorrection  = -timeCorrection;
 6538              		.loc 1 2873 0
 6539 2ce4 3B69     		ldr	r3, [r7, #16]
 6540 2ce6 C3F10003 		rsb	r3, r3, #0
 6541 2cea 3B61     		str	r3, [r7, #16]
2874:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2875:openstack/02a-MAClow/IEEE802154Ecsl.c ****             synchronizeAck(timeCorrection);
 6542              		.loc 1 2875 0
 6543 2cec 3869     		ldr	r0, [r7, #16]
 6544 2cee FFF7FEFF 		bl	synchronizeAck
2876:openstack/02a-MAClow/IEEE802154Ecsl.c ****          }
2877:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 6545              		.loc 1 2877 0
 6546 2cf2 06E0     		b	.L313
 6547              	.L309:
2878:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2879:openstack/02a-MAClow/IEEE802154Ecsl.c ****       default:
2880:openstack/02a-MAClow/IEEE802154Ecsl.c ****          *lenIE = 0; //no header or not recognized.
 6548              		.loc 1 2880 0
 6549 2cf4 3B68     		ldr	r3, [r7, #0]
 6550 2cf6 4FF00002 		mov	r2, #0
 6551 2cfa 1A80     		strh	r2, [r3, #0]	@ movhi
2881:openstack/02a-MAClow/IEEE802154Ecsl.c ****          return FALSE;
 6552              		.loc 1 2881 0
 6553 2cfc 4FF00003 		mov	r3, #0
 6554 2d00 11E0     		b	.L308
 6555              	.L313:
2877:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 6556              		.loc 1 2877 0
 6557 2d02 00BF     		nop
 6558              	.L305:
2882:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2883:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2884:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if(*lenIE>127) {
 6559              		.loc 1 2884 0
 6560 2d04 3B68     		ldr	r3, [r7, #0]
 6561 2d06 1B88     		ldrh	r3, [r3, #0]
 6562 2d08 7F2B     		cmp	r3, #127
 6563 2d0a 0AD9     		bls	.L307
2885:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // log the error
2886:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openserial_printError(
 6564              		.loc 1 2886 0
 6565 2d0c 3B68     		ldr	r3, [r7, #0]
 6566 2d0e 1B88     		ldrh	r3, [r3, #0]
 6567 2d10 4FF00900 		mov	r0, #9
 6568 2d14 4FF03301 		mov	r1, #51
 6569 2d18 1A46     		mov	r2, r3
 6570 2d1a 4FF00103 		mov	r3, #1
 6571 2d1e FFF7FEFF 		bl	openserial_printError
 6572              	.L307:
2887:openstack/02a-MAClow/IEEE802154Ecsl.c ****          COMPONENT_IEEE802154E,
2888:openstack/02a-MAClow/IEEE802154Ecsl.c ****          ERR_HEADER_TOO_LONG,
2889:openstack/02a-MAClow/IEEE802154Ecsl.c ****          (errorparameter_t)*lenIE,
2890:openstack/02a-MAClow/IEEE802154Ecsl.c ****          (errorparameter_t)1
2891:openstack/02a-MAClow/IEEE802154Ecsl.c ****       );
2892:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2893:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return TRUE;
 6573              		.loc 1 2893 0
 6574 2d22 4FF00103 		mov	r3, #1
 6575              	.L308:
2894:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 6576              		.loc 1 2894 0
 6577 2d26 1846     		mov	r0, r3
 6578 2d28 07F12007 		add	r7, r7, #32
 6579 2d2c BD46     		mov	sp, r7
 6580 2d2e 80BD     		pop	{r7, pc}
 6581              		.cfi_endproc
 6582              	.LFE71:
 6584              		.align	2
 6585              		.global	joinPriorityStoreFromAdv
 6586              		.thumb
 6587              		.thumb_func
 6589              	joinPriorityStoreFromAdv:
 6590              	.LFB72:
2895:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2896:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void joinPriorityStoreFromAdv(uint8_t jp){
 6591              		.loc 1 2896 0
 6592              		.cfi_startproc
 6593              		@ args = 0, pretend = 0, frame = 8
 6594              		@ frame_needed = 1, uses_anonymous_args = 0
 6595              		@ link register save eliminated.
 6596 2d30 80B4     		push	{r7}
 6597              	.LCFI176:
 6598              		.cfi_def_cfa_offset 4
 6599              		.cfi_offset 7, -4
 6600 2d32 83B0     		sub	sp, sp, #12
 6601              	.LCFI177:
 6602              		.cfi_def_cfa_offset 16
 6603 2d34 00AF     		add	r7, sp, #0
 6604              	.LCFI178:
 6605              		.cfi_def_cfa_register 7
 6606 2d36 0346     		mov	r3, r0
 6607 2d38 FB71     		strb	r3, [r7, #7]
2897:openstack/02a-MAClow/IEEE802154Ecsl.c ****   ieee154e_vars.dataReceived->l2_joinPriority = jp;
 6608              		.loc 1 2897 0
 6609 2d3a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6610 2d3e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6611 2d42 9B69     		ldr	r3, [r3, #24]
 6612 2d44 FA79     		ldrb	r2, [r7, #7]
 6613 2d46 83F86420 		strb	r2, [r3, #100]
2898:openstack/02a-MAClow/IEEE802154Ecsl.c ****   ieee154e_vars.dataReceived->l2_joinPriorityPresent = TRUE;
 6614              		.loc 1 2898 0
 6615 2d4a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6616 2d4e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6617 2d52 9B69     		ldr	r3, [r3, #24]
 6618 2d54 4FF00102 		mov	r2, #1
 6619 2d58 83F86620 		strb	r2, [r3, #102]
2899:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 6620              		.loc 1 2899 0
 6621 2d5c 07F10C07 		add	r7, r7, #12
 6622 2d60 BD46     		mov	sp, r7
 6623 2d62 80BC     		pop	{r7}
 6624 2d64 7047     		bx	lr
 6625              		.cfi_endproc
 6626              	.LFE72:
 6628 2d66 00BF     		.align	2
 6629              		.global	asnStoreFromAdv
 6630              		.thumb
 6631              		.thumb_func
 6633              	asnStoreFromAdv:
 6634              	.LFB73:
2900:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2901:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void asnStoreFromAdv(uint8_t* asn) {
 6635              		.loc 1 2901 0
 6636              		.cfi_startproc
 6637              		@ args = 0, pretend = 0, frame = 8
 6638              		@ frame_needed = 1, uses_anonymous_args = 0
 6639 2d68 90B5     		push	{r4, r7, lr}
 6640              	.LCFI179:
 6641              		.cfi_def_cfa_offset 12
 6642              		.cfi_offset 4, -12
 6643              		.cfi_offset 7, -8
 6644              		.cfi_offset 14, -4
 6645 2d6a 83B0     		sub	sp, sp, #12
 6646              	.LCFI180:
 6647              		.cfi_def_cfa_offset 24
 6648 2d6c 00AF     		add	r7, sp, #0
 6649              	.LCFI181:
 6650              		.cfi_def_cfa_register 7
 6651 2d6e 7860     		str	r0, [r7, #4]
2902:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2903:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // store the ASN
2904:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asn.bytes0and1   =     asn[0]+
 6652              		.loc 1 2904 0
 6653 2d70 7B68     		ldr	r3, [r7, #4]
 6654 2d72 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 6655 2d74 1A46     		mov	r2, r3
2905:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                     256*asn[1];
 6656              		.loc 1 2905 0
 6657 2d76 7B68     		ldr	r3, [r7, #4]
 6658 2d78 03F10103 		add	r3, r3, #1
 6659 2d7c 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
2904:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asn.bytes0and1   =     asn[0]+
 6660              		.loc 1 2904 0
 6661 2d7e 4FEA0323 		lsl	r3, r3, #8
 6662 2d82 9BB2     		uxth	r3, r3
 6663 2d84 D318     		adds	r3, r2, r3
 6664 2d86 9AB2     		uxth	r2, r3
 6665 2d88 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6666 2d8c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6667 2d90 A3F80320 		strh	r2, [r3, #3]	@ unaligned
2906:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asn.bytes2and3   =     asn[2]+
 6668              		.loc 1 2906 0
 6669 2d94 7B68     		ldr	r3, [r7, #4]
 6670 2d96 03F10203 		add	r3, r3, #2
 6671 2d9a 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 6672 2d9c 1A46     		mov	r2, r3
2907:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                     256*asn[3];
 6673              		.loc 1 2907 0
 6674 2d9e 7B68     		ldr	r3, [r7, #4]
 6675 2da0 03F10303 		add	r3, r3, #3
 6676 2da4 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
2906:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asn.bytes2and3   =     asn[2]+
 6677              		.loc 1 2906 0
 6678 2da6 4FEA0323 		lsl	r3, r3, #8
 6679 2daa 9BB2     		uxth	r3, r3
 6680 2dac D318     		adds	r3, r2, r3
 6681 2dae 9AB2     		uxth	r2, r3
 6682 2db0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6683 2db4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6684 2db8 A3F80120 		strh	r2, [r3, #1]	@ unaligned
2908:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asn.byte4        =     asn[4];
 6685              		.loc 1 2908 0
 6686 2dbc 7B68     		ldr	r3, [r7, #4]
 6687 2dbe 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 6688 2dc0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6689 2dc4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6690 2dc8 1A70     		strb	r2, [r3, #0]
2909:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2910:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // determine the current slotOffset
2911:openstack/02a-MAClow/IEEE802154Ecsl.c ****    /*
2912:openstack/02a-MAClow/IEEE802154Ecsl.c ****    Note: this is a bit of a hack. Normally, slotOffset=ASN%slotlength. But since
2913:openstack/02a-MAClow/IEEE802154Ecsl.c ****    the ADV is exchanged in slot 0, we know that we're currently at slotOffset==0
2914:openstack/02a-MAClow/IEEE802154Ecsl.c ****    */
2915:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.slotOffset       = 0;
 6691              		.loc 1 2915 0
 6692 2dca 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6693 2dce C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6694 2dd2 4FF00002 		mov	r2, #0
 6695 2dd6 DA80     		strh	r2, [r3, #6]	@ movhi
2916:openstack/02a-MAClow/IEEE802154Ecsl.c ****    schedule_syncSlotOffset(ieee154e_vars.slotOffset);
 6696              		.loc 1 2916 0
 6697 2dd8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6698 2ddc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6699 2de0 DB88     		ldrh	r3, [r3, #6]
 6700 2de2 1846     		mov	r0, r3
 6701 2de4 FFF7FEFF 		bl	schedule_syncSlotOffset
2917:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.nextActiveSlotOffset = schedule_getNextActiveSlotOffset();
 6702              		.loc 1 2917 0
 6703 2de8 FFF7FEFF 		bl	schedule_getNextActiveSlotOffset
 6704 2dec 0346     		mov	r3, r0
 6705 2dee 1A46     		mov	r2, r3
 6706 2df0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6707 2df4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6708 2df8 1A81     		strh	r2, [r3, #8]	@ movhi
2918:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2919:openstack/02a-MAClow/IEEE802154Ecsl.c ****    /*
2920:openstack/02a-MAClow/IEEE802154Ecsl.c ****    infer the asnOffset based on the fact that
2921:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.freq = 11 + (asnOffset + channelOffset)%16
2922:openstack/02a-MAClow/IEEE802154Ecsl.c ****    */
2923:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asnOffset = ieee154e_vars.freq - 11 - schedule_getChannelOffset();
 6709              		.loc 1 2923 0
 6710 2dfa 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6711 2dfe C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6712 2e02 93F82C40 		ldrb	r4, [r3, #44]	@ zero_extendqisi2
 6713 2e06 FFF7FEFF 		bl	schedule_getChannelOffset
 6714 2e0a 0346     		mov	r3, r0
 6715 2e0c E31A     		subs	r3, r4, r3
 6716 2e0e DBB2     		uxtb	r3, r3
 6717 2e10 A3F10B03 		sub	r3, r3, #11
 6718 2e14 DAB2     		uxtb	r2, r3
 6719 2e16 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6720 2e1a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6721 2e1e 83F82D20 		strb	r2, [r3, #45]
2924:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 6722              		.loc 1 2924 0
 6723 2e22 07F10C07 		add	r7, r7, #12
 6724 2e26 BD46     		mov	sp, r7
 6725 2e28 90BD     		pop	{r4, r7, pc}
 6726              		.cfi_endproc
 6727              	.LFE73:
 6729 2e2a 00BF     		.align	2
 6730              		.global	ieee154e_asnDiff
 6731              		.thumb
 6732              		.thumb_func
 6734              	ieee154e_asnDiff:
 6735              	.LFB74:
2925:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2926:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2927:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2928:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2929:openstack/02a-MAClow/IEEE802154Ecsl.c **** /brief Difference between some older ASN and the current ASN.
2930:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2931:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in] someASN some ASN to compare to the current
2932:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2933:openstack/02a-MAClow/IEEE802154Ecsl.c **** \returns The ASN difference, or 0xffff if more than 65535 different
2934:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2935:openstack/02a-MAClow/IEEE802154Ecsl.c **** PORT_RADIOTIMER_WIDTH ieee154e_asnDiff(asn_t* someASN) {
 6736              		.loc 1 2935 0
 6737              		.cfi_startproc
 6738              		@ args = 0, pretend = 0, frame = 16
 6739              		@ frame_needed = 1, uses_anonymous_args = 0
 6740 2e2c 80B5     		push	{r7, lr}
 6741              	.LCFI182:
 6742              		.cfi_def_cfa_offset 8
 6743              		.cfi_offset 7, -8
 6744              		.cfi_offset 14, -4
 6745 2e2e 84B0     		sub	sp, sp, #16
 6746              	.LCFI183:
 6747              		.cfi_def_cfa_offset 24
 6748 2e30 00AF     		add	r7, sp, #0
 6749              	.LCFI184:
 6750              		.cfi_def_cfa_register 7
 6751 2e32 7860     		str	r0, [r7, #4]
2936:openstack/02a-MAClow/IEEE802154Ecsl.c ****    PORT_RADIOTIMER_WIDTH diff;
2937:openstack/02a-MAClow/IEEE802154Ecsl.c ****    INTERRUPT_DECLARATION();
2938:openstack/02a-MAClow/IEEE802154Ecsl.c ****    DISABLE_INTERRUPTS();
 6752              		.loc 1 2938 0
 6753 2e34 FFF7FEFF 		bl	IntMasterDisable
2939:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.asn.byte4 != someASN->byte4) {
 6754              		.loc 1 2939 0
 6755 2e38 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6756 2e3c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6757 2e40 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 6758 2e42 7B68     		ldr	r3, [r7, #4]
 6759 2e44 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 6760 2e46 9A42     		cmp	r2, r3
 6761 2e48 04D0     		beq	.L317
2940:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ENABLE_INTERRUPTS();
 6762              		.loc 1 2940 0
 6763 2e4a FFF7FEFF 		bl	IntMasterEnable
2941:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return (PORT_RADIOTIMER_WIDTH)0xFFFFFFFF;;
 6764              		.loc 1 2941 0
 6765 2e4e 4FF0FF33 		mov	r3, #-1
 6766 2e52 4CE0     		b	.L318
 6767              	.L317:
2942:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2943:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2944:openstack/02a-MAClow/IEEE802154Ecsl.c ****    diff = 0;
 6768              		.loc 1 2944 0
 6769 2e54 4FF00003 		mov	r3, #0
 6770 2e58 FB60     		str	r3, [r7, #12]
2945:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.asn.bytes2and3 == someASN->bytes2and3) {
 6771              		.loc 1 2945 0
 6772 2e5a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6773 2e5e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6774 2e62 B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 6775 2e66 9AB2     		uxth	r2, r3
 6776 2e68 7B68     		ldr	r3, [r7, #4]
 6777 2e6a B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 6778 2e6e 9BB2     		uxth	r3, r3
 6779 2e70 9A42     		cmp	r2, r3
 6780 2e72 0FD1     		bne	.L319
2946:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ENABLE_INTERRUPTS();
 6781              		.loc 1 2946 0
 6782 2e74 FFF7FEFF 		bl	IntMasterEnable
2947:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return ieee154e_vars.asn.bytes0and1-someASN->bytes0and1;
 6783              		.loc 1 2947 0
 6784 2e78 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6785 2e7c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6786 2e80 B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 6787 2e84 9BB2     		uxth	r3, r3
 6788 2e86 1A46     		mov	r2, r3
 6789 2e88 7B68     		ldr	r3, [r7, #4]
 6790 2e8a B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 6791 2e8e 9BB2     		uxth	r3, r3
 6792 2e90 D31A     		subs	r3, r2, r3
 6793 2e92 2CE0     		b	.L318
 6794              	.L319:
2948:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else if (ieee154e_vars.asn.bytes2and3-someASN->bytes2and3==1) {
 6795              		.loc 1 2948 0
 6796 2e94 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6797 2e98 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6798 2e9c B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 6799 2ea0 9BB2     		uxth	r3, r3
 6800 2ea2 1A46     		mov	r2, r3
 6801 2ea4 7B68     		ldr	r3, [r7, #4]
 6802 2ea6 B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 6803 2eaa 9BB2     		uxth	r3, r3
 6804 2eac D31A     		subs	r3, r2, r3
 6805 2eae 012B     		cmp	r3, #1
 6806 2eb0 17D1     		bne	.L320
2949:openstack/02a-MAClow/IEEE802154Ecsl.c ****       diff  = ieee154e_vars.asn.bytes0and1;
 6807              		.loc 1 2949 0
 6808 2eb2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6809 2eb6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6810 2eba B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 6811 2ebe 9BB2     		uxth	r3, r3
 6812 2ec0 FB60     		str	r3, [r7, #12]
2950:openstack/02a-MAClow/IEEE802154Ecsl.c ****       diff += 0xffff-someASN->bytes0and1;
 6813              		.loc 1 2950 0
 6814 2ec2 7B68     		ldr	r3, [r7, #4]
 6815 2ec4 B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 6816 2ec8 9BB2     		uxth	r3, r3
 6817 2eca FA68     		ldr	r2, [r7, #12]
 6818 2ecc D31A     		subs	r3, r2, r3
 6819 2ece 03F57F43 		add	r3, r3, #65280
 6820 2ed2 03F1FF03 		add	r3, r3, #255
 6821 2ed6 FB60     		str	r3, [r7, #12]
2951:openstack/02a-MAClow/IEEE802154Ecsl.c ****       diff += 1;
 6822              		.loc 1 2951 0
 6823 2ed8 FB68     		ldr	r3, [r7, #12]
 6824 2eda 03F10103 		add	r3, r3, #1
 6825 2ede FB60     		str	r3, [r7, #12]
 6826 2ee0 02E0     		b	.L321
 6827              	.L320:
2952:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
2953:openstack/02a-MAClow/IEEE802154Ecsl.c ****       diff = (PORT_RADIOTIMER_WIDTH)0xFFFFFFFF;;
 6828              		.loc 1 2953 0
 6829 2ee2 4FF0FF33 		mov	r3, #-1
 6830 2ee6 FB60     		str	r3, [r7, #12]
 6831              	.L321:
2954:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2955:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ENABLE_INTERRUPTS();
 6832              		.loc 1 2955 0
 6833 2ee8 FFF7FEFF 		bl	IntMasterEnable
2956:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return diff;
 6834              		.loc 1 2956 0
 6835 2eec FB68     		ldr	r3, [r7, #12]
 6836              	.L318:
2957:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 6837              		.loc 1 2957 0
 6838 2eee 1846     		mov	r0, r3
 6839 2ef0 07F11007 		add	r7, r7, #16
 6840 2ef4 BD46     		mov	sp, r7
 6841 2ef6 80BD     		pop	{r7, pc}
 6842              		.cfi_endproc
 6843              	.LFE74:
 6845              	.Letext0:
 6846              		.file 2 "/opt/gcc-arm-none-eabi-4_7-2013q3/bin/../lib/gcc/arm-none-eabi/4.7.4/../../../../arm-none
 6847              		.file 3 "inc/opendefs.h"
 6848              		.file 4 "openstack/02b-MAChigh/schedule.h"
 6849              		.file 5 "openstack/02b-MAChigh/processIE.h"
 6850              		.file 6 "openstack/02a-MAClow/IEEE802154Ecsl.h"
 6851              		.file 7 "openstack/02a-MAClow/IEEE802154.h"
 6852              		.file 8 "kernel/scheduler.h"
 6853              		.file 9 "bsp/boards/OpenMote-CC2538/board_info.h"
 6854              		.file 10 "openstack/03b-IPv6/icmpv6rpl.h"
DEFINED SYMBOLS
                            *ABS*:00000000 IEEE802154Ecsl.c
     /tmp/cc2R3Vn9.s:19     .rodata:00000000 $d
     /tmp/cc2R3Vn9.s:22     .rodata:00000000 rreg_uriquery
     /tmp/cc2R3Vn9.s:27     .rodata:00000008 infoBoardname
     /tmp/cc2R3Vn9.s:32     .rodata:00000010 infouCName
     /tmp/cc2R3Vn9.s:37     .rodata:00000018 infoRadioName
     /tmp/cc2R3Vn9.s:42     .rodata:00000024 infoStackName
     /tmp/cc2R3Vn9.s:47     .rodata:00000030 all_routers_multicast
                            *COM*:0000004c ieee154e_vars
                            *COM*:0000000f ieee154e_stats
                            *COM*:00000014 ieee154e_dbg
     /tmp/cc2R3Vn9.s:68     .text:00000000 $t
     /tmp/cc2R3Vn9.s:73     .text:00000000 ieee154e_init
     /tmp/cc2R3Vn9.s:5487   .text:000025a0 changeIsSync
     /tmp/cc2R3Vn9.s:5637   .text:00002650 resetStats
     /tmp/cc2R3Vn9.s:162    .text:000000b8 isr_ieee154ecsl_newChannelSample
     /tmp/cc2R3Vn9.s:223    .text:0000011c isr_ieee154ecsl_timer
     /tmp/cc2R3Vn9.s:492    .text:00000320 ieee154ecsl_startOfFrame
     /tmp/cc2R3Vn9.s:646    .text:0000045c ieee154ecsl_endOfFrame
     /tmp/cc2R3Vn9.s:2620   .text:000011dc activity_csl_wakeup_ri1
     /tmp/cc2R3Vn9.s:254    .text:00000148 $d
     /tmp/cc2R3Vn9.s:2688   .text:0000124c activity_csl_wakeup_ri2
     /tmp/cc2R3Vn9.s:272    .text:00000188 $t
     /tmp/cc2R3Vn9.s:2738   .text:0000129c activity_csl_wakeup_rie1
     /tmp/cc2R3Vn9.s:2779   .text:000012cc activity_csl_wakeup_ri3
     /tmp/cc2R3Vn9.s:2811   .text:000012e8 activity_csl_wakeup_rie2
     /tmp/cc2R3Vn9.s:2899   .text:00001358 activity_csl_wakeup_rie3
     /tmp/cc2R3Vn9.s:3296   .text:000016b4 activity_csl_wakeup_rie4
     /tmp/cc2R3Vn9.s:3322   .text:000016c0 activity_csl_data_ri2
     /tmp/cc2R3Vn9.s:3372   .text:00001710 activity_csl_data_rie1
     /tmp/cc2R3Vn9.s:3413   .text:00001740 activity_csl_data_ri3
     /tmp/cc2R3Vn9.s:3445   .text:0000175c activity_csl_data_rie2
     /tmp/cc2R3Vn9.s:3523   .text:000017b0 activity_csl_data_rie3
     /tmp/cc2R3Vn9.s:3921   .text:00001aec activity_csl_data_ri6
     /tmp/cc2R3Vn9.s:4154   .text:00001d08 activity_csl_data_rie4
     /tmp/cc2R3Vn9.s:4195   .text:00001d38 activity_csl_data_ri7
     /tmp/cc2R3Vn9.s:4231   .text:00001d60 activity_csl_data_rie5
     /tmp/cc2R3Vn9.s:4319   .text:00001dcc activity_csl_data_rie6
     /tmp/cc2R3Vn9.s:6016   .text:000028f8 endOps
     /tmp/cc2R3Vn9.s:373    .text:0000023c $d
     /tmp/cc2R3Vn9.s:1155   .text:00000818 activity_csl_wakeup_ti2
     /tmp/cc2R3Vn9.s:391    .text:0000027c $t
     /tmp/cc2R3Vn9.s:1388   .text:00000a54 activity_csl_wakeup_tie1
     /tmp/cc2R3Vn9.s:1426   .text:00000a80 activity_csl_wakeup_ti3
     /tmp/cc2R3Vn9.s:1462   .text:00000aa8 activity_csl_wakeup_tie2
     /tmp/cc2R3Vn9.s:1547   .text:00000b10 activity_csl_wakeup_tie3
     /tmp/cc2R3Vn9.s:1630   .text:00000b74 activity_csl_data_ti1
     /tmp/cc2R3Vn9.s:1664   .text:00000b98 activity_csl_data_ti2
     /tmp/cc2R3Vn9.s:1728   .text:00000c08 activity_csl_data_tie1
     /tmp/cc2R3Vn9.s:1766   .text:00000c34 activity_csl_data_ti3
     /tmp/cc2R3Vn9.s:1802   .text:00000c5c activity_csl_data_tie2
     /tmp/cc2R3Vn9.s:1887   .text:00000cc4 activity_csl_data_tie3
     /tmp/cc2R3Vn9.s:2038   .text:00000dbc activity_csl_data_ti6
     /tmp/cc2R3Vn9.s:2088   .text:00000e0c activity_csl_data_tie4
     /tmp/cc2R3Vn9.s:2126   .text:00000e38 activity_csl_data_ti7
     /tmp/cc2R3Vn9.s:2162   .text:00000e60 activity_csl_data_tie5
     /tmp/cc2R3Vn9.s:2271   .text:00000f08 activity_csl_data_tie6
     /tmp/cc2R3Vn9.s:527    .text:00000350 $d
     /tmp/cc2R3Vn9.s:541    .text:00000380 $t
     /tmp/cc2R3Vn9.s:2847   .text:00001310 activity_csl_wakeup_ri4
     /tmp/cc2R3Vn9.s:3471   .text:00001768 activity_csl_data_ri4
     /tmp/cc2R3Vn9.s:4272   .text:00001d90 activity_csl_data_ri8
     /tmp/cc2R3Vn9.s:578    .text:000003c8 $d
     /tmp/cc2R3Vn9.s:592    .text:000003f8 $t
     /tmp/cc2R3Vn9.s:2229   .text:00000ed8 activity_csl_data_ti8
     /tmp/cc2R3Vn9.s:1500   .text:00000ad4 activity_csl_wakeup_ti4
     /tmp/cc2R3Vn9.s:1840   .text:00000c88 activity_csl_data_ti4
     /tmp/cc2R3Vn9.s:681    .text:0000048c $d
     /tmp/cc2R3Vn9.s:696    .text:000004c0 $t
     /tmp/cc2R3Vn9.s:2940   .text:00001388 activity_csl_wakeup_ri5
     /tmp/cc2R3Vn9.s:3564   .text:000017e0 activity_csl_data_ri5
     /tmp/cc2R3Vn9.s:4360   .text:00001dfc activity_csl_data_ri9
     /tmp/cc2R3Vn9.s:1585   .text:00000b3c activity_csl_wakeup_ti5
     /tmp/cc2R3Vn9.s:1925   .text:00000cf0 activity_csl_data_ti5
     /tmp/cc2R3Vn9.s:2297   .text:00000f14 activity_csl_data_ti9
     /tmp/cc2R3Vn9.s:807    .text:00000594 isr_ieee154ecsl_txtimer_cb
     /tmp/cc2R3Vn9.s:1014   .text:00000704 activity_csl_wakeup_ti1
     /tmp/cc2R3Vn9.s:857    .text:000005d8 isr_ieee154ecsl_addPacketToQueueForTestingCslTx_cb
     /tmp/cc2R3Vn9.s:5204   .text:00002374 incrementAsnOffset
     /tmp/cc2R3Vn9.s:5760   .text:00002714 changeState
     /tmp/cc2R3Vn9.s:4425   .text:00001e68 ieee802154_createWakeUpFrame
     /tmp/cc2R3Vn9.s:5540   .text:000025e0 notif_sendDone
     /tmp/cc2R3Vn9.s:5115   .text:000022f4 isValidAck
     /tmp/cc2R3Vn9.s:6245   .text:00002ad8 ieee154e_processIEs
     /tmp/cc2R3Vn9.s:4554   .text:00001f4c ieee802154_retrieveWakeUpFrame
     /tmp/cc2R3Vn9.s:5022   .text:00002278 isValidRxFrame
     /tmp/cc2R3Vn9.s:5594   .text:0000262c notif_receive
     /tmp/cc2R3Vn9.s:5306   .text:0000245c ieee154e_getAsn
     /tmp/cc2R3Vn9.s:5383   .text:000024e8 synchronizeAck
     /tmp/cc2R3Vn9.s:5699   .text:000026c0 updateStats
     /tmp/cc2R3Vn9.s:5794   .text:00002740 $d
     /tmp/cc2R3Vn9.s:5856   .text:00002830 $t
     /tmp/cc2R3Vn9.s:5882   .text:0000284c debugPrint_asn
     /tmp/cc2R3Vn9.s:5937   .text:000028a0 debugPrint_isSync
     /tmp/cc2R3Vn9.s:5983   .text:000028d8 debugPrint_macStats
     /tmp/cc2R3Vn9.s:6214   .text:00002ac0 ieee154e_isSynch
     /tmp/cc2R3Vn9.s:6633   .text:00002d68 asnStoreFromAdv
     /tmp/cc2R3Vn9.s:6589   .text:00002d30 joinPriorityStoreFromAdv
     /tmp/cc2R3Vn9.s:6734   .text:00002e2c ieee154e_asnDiff
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.1.e96eee74da26538b12ac9582e3798382
                           .group:00000000 wm4.newlib.h.8.a9901dc52d1357e3e94003403d43f8b5
                           .group:00000000 wm4.features.h.22.b72b3baab2bb2eab3661375590100b6b
                           .group:00000000 wm4.config.h.193.5fb8ef056cdff92dec3dee9552839d8c
                           .group:00000000 wm4._ansi.h.23.b5bb84d7ba97d82b5b1dc1826a7ae811
                           .group:00000000 wm4.stdint.h.20.54ad762faa59e3c05491630641c8d8bf
                           .group:00000000 wm4.toolchain_defs.h.2.e4ebbe6e0a48032a9b79077dc42e1ffd
                           .group:00000000 wm4._default_types.h.6.5e12cd604db8ce00b62bb2f02708eaf3
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4.stddef.h.349.31f4c5baff3fa2689010b32028da9c47
                           .group:00000000 wm4.reent.h.16.9e42f0e588b85e70b2bf6572af57ce64
                           .group:00000000 wm4.stddef.h.187.9e651b6b8b16e149c1353259404973ea
                           .group:00000000 wm4.string.h.17.f8d12df81104836a3f2a5d589ae830d8
                           .group:00000000 wm4.stdbool.h.29.1c9ee6859ce8145f7838a4f2549ccec2
                           .group:00000000 wm4.hw_types.h.67.b10589a0806dcc2d274d6fab6b736519
                           .group:00000000 wm4.interrupt.h.41.272fc4ec0e276feb439e7974d0f77eaf
                           .group:00000000 wm4.board_info.h.21.847e72606a2fc49b1c228f268b8a62aa
                           .group:00000000 wm4.opendefs.h.19.05852eb648ac65e48c7817e5cbf03346
                           .group:00000000 wm4.schedule.h.2.74f699399ee9cbf3b59178f1204d8511
                           .group:00000000 wm4.processIE.h.2.1848f1e3c653035e9779472584ce0441
                           .group:00000000 wm4.opentimers.h.8.044f2d040a134cdb0ddb58adfc2508be
                           .group:00000000 wm4.IEEE802154Ecsl.h.21.4a27f1f1ecd53a3f77f305e2d49a8f4a
                           .group:00000000 wm4.idmanager.h.2.8c0e2159b32ef3125cbb1e984805cbfe
                           .group:00000000 wm4.openserial.h.8.8c63e3800d2936b44b5370ce1aae62b7
                           .group:00000000 wm4.scheduler.h.2.ca320b72942c5204a6e225e3c9c0814e
                           .group:00000000 wm4.icmpv6rpl.h.2.0ce84dbe8c203c7079b39e7e96c7c01e
                           .group:00000000 wm4.neighbors.h.15.9f35f180a0332d1bc442efb0ec51905c
                           .group:00000000 wm4.sixtop.h.2.0b8613e8e48e9109b53e6143f3ed1895

UNDEFINED SYMBOLS
memset
idmanager_getIsDAGroot
radio_rfOn
radio_setOverflowCb
radio_setCompareCb
radio_setStartFrameCb
radio_setEndFrameCb
radio_startTimer
radio_setTimerPeriod
openserial_printInfo
openserial_printError
leds_all_off
openqueue_macGetDataPacket
openqueue_getFreePacketBuffer
ieee802154_prependHeader
packetfunctions_reserveFooterSize
debugpins_slot_toggle
debugpins_frame_toggle
schedule_advanceSlot
openserial_stop
schedule_getType
schedule_getOkToSend
schedule_getNeighbor
radiotimer_schedule
radio_loadPacket
radio_txEnable
radio_getTimerValue
openqueue_freePacketBuffer
radio_txNow
radiotimer_cancel
radio_rfOff
packetfunctions_isBroadcastMulticast
leds_sync_blink
schedule_indicateTx
radio_rxEnable
radio_rxNow
radio_getReceivedFrame
packetfunctions_tossFooter
ieee802154_retrieveHeader
packetfunctions_tossHeader
packetfunctions_mac64bToMac16b
packetfunctions_sameAddress
idmanager_getMyID
packetfunctions_reserveHeaderSize
packetfunctions_writeAddress
packetfunctions_readAddress
idmanager_isMyAddress
schedule_getFrameLength
radio_getTimerPeriod
adaptive_sync_indicateTimeCorrection
leds_sync_on
leds_sync_off
schedule_resetBackoff
task_sixtopNotifSendDone
scheduler_push_task
leds_error_toggle
debugpins_fsm_set
debugpins_fsm_clr
debugpins_fsm_toggle
openserial_printStatus
processIE_retrieveSlotframeLinkIE
neighbors_isPreferredParent
schedule_syncSlotOffset
schedule_getNextActiveSlotOffset
schedule_getChannelOffset
IntMasterDisable
IntMasterEnable
