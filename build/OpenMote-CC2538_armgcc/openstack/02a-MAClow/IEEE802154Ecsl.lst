   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"IEEE802154Ecsl.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.rodata
  19              		.align	2
  22              	rreg_uriquery:
  23 0000 683D7563 		.ascii	"h=ucb\000"
  23      6200
  24 0006 0000     		.align	2
  27              	infoBoardname:
  28 0008 43433235 		.ascii	"CC2538\000"
  28      333800
  29 000f 00       		.align	2
  32              	infouCName:
  33 0010 43433235 		.ascii	"CC2538\000"
  33      333800
  34 0017 00       		.align	2
  37              	infoRadioName:
  38 0018 43433235 		.ascii	"CC2538 SoC\000"
  38      33382053 
  38      6F4300
  39 0023 00       		.align	2
  42              	infoStackName:
  43 0024 4F70656E 		.ascii	"OpenWSN \000"
  43      57534E20 
  43      00
  44 002d 000000   		.align	2
  47              	all_routers_multicast:
  48 0030 FF       		.byte	-1
  49 0031 02       		.byte	2
  50 0032 00       		.byte	0
  51 0033 00       		.byte	0
  52 0034 00       		.byte	0
  53 0035 00       		.byte	0
  54 0036 00       		.byte	0
  55 0037 00       		.byte	0
  56 0038 00       		.byte	0
  57 0039 00       		.byte	0
  58 003a 00       		.byte	0
  59 003b 00       		.byte	0
  60 003c 00       		.byte	0
  61 003d 00       		.byte	0
  62 003e 00       		.byte	0
  63 003f 02       		.byte	2
  64              		.comm	ieee154e_vars,76,4
  65              		.comm	ieee154e_stats,15,4
  66              		.comm	ieee154e_dbg,20,4
  67              		.text
  68              		.align	2
  69              		.global	ieee154e_init
  70              		.thumb
  71              		.thumb_func
  73              	ieee154e_init:
  74              	.LFB0:
  75              		.file 1 "openstack/02a-MAClow/IEEE802154Ecsl.c"
   1:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "IEEE802154Ecsl.h"
   2:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
   3:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "opendefs.h"
   4:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "radio.h"
   5:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "radiotimer.h"
   6:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "IEEE802154.h"
   7:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "openqueue.h"
   8:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "idmanager.h"
   9:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "openserial.h"
  10:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "schedule.h"
  11:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "packetfunctions.h"
  12:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "scheduler.h"
  13:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "leds.h"
  14:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "neighbors.h"
  15:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "debugpins.h"
  16:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "sixtop.h"
  17:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "adaptive_sync.h"
  18:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "processIE.h"
  19:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  20:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
  21:openstack/02a-MAClow/IEEE802154Ecsl.c **** //=========================== VARIABLES ================================
  22:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
  23:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  24:openstack/02a-MAClow/IEEE802154Ecsl.c **** ieee154e_vars_t    ieee154e_vars;
  25:openstack/02a-MAClow/IEEE802154Ecsl.c **** ieee154e_stats_t   ieee154e_stats;
  26:openstack/02a-MAClow/IEEE802154Ecsl.c **** ieee154e_dbg_t     ieee154e_dbg;
  27:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  28:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
  29:openstack/02a-MAClow/IEEE802154Ecsl.c **** //========================== PROTOTYPES ================================
  30:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
  31:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  32:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  33:openstack/02a-MAClow/IEEE802154Ecsl.c **** // TX-MODE: CSL Frame sending activities prototypes
  34:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ti1(void);
  35:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ti2(void);
  36:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_tie1(void);
  37:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ti3(void);
  38:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_tie2(void);
  39:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ti4(PORT_RADIOTIMER_WIDTH capturedTime);
  40:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_tie3(void);
  41:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ti5(PORT_RADIOTIMER_WIDTH capturedTime);
  42:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  43:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti1(void);
  44:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti2(void);
  45:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_tie1(void);
  46:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti3(void);
  47:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_tie2(void);
  48:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti4(PORT_RADIOTIMER_WIDTH capturedTime);
  49:openstack/02a-MAClow/IEEE802154Ecsl.c **** void	activity_csl_data_tie3(void);
  50:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti5(PORT_RADIOTIMER_WIDTH capturedTime);
  51:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti6(void);
  52:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_tie4(void);
  53:openstack/02a-MAClow/IEEE802154Ecsl.c **** void	activity_csl_data_ti7(void);
  54:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_tie5(void);
  55:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti8(PORT_RADIOTIMER_WIDTH capturedTime);
  56:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_tie6(void);
  57:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti9(PORT_RADIOTIMER_WIDTH capturedTime);
  58:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  59:openstack/02a-MAClow/IEEE802154Ecsl.c **** // RX-MODE: CSL Sampling activities prototypes
  60:openstack/02a-MAClow/IEEE802154Ecsl.c **** void 	activity_csl_wakeup_ri1(void);
  61:openstack/02a-MAClow/IEEE802154Ecsl.c **** void 	activity_csl_wakeup_ri2(void);
  62:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_rie1(void);
  63:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ri3(void);
  64:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_rie2(void);
  65:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ri4(PORT_RADIOTIMER_WIDTH capturedTime);
  66:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_rie3(void);
  67:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ri5(PORT_RADIOTIMER_WIDTH capturedTime);
  68:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_rie4(void);
  69:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  70:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ri2(void);
  71:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_rie1(void);
  72:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ri3(void);
  73:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_rie2(void);
  74:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ri4(PORT_RADIOTIMER_WIDTH capturedTime);
  75:openstack/02a-MAClow/IEEE802154Ecsl.c **** void	activity_csl_data_rie3(void);
  76:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ri5(PORT_RADIOTIMER_WIDTH capturedTime);
  77:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ri6(void);
  78:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_rie4(void);
  79:openstack/02a-MAClow/IEEE802154Ecsl.c **** void	activity_csl_data_ri7(void);
  80:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_rie5(void);
  81:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ri8(PORT_RADIOTIMER_WIDTH capturedTime);
  82:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_rie6(void);
  83:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ri9(PORT_RADIOTIMER_WIDTH capturedTime);
  84:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  85:openstack/02a-MAClow/IEEE802154Ecsl.c **** // frame validity check
  86:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool     isValidRxFrame(ieee802154_header_iht* ieee802514_header);
  87:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool     isValidAck(ieee802154_header_iht*     ieee802514_header,
  88:openstack/02a-MAClow/IEEE802154Ecsl.c ****                     OpenQueueEntry_t*          packetSent);
  89:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     changeIsSync(bool newIsSync);
  90:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  91:openstack/02a-MAClow/IEEE802154Ecsl.c **** // statistics
  92:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     resetStats(void);
  93:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     updateStats(PORT_SIGNED_INT_WIDTH timeCorrection);
  94:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  95:openstack/02a-MAClow/IEEE802154Ecsl.c **** // notifying upper layer
  96:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     notif_sendDone(OpenQueueEntry_t* packetSent, owerror_t error);
  97:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     notif_receive(OpenQueueEntry_t* packetReceived, uint8_t action);
  98:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  99:openstack/02a-MAClow/IEEE802154Ecsl.c **** // IEs Handling
 100:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool     ieee154e_processIEs(OpenQueueEntry_t* pkt, uint16_t* lenIE);
 101:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 102:openstack/02a-MAClow/IEEE802154Ecsl.c **** // ASN handling
 103:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     incrementAsnOffset(void);
 104:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     asnStoreFromAdv(uint8_t* asn);
 105:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     joinPriorityStoreFromAdv(uint8_t jp);
 106:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 107:openstack/02a-MAClow/IEEE802154Ecsl.c **** // misc
 108:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     changeState(ieee154e_state_t newstate);
 109:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     endOps(void);
 110:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool     debugPrint_asn(void);
 111:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool     debugPrint_isSync(void);
 112:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 113:openstack/02a-MAClow/IEEE802154Ecsl.c **** // CSL Sampling interrupts
 114:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     isr_ieee154ecsl_newChannelSample(void);
 115:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     isr_ieee154ecsl_timer(void);
 116:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 117:openstack/02a-MAClow/IEEE802154Ecsl.c **** // CSL queue checking for local transmissions
 118:openstack/02a-MAClow/IEEE802154Ecsl.c **** void 	 isr_ieee154ecsl_txtimer_cb(void);
 119:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 120:openstack/02a-MAClow/IEEE802154Ecsl.c **** // Testing callback to put a packet on queue for testing CSL Tx mode.
 121:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     isr_ieee154ecsl_addPacketToQueueForTestingCslTx_cb (void);
 122:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 123:openstack/02a-MAClow/IEEE802154Ecsl.c **** // CSL Wake-up frames (create and retrieve methods).
 124:openstack/02a-MAClow/IEEE802154Ecsl.c **** void 	ieee802154_retrieveWakeUpFrame(OpenQueueEntry_t* msg, ieee802154_header_iht* ieee802514_heade
 125:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    ieee802154_createWakeUpFrame(OpenQueueEntry_t* msg, uint8_t sequenceNumber, open_addr_t* ne
 126:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 127:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 128:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 129:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
 130:openstack/02a-MAClow/IEEE802154Ecsl.c **** //========================== INITIALIZATION ============================
 131:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
 132:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 133:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 134:openstack/02a-MAClow/IEEE802154Ecsl.c ****   \brief This function initializes this module.
 135:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 136:openstack/02a-MAClow/IEEE802154Ecsl.c ****   Call this function once before any other function in this module, possibly during boot-up.
 137:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 138:openstack/02a-MAClow/IEEE802154Ecsl.c **** void ieee154e_init() {
  76              		.loc 1 138 0
  77              		.cfi_startproc
  78              		@ args = 0, pretend = 0, frame = 0
  79              		@ frame_needed = 1, uses_anonymous_args = 0
  80 0000 80B5     		push	{r7, lr}
  81              	.LCFI0:
  82              		.cfi_def_cfa_offset 8
  83              		.cfi_offset 7, -8
  84              		.cfi_offset 14, -4
  85 0002 00AF     		add	r7, sp, #0
  86              	.LCFI1:
  87              		.cfi_def_cfa_register 7
 139:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
 140:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // initialize variables
 141:openstack/02a-MAClow/IEEE802154Ecsl.c ****    memset(&ieee154e_vars,0,sizeof(ieee154e_vars_t));
  88              		.loc 1 141 0
  89 0004 40F20000 		movw	r0, #:lower16:ieee154e_vars
  90 0008 C0F20000 		movt	r0, #:upper16:ieee154e_vars
  91 000c 4FF00001 		mov	r1, #0
  92 0010 4FF04C02 		mov	r2, #76
  93 0014 FFF7FEFF 		bl	memset
 142:openstack/02a-MAClow/IEEE802154Ecsl.c ****    memset(&ieee154e_dbg,0,sizeof(ieee154e_dbg_t));
  94              		.loc 1 142 0
  95 0018 40F20000 		movw	r0, #:lower16:ieee154e_dbg
  96 001c C0F20000 		movt	r0, #:upper16:ieee154e_dbg
  97 0020 4FF00001 		mov	r1, #0
  98 0024 4FF01402 		mov	r2, #20
  99 0028 FFF7FEFF 		bl	memset
 143:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
 144:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (idmanager_getIsDAGroot()==TRUE) {
 100              		.loc 1 144 0
 101 002c FFF7FEFF 		bl	idmanager_getIsDAGroot
 102 0030 0346     		mov	r3, r0
 103 0032 002B     		cmp	r3, #0
 104 0034 04D0     		beq	.L2
 145:openstack/02a-MAClow/IEEE802154Ecsl.c ****       changeIsSync(TRUE);
 105              		.loc 1 145 0
 106 0036 4FF00100 		mov	r0, #1
 107 003a FFF7FEFF 		bl	changeIsSync
 108 003e 03E0     		b	.L3
 109              	.L2:
 146:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
 147:openstack/02a-MAClow/IEEE802154Ecsl.c ****       changeIsSync(FALSE);
 110              		.loc 1 147 0
 111 0040 4FF00000 		mov	r0, #0
 112 0044 FFF7FEFF 		bl	changeIsSync
 113              	.L3:
 148:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 149:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
 150:openstack/02a-MAClow/IEEE802154Ecsl.c ****    resetStats();
 114              		.loc 1 150 0
 115 0048 FFF7FEFF 		bl	resetStats
 151:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.numDeSync                 = 0;
 116              		.loc 1 151 0
 117 004c 40F20003 		movw	r3, #:lower16:ieee154e_stats
 118 0050 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 119 0054 4FF00002 		mov	r2, #0
 120 0058 9A71     		strb	r2, [r3, #6]
 152:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
 153:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // update CSL Mode to SLEEP in order to allow RX o TX.
 154:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.cslMode = CSL_SLEEP_MODE;
 121              		.loc 1 154 0
 122 005a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 123 005e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 124 0062 4FF00002 		mov	r2, #0
 125 0066 83F84520 		strb	r2, [r3, #69]
 155:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Set initial DSN counter for wake-up sequence frames.
 156:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.cslDSN	 = 0;
 126              		.loc 1 156 0
 127 006a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 128 006e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 129 0072 4FF00002 		mov	r2, #0
 130 0076 83F84420 		strb	r2, [r3, #68]
 157:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 158:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // switch radio on - Does this function really do anything?. Its contents are commented...
 159:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rfOn();
 131              		.loc 1 159 0
 132 007a FFF7FEFF 		bl	radio_rfOn
 160:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
 161:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // set callback functions for the radio
 162:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_setOverflowCb(isr_ieee154ecsl_newChannelSample); // Fires every macCSLPeriod for CSL chann
 133              		.loc 1 162 0
 134 007e 40F20000 		movw	r0, #:lower16:isr_ieee154ecsl_newChannelSample
 135 0082 C0F20000 		movt	r0, #:upper16:isr_ieee154ecsl_newChannelSample
 136 0086 FFF7FEFF 		bl	radio_setOverflowCb
 163:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_setCompareCb(isr_ieee154ecsl_timer);             // Fires for FSM state changing
 137              		.loc 1 163 0
 138 008a 40F20000 		movw	r0, #:lower16:isr_ieee154ecsl_timer
 139 008e C0F20000 		movt	r0, #:upper16:isr_ieee154ecsl_timer
 140 0092 FFF7FEFF 		bl	radio_setCompareCb
 164:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_setStartFrameCb(ieee154ecsl_startOfFrame);
 141              		.loc 1 164 0
 142 0096 40F20000 		movw	r0, #:lower16:ieee154ecsl_startOfFrame
 143 009a C0F20000 		movt	r0, #:upper16:ieee154ecsl_startOfFrame
 144 009e FFF7FEFF 		bl	radio_setStartFrameCb
 165:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_setEndFrameCb(ieee154ecsl_endOfFrame);
 145              		.loc 1 165 0
 146 00a2 40F20000 		movw	r0, #:lower16:ieee154ecsl_endOfFrame
 147 00a6 C0F20000 		movt	r0, #:upper16:ieee154ecsl_endOfFrame
 148 00aa FFF7FEFF 		bl	radio_setEndFrameCb
 166:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 167:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // set timer for checking frames on local queue to transmit.
 168:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //ieee154e_vars.txTimer = opentimers_start(macCSLTxChkFreq, TIMER_PERIODIC, TIME_TICS, isr_ieee1
 169:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 170:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // set timer for callback to add packet to queue for testing CSL TX (every 5 seconds)
 171:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //ieee154e_vars.cslTxTestTimer = opentimers_start(2000, TIMER_PERIODIC, TIME_MS, isr_ieee154ecsl
 172:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 173:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // have the radio start its timer for channel sampling (macCSLPeriod)
 174:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_startTimer(macCSLPeriod);
 149              		.loc 1 174 0
 150 00ae 41F69A10 		movw	r0, #6554
 151 00b2 FFF7FEFF 		bl	radio_startTimer
 175:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 152              		.loc 1 175 0
 153 00b6 80BD     		pop	{r7, pc}
 154              		.cfi_endproc
 155              	.LFE0:
 157              		.align	2
 158              		.global	isr_ieee154ecsl_newChannelSample
 159              		.thumb
 160              		.thumb_func
 162              	isr_ieee154ecsl_newChannelSample:
 163              	.LFB1:
 176:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 177:openstack/02a-MAClow/IEEE802154Ecsl.c **** //=========================== public ==========================================
 178:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 179:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
 180:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================  EVENTS & CALLBACKS ===========================
 181:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
 182:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 183:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 184:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Indicates a new CSL Channel Sample has just started.
 185:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 186:openstack/02a-MAClow/IEEE802154Ecsl.c **** This function executes in ISR mode, when the new CSÑ Channel Sample timer fires.
 187:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 188:openstack/02a-MAClow/IEEE802154Ecsl.c **** void isr_ieee154ecsl_newChannelSample() {
 164              		.loc 1 188 0
 165              		.cfi_startproc
 166              		@ args = 0, pretend = 0, frame = 0
 167              		@ frame_needed = 1, uses_anonymous_args = 0
 168 00b8 80B5     		push	{r7, lr}
 169              	.LCFI2:
 170              		.cfi_def_cfa_offset 8
 171              		.cfi_offset 7, -8
 172              		.cfi_offset 14, -4
 173 00ba 00AF     		add	r7, sp, #0
 174              	.LCFI3:
 175              		.cfi_def_cfa_register 7
 189:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Establish the new timer for the next channel sample
 190:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_setTimerPeriod(macCSLPeriod);
 176              		.loc 1 190 0
 177 00bc 41F69A10 		movw	r0, #6554
 178 00c0 FFF7FEFF 		bl	radio_setTimerPeriod
 191:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 192:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Verificamos que no estamos ya en un proceso de TX o RX previo.
 193:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if(ieee154e_vars.cslMode == CSL_SLEEP_MODE) {
 179              		.loc 1 193 0
 180 00c4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 181 00c8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 182 00cc 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 183 00d0 002B     		cmp	r3, #0
 184 00d2 02D1     		bne	.L5
 194:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // We call the first activity on FSM for channel sampling (CSL FSM RX mode)
 195:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  activity_csl_wakeup_ri1();
 185              		.loc 1 195 0
 186 00d4 FFF7FEFF 		bl	activity_csl_wakeup_ri1
 187 00d8 12E0     		b	.L6
 188              	.L5:
 196:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
 197:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // log the info about a operation in progress
 198:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printInfo(COMPONENT_IEEE802154E,ERR_MAC_OPERATION_IN_PROGRESS,
 199:openstack/02a-MAClow/IEEE802154Ecsl.c **** 						  (errorparameter_t)ieee154e_vars.cslMode, (errorparameter_t)ieee154e_dbg.num_cslSamples);
 189              		.loc 1 199 0
 190 00da 40F20003 		movw	r3, #:lower16:ieee154e_vars
 191 00de C0F20003 		movt	r3, #:upper16:ieee154e_vars
 192 00e2 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 198:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printInfo(COMPONENT_IEEE802154E,ERR_MAC_OPERATION_IN_PROGRESS,
 193              		.loc 1 198 0
 194 00e6 1A46     		mov	r2, r3
 195              		.loc 1 199 0
 196 00e8 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 197 00ec C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 198 00f0 1B69     		ldr	r3, [r3, #16]
 198:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printInfo(COMPONENT_IEEE802154E,ERR_MAC_OPERATION_IN_PROGRESS,
 199              		.loc 1 198 0
 200 00f2 9BB2     		uxth	r3, r3
 201 00f4 4FF00900 		mov	r0, #9
 202 00f8 4FF04001 		mov	r1, #64
 203 00fc FFF7FEFF 		bl	openserial_printInfo
 204              	.L6:
 200:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 201:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 202:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Increment the number of cslSamples.
 203:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_dbg.num_cslSamples++;
 205              		.loc 1 203 0
 206 0100 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 207 0104 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 208 0108 1B69     		ldr	r3, [r3, #16]
 209 010a 03F10102 		add	r2, r3, #1
 210 010e 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 211 0112 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 212 0116 1A61     		str	r2, [r3, #16]
 204:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 213              		.loc 1 204 0
 214 0118 80BD     		pop	{r7, pc}
 215              		.cfi_endproc
 216              	.LFE1:
 218 011a 00BF     		.align	2
 219              		.global	isr_ieee154ecsl_timer
 220              		.thumb
 221              		.thumb_func
 223              	isr_ieee154ecsl_timer:
 224              	.LFB2:
 205:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 206:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 207:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Indicates the FSM timer has fired.
 208:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 209:openstack/02a-MAClow/IEEE802154Ecsl.c **** This function executes in ISR mode, when the FSM timer fires.
 210:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 211:openstack/02a-MAClow/IEEE802154Ecsl.c **** void isr_ieee154ecsl_timer() {
 225              		.loc 1 211 0
 226              		.cfi_startproc
 227              		@ args = 0, pretend = 0, frame = 0
 228              		@ frame_needed = 1, uses_anonymous_args = 0
 229 011c 80B5     		push	{r7, lr}
 230              	.LCFI4:
 231              		.cfi_def_cfa_offset 8
 232              		.cfi_offset 7, -8
 233              		.cfi_offset 14, -4
 234 011e 00AF     		add	r7, sp, #0
 235              	.LCFI5:
 236              		.cfi_def_cfa_register 7
 212:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.cslMode == CSL_RX_MODE)  { // Current CSL operation mode is channel sampling a
 237              		.loc 1 212 0
 238 0120 40F20003 		movw	r3, #:lower16:ieee154e_vars
 239 0124 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 240 0128 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 241 012c 012B     		cmp	r3, #1
 242 012e 71D1     		bne	.L8
 213:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   switch (ieee154e_vars.state) {
 243              		.loc 1 213 0
 244 0130 40F20003 		movw	r3, #:lower16:ieee154e_vars
 245 0134 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 246 0138 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 247 013a A3F12A03 		sub	r3, r3, #42
 248 013e 0F2B     		cmp	r3, #15
 249 0140 53D8     		bhi	.L9
 250 0142 01A2     		adr	r2, .L26
 251 0144 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 252              		.align	2
 253              	.L26:
 254 0148 89010000 		.word	.L10+1
 255 014c 8F010000 		.word	.L11+1
 256 0150 95010000 		.word	.L12+1
 257 0154 9B010000 		.word	.L13+1
 258 0158 A1010000 		.word	.L14+1
 259 015c A7010000 		.word	.L15+1
 260 0160 AD010000 		.word	.L16+1
 261 0164 B3010000 		.word	.L17+1
 262 0168 B9010000 		.word	.L18+1
 263 016c BF010000 		.word	.L19+1
 264 0170 C5010000 		.word	.L20+1
 265 0174 CB010000 		.word	.L21+1
 266 0178 D1010000 		.word	.L22+1
 267 017c D7010000 		.word	.L23+1
 268 0180 DD010000 		.word	.L24+1
 269 0184 E3010000 		.word	.L25+1
 270              	.L10:
 214:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      // RX-MODE
 215:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUPOFFSET:      activity_csl_wakeup_ri2();  break;
 271              		.loc 1 215 0
 272 0188 FFF7FEFF 		bl	activity_csl_wakeup_ri2
 273 018c E1E0     		b	.L28
 274              	.L11:
 216:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUPPREPARE:     activity_csl_wakeup_rie1(); break;
 275              		.loc 1 216 0
 276 018e FFF7FEFF 		bl	activity_csl_wakeup_rie1
 277 0192 DEE0     		b	.L28
 278              	.L12:
 217:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUPREADY:       activity_csl_wakeup_ri3();  break;
 279              		.loc 1 217 0
 280 0194 FFF7FEFF 		bl	activity_csl_wakeup_ri3
 281 0198 DBE0     		b	.L28
 282              	.L13:
 218:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUPLISTEN:      activity_csl_wakeup_rie2(); break;
 283              		.loc 1 218 0
 284 019a FFF7FEFF 		bl	activity_csl_wakeup_rie2
 285 019e D8E0     		b	.L28
 286              	.L14:
 219:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUP:			 activity_csl_wakeup_rie3(); break;
 287              		.loc 1 219 0
 288 01a0 FFF7FEFF 		bl	activity_csl_wakeup_rie3
 289 01a4 D5E0     		b	.L28
 290              	.L15:
 220:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUPVALIDATE: 	 activity_csl_wakeup_rie4(); break;
 291              		.loc 1 220 0
 292 01a6 FFF7FEFF 		bl	activity_csl_wakeup_rie4
 293 01aa D2E0     		b	.L28
 294              	.L16:
 221:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 222:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXDATAOFFSET:    	 activity_csl_data_ri2();    break;
 295              		.loc 1 222 0
 296 01ac FFF7FEFF 		bl	activity_csl_data_ri2
 297 01b0 CFE0     		b	.L28
 298              	.L17:
 223:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXDATAPREPARE:       activity_csl_data_rie1();   break;
 299              		.loc 1 223 0
 300 01b2 FFF7FEFF 		bl	activity_csl_data_rie1
 301 01b6 CCE0     		b	.L28
 302              	.L18:
 224:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXDATAREADY:         activity_csl_data_ri3();    break;
 303              		.loc 1 224 0
 304 01b8 FFF7FEFF 		bl	activity_csl_data_ri3
 305 01bc C9E0     		b	.L28
 306              	.L19:
 225:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXDATALISTEN:        activity_csl_data_rie2();   break;
 307              		.loc 1 225 0
 308 01be FFF7FEFF 		bl	activity_csl_data_rie2
 309 01c2 C6E0     		b	.L28
 310              	.L20:
 226:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXDATA:			     activity_csl_data_rie3();   break;
 311              		.loc 1 226 0
 312 01c4 FFF7FEFF 		bl	activity_csl_data_rie3
 313 01c8 C3E0     		b	.L28
 314              	.L21:
 227:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 228:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLTXACKOFFSET: 	     activity_csl_data_ri6();    break;
 315              		.loc 1 228 0
 316 01ca FFF7FEFF 		bl	activity_csl_data_ri6
 317 01ce C0E0     		b	.L28
 318              	.L22:
 229:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLTXACKPREPARE:        activity_csl_data_rie4();   break;
 319              		.loc 1 229 0
 320 01d0 FFF7FEFF 		bl	activity_csl_data_rie4
 321 01d4 BDE0     		b	.L28
 322              	.L23:
 230:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLTXACKREADY:          activity_csl_data_ri7();    break;
 323              		.loc 1 230 0
 324 01d6 FFF7FEFF 		bl	activity_csl_data_ri7
 325 01da BAE0     		b	.L28
 326              	.L24:
 231:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLTXACKDELAY:          activity_csl_data_rie5();   break;
 327              		.loc 1 231 0
 328 01dc FFF7FEFF 		bl	activity_csl_data_rie5
 329 01e0 B7E0     		b	.L28
 330              	.L25:
 232:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLTXACK:               activity_csl_data_rie6();   break;
 331              		.loc 1 232 0
 332 01e2 FFF7FEFF 		bl	activity_csl_data_rie6
 333 01e6 00BF     		nop
 334 01e8 B3E0     		b	.L28
 335              	.L9:
 233:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  default:
 234:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 // log the error
 235:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_TIMERFIRES,
 236:openstack/02a-MAClow/IEEE802154Ecsl.c **** 								   (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_dbg.num_cslSamples);
 336              		.loc 1 236 0
 337 01ea 40F20003 		movw	r3, #:lower16:ieee154e_vars
 338 01ee C0F20003 		movt	r3, #:upper16:ieee154e_vars
 339 01f2 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 235:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_TIMERFIRES,
 340              		.loc 1 235 0
 341 01f4 1A46     		mov	r2, r3
 342              		.loc 1 236 0
 343 01f6 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 344 01fa C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 345 01fe 1B69     		ldr	r3, [r3, #16]
 235:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_TIMERFIRES,
 346              		.loc 1 235 0
 347 0200 9BB2     		uxth	r3, r3
 348 0202 4FF00900 		mov	r0, #9
 349 0206 4FF03B01 		mov	r1, #59
 350 020a FFF7FEFF 		bl	openserial_printError
 237:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 // abort
 238:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 endOps();
 351              		.loc 1 238 0
 352 020e FFF7FEFF 		bl	endOps
 239:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 break;
 353              		.loc 1 239 0
 354 0212 9EE0     		b	.L28
 355              	.L8:
 240:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 241:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else if (ieee154e_vars.cslMode == CSL_TX_MODE)  { // Current CSL operation mode is frame TX.
 356              		.loc 1 241 0
 357 0214 40F20003 		movw	r3, #:lower16:ieee154e_vars
 358 0218 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 359 021c 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 360 0220 022B     		cmp	r3, #2
 361 0222 40F09680 		bne	.L28
 242:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   switch (ieee154e_vars.state) {
 362              		.loc 1 242 0
 363 0226 40F20003 		movw	r3, #:lower16:ieee154e_vars
 364 022a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 365 022e 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 366 0230 A3F11A03 		sub	r3, r3, #26
 367 0234 212B     		cmp	r3, #33
 368 0236 77D8     		bhi	.L29
 369 0238 01A2     		adr	r2, .L46
 370 023a 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 371 023e 00BF     		.align	2
 372              	.L46:
 373 0240 C9020000 		.word	.L30+1
 374 0244 CF020000 		.word	.L31+1
 375 0248 D5020000 		.word	.L32+1
 376 024c DB020000 		.word	.L33+1
 377 0250 E1020000 		.word	.L34+1
 378 0254 ED020000 		.word	.L35+1
 379 0258 F3020000 		.word	.L36+1
 380 025c F9020000 		.word	.L37+1
 381 0260 FF020000 		.word	.L38+1
 382 0264 05030000 		.word	.L39+1
 383 0268 0B030000 		.word	.L40+1
 384 026c 11030000 		.word	.L41+1
 385 0270 17030000 		.word	.L42+1
 386 0274 1D030000 		.word	.L43+1
 387 0278 23030000 		.word	.L44+1
 388 027c 29030000 		.word	.L29+1
 389 0280 29030000 		.word	.L29+1
 390 0284 29030000 		.word	.L29+1
 391 0288 29030000 		.word	.L29+1
 392 028c 29030000 		.word	.L29+1
 393 0290 29030000 		.word	.L29+1
 394 0294 29030000 		.word	.L29+1
 395 0298 29030000 		.word	.L29+1
 396 029c 29030000 		.word	.L29+1
 397 02a0 29030000 		.word	.L29+1
 398 02a4 29030000 		.word	.L29+1
 399 02a8 29030000 		.word	.L29+1
 400 02ac 29030000 		.word	.L29+1
 401 02b0 29030000 		.word	.L29+1
 402 02b4 29030000 		.word	.L29+1
 403 02b8 29030000 		.word	.L29+1
 404 02bc 29030000 		.word	.L29+1
 405 02c0 29030000 		.word	.L29+1
 406 02c4 E7020000 		.word	.L45+1
 407              	.L30:
 243:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      // TX-MODE
 244:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXWAKEUPOFFSET:		 activity_csl_wakeup_ti2();  break;
 408              		.loc 1 244 0
 409 02c8 FFF7FEFF 		bl	activity_csl_wakeup_ti2
 410 02cc 41E0     		b	.L28
 411              	.L31:
 245:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXWAKEUPPREPARE:	 activity_csl_wakeup_tie1(); break;
 412              		.loc 1 245 0
 413 02ce FFF7FEFF 		bl	activity_csl_wakeup_tie1
 414 02d2 3EE0     		b	.L28
 415              	.L32:
 246:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXWAKEUPREADY:	     activity_csl_wakeup_ti3();  break;
 416              		.loc 1 246 0
 417 02d4 FFF7FEFF 		bl	activity_csl_wakeup_ti3
 418 02d8 3BE0     		b	.L28
 419              	.L33:
 247:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXWAKEUPDELAY:	     activity_csl_wakeup_tie2(); break;
 420              		.loc 1 247 0
 421 02da FFF7FEFF 		bl	activity_csl_wakeup_tie2
 422 02de 38E0     		b	.L28
 423              	.L34:
 248:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXWAKEUP: 	         activity_csl_wakeup_tie3(); break;
 424              		.loc 1 248 0
 425 02e0 FFF7FEFF 		bl	activity_csl_wakeup_tie3
 426 02e4 35E0     		b	.L28
 427              	.L45:
 249:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 250:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXDATAPREOFFSET:	 activity_csl_data_ti1();	 break;
 428              		.loc 1 250 0
 429 02e6 FFF7FEFF 		bl	activity_csl_data_ti1
 430 02ea 32E0     		b	.L28
 431              	.L35:
 251:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXDATAOFFSET:        activity_csl_data_ti2();    break;
 432              		.loc 1 251 0
 433 02ec FFF7FEFF 		bl	activity_csl_data_ti2
 434 02f0 2FE0     		b	.L28
 435              	.L36:
 252:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXDATAPREPARE:	     activity_csl_data_tie1(); 	 break;
 436              		.loc 1 252 0
 437 02f2 FFF7FEFF 		bl	activity_csl_data_tie1
 438 02f6 2CE0     		b	.L28
 439              	.L37:
 253:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXDATAREADY:	     activity_csl_data_ti3(); 	 break;
 440              		.loc 1 253 0
 441 02f8 FFF7FEFF 		bl	activity_csl_data_ti3
 442 02fc 29E0     		b	.L28
 443              	.L38:
 254:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXDATADELAY:	     activity_csl_data_tie2(); 	 break;
 444              		.loc 1 254 0
 445 02fe FFF7FEFF 		bl	activity_csl_data_tie2
 446 0302 26E0     		b	.L28
 447              	.L39:
 255:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXDATA: 	         activity_csl_data_tie3();	 break;
 448              		.loc 1 255 0
 449 0304 FFF7FEFF 		bl	activity_csl_data_tie3
 450 0308 23E0     		b	.L28
 451              	.L40:
 256:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 257:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLRXACKOFFSET: 	     activity_csl_data_ti6();	 break;
 452              		.loc 1 257 0
 453 030a FFF7FEFF 		bl	activity_csl_data_ti6
 454 030e 20E0     		b	.L28
 455              	.L41:
 258:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLRXACKPREPARE:	     activity_csl_data_tie4(); 	 break;
 456              		.loc 1 258 0
 457 0310 FFF7FEFF 		bl	activity_csl_data_tie4
 458 0314 1DE0     		b	.L28
 459              	.L42:
 259:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLRXACKREADY: 	     activity_csl_data_ti7(); 	 break;
 460              		.loc 1 259 0
 461 0316 FFF7FEFF 		bl	activity_csl_data_ti7
 462 031a 1AE0     		b	.L28
 463              	.L43:
 260:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLRXACKLISTEN: 	     activity_csl_data_tie5(); 	 break;
 464              		.loc 1 260 0
 465 031c FFF7FEFF 		bl	activity_csl_data_tie5
 466 0320 17E0     		b	.L28
 467              	.L44:
 261:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLRXACK:     	         activity_csl_data_tie6(); 	 break;
 468              		.loc 1 261 0
 469 0322 FFF7FEFF 		bl	activity_csl_data_tie6
 470 0326 14E0     		b	.L28
 471              	.L29:
 262:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 263:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  default:
 264:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 // log the error
 265:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_TIMERFIRES,
 266:openstack/02a-MAClow/IEEE802154Ecsl.c **** 								   (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_dbg.num_cslSamples);
 472              		.loc 1 266 0
 473 0328 40F20003 		movw	r3, #:lower16:ieee154e_vars
 474 032c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 475 0330 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 265:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_TIMERFIRES,
 476              		.loc 1 265 0
 477 0332 1A46     		mov	r2, r3
 478              		.loc 1 266 0
 479 0334 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 480 0338 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 481 033c 1B69     		ldr	r3, [r3, #16]
 265:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_TIMERFIRES,
 482              		.loc 1 265 0
 483 033e 9BB2     		uxth	r3, r3
 484 0340 4FF00900 		mov	r0, #9
 485 0344 4FF03B01 		mov	r1, #59
 486 0348 FFF7FEFF 		bl	openserial_printError
 267:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 // abort
 268:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 endOps();
 487              		.loc 1 268 0
 488 034c FFF7FEFF 		bl	endOps
 269:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 break;
 489              		.loc 1 269 0
 490 0350 00BF     		nop
 491              	.L28:
 270:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 271:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 272:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_dbg.num_timer++;
 492              		.loc 1 272 0
 493 0352 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 494 0356 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 495 035a 5B68     		ldr	r3, [r3, #4]
 496 035c 03F10102 		add	r2, r3, #1
 497 0360 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 498 0364 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 499 0368 5A60     		str	r2, [r3, #4]
 273:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 500              		.loc 1 273 0
 501 036a 80BD     		pop	{r7, pc}
 502              		.cfi_endproc
 503              	.LFE2:
 505              		.align	2
 506              		.global	ieee154ecsl_startOfFrame
 507              		.thumb
 508              		.thumb_func
 510              	ieee154ecsl_startOfFrame:
 511              	.LFB3:
 274:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 275:openstack/02a-MAClow/IEEE802154Ecsl.c **** void ieee154ecsl_startOfFrame(PORT_RADIOTIMER_WIDTH capturedTime) {
 512              		.loc 1 275 0
 513              		.cfi_startproc
 514              		@ args = 0, pretend = 0, frame = 8
 515              		@ frame_needed = 1, uses_anonymous_args = 0
 516 036c 80B5     		push	{r7, lr}
 517              	.LCFI6:
 518              		.cfi_def_cfa_offset 8
 519              		.cfi_offset 7, -8
 520              		.cfi_offset 14, -4
 521 036e 82B0     		sub	sp, sp, #8
 522              	.LCFI7:
 523              		.cfi_def_cfa_offset 16
 524 0370 00AF     		add	r7, sp, #0
 525              	.LCFI8:
 526              		.cfi_def_cfa_register 7
 527 0372 7860     		str	r0, [r7, #4]
 276:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	if(ieee154e_vars.cslMode == CSL_RX_MODE)  { // Current CSL operation mode is channel sampling and 
 528              		.loc 1 276 0
 529 0374 40F20003 		movw	r3, #:lower16:ieee154e_vars
 530 0378 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 531 037c 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 532 0380 012B     		cmp	r3, #1
 533 0382 33D1     		bne	.L48
 277:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   switch (ieee154e_vars.state) {
 534              		.loc 1 277 0
 535 0384 40F20003 		movw	r3, #:lower16:ieee154e_vars
 536 0388 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 537 038c 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 538 038e A3F12D03 		sub	r3, r3, #45
 539 0392 0B2B     		cmp	r3, #11
 540 0394 27D8     		bhi	.L49
 541 0396 01A2     		adr	r2, .L53
 542 0398 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 543              		.align	2
 544              	.L53:
 545 039c CD030000 		.word	.L50+1
 546 03a0 CD030000 		.word	.L50+1
 547 03a4 E7030000 		.word	.L49+1
 548 03a8 E7030000 		.word	.L49+1
 549 03ac E7030000 		.word	.L49+1
 550 03b0 D5030000 		.word	.L51+1
 551 03b4 D5030000 		.word	.L51+1
 552 03b8 E7030000 		.word	.L49+1
 553 03bc E7030000 		.word	.L49+1
 554 03c0 E7030000 		.word	.L49+1
 555 03c4 E7030000 		.word	.L49+1
 556 03c8 DD030000 		.word	.L52+1
 557              	.L50:
 278:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  // RX MODE
 279:openstack/02a-MAClow/IEEE802154Ecsl.c ****           /*
 280:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   It is possible to receive in this state for radio where there is no way of differentiated betw
 281:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   (e.g. CC2420). We must therefore expect to the start of a packet in this "ready" state.
 282:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  */
 283:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUP:    			 // no break!
 284:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUPLISTEN:	 	     activity_csl_wakeup_ri4(capturedTime); break;
 558              		.loc 1 284 0
 559 03cc 7868     		ldr	r0, [r7, #4]
 560 03ce FFF7FEFF 		bl	activity_csl_wakeup_ri4
 561 03d2 56E0     		b	.L55
 562              	.L51:
 285:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 286:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXDATAREADY:		     // no break!
 287:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXDATALISTEN:            activity_csl_data_ri4(capturedTime);   break;
 563              		.loc 1 287 0
 564 03d4 7868     		ldr	r0, [r7, #4]
 565 03d6 FFF7FEFF 		bl	activity_csl_data_ri4
 566 03da 52E0     		b	.L55
 567              	.L52:
 288:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 289:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLTXACKDELAY:              activity_csl_data_ri8(capturedTime);   break;
 568              		.loc 1 289 0
 569 03dc 7868     		ldr	r0, [r7, #4]
 570 03de FFF7FEFF 		bl	activity_csl_data_ri8
 571 03e2 00BF     		nop
 572 03e4 4DE0     		b	.L55
 573              	.L49:
 290:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  default:
 291:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			// log the error
 292:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			//openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_SAMPLE,
 293:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			//					  (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_dbg.num_cslSamples);
 294:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			// abort
 295:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			endOps();
 574              		.loc 1 295 0
 575 03e6 FFF7FEFF 		bl	endOps
 296:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			break;
 576              		.loc 1 296 0
 577 03ea 4AE0     		b	.L55
 578              	.L48:
 297:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		}
 298:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	} else if (ieee154e_vars.cslMode == CSL_TX_MODE)  { // Current CSL operation mode is frame TX.
 579              		.loc 1 298 0
 580 03ec 40F20003 		movw	r3, #:lower16:ieee154e_vars
 581 03f0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 582 03f4 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 583 03f8 022B     		cmp	r3, #2
 584 03fa 42D1     		bne	.L55
 299:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   switch (ieee154e_vars.state) {
 585              		.loc 1 299 0
 586 03fc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 587 0400 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 588 0404 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 589 0406 A3F11D03 		sub	r3, r3, #29
 590 040a 0A2B     		cmp	r3, #10
 591 040c 24D8     		bhi	.L56
 592 040e 01A2     		adr	r2, .L60
 593 0410 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 594              		.align	2
 595              	.L60:
 596 0414 49040000 		.word	.L57+1
 597 0418 59040000 		.word	.L56+1
 598 041c 59040000 		.word	.L56+1
 599 0420 59040000 		.word	.L56+1
 600 0424 59040000 		.word	.L56+1
 601 0428 51040000 		.word	.L58+1
 602 042c 59040000 		.word	.L56+1
 603 0430 59040000 		.word	.L56+1
 604 0434 59040000 		.word	.L56+1
 605 0438 41040000 		.word	.L59+1
 606 043c 41040000 		.word	.L59+1
 607              	.L59:
 300:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  // TX MODE
 301:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 302:openstack/02a-MAClow/IEEE802154Ecsl.c ****           /*
 303:openstack/02a-MAClow/IEEE802154Ecsl.c ****           It is possible to receive in this state for radio where there is no way of differentiated
 304:openstack/02a-MAClow/IEEE802154Ecsl.c ****           (e.g. CC2420). We must therefore expect to the start of a packet in this "ready" state.
 305:openstack/02a-MAClow/IEEE802154Ecsl.c ****           */
 306:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLRXACKREADY:               // no break!
 307:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLRXACKLISTEN:              activity_csl_data_ti8(capturedTime);  break;
 608              		.loc 1 307 0
 609 0440 7868     		ldr	r0, [r7, #4]
 610 0442 FFF7FEFF 		bl	activity_csl_data_ti8
 611 0446 1CE0     		b	.L55
 612              	.L57:
 308:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 309:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXWAKEUPDELAY:            activity_csl_wakeup_ti4(capturedTime); break;
 613              		.loc 1 309 0
 614 0448 7868     		ldr	r0, [r7, #4]
 615 044a FFF7FEFF 		bl	activity_csl_wakeup_ti4
 616 044e 18E0     		b	.L55
 617              	.L58:
 310:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXDATADELAY:              activity_csl_data_ti4(capturedTime);   break;
 618              		.loc 1 310 0
 619 0450 7868     		ldr	r0, [r7, #4]
 620 0452 FFF7FEFF 		bl	activity_csl_data_ti4
 621 0456 14E0     		b	.L55
 622              	.L56:
 311:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 312:openstack/02a-MAClow/IEEE802154Ecsl.c ****           default:
 313:openstack/02a-MAClow/IEEE802154Ecsl.c ****    			// log the error
 314:openstack/02a-MAClow/IEEE802154Ecsl.c ****    			openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_SAMPLE,
 315:openstack/02a-MAClow/IEEE802154Ecsl.c ****    								  (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_dbg.num_cslSamples);
 623              		.loc 1 315 0
 624 0458 40F20003 		movw	r3, #:lower16:ieee154e_vars
 625 045c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 626 0460 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 314:openstack/02a-MAClow/IEEE802154Ecsl.c ****    			openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_SAMPLE,
 627              		.loc 1 314 0
 628 0462 1A46     		mov	r2, r3
 629              		.loc 1 315 0
 630 0464 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 631 0468 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 632 046c 1B69     		ldr	r3, [r3, #16]
 314:openstack/02a-MAClow/IEEE802154Ecsl.c ****    			openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_SAMPLE,
 633              		.loc 1 314 0
 634 046e 9BB2     		uxth	r3, r3
 635 0470 4FF00900 		mov	r0, #9
 636 0474 4FF03E01 		mov	r1, #62
 637 0478 FFF7FEFF 		bl	openserial_printError
 316:openstack/02a-MAClow/IEEE802154Ecsl.c ****    			// abort
 317:openstack/02a-MAClow/IEEE802154Ecsl.c ****    			endOps();
 638              		.loc 1 317 0
 639 047c FFF7FEFF 		bl	endOps
 318:openstack/02a-MAClow/IEEE802154Ecsl.c ****    			break;
 640              		.loc 1 318 0
 641 0480 00BF     		nop
 642              	.L55:
 319:openstack/02a-MAClow/IEEE802154Ecsl.c ****    		}
 320:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	}
 321:openstack/02a-MAClow/IEEE802154Ecsl.c ****   ieee154e_dbg.num_startOfFrame++;
 643              		.loc 1 321 0
 644 0482 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 645 0486 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 646 048a 9B68     		ldr	r3, [r3, #8]
 647 048c 03F10102 		add	r2, r3, #1
 648 0490 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 649 0494 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 650 0498 9A60     		str	r2, [r3, #8]
 322:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 651              		.loc 1 322 0
 652 049a 07F10807 		add	r7, r7, #8
 653 049e BD46     		mov	sp, r7
 654 04a0 80BD     		pop	{r7, pc}
 655              		.cfi_endproc
 656              	.LFE3:
 658 04a2 00BF     		.align	2
 659              		.global	ieee154ecsl_endOfFrame
 660              		.thumb
 661              		.thumb_func
 663              	ieee154ecsl_endOfFrame:
 664              	.LFB4:
 323:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 324:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 325:openstack/02a-MAClow/IEEE802154Ecsl.c **** void ieee154ecsl_endOfFrame(PORT_RADIOTIMER_WIDTH capturedTime) {
 665              		.loc 1 325 0
 666              		.cfi_startproc
 667              		@ args = 0, pretend = 0, frame = 8
 668              		@ frame_needed = 1, uses_anonymous_args = 0
 669 04a4 80B5     		push	{r7, lr}
 670              	.LCFI9:
 671              		.cfi_def_cfa_offset 8
 672              		.cfi_offset 7, -8
 673              		.cfi_offset 14, -4
 674 04a6 82B0     		sub	sp, sp, #8
 675              	.LCFI10:
 676              		.cfi_def_cfa_offset 16
 677 04a8 00AF     		add	r7, sp, #0
 678              	.LCFI11:
 679              		.cfi_def_cfa_register 7
 680 04aa 7860     		str	r0, [r7, #4]
 326:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	if(ieee154e_vars.cslMode == CSL_RX_MODE)  { // Current CSL operation mode is channel sampling and 
 681              		.loc 1 326 0
 682 04ac 40F20003 		movw	r3, #:lower16:ieee154e_vars
 683 04b0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 684 04b4 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 685 04b8 012B     		cmp	r3, #1
 686 04ba 2CD1     		bne	.L62
 327:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   switch (ieee154e_vars.state) {
 687              		.loc 1 327 0
 688 04bc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 689 04c0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 690 04c4 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 691 04c6 342B     		cmp	r3, #52
 692 04c8 07D0     		beq	.L65
 693 04ca 392B     		cmp	r3, #57
 694 04cc 09D0     		beq	.L66
 695 04ce 2E2B     		cmp	r3, #46
 696 04d0 0CD1     		bne	.L73
 697              	.L64:
 328:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		 // RX MODE
 329:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		 case S_CSLRXWAKEUP:           activity_csl_wakeup_ri5(capturedTime);  break;
 698              		.loc 1 329 0
 699 04d2 7868     		ldr	r0, [r7, #4]
 700 04d4 FFF7FEFF 		bl	activity_csl_wakeup_ri5
 701 04d8 51E0     		b	.L68
 702              	.L65:
 330:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		 case S_CSLRXDATA:             activity_csl_data_ri5(capturedTime);    break;
 703              		.loc 1 330 0
 704 04da 7868     		ldr	r0, [r7, #4]
 705 04dc FFF7FEFF 		bl	activity_csl_data_ri5
 706 04e0 4DE0     		b	.L68
 707              	.L66:
 331:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		 case S_CSLTXACK:              activity_csl_data_ri9(capturedTime);    break;
 708              		.loc 1 331 0
 709 04e2 7868     		ldr	r0, [r7, #4]
 710 04e4 FFF7FEFF 		bl	activity_csl_data_ri9
 711 04e8 00BF     		nop
 712 04ea 48E0     		b	.L68
 713              	.L73:
 332:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		 default:
 333:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			// log the error
 334:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_ENDOFFRAME,
 335:openstack/02a-MAClow/IEEE802154Ecsl.c **** 								  (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_dbg.num_cslSamples);
 714              		.loc 1 335 0
 715 04ec 40F20003 		movw	r3, #:lower16:ieee154e_vars
 716 04f0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 717 04f4 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 334:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_ENDOFFRAME,
 718              		.loc 1 334 0
 719 04f6 1A46     		mov	r2, r3
 720              		.loc 1 335 0
 721 04f8 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 722 04fc C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 723 0500 1B69     		ldr	r3, [r3, #16]
 334:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_ENDOFFRAME,
 724              		.loc 1 334 0
 725 0502 9BB2     		uxth	r3, r3
 726 0504 4FF00900 		mov	r0, #9
 727 0508 4FF03F01 		mov	r1, #63
 728 050c FFF7FEFF 		bl	openserial_printError
 336:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			// abort
 337:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			endOps();
 729              		.loc 1 337 0
 730 0510 FFF7FEFF 		bl	endOps
 338:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			break;
 731              		.loc 1 338 0
 732 0514 33E0     		b	.L68
 733              	.L62:
 339:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 340:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	} else if (ieee154e_vars.cslMode == CSL_TX_MODE)  { // Current CSL operation mode is frame TX.
 734              		.loc 1 340 0
 735 0516 40F20003 		movw	r3, #:lower16:ieee154e_vars
 736 051a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 737 051e 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 738 0522 022B     		cmp	r3, #2
 739 0524 2BD1     		bne	.L68
 341:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  switch (ieee154e_vars.state) {
 740              		.loc 1 341 0
 741 0526 40F20003 		movw	r3, #:lower16:ieee154e_vars
 742 052a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 743 052e 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 744 0530 232B     		cmp	r3, #35
 745 0532 07D0     		beq	.L71
 746 0534 282B     		cmp	r3, #40
 747 0536 09D0     		beq	.L72
 748 0538 1E2B     		cmp	r3, #30
 749 053a 0BD1     		bne	.L74
 750              	.L70:
 342:openstack/02a-MAClow/IEEE802154Ecsl.c ****         // TX MODE
 343:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	    case S_CSLTXWAKEUP:            activity_csl_wakeup_ti5(capturedTime); break;
 751              		.loc 1 343 0
 752 053c 7868     		ldr	r0, [r7, #4]
 753 053e FFF7FEFF 		bl	activity_csl_wakeup_ti5
 754 0542 1CE0     		b	.L68
 755              	.L71:
 344:openstack/02a-MAClow/IEEE802154Ecsl.c ****         case S_CSLTXDATA:              activity_csl_data_ti5(capturedTime);   break;
 756              		.loc 1 344 0
 757 0544 7868     		ldr	r0, [r7, #4]
 758 0546 FFF7FEFF 		bl	activity_csl_data_ti5
 759 054a 18E0     		b	.L68
 760              	.L72:
 345:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	    case S_CSLRXACK:               activity_csl_data_ti9(capturedTime);   break;
 761              		.loc 1 345 0
 762 054c 7868     		ldr	r0, [r7, #4]
 763 054e FFF7FEFF 		bl	activity_csl_data_ti9
 764 0552 14E0     		b	.L68
 765              	.L74:
 346:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	    default:
 347:openstack/02a-MAClow/IEEE802154Ecsl.c ****            // log the error
 348:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_ENDOFFRAME,
 349:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			   				    (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_dbg.num_cslSamples)
 766              		.loc 1 349 0
 767 0554 40F20003 		movw	r3, #:lower16:ieee154e_vars
 768 0558 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 769 055c 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 348:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_ENDOFFRAME,
 770              		.loc 1 348 0
 771 055e 1A46     		mov	r2, r3
 772              		.loc 1 349 0
 773 0560 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 774 0564 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 775 0568 1B69     		ldr	r3, [r3, #16]
 348:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_ENDOFFRAME,
 776              		.loc 1 348 0
 777 056a 9BB2     		uxth	r3, r3
 778 056c 4FF00900 		mov	r0, #9
 779 0570 4FF03F01 		mov	r1, #63
 780 0574 FFF7FEFF 		bl	openserial_printError
 350:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	   // abort
 351:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   endOps();
 781              		.loc 1 351 0
 782 0578 FFF7FEFF 		bl	endOps
 352:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   break;
 783              		.loc 1 352 0
 784 057c 00BF     		nop
 785              	.L68:
 353:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  }
 354:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	}
 355:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_dbg.num_endOfFrame++;
 786              		.loc 1 355 0
 787 057e 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 788 0582 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 789 0586 DB68     		ldr	r3, [r3, #12]
 790 0588 03F10102 		add	r2, r3, #1
 791 058c 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 792 0590 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 793 0594 DA60     		str	r2, [r3, #12]
 356:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 794              		.loc 1 356 0
 795 0596 07F10807 		add	r7, r7, #8
 796 059a BD46     		mov	sp, r7
 797 059c 80BD     		pop	{r7, pc}
 798              		.cfi_endproc
 799              	.LFE4:
 801 059e 00BF     		.align	2
 802              		.global	isr_ieee154ecsl_txtimer_cb
 803              		.thumb
 804              		.thumb_func
 806              	isr_ieee154ecsl_txtimer_cb:
 807              	.LFB5:
 357:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 358:openstack/02a-MAClow/IEEE802154Ecsl.c **** // tx timer interrupt callbacks
 359:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 360:openstack/02a-MAClow/IEEE802154Ecsl.c **** void isr_ieee154ecsl_txtimer_cb() {
 808              		.loc 1 360 0
 809              		.cfi_startproc
 810              		@ args = 0, pretend = 0, frame = 0
 811              		@ frame_needed = 1, uses_anonymous_args = 0
 812 05a0 80B5     		push	{r7, lr}
 813              	.LCFI12:
 814              		.cfi_def_cfa_offset 8
 815              		.cfi_offset 7, -8
 816              		.cfi_offset 14, -4
 817 05a2 00AF     		add	r7, sp, #0
 818              	.LCFI13:
 819              		.cfi_def_cfa_register 7
 361:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 362:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// Verificamos que no estamos ya en un proceso de TX o RX previo.
 363:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if(ieee154e_vars.cslMode == CSL_SLEEP_MODE) {
 820              		.loc 1 363 0
 821 05a4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 822 05a8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 823 05ac 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 824 05b0 002B     		cmp	r3, #0
 825 05b2 02D1     		bne	.L76
 364:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // We call the first activity on FSM for channel sampling (CSL FSM RX mode)
 365:openstack/02a-MAClow/IEEE802154Ecsl.c ****       activity_csl_wakeup_ti1();
 826              		.loc 1 365 0
 827 05b4 FFF7FEFF 		bl	activity_csl_wakeup_ti1
 828 05b8 12E0     		b	.L75
 829              	.L76:
 366:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 367:openstack/02a-MAClow/IEEE802154Ecsl.c ****    else {
 368:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // log the info about a operation in progress
 369:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printInfo(COMPONENT_IEEE802154E,ERR_MAC_OPERATION_IN_PROGRESS,
 370:openstack/02a-MAClow/IEEE802154Ecsl.c **** 						  (errorparameter_t)ieee154e_vars.cslMode, (errorparameter_t)ieee154e_dbg.num_cslSamples);
 830              		.loc 1 370 0
 831 05ba 40F20003 		movw	r3, #:lower16:ieee154e_vars
 832 05be C0F20003 		movt	r3, #:upper16:ieee154e_vars
 833 05c2 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 369:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printInfo(COMPONENT_IEEE802154E,ERR_MAC_OPERATION_IN_PROGRESS,
 834              		.loc 1 369 0
 835 05c6 1A46     		mov	r2, r3
 836              		.loc 1 370 0
 837 05c8 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 838 05cc C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 839 05d0 1B69     		ldr	r3, [r3, #16]
 369:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printInfo(COMPONENT_IEEE802154E,ERR_MAC_OPERATION_IN_PROGRESS,
 840              		.loc 1 369 0
 841 05d2 9BB2     		uxth	r3, r3
 842 05d4 4FF00900 		mov	r0, #9
 843 05d8 4FF04001 		mov	r1, #64
 844 05dc FFF7FEFF 		bl	openserial_printInfo
 845              	.L75:
 371:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 372:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 846              		.loc 1 372 0
 847 05e0 80BD     		pop	{r7, pc}
 848              		.cfi_endproc
 849              	.LFE5:
 851 05e2 00BF     		.align	2
 852              		.global	isr_ieee154ecsl_addPacketToQueueForTestingCslTx_cb
 853              		.thumb
 854              		.thumb_func
 856              	isr_ieee154ecsl_addPacketToQueueForTestingCslTx_cb:
 857              	.LFB6:
 373:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 374:openstack/02a-MAClow/IEEE802154Ecsl.c **** // test timer interrupt callback to put a new packet on queue for testing CSL TX mode.
 375:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 376:openstack/02a-MAClow/IEEE802154Ecsl.c **** void isr_ieee154ecsl_addPacketToQueueForTestingCslTx_cb () {
 858              		.loc 1 376 0
 859              		.cfi_startproc
 860              		@ args = 0, pretend = 0, frame = 24
 861              		@ frame_needed = 1, uses_anonymous_args = 0
 862 05e4 B0B5     		push	{r4, r5, r7, lr}
 863              	.LCFI14:
 864              		.cfi_def_cfa_offset 16
 865              		.cfi_offset 4, -16
 866              		.cfi_offset 5, -12
 867              		.cfi_offset 7, -8
 868              		.cfi_offset 14, -4
 869 05e6 8AB0     		sub	sp, sp, #40
 870              	.LCFI15:
 871              		.cfi_def_cfa_offset 56
 872 05e8 04AF     		add	r7, sp, #16
 873              	.LCFI16:
 874              		.cfi_def_cfa 7, 40
 377:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 378:openstack/02a-MAClow/IEEE802154Ecsl.c ****   OpenQueueEntry_t* pkt;
 379:openstack/02a-MAClow/IEEE802154Ecsl.c ****   open_addr_t neighbor;
 380:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 381:openstack/02a-MAClow/IEEE802154Ecsl.c ****   // Simulate a ficticious address for CSL testing.
 382:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[0]=0x00;
 875              		.loc 1 382 0
 876 05ea 4FF00003 		mov	r3, #0
 877 05ee 7B70     		strb	r3, [r7, #1]
 383:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[1]=0x11;
 878              		.loc 1 383 0
 879 05f0 4FF01103 		mov	r3, #17
 880 05f4 BB70     		strb	r3, [r7, #2]
 384:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[2]=0x22;
 881              		.loc 1 384 0
 882 05f6 4FF02203 		mov	r3, #34
 883 05fa FB70     		strb	r3, [r7, #3]
 385:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[3]=0x33;
 884              		.loc 1 385 0
 885 05fc 4FF03303 		mov	r3, #51
 886 0600 3B71     		strb	r3, [r7, #4]
 386:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[4]=0x44;
 887              		.loc 1 386 0
 888 0602 4FF04403 		mov	r3, #68
 889 0606 7B71     		strb	r3, [r7, #5]
 387:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[5]=0x55;
 890              		.loc 1 387 0
 891 0608 4FF05503 		mov	r3, #85
 892 060c BB71     		strb	r3, [r7, #6]
 388:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[6]=0x66;
 893              		.loc 1 388 0
 894 060e 4FF06603 		mov	r3, #102
 895 0612 FB71     		strb	r3, [r7, #7]
 389:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[7]=0x77;
 896              		.loc 1 389 0
 897 0614 4FF07703 		mov	r3, #119
 898 0618 3B72     		strb	r3, [r7, #8]
 390:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 391:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.type=ADDR_64B;
 899              		.loc 1 391 0
 900 061a 4FF00203 		mov	r3, #2
 901 061e 3B70     		strb	r3, [r7, #0]
 392:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 393:openstack/02a-MAClow/IEEE802154Ecsl.c ****   // Switch off all the leds.
 394:openstack/02a-MAClow/IEEE802154Ecsl.c ****   leds_all_off();
 902              		.loc 1 394 0
 903 0620 FFF7FEFF 		bl	leds_all_off
 395:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 396:openstack/02a-MAClow/IEEE802154Ecsl.c ****   // CREATE DATA PACKET ONLY IF NOT ALREADY EXISTS ON QUEUE.
 397:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 398:openstack/02a-MAClow/IEEE802154Ecsl.c ****   if (openqueue_macGetDataPacket(&neighbor) == NULL) {
 904              		.loc 1 398 0
 905 0624 3B46     		mov	r3, r7
 906 0626 1846     		mov	r0, r3
 907 0628 FFF7FEFF 		bl	openqueue_macGetDataPacket
 908 062c 0346     		mov	r3, r0
 909 062e 002B     		cmp	r3, #0
 910 0630 6FD1     		bne	.L78
 399:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 400:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // get freebuffer.
 401:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt = openqueue_getFreePacketBuffer(COMPONENT_IEEE802154E);
 911              		.loc 1 401 0
 912 0632 4FF00900 		mov	r0, #9
 913 0636 FFF7FEFF 		bl	openqueue_getFreePacketBuffer
 914 063a 7861     		str	r0, [r7, #20]
 402:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  if(pkt==NULL) {
 915              		.loc 1 402 0
 916 063c 7B69     		ldr	r3, [r7, #20]
 917 063e 002B     		cmp	r3, #0
 918 0640 0CD1     		bne	.L80
 403:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		// registro del error & fin de operaciones.
 404:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		openserial_printError(COMPONENT_IEEE802154E,ERR_NO_FREE_PACKET_BUFFER, (errorparameter_t)0, (erro
 919              		.loc 1 404 0
 920 0642 4FF00900 		mov	r0, #9
 921 0646 4FF02C01 		mov	r1, #44
 922 064a 4FF00002 		mov	r2, #0
 923 064e 4FF00003 		mov	r3, #0
 924 0652 FFF7FEFF 		bl	openserial_printError
 405:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		endOps();
 925              		.loc 1 405 0
 926 0656 FFF7FEFF 		bl	endOps
 927 065a 5AE0     		b	.L78
 928              	.L80:
 406:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		return;
 407:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  }
 408:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 409:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // Declaración de propiedad sobre el paquete.
 410:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->creator = COMPONENT_SIXTOP_TO_IEEE802154E;
 929              		.loc 1 410 0
 930 065c 7B69     		ldr	r3, [r7, #20]
 931 065e 4FF00A02 		mov	r2, #10
 932 0662 1A70     		strb	r2, [r3, #0]
 411:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->owner   = COMPONENT_SIXTOP_TO_IEEE802154E;
 933              		.loc 1 411 0
 934 0664 7B69     		ldr	r3, [r7, #20]
 935 0666 4FF00A02 		mov	r2, #10
 936 066a 5A70     		strb	r2, [r3, #1]
 412:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 413:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // Frame type (data frame).
 414:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->l2_frameType=IEEE154_TYPE_DATA;
 937              		.loc 1 414 0
 938 066c 7B69     		ldr	r3, [r7, #20]
 939 066e 4FF00102 		mov	r2, #1
 940 0672 83F84920 		strb	r2, [r3, #73]
 415:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 416:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // Flag created only to discriminate and toggle led indicator (only for TESTING)
 417:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->cslFlag=123;
 941              		.loc 1 417 0
 942 0676 7B69     		ldr	r3, [r7, #20]
 943 0678 4FF07B02 		mov	r2, #123
 944 067c 83F8ED20 		strb	r2, [r3, #237]
 418:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 419:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // Neighbor address.
 420:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  memcpy(&(pkt->l2_nextORpreviousHop),&neighbor,sizeof(open_addr_t));
 945              		.loc 1 420 0
 946 0680 7B69     		ldr	r3, [r7, #20]
 947 0682 03F13803 		add	r3, r3, #56
 948 0686 1D46     		mov	r5, r3
 949 0688 3C46     		mov	r4, r7
 950 068a 0FCC     		ldmia	r4!, {r0, r1, r2, r3}
 951 068c 2860     		str	r0, [r5, #0]	@ unaligned
 952 068e 6960     		str	r1, [r5, #4]	@ unaligned
 953 0690 AA60     		str	r2, [r5, #8]	@ unaligned
 954 0692 EB60     		str	r3, [r5, #12]	@ unaligned
 955 0694 2378     		ldrb	r3, [r4, #0]
 956 0696 2B74     		strb	r3, [r5, #16]
 421:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 422:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // TX retries
 423:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->l2_retriesLeft = TXRETRIES;
 957              		.loc 1 423 0
 958 0698 7B69     		ldr	r3, [r7, #20]
 959 069a 4FF00302 		mov	r2, #3
 960 069e 83F84B20 		strb	r2, [r3, #75]
 424:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 425:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // record this packet's dsn (for matching the ACK)
 426:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->l2_dsn = ieee154e_vars.cslDSN++;
 961              		.loc 1 426 0
 962 06a2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 963 06a6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 964 06aa 93F84430 		ldrb	r3, [r3, #68]	@ zero_extendqisi2
 965 06ae 7A69     		ldr	r2, [r7, #20]
 966 06b0 1946     		mov	r1, r3
 967 06b2 82F84A10 		strb	r1, [r2, #74]
 968 06b6 03F10103 		add	r3, r3, #1
 969 06ba DAB2     		uxtb	r2, r3
 970 06bc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 971 06c0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 972 06c4 83F84420 		strb	r2, [r3, #68]
 427:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 428:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // this is a new packet which I never attempted to send
 429:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->l2_numTxAttempts = 0;
 973              		.loc 1 429 0
 974 06c8 7B69     		ldr	r3, [r7, #20]
 975 06ca 4FF00002 		mov	r2, #0
 976 06ce 83F84C20 		strb	r2, [r3, #76]
 430:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 431:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // transmit with the default TX power
 432:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->l1_txPower = TX_POWER;
 977              		.loc 1 432 0
 978 06d2 7B69     		ldr	r3, [r7, #20]
 979 06d4 4FF01F02 		mov	r2, #31
 980 06d8 83F86720 		strb	r2, [r3, #103]
 433:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 434:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // add a IEEE802.15.4 header
 435:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  ieee802154_prependHeader(pkt,
 436:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							   pkt->l2_frameType,
 981              		.loc 1 436 0
 982 06dc 7B69     		ldr	r3, [r7, #20]
 435:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  ieee802154_prependHeader(pkt,
 983              		.loc 1 435 0
 984 06de 93F84930 		ldrb	r3, [r3, #73]	@ zero_extendqisi2
 437:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							   IEEE154_IELIST_NO,
 438:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							   IEEE154_FRAMEVERSION,
 439:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							   IEEE154_SEC_NO_SECURITY,
 440:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							   pkt->l2_dsn,
 985              		.loc 1 440 0
 986 06e2 7A69     		ldr	r2, [r7, #20]
 435:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  ieee802154_prependHeader(pkt,
 987              		.loc 1 435 0
 988 06e4 92F84A10 		ldrb	r1, [r2, #74]	@ zero_extendqisi2
 989 06e8 7A69     		ldr	r2, [r7, #20]
 990 06ea 02F13802 		add	r2, r2, #56
 991 06ee 4FF00000 		mov	r0, #0
 992 06f2 0090     		str	r0, [sp, #0]
 993 06f4 0191     		str	r1, [sp, #4]
 994 06f6 0292     		str	r2, [sp, #8]
 995 06f8 7869     		ldr	r0, [r7, #20]
 996 06fa 1946     		mov	r1, r3
 997 06fc 4FF00002 		mov	r2, #0
 998 0700 4FF00203 		mov	r3, #2
 999 0704 FFF7FEFF 		bl	ieee802154_prependHeader
 441:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							   &(pkt->l2_nextORpreviousHop)
 442:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							   );
 443:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 444:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // reserve space for 2-byte CRC
 445:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  packetfunctions_reserveFooterSize(pkt,2);
 1000              		.loc 1 445 0
 1001 0708 7869     		ldr	r0, [r7, #20]
 1002 070a 4FF00201 		mov	r1, #2
 1003 070e FFF7FEFF 		bl	packetfunctions_reserveFooterSize
 1004              	.L78:
 446:openstack/02a-MAClow/IEEE802154Ecsl.c ****   }
 447:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 448:openstack/02a-MAClow/IEEE802154Ecsl.c ****   return;
 449:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1005              		.loc 1 449 0
 1006 0712 07F11807 		add	r7, r7, #24
 1007 0716 BD46     		mov	sp, r7
 1008 0718 B0BD     		pop	{r4, r5, r7, pc}
 1009              		.cfi_endproc
 1010              	.LFE6:
 1012 071a 00BF     		.align	2
 1013              		.global	activity_csl_wakeup_ti1
 1014              		.thumb
 1015              		.thumb_func
 1017              	activity_csl_wakeup_ti1:
 1018              	.LFB7:
 450:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 451:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 452:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
 453:openstack/02a-MAClow/IEEE802154Ecsl.c **** //========================== CSL TX MODE ===============================
 454:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
 455:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 456:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 457:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [wake-up ti1].
 458:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 459:openstack/02a-MAClow/IEEE802154Ecsl.c ****  This method is invoked in ISR-mode from "isr_ieee154ecsl_txtimer_cb" function when TX Timer is fir
 460:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 461:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 462:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ti1() {
 1019              		.loc 1 462 0
 1020              		.cfi_startproc
 1021              		@ args = 0, pretend = 0, frame = 24
 1022              		@ frame_needed = 1, uses_anonymous_args = 0
 1023 071c 80B5     		push	{r7, lr}
 1024              	.LCFI17:
 1025              		.cfi_def_cfa_offset 8
 1026              		.cfi_offset 7, -8
 1027              		.cfi_offset 14, -4
 1028 071e 86B0     		sub	sp, sp, #24
 1029              	.LCFI18:
 1030              		.cfi_def_cfa_offset 32
 1031 0720 00AF     		add	r7, sp, #0
 1032              	.LCFI19:
 1033              		.cfi_def_cfa_register 7
 463:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   cellType_t  cellType;
 464:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   open_addr_t neighbor;
 465:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 466:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // update CSL Mode to TX in order to avoid problems in FSM.
 467:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   ieee154e_vars.cslMode = CSL_TX_MODE;
 1034              		.loc 1 467 0
 1035 0722 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1036 0726 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1037 072a 4FF00202 		mov	r2, #2
 1038 072e 83F84520 		strb	r2, [r3, #69]
 468:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 469:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // Las acciones que realizaremos son las siguientes:
 470:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   //  - Avanzar el schedule para posicionar la siguiente posición en éste, el cual marcará la 
 471:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   //  - Verificar el estado actual dentro de la FSM para comprobar que efectivamente nos encontra
 472:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   //  - Si no hay problema en ambos, verificamos el tipo de slot en el schedule y preparamos un p
 473:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   //    destino asociado a dicho slot.
 474:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 475:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // increment ASN (do this first so debug pins are in sync)
 476:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   incrementAsnOffset();
 1039              		.loc 1 476 0
 1040 0732 FFF7FEFF 		bl	incrementAsnOffset
 477:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 478:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // wiggle debug pins
 479:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   debugpins_slot_toggle();
 1041              		.loc 1 479 0
 1042 0736 FFF7FEFF 		bl	debugpins_slot_toggle
 480:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   if (ieee154e_vars.slotOffset==0) {
 1043              		.loc 1 480 0
 1044 073a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1045 073e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1046 0742 DB88     		ldrh	r3, [r3, #6]
 1047 0744 002B     		cmp	r3, #0
 1048 0746 01D1     		bne	.L83
 481:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      debugpins_frame_toggle();
 1049              		.loc 1 481 0
 1050 0748 FFF7FEFF 		bl	debugpins_frame_toggle
 1051              	.L83:
 482:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 483:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 484:openstack/02a-MAClow/IEEE802154Ecsl.c ****        // if the previous slot took too long, we will not be in the right state
 485:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   if (ieee154e_vars.state!=S_SLEEP) {
 1052              		.loc 1 485 0
 1053 074c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1054 0750 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1055 0754 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 1056 0756 002B     		cmp	r3, #0
 1057 0758 14D0     		beq	.L84
 486:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      // log the error
 487:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_STARTSLOT,
 488:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	                            (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_dbg.
 1058              		.loc 1 488 0
 1059 075a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1060 075e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1061 0762 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 487:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_STARTSLOT,
 1062              		.loc 1 487 0
 1063 0764 1A46     		mov	r2, r3
 1064              		.loc 1 488 0
 1065 0766 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 1066 076a C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 1067 076e 1B69     		ldr	r3, [r3, #16]
 487:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_STARTSLOT,
 1068              		.loc 1 487 0
 1069 0770 9BB2     		uxth	r3, r3
 1070 0772 4FF00900 		mov	r0, #9
 1071 0776 4FF01E01 		mov	r1, #30
 1072 077a FFF7FEFF 		bl	openserial_printError
 489:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      // abort
 490:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      endOps();
 1073              		.loc 1 490 0
 1074 077e FFF7FEFF 		bl	endOps
 1075 0782 51E0     		b	.L82
 1076              	.L84:
 491:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      return;
 492:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 493:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 494:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // advance the schedule
 495:openstack/02a-MAClow/IEEE802154Ecsl.c ****        schedule_advanceSlot();
 1077              		.loc 1 495 0
 1078 0784 FFF7FEFF 		bl	schedule_advanceSlot
 496:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 497:openstack/02a-MAClow/IEEE802154Ecsl.c ****        // stop using serial
 498:openstack/02a-MAClow/IEEE802154Ecsl.c ****        openserial_stop();
 1079              		.loc 1 498 0
 1080 0788 FFF7FEFF 		bl	openserial_stop
 499:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 500:openstack/02a-MAClow/IEEE802154Ecsl.c ****        // check the schedule to see what type of slot this is
 501:openstack/02a-MAClow/IEEE802154Ecsl.c ****        cellType = schedule_getType();
 1081              		.loc 1 501 0
 1082 078c FFF7FEFF 		bl	schedule_getType
 1083 0790 0346     		mov	r3, r0
 1084 0792 FB75     		strb	r3, [r7, #23]
 502:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 503:openstack/02a-MAClow/IEEE802154Ecsl.c ****        // check whether we can send
 504:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   if (schedule_getOkToSend()) {
 1085              		.loc 1 504 0
 1086 0794 FFF7FEFF 		bl	schedule_getOkToSend
 1087 0798 0346     		mov	r3, r0
 1088 079a 002B     		cmp	r3, #0
 1089 079c 10D0     		beq	.L86
 505:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       schedule_getNeighbor(&neighbor);
 1090              		.loc 1 505 0
 1091 079e 07F10403 		add	r3, r7, #4
 1092 07a2 1846     		mov	r0, r3
 1093 07a4 FFF7FEFF 		bl	schedule_getNeighbor
 506:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       ieee154e_vars.dataToSend = openqueue_macGetDataPacket(&neighbor);
 1094              		.loc 1 506 0
 1095 07a8 07F10403 		add	r3, r7, #4
 1096 07ac 1846     		mov	r0, r3
 1097 07ae FFF7FEFF 		bl	openqueue_macGetDataPacket
 1098 07b2 0246     		mov	r2, r0
 1099 07b4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1100 07b8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1101 07bc 5A61     		str	r2, [r3, #20]
 1102 07be 06E0     		b	.L87
 1103              	.L86:
 507:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   } else {
 508:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       ieee154e_vars.dataToSend = NULL;
 1104              		.loc 1 508 0
 1105 07c0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1106 07c4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1107 07c8 4FF00002 		mov	r2, #0
 1108 07cc 5A61     		str	r2, [r3, #20]
 1109              	.L87:
 509:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 510:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   if((ieee154e_vars.dataToSend!=NULL) && (cellType == CELLTYPE_TX)) {   // If I have a packet to 
 1110              		.loc 1 510 0
 1111 07ce 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1112 07d2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1113 07d6 5B69     		ldr	r3, [r3, #20]
 1114 07d8 002B     		cmp	r3, #0
 1115 07da 1DD0     		beq	.L88
 1116              		.loc 1 510 0 is_stmt 0 discriminator 1
 1117 07dc FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 1118 07de 022B     		cmp	r3, #2
 1119 07e0 1AD1     		bne	.L88
 511:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       // change state to start sending CSL preamble before send the data packet.
 512:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       changeState(S_CSLTXWAKEUPOFFSET);
 1120              		.loc 1 512 0 is_stmt 1
 1121 07e2 4FF01A00 		mov	r0, #26
 1122 07e6 FFF7FEFF 		bl	changeState
 513:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 514:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       // change owner
 515:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       //ieee154e_vars.dataToSend->owner = COMPONENT_IEEE802154E;
 516:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       // record that I will attempt to transmit this packet
 517:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       ieee154e_vars.dataToSend->l2_numTxAttempts++;
 1123              		.loc 1 517 0
 1124 07ea 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1125 07ee C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1126 07f2 5B69     		ldr	r3, [r3, #20]
 1127 07f4 93F84C20 		ldrb	r2, [r3, #76]	@ zero_extendqisi2
 1128 07f8 02F10102 		add	r2, r2, #1
 1129 07fc D2B2     		uxtb	r2, r2
 1130 07fe 83F84C20 		strb	r2, [r3, #76]
 518:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       // arm tt1
 519:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       radiotimer_schedule(DURATION_tt1);
 1131              		.loc 1 519 0
 1132 0802 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1133 0806 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1134 080a 5B6A     		ldr	r3, [r3, #36]
 1135 080c 03F13A03 		add	r3, r3, #58
 1136 0810 1846     		mov	r0, r3
 1137 0812 FFF7FEFF 		bl	radiotimer_schedule
 1138 0816 07E0     		b	.L82
 1139              	.L88:
 520:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   } else {
 521:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       // abort because slot is not TX or there is no data to send, so we reset TX Mode state
 522:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   ieee154e_vars.cslMode = CSL_SLEEP_MODE;
 1140              		.loc 1 522 0
 1141 0818 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1142 081c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1143 0820 4FF00002 		mov	r2, #0
 1144 0824 83F84520 		strb	r2, [r3, #69]
 1145              	.L82:
 523:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 524:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1146              		.loc 1 524 0
 1147 0828 07F11807 		add	r7, r7, #24
 1148 082c BD46     		mov	sp, r7
 1149 082e 80BD     		pop	{r7, pc}
 1150              		.cfi_endproc
 1151              	.LFE7:
 1153              		.align	2
 1154              		.global	activity_csl_wakeup_ti2
 1155              		.thumb
 1156              		.thumb_func
 1158              	activity_csl_wakeup_ti2:
 1159              	.LFB8:
 525:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 526:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 527:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [wake-up ti2].
 528:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 529:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 530:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to prepare the radio for sending packets.
 531:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 532:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 533:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ti2() {
 1160              		.loc 1 533 0
 1161              		.cfi_startproc
 1162              		@ args = 0, pretend = 0, frame = 24
 1163              		@ frame_needed = 1, uses_anonymous_args = 0
 1164 0830 80B5     		push	{r7, lr}
 1165              	.LCFI20:
 1166              		.cfi_def_cfa_offset 8
 1167              		.cfi_offset 7, -8
 1168              		.cfi_offset 14, -4
 1169 0832 86B0     		sub	sp, sp, #24
 1170              	.LCFI21:
 1171              		.cfi_def_cfa_offset 32
 1172 0834 00AF     		add	r7, sp, #0
 1173              	.LCFI22:
 1174              		.cfi_def_cfa_register 7
 534:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 535:openstack/02a-MAClow/IEEE802154Ecsl.c ****    open_addr_t neighbor;
 536:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 537:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // El tiempo de rendezvous que será necesario esperar será macCSLMaxPeriod al tratarse de
 538:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // una comunicación en modo TX no sincronizado.
 539:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 540:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Calculamos el valor del rz-time en cada trama wake-up de la secuencia dado que debe ir reduci
 541:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // al extemo remoto el tiempo restante hasta el envío de la trama de datos.
 542:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 543:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // El tiempo lastCapturedTime se ve incrementado tras el envio de cada trama wake-up por lo que 
 544:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // valor más proximo al macCSLMaxPeriod.
 545:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 546:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.remainingRzTime = macCSLMaxPeriod - ieee154e_vars.lastCapturedTime;
 1175              		.loc 1 546 0
 1176 0836 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1177 083a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1178 083e 5B6A     		ldr	r3, [r3, #36]
 1179 0840 9BB2     		uxth	r3, r3
 1180 0842 C3F5CC53 		rsb	r3, r3, #6528
 1181 0846 03F11A03 		add	r3, r3, #26
 1182 084a 9AB2     		uxth	r2, r3
 1183 084c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1184 0850 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1185 0854 A3F84820 		strh	r2, [r3, #72]	@ movhi
 547:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 548:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if(DURATION_txcsl < ieee154e_vars.remainingRzTime) { // Si da tiempo a enviar una nueva trama de
 1186              		.loc 1 548 0
 1187 0858 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1188 085c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1189 0860 B3F84820 		ldrh	r2, [r3, #72]
 1190 0864 40F24113 		movw	r3, #321
 1191 0868 9A42     		cmp	r2, r3
 1192 086a 40F2CB80 		bls	.L91
 549:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 550:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // change state
 551:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   changeState(S_CSLTXWAKEUPPREPARE);
 1193              		.loc 1 551 0
 1194 086e 4FF01B00 		mov	r0, #27
 1195 0872 FFF7FEFF 		bl	changeState
 552:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 553:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   //
 554:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // Construimos el paquete Wake-Up con su valor RZTime asociado en caso de no existir ya.
 555:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   //
 556:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 557:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   if (ieee154e_vars.wakeupToSend == NULL) { // first time
 1196              		.loc 1 557 0
 1197 0876 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1198 087a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1199 087e DB6B     		ldr	r3, [r3, #60]
 1200 0880 002B     		cmp	r3, #0
 1201 0882 7FD1     		bne	.L92
 558:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 559:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // obtenemos un buffer en el cual poder guardar los datos recibidos.
 560:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   ieee154e_vars.wakeupToSend = openqueue_getFreePacketBuffer(COMPONENT_IEEE802154E);
 1202              		.loc 1 560 0
 1203 0884 4FF00900 		mov	r0, #9
 1204 0888 FFF7FEFF 		bl	openqueue_getFreePacketBuffer
 1205 088c 0246     		mov	r2, r0
 1206 088e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1207 0892 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1208 0896 DA63     		str	r2, [r3, #60]
 561:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   if (ieee154e_vars.wakeupToSend == NULL) {
 1209              		.loc 1 561 0
 1210 0898 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1211 089c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1212 08a0 DB6B     		ldr	r3, [r3, #60]
 1213 08a2 002B     		cmp	r3, #0
 1214 08a4 0CD1     		bne	.L93
 562:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			  // registro del error & fin de operaciones.
 563:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			  openserial_printError(COMPONENT_IEEE802154E,ERR_NO_FREE_PACKET_BUFFER, (errorparameter_t)0, (e
 1215              		.loc 1 563 0
 1216 08a6 4FF00900 		mov	r0, #9
 1217 08aa 4FF02C01 		mov	r1, #44
 1218 08ae 4FF00002 		mov	r2, #0
 1219 08b2 4FF00003 		mov	r3, #0
 1220 08b6 FFF7FEFF 		bl	openserial_printError
 564:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			  endOps();
 1221              		.loc 1 564 0
 1222 08ba FFF7FEFF 		bl	endOps
 1223 08be AEE0     		b	.L90
 1224              	.L93:
 565:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			  return;
 566:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   }
 567:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 568:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // Declaración de propiedad sobre el paquete.
 569:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   ieee154e_vars.wakeupToSend->creator = COMPONENT_IEEE802154E;
 1225              		.loc 1 569 0
 1226 08c0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1227 08c4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1228 08c8 DB6B     		ldr	r3, [r3, #60]
 1229 08ca 4FF00902 		mov	r2, #9
 1230 08ce 1A70     		strb	r2, [r3, #0]
 570:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   ieee154e_vars.wakeupToSend->owner   = COMPONENT_IEEE802154E;
 1231              		.loc 1 570 0
 1232 08d0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1233 08d4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1234 08d8 DB6B     		ldr	r3, [r3, #60]
 1235 08da 4FF00902 		mov	r2, #9
 1236 08de 5A70     		strb	r2, [r3, #1]
 571:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 572:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // El tipo de trama es Multipurpose.
 573:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   ieee154e_vars.wakeupToSend->l2_frameType = IEEE154_TYPE_MULTIPURPOSE;
 1237              		.loc 1 573 0
 1238 08e0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1239 08e4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1240 08e8 DB6B     		ldr	r3, [r3, #60]
 1241 08ea 4FF00502 		mov	r2, #5
 1242 08ee 83F84920 		strb	r2, [r3, #73]
 574:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 575:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // El dsn del paquete lo obtenemos a partir del actual DSN incrementado en cada paquete de la 
 576:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   ieee154e_vars.wakeupToSend->l2_dsn = ieee154e_vars.cslDSN++;
 1243              		.loc 1 576 0
 1244 08f2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1245 08f6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1246 08fa DA6B     		ldr	r2, [r3, #60]
 1247 08fc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1248 0900 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1249 0904 93F84430 		ldrb	r3, [r3, #68]	@ zero_extendqisi2
 1250 0908 1946     		mov	r1, r3
 1251 090a 82F84A10 		strb	r1, [r2, #74]
 1252 090e 03F10103 		add	r3, r3, #1
 1253 0912 DAB2     		uxtb	r2, r3
 1254 0914 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1255 0918 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1256 091c 83F84420 		strb	r2, [r3, #68]
 577:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 578:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // El destinatario es el mismo que el destinatario del mensaje de datos indicado en el schedul
 579:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   schedule_getNeighbor(&neighbor);
 1257              		.loc 1 579 0
 1258 0920 07F10403 		add	r3, r7, #4
 1259 0924 1846     		mov	r0, r3
 1260 0926 FFF7FEFF 		bl	schedule_getNeighbor
 580:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 581:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // Verificamos que se trata de una dirección corta (short address). En caso contrario generam
 582:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   if(neighbor.type != ADDR_16B) {
 1261              		.loc 1 582 0
 1262 092a 3B79     		ldrb	r3, [r7, #4]	@ zero_extendqisi2
 1263 092c 012B     		cmp	r3, #1
 1264 092e 08D0     		beq	.L95
 583:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			   // CSL: This is an invalid address because address in wake-up frame must be short address.
 584:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			   // We do not finish operations but we will use later short address getting it from long addre
 585:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			   openserial_printInfo(COMPONENT_IEEE802154,ERR_IEEE154_UNSUPPORTED, (errorparameter_t)1, (erro
 1265              		.loc 1 585 0
 1266 0930 3B79     		ldrb	r3, [r7, #4]	@ zero_extendqisi2
 1267 0932 4FF00800 		mov	r0, #8
 1268 0936 4FF01901 		mov	r1, #25
 1269 093a 4FF00102 		mov	r2, #1
 1270 093e FFF7FEFF 		bl	openserial_printInfo
 1271              	.L95:
 586:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   }
 587:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 588:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // create frame header.
 589:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   ieee802154_createWakeUpFrame(ieee154e_vars.wakeupToSend,
 1272              		.loc 1 589 0
 1273 0942 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1274 0946 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1275 094a D86B     		ldr	r0, [r3, #60]
 590:openstack/02a-MAClow/IEEE802154Ecsl.c **** 										ieee154e_vars.wakeupToSend->l2_dsn,
 1276              		.loc 1 590 0
 1277 094c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1278 0950 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1279 0954 DB6B     		ldr	r3, [r3, #60]
 589:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   ieee802154_createWakeUpFrame(ieee154e_vars.wakeupToSend,
 1280              		.loc 1 589 0
 1281 0956 93F84A10 		ldrb	r1, [r3, #74]	@ zero_extendqisi2
 1282 095a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1283 095e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1284 0962 B3F84830 		ldrh	r3, [r3, #72]
 1285 0966 07F10402 		add	r2, r7, #4
 1286 096a FFF7FEFF 		bl	ieee802154_createWakeUpFrame
 591:openstack/02a-MAClow/IEEE802154Ecsl.c **** 										&neighbor,
 592:openstack/02a-MAClow/IEEE802154Ecsl.c **** 										ieee154e_vars.remainingRzTime);
 593:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 594:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // space for 2-byte CRC
 595:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   packetfunctions_reserveFooterSize(ieee154e_vars.wakeupToSend,2);
 1287              		.loc 1 595 0
 1288 096e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1289 0972 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1290 0976 DB6B     		ldr	r3, [r3, #60]
 1291 0978 1846     		mov	r0, r3
 1292 097a 4FF00201 		mov	r1, #2
 1293 097e FFF7FEFF 		bl	packetfunctions_reserveFooterSize
 1294 0982 0EE0     		b	.L96
 1295              	.L92:
 596:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 597:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   else {
 598:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // update rztime in header.
 599:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // Se posiciona 8 posiciones antes dado que estamos escribiendo el paquete de atras hacia dela
 600:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // - 1 byte FCF
 601:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // - 1 byte SEQ
 602:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // - 2 bytes PANID
 603:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // - 2 bytes DEST ADDR
 604:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // - 2 bytes RZTIME IE HEADER
 605:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // - 2 bytes RZTIME (el cual se sobrescribirá con el nuevo valor).
 606:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   *((uint16_t*)(ieee154e_vars.wakeupToSend->payload+8)) = ieee154e_vars.remainingRzTime;
 1296              		.loc 1 606 0
 1297 0984 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1298 0988 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1299 098c DB6B     		ldr	r3, [r3, #60]
 1300 098e 5B68     		ldr	r3, [r3, #4]
 1301 0990 03F10802 		add	r2, r3, #8
 1302 0994 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1303 0998 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1304 099c B3F84830 		ldrh	r3, [r3, #72]
 1305 09a0 1380     		strh	r3, [r2, #0]	@ movhi
 1306              	.L96:
 607:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 608:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 609:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 610:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // load the packet in the radio's Tx buffer
 611:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   radio_loadPacket(ieee154e_vars.wakeupToSend->payload, ieee154e_vars.wakeupToSend->length);
 1307              		.loc 1 611 0
 1308 09a2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1309 09a6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1310 09aa DB6B     		ldr	r3, [r3, #60]
 1311 09ac 5A68     		ldr	r2, [r3, #4]
 1312 09ae 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1313 09b2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1314 09b6 DB6B     		ldr	r3, [r3, #60]
 1315 09b8 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 1316 09ba 1046     		mov	r0, r2
 1317 09bc 1946     		mov	r1, r3
 1318 09be FFF7FEFF 		bl	radio_loadPacket
 612:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 613:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // enable the radio in Tx mode. This does not send the packet.
 614:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   radio_txEnable();
 1319              		.loc 1 614 0
 1320 09c2 FFF7FEFF 		bl	radio_txEnable
 615:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   ieee154e_vars.radioOnInit=radio_getTimerValue();
 1321              		.loc 1 615 0
 1322 09c6 FFF7FEFF 		bl	radio_getTimerValue
 1323 09ca 0246     		mov	r2, r0
 1324 09cc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1325 09d0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1326 09d4 1A63     		str	r2, [r3, #48]
 616:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   ieee154e_vars.radioOnThisSlot=TRUE;
 1327              		.loc 1 616 0
 1328 09d6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1329 09da C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1330 09de 4FF00102 		mov	r2, #1
 1331 09e2 83F83820 		strb	r2, [r3, #56]
 617:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 618:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // arm tt2
 619:openstack/02a-MAClow/IEEE802154Ecsl.c ****        radiotimer_schedule(DURATION_tt2);
 1332              		.loc 1 619 0
 1333 09e6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1334 09ea C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1335 09ee 5B6A     		ldr	r3, [r3, #36]
 1336 09f0 03F17C03 		add	r3, r3, #124
 1337 09f4 1846     		mov	r0, r3
 1338 09f6 FFF7FEFF 		bl	radiotimer_schedule
 620:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 621:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // change state
 622:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   changeState(S_CSLTXWAKEUPREADY);
 1339              		.loc 1 622 0
 1340 09fa 4FF01C00 		mov	r0, #28
 1341 09fe FFF7FEFF 		bl	changeState
 1342 0a02 0CE0     		b	.L90
 1343              	.L91:
 623:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 624:openstack/02a-MAClow/IEEE802154Ecsl.c ****    else {
 625:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // Si no da tiempo a enviar una nueva trama, simplemente esperamos un tiempo igual a remainingR
 626:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // el tiempo que queda pendiente hasta el envío de la trama de datos y actualizamos directamen
 627:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // pasar a la transmisión de los datos.
 628:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 629:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // change state
 630:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   changeState(S_CSLTXDATAPREOFFSET);
 1344              		.loc 1 630 0
 1345 0a04 4FF03B00 		mov	r0, #59
 1346 0a08 FFF7FEFF 		bl	changeState
 631:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 632:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // arm tt1 + remaining rendezvous time.
 633:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   radiotimer_schedule(ieee154e_vars.remainingRzTime);
 1347              		.loc 1 633 0
 1348 0a0c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1349 0a10 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1350 0a14 B3F84830 		ldrh	r3, [r3, #72]
 1351 0a18 1846     		mov	r0, r3
 1352 0a1a FFF7FEFF 		bl	radiotimer_schedule
 1353              	.L90:
 634:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 635:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1354              		.loc 1 635 0
 1355 0a1e 07F11807 		add	r7, r7, #24
 1356 0a22 BD46     		mov	sp, r7
 1357 0a24 80BD     		pop	{r7, pc}
 1358              		.cfi_endproc
 1359              	.LFE8:
 1361 0a26 00BF     		.align	2
 1362              		.global	activity_csl_wakeup_tie1
 1363              		.thumb
 1364              		.thumb_func
 1366              	activity_csl_wakeup_tie1:
 1367              	.LFB9:
 636:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 637:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 638:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [wake-up tie1].
 639:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 640:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #tt2 expiring, i.e. timer fires while state = S_CSLTXWAKEUPPREPARE. This is 
 641:openstack/02a-MAClow/IEEE802154Ecsl.c ****   did not have enough time to execute. Chances are to set maxTxDataPrepare too small. The implement
 642:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 643:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_tie1() {
 1368              		.loc 1 643 0
 1369              		.cfi_startproc
 1370              		@ args = 0, pretend = 0, frame = 0
 1371              		@ frame_needed = 1, uses_anonymous_args = 0
 1372 0a28 80B5     		push	{r7, lr}
 1373              	.LCFI23:
 1374              		.cfi_def_cfa_offset 8
 1375              		.cfi_offset 7, -8
 1376              		.cfi_offset 14, -4
 1377 0a2a 00AF     		add	r7, sp, #0
 1378              	.LCFI24:
 1379              		.cfi_def_cfa_register 7
 644:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
 645:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXDATAPREPARE_OVERFLOW,
 646:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_vars.slo
 1380              		.loc 1 646 0
 1381 0a2c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1382 0a30 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1383 0a34 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 645:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXDATAPREPARE_OVERFLOW,
 1384              		.loc 1 645 0
 1385 0a36 1A46     		mov	r2, r3
 1386 0a38 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1387 0a3c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1388 0a40 DB88     		ldrh	r3, [r3, #6]
 1389 0a42 4FF00900 		mov	r0, #9
 1390 0a46 4FF02201 		mov	r1, #34
 1391 0a4a FFF7FEFF 		bl	openserial_printError
 647:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 648:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
 649:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 1392              		.loc 1 649 0
 1393 0a4e FFF7FEFF 		bl	endOps
 650:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1394              		.loc 1 650 0
 1395 0a52 80BD     		pop	{r7, pc}
 1396              		.cfi_endproc
 1397              	.LFE9:
 1399              		.align	2
 1400              		.global	activity_csl_wakeup_ti3
 1401              		.thumb
 1402              		.thumb_func
 1404              	activity_csl_wakeup_ti3:
 1405              	.LFB10:
 651:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 652:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 653:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [wake-up ti3].
 654:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 655:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 656:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The radio is configured and this interrupt gives it the "go" signal to start listening.
 657:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 658:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 659:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ti3() {
 1406              		.loc 1 659 0
 1407              		.cfi_startproc
 1408              		@ args = 0, pretend = 0, frame = 0
 1409              		@ frame_needed = 1, uses_anonymous_args = 0
 1410 0a54 80B5     		push	{r7, lr}
 1411              	.LCFI25:
 1412              		.cfi_def_cfa_offset 8
 1413              		.cfi_offset 7, -8
 1414              		.cfi_offset 14, -4
 1415 0a56 00AF     		add	r7, sp, #0
 1416              	.LCFI26:
 1417              		.cfi_def_cfa_register 7
 660:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 661:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXWAKEUPDELAY);
 1418              		.loc 1 661 0
 1419 0a58 4FF01D00 		mov	r0, #29
 1420 0a5c FFF7FEFF 		bl	changeState
 662:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 663:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt3
 664:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt3);
 1421              		.loc 1 664 0
 1422 0a60 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1423 0a64 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1424 0a68 5B6A     		ldr	r3, [r3, #36]
 1425 0a6a 03F19D03 		add	r3, r3, #157
 1426 0a6e 1846     		mov	r0, r3
 1427 0a70 FFF7FEFF 		bl	radiotimer_schedule
 665:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 666:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // give the 'go' to transmit
 667:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_txNow();
 1428              		.loc 1 667 0
 1429 0a74 FFF7FEFF 		bl	radio_txNow
 668:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1430              		.loc 1 668 0
 1431 0a78 80BD     		pop	{r7, pc}
 1432              		.cfi_endproc
 1433              	.LFE10:
 1435 0a7a 00BF     		.align	2
 1436              		.global	activity_csl_wakeup_tie2
 1437              		.thumb
 1438              		.thumb_func
 1440              	activity_csl_wakeup_tie2:
 1441              	.LFB11:
 669:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 670:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 671:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [wakeup tie2].
 672:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 673:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #tt3 expiring, i.e. timer fires while state = S_CSLTXWAKEUPDELAY. If no pack
 674:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 675:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_tie2() {
 1442              		.loc 1 675 0
 1443              		.cfi_startproc
 1444              		@ args = 0, pretend = 0, frame = 0
 1445              		@ frame_needed = 1, uses_anonymous_args = 0
 1446 0a7c 80B5     		push	{r7, lr}
 1447              	.LCFI27:
 1448              		.cfi_def_cfa_offset 8
 1449              		.cfi_offset 7, -8
 1450              		.cfi_offset 14, -4
 1451 0a7e 00AF     		add	r7, sp, #0
 1452              	.LCFI28:
 1453              		.cfi_def_cfa_register 7
 676:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
 677:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIO_OVERFLOWS,
 678:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_vars.slo
 1454              		.loc 1 678 0
 1455 0a80 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1456 0a84 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1457 0a88 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 677:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIO_OVERFLOWS,
 1458              		.loc 1 677 0
 1459 0a8a 1A46     		mov	r2, r3
 1460 0a8c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1461 0a90 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1462 0a94 DB88     		ldrh	r3, [r3, #6]
 1463 0a96 4FF00900 		mov	r0, #9
 1464 0a9a 4FF02701 		mov	r1, #39
 1465 0a9e FFF7FEFF 		bl	openserial_printError
 679:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
 680:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 1466              		.loc 1 680 0
 1467 0aa2 FFF7FEFF 		bl	endOps
 681:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1468              		.loc 1 681 0
 1469 0aa6 80BD     		pop	{r7, pc}
 1470              		.cfi_endproc
 1471              	.LFE11:
 1473              		.align	2
 1474              		.global	activity_csl_wakeup_ti4
 1475              		.thumb
 1476              		.thumb_func
 1478              	activity_csl_wakeup_ti4:
 1479              	.LFB12:
 682:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 683:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 684:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [wake-up ti4].
 685:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 686:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_startOfFrame" function when a start of frame ev
 687:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to capture the time, cancel #tt3 and arm #tt4 (max time to send all the pack
 688:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 689:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ti4(PORT_RADIOTIMER_WIDTH capturedTime) {
 1480              		.loc 1 689 0
 1481              		.cfi_startproc
 1482              		@ args = 0, pretend = 0, frame = 8
 1483              		@ frame_needed = 1, uses_anonymous_args = 0
 1484 0aa8 80B5     		push	{r7, lr}
 1485              	.LCFI29:
 1486              		.cfi_def_cfa_offset 8
 1487              		.cfi_offset 7, -8
 1488              		.cfi_offset 14, -4
 1489 0aaa 82B0     		sub	sp, sp, #8
 1490              	.LCFI30:
 1491              		.cfi_def_cfa_offset 16
 1492 0aac 00AF     		add	r7, sp, #0
 1493              	.LCFI31:
 1494              		.cfi_def_cfa_register 7
 1495 0aae 7860     		str	r0, [r7, #4]
 690:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 691:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel tt3
 692:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 1496              		.loc 1 692 0
 1497 0ab0 FFF7FEFF 		bl	radiotimer_cancel
 693:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 694:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
 695:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.lastCapturedTime = capturedTime;
 1498              		.loc 1 695 0
 1499 0ab4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1500 0ab8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1501 0abc 7A68     		ldr	r2, [r7, #4]
 1502 0abe 5A62     		str	r2, [r3, #36]
 696:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 697:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 698:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXWAKEUP);
 1503              		.loc 1 698 0
 1504 0ac0 4FF01E00 		mov	r0, #30
 1505 0ac4 FFF7FEFF 		bl	changeState
 699:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 700:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt4
 701:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt4);
 1506              		.loc 1 701 0
 1507 0ac8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1508 0acc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1509 0ad0 5B6A     		ldr	r3, [r3, #36]
 1510 0ad2 03F1A403 		add	r3, r3, #164
 1511 0ad6 1846     		mov	r0, r3
 1512 0ad8 FFF7FEFF 		bl	radiotimer_schedule
 702:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1513              		.loc 1 702 0
 1514 0adc 07F10807 		add	r7, r7, #8
 1515 0ae0 BD46     		mov	sp, r7
 1516 0ae2 80BD     		pop	{r7, pc}
 1517              		.cfi_endproc
 1518              	.LFE12:
 1520              		.align	2
 1521              		.global	activity_csl_wakeup_tie3
 1522              		.thumb
 1523              		.thumb_func
 1525              	activity_csl_wakeup_tie3:
 1526              	.LFB13:
 703:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 704:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 705:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [wake-up tie3].
 706:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 707:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #tt4 expiring, i.e. timer fires while state = S_CSLTXWAKEUP. This is an erro
 708:openstack/02a-MAClow/IEEE802154Ecsl.c ****   took too long to transmit the data packet. The implemented behaviour is to log the error and fini
 709:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 710:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_tie3() {
 1527              		.loc 1 710 0
 1528              		.cfi_startproc
 1529              		@ args = 0, pretend = 0, frame = 0
 1530              		@ frame_needed = 1, uses_anonymous_args = 0
 1531 0ae4 80B5     		push	{r7, lr}
 1532              	.LCFI32:
 1533              		.cfi_def_cfa_offset 8
 1534              		.cfi_offset 7, -8
 1535              		.cfi_offset 14, -4
 1536 0ae6 00AF     		add	r7, sp, #0
 1537              	.LCFI33:
 1538              		.cfi_def_cfa_register 7
 711:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
 712:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
 713:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_vars.slo
 1539              		.loc 1 713 0
 1540 0ae8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1541 0aec C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1542 0af0 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 712:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
 1543              		.loc 1 712 0
 1544 0af2 1A46     		mov	r2, r3
 1545 0af4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1546 0af8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1547 0afc DB88     		ldrh	r3, [r3, #6]
 1548 0afe 4FF00900 		mov	r0, #9
 1549 0b02 4FF02601 		mov	r1, #38
 1550 0b06 FFF7FEFF 		bl	openserial_printError
 714:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
 715:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 1551              		.loc 1 715 0
 1552 0b0a FFF7FEFF 		bl	endOps
 716:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1553              		.loc 1 716 0
 1554 0b0e 80BD     		pop	{r7, pc}
 1555              		.cfi_endproc
 1556              	.LFE13:
 1558              		.align	2
 1559              		.global	activity_csl_wakeup_ti5
 1560              		.thumb
 1561              		.thumb_func
 1563              	activity_csl_wakeup_ti5:
 1564              	.LFB14:
 717:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 718:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 719:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 720:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [wake-up ri5].
 721:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 722:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_endOfFrame" function when a end of frame event 
 723:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change state, cancel #rt4, and start sending data frame and wait for ACK.
 724:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 725:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ti5(PORT_RADIOTIMER_WIDTH capturedTime) {
 1565              		.loc 1 725 0
 1566              		.cfi_startproc
 1567              		@ args = 0, pretend = 0, frame = 8
 1568              		@ frame_needed = 1, uses_anonymous_args = 0
 1569 0b10 80B5     		push	{r7, lr}
 1570              	.LCFI34:
 1571              		.cfi_def_cfa_offset 8
 1572              		.cfi_offset 7, -8
 1573              		.cfi_offset 14, -4
 1574 0b12 82B0     		sub	sp, sp, #8
 1575              	.LCFI35:
 1576              		.cfi_def_cfa_offset 16
 1577 0b14 00AF     		add	r7, sp, #0
 1578              	.LCFI36:
 1579              		.cfi_def_cfa_register 7
 1580 0b16 7860     		str	r0, [r7, #4]
 726:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 727:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// record the captured time
 728:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	ieee154e_vars.lastCapturedTime = capturedTime;
 1581              		.loc 1 728 0
 1582 0b18 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1583 0b1c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1584 0b20 7A68     		ldr	r2, [r7, #4]
 1585 0b22 5A62     		str	r2, [r3, #36]
 729:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 730:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// Mientras el tiempo capturado en el envío de la ultima trama wake-up de la trama wake-up sequen
 731:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// sea inferior al tiempo de la duración del rztime inicial, debemos seguir enviando tramas wake-
 732:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// En caso contrario, enviamos la trama de datos.
 733:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 734:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//if((macCSLMaxPeriod - ieee154e_vars.lastCapturedTime) < ieee154e_vars.remainingRzTime) {
 735:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//	changeState(S_CSLTXWAKEUPOFFSET);
 736:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//}
 737:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//else {
 738:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //   changeState(S_CSLTXDATAOFFSET);
 739:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //}
 740:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 741:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	changeState(S_CSLTXWAKEUPOFFSET);
 1586              		.loc 1 741 0
 1587 0b24 4FF01A00 		mov	r0, #26
 1588 0b28 FFF7FEFF 		bl	changeState
 742:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 743:openstack/02a-MAClow/IEEE802154Ecsl.c ****     // arm tt1 (enviemos de nuevo una trama de wake-up o de datos, el tiempo será tt1).
 744:openstack/02a-MAClow/IEEE802154Ecsl.c ****     radiotimer_schedule(DURATION_tt1);
 1589              		.loc 1 744 0
 1590 0b2c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1591 0b30 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1592 0b34 5B6A     		ldr	r3, [r3, #36]
 1593 0b36 03F13A03 		add	r3, r3, #58
 1594 0b3a 1846     		mov	r0, r3
 1595 0b3c FFF7FEFF 		bl	radiotimer_schedule
 745:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1596              		.loc 1 745 0
 1597 0b40 07F10807 		add	r7, r7, #8
 1598 0b44 BD46     		mov	sp, r7
 1599 0b46 80BD     		pop	{r7, pc}
 1600              		.cfi_endproc
 1601              	.LFE14:
 1603              		.align	2
 1604              		.global	activity_csl_data_ti1
 1605              		.thumb
 1606              		.thumb_func
 1608              	activity_csl_data_ti1:
 1609              	.LFB15:
 746:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 747:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 748:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti1].
 749:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 750:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires after 
 751:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to prepare the data to be sent.
 752:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 753:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 754:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti1() {
 1610              		.loc 1 754 0
 1611              		.cfi_startproc
 1612              		@ args = 0, pretend = 0, frame = 0
 1613              		@ frame_needed = 1, uses_anonymous_args = 0
 1614 0b48 80B5     		push	{r7, lr}
 1615              	.LCFI37:
 1616              		.cfi_def_cfa_offset 8
 1617              		.cfi_offset 7, -8
 1618              		.cfi_offset 14, -4
 1619 0b4a 00AF     		add	r7, sp, #0
 1620              	.LCFI38:
 1621              		.cfi_def_cfa_register 7
 755:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 756:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// change state
 757:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	changeState(S_CSLTXDATAOFFSET);
 1622              		.loc 1 757 0
 1623 0b4c 4FF01F00 		mov	r0, #31
 1624 0b50 FFF7FEFF 		bl	changeState
 758:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 759:openstack/02a-MAClow/IEEE802154Ecsl.c ****     // arm tt1 (enviemos de nuevo una trama de wake-up o de datos, el tiempo será tt1).
 760:openstack/02a-MAClow/IEEE802154Ecsl.c ****     radiotimer_schedule(DURATION_tt1);
 1625              		.loc 1 760 0
 1626 0b54 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1627 0b58 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1628 0b5c 5B6A     		ldr	r3, [r3, #36]
 1629 0b5e 03F13A03 		add	r3, r3, #58
 1630 0b62 1846     		mov	r0, r3
 1631 0b64 FFF7FEFF 		bl	radiotimer_schedule
 761:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1632              		.loc 1 761 0
 1633 0b68 80BD     		pop	{r7, pc}
 1634              		.cfi_endproc
 1635              	.LFE15:
 1637 0b6a 00BF     		.align	2
 1638              		.global	activity_csl_data_ti2
 1639              		.thumb
 1640              		.thumb_func
 1642              	activity_csl_data_ti2:
 1643              	.LFB16:
 762:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 763:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 764:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 765:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 766:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti2].
 767:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 768:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 769:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to prepare the radio for sending packets.
 770:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 771:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti2() {
 1644              		.loc 1 771 0
 1645              		.cfi_startproc
 1646              		@ args = 0, pretend = 0, frame = 0
 1647              		@ frame_needed = 1, uses_anonymous_args = 0
 1648 0b6c 80B5     		push	{r7, lr}
 1649              	.LCFI39:
 1650              		.cfi_def_cfa_offset 8
 1651              		.cfi_offset 7, -8
 1652              		.cfi_offset 14, -4
 1653 0b6e 00AF     		add	r7, sp, #0
 1654              	.LCFI40:
 1655              		.cfi_def_cfa_register 7
 772:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 773:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXDATAPREPARE);
 1656              		.loc 1 773 0
 1657 0b70 4FF02000 		mov	r0, #32
 1658 0b74 FFF7FEFF 		bl	changeState
 774:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 775:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // load the packet in the radio's Tx buffer
 776:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_loadPacket(ieee154e_vars.dataToSend->payload,
 1659              		.loc 1 776 0
 1660 0b78 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1661 0b7c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1662 0b80 5B69     		ldr	r3, [r3, #20]
 1663 0b82 5A68     		ldr	r2, [r3, #4]
 777:openstack/02a-MAClow/IEEE802154Ecsl.c ****                     ieee154e_vars.dataToSend->length);
 1664              		.loc 1 777 0
 1665 0b84 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1666 0b88 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1667 0b8c 5B69     		ldr	r3, [r3, #20]
 776:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_loadPacket(ieee154e_vars.dataToSend->payload,
 1668              		.loc 1 776 0
 1669 0b8e 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 1670 0b90 1046     		mov	r0, r2
 1671 0b92 1946     		mov	r1, r3
 1672 0b94 FFF7FEFF 		bl	radio_loadPacket
 778:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 779:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // enable the radio in Tx mode. This does not send the packet.
 780:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_txEnable();
 1673              		.loc 1 780 0
 1674 0b98 FFF7FEFF 		bl	radio_txEnable
 781:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnInit=radio_getTimerValue();
 1675              		.loc 1 781 0
 1676 0b9c FFF7FEFF 		bl	radio_getTimerValue
 1677 0ba0 0246     		mov	r2, r0
 1678 0ba2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1679 0ba6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1680 0baa 1A63     		str	r2, [r3, #48]
 782:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnThisSlot=TRUE;
 1681              		.loc 1 782 0
 1682 0bac 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1683 0bb0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1684 0bb4 4FF00102 		mov	r2, #1
 1685 0bb8 83F83820 		strb	r2, [r3, #56]
 783:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 784:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt2
 785:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt2);
 1686              		.loc 1 785 0
 1687 0bbc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1688 0bc0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1689 0bc4 5B6A     		ldr	r3, [r3, #36]
 1690 0bc6 03F17C03 		add	r3, r3, #124
 1691 0bca 1846     		mov	r0, r3
 1692 0bcc FFF7FEFF 		bl	radiotimer_schedule
 786:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 787:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 788:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXDATAREADY);
 1693              		.loc 1 788 0
 1694 0bd0 4FF02100 		mov	r0, #33
 1695 0bd4 FFF7FEFF 		bl	changeState
 789:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 790:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1696              		.loc 1 790 0
 1697 0bd8 80BD     		pop	{r7, pc}
 1698              		.cfi_endproc
 1699              	.LFE16:
 1701 0bda 00BF     		.align	2
 1702              		.global	activity_csl_data_tie1
 1703              		.thumb
 1704              		.thumb_func
 1706              	activity_csl_data_tie1:
 1707              	.LFB17:
 791:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 792:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 793:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data tie1].
 794:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 795:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #tt2 expiring, i.e. timer fires while state = S_CSLTXDATAPREPARE. This is re
 796:openstack/02a-MAClow/IEEE802154Ecsl.c ****   did not have enough time to execute. Chances are to set maxTxDataPrepare too small. The implement
 797:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 798:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_tie1() {
 1708              		.loc 1 798 0
 1709              		.cfi_startproc
 1710              		@ args = 0, pretend = 0, frame = 0
 1711              		@ frame_needed = 1, uses_anonymous_args = 0
 1712 0bdc 80B5     		push	{r7, lr}
 1713              	.LCFI41:
 1714              		.cfi_def_cfa_offset 8
 1715              		.cfi_offset 7, -8
 1716              		.cfi_offset 14, -4
 1717 0bde 00AF     		add	r7, sp, #0
 1718              	.LCFI42:
 1719              		.cfi_def_cfa_register 7
 799:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
 800:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXDATAPREPARE_OVERFLOW,
 801:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_vars.slo
 1720              		.loc 1 801 0
 1721 0be0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1722 0be4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1723 0be8 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 800:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXDATAPREPARE_OVERFLOW,
 1724              		.loc 1 800 0
 1725 0bea 1A46     		mov	r2, r3
 1726 0bec 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1727 0bf0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1728 0bf4 DB88     		ldrh	r3, [r3, #6]
 1729 0bf6 4FF00900 		mov	r0, #9
 1730 0bfa 4FF02201 		mov	r1, #34
 1731 0bfe FFF7FEFF 		bl	openserial_printError
 802:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
 803:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 1732              		.loc 1 803 0
 1733 0c02 FFF7FEFF 		bl	endOps
 804:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1734              		.loc 1 804 0
 1735 0c06 80BD     		pop	{r7, pc}
 1736              		.cfi_endproc
 1737              	.LFE17:
 1739              		.align	2
 1740              		.global	activity_csl_data_ti3
 1741              		.thumb
 1742              		.thumb_func
 1744              	activity_csl_data_ti3:
 1745              	.LFB18:
 805:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 806:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 807:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti3].
 808:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 809:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 810:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The radio is configured and this interrupt gives it the "go" signal to start listening.
 811:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 812:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti3() {
 1746              		.loc 1 812 0
 1747              		.cfi_startproc
 1748              		@ args = 0, pretend = 0, frame = 0
 1749              		@ frame_needed = 1, uses_anonymous_args = 0
 1750 0c08 80B5     		push	{r7, lr}
 1751              	.LCFI43:
 1752              		.cfi_def_cfa_offset 8
 1753              		.cfi_offset 7, -8
 1754              		.cfi_offset 14, -4
 1755 0c0a 00AF     		add	r7, sp, #0
 1756              	.LCFI44:
 1757              		.cfi_def_cfa_register 7
 813:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 814:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXDATADELAY);
 1758              		.loc 1 814 0
 1759 0c0c 4FF02200 		mov	r0, #34
 1760 0c10 FFF7FEFF 		bl	changeState
 815:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 816:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt3
 817:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt3);
 1761              		.loc 1 817 0
 1762 0c14 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1763 0c18 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1764 0c1c 5B6A     		ldr	r3, [r3, #36]
 1765 0c1e 03F19D03 		add	r3, r3, #157
 1766 0c22 1846     		mov	r0, r3
 1767 0c24 FFF7FEFF 		bl	radiotimer_schedule
 818:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 819:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // give the 'go' to transmit
 820:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_txNow();
 1768              		.loc 1 820 0
 1769 0c28 FFF7FEFF 		bl	radio_txNow
 821:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1770              		.loc 1 821 0
 1771 0c2c 80BD     		pop	{r7, pc}
 1772              		.cfi_endproc
 1773              	.LFE18:
 1775 0c2e 00BF     		.align	2
 1776              		.global	activity_csl_data_tie2
 1777              		.thumb
 1778              		.thumb_func
 1780              	activity_csl_data_tie2:
 1781              	.LFB19:
 822:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 823:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 824:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 825:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX Sampling error [data tie2].
 826:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 827:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #tt3 expiring, i.e. timer fires while state = S_CSLTXDATADELAY. If no packet
 828:openstack/02a-MAClow/IEEE802154Ecsl.c ****   none will be sent and it is safe to switch off the radio. This timer is set such that the radio w
 829:openstack/02a-MAClow/IEEE802154Ecsl.c ****   duration (#TsLongGT).
 830:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 831:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_tie2() {
 1782              		.loc 1 831 0
 1783              		.cfi_startproc
 1784              		@ args = 0, pretend = 0, frame = 0
 1785              		@ frame_needed = 1, uses_anonymous_args = 0
 1786 0c30 80B5     		push	{r7, lr}
 1787              	.LCFI45:
 1788              		.cfi_def_cfa_offset 8
 1789              		.cfi_offset 7, -8
 1790              		.cfi_offset 14, -4
 1791 0c32 00AF     		add	r7, sp, #0
 1792              	.LCFI46:
 1793              		.cfi_def_cfa_register 7
 832:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
 833:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIO_OVERFLOWS,
 834:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_vars.slo
 1794              		.loc 1 834 0
 1795 0c34 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1796 0c38 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1797 0c3c 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 833:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIO_OVERFLOWS,
 1798              		.loc 1 833 0
 1799 0c3e 1A46     		mov	r2, r3
 1800 0c40 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1801 0c44 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1802 0c48 DB88     		ldrh	r3, [r3, #6]
 1803 0c4a 4FF00900 		mov	r0, #9
 1804 0c4e 4FF02701 		mov	r1, #39
 1805 0c52 FFF7FEFF 		bl	openserial_printError
 835:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 836:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
 837:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 1806              		.loc 1 837 0
 1807 0c56 FFF7FEFF 		bl	endOps
 838:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1808              		.loc 1 838 0
 1809 0c5a 80BD     		pop	{r7, pc}
 1810              		.cfi_endproc
 1811              	.LFE19:
 1813              		.align	2
 1814              		.global	activity_csl_data_ti4
 1815              		.thumb
 1816              		.thumb_func
 1818              	activity_csl_data_ti4:
 1819              	.LFB20:
 839:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 840:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 841:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 842:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti4].
 843:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 844:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_startOfFrame" function when a start of frame ev
 845:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change state, cancel #tt3 and arm #tt4 (max time to sent all the packet).
 846:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 847:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti4(PORT_RADIOTIMER_WIDTH capturedTime) {
 1820              		.loc 1 847 0
 1821              		.cfi_startproc
 1822              		@ args = 0, pretend = 0, frame = 8
 1823              		@ frame_needed = 1, uses_anonymous_args = 0
 1824 0c5c 80B5     		push	{r7, lr}
 1825              	.LCFI47:
 1826              		.cfi_def_cfa_offset 8
 1827              		.cfi_offset 7, -8
 1828              		.cfi_offset 14, -4
 1829 0c5e 82B0     		sub	sp, sp, #8
 1830              	.LCFI48:
 1831              		.cfi_def_cfa_offset 16
 1832 0c60 00AF     		add	r7, sp, #0
 1833              	.LCFI49:
 1834              		.cfi_def_cfa_register 7
 1835 0c62 7860     		str	r0, [r7, #4]
 848:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 849:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXDATA);
 1836              		.loc 1 849 0
 1837 0c64 4FF02300 		mov	r0, #35
 1838 0c68 FFF7FEFF 		bl	changeState
 850:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 851:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel tt3
 852:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 1839              		.loc 1 852 0
 1840 0c6c FFF7FEFF 		bl	radiotimer_cancel
 853:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 854:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
 855:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //ieee154e_vars.lastCapturedTime = capturedTime;
 856:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 857:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt4
 858:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt4);
 1841              		.loc 1 858 0
 1842 0c70 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1843 0c74 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1844 0c78 5B6A     		ldr	r3, [r3, #36]
 1845 0c7a 03F1A403 		add	r3, r3, #164
 1846 0c7e 1846     		mov	r0, r3
 1847 0c80 FFF7FEFF 		bl	radiotimer_schedule
 859:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1848              		.loc 1 859 0
 1849 0c84 07F10807 		add	r7, r7, #8
 1850 0c88 BD46     		mov	sp, r7
 1851 0c8a 80BD     		pop	{r7, pc}
 1852              		.cfi_endproc
 1853              	.LFE20:
 1855              		.align	2
 1856              		.global	activity_csl_data_tie3
 1857              		.thumb
 1858              		.thumb_func
 1860              	activity_csl_data_tie3:
 1861              	.LFB21:
 860:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 861:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 862:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data tie3].
 863:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 864:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #tt4 expiring, i.e. timer fires while state = S_CSLTXDATA. This is an error 
 865:openstack/02a-MAClow/IEEE802154Ecsl.c ****   to transmit the data packet. The implemented behaviour is to log the error and finish.
 866:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 867:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_tie3() {
 1862              		.loc 1 867 0
 1863              		.cfi_startproc
 1864              		@ args = 0, pretend = 0, frame = 0
 1865              		@ frame_needed = 1, uses_anonymous_args = 0
 1866 0c8c 80B5     		push	{r7, lr}
 1867              	.LCFI50:
 1868              		.cfi_def_cfa_offset 8
 1869              		.cfi_offset 7, -8
 1870              		.cfi_offset 14, -4
 1871 0c8e 00AF     		add	r7, sp, #0
 1872              	.LCFI51:
 1873              		.cfi_def_cfa_register 7
 868:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
 869:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
 870:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_vars.slo
 1874              		.loc 1 870 0
 1875 0c90 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1876 0c94 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1877 0c98 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 869:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
 1878              		.loc 1 869 0
 1879 0c9a 1A46     		mov	r2, r3
 1880 0c9c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1881 0ca0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1882 0ca4 DB88     		ldrh	r3, [r3, #6]
 1883 0ca6 4FF00900 		mov	r0, #9
 1884 0caa 4FF02601 		mov	r1, #38
 1885 0cae FFF7FEFF 		bl	openserial_printError
 871:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
 872:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 1886              		.loc 1 872 0
 1887 0cb2 FFF7FEFF 		bl	endOps
 873:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1888              		.loc 1 873 0
 1889 0cb6 80BD     		pop	{r7, pc}
 1890              		.cfi_endproc
 1891              	.LFE21:
 1893              		.align	2
 1894              		.global	activity_csl_data_ti5
 1895              		.thumb
 1896              		.thumb_func
 1898              	activity_csl_data_ti5:
 1899              	.LFB22:
 874:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 875:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 876:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ri5].
 877:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 878:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_endOfFrame" function when a end of frame event 
 879:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change state, cancel #tt4, and notify upper layer and schedule about succ
 880:openstack/02a-MAClow/IEEE802154Ecsl.c ****   start process for receive ACK frame (arm #tt5).
 881:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 882:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti5(PORT_RADIOTIMER_WIDTH capturedTime) {
 1900              		.loc 1 882 0
 1901              		.cfi_startproc
 1902              		@ args = 0, pretend = 0, frame = 16
 1903              		@ frame_needed = 1, uses_anonymous_args = 0
 1904 0cb8 90B5     		push	{r4, r7, lr}
 1905              	.LCFI52:
 1906              		.cfi_def_cfa_offset 12
 1907              		.cfi_offset 4, -12
 1908              		.cfi_offset 7, -8
 1909              		.cfi_offset 14, -4
 1910 0cba 85B0     		sub	sp, sp, #20
 1911              	.LCFI53:
 1912              		.cfi_def_cfa_offset 32
 1913 0cbc 00AF     		add	r7, sp, #0
 1914              	.LCFI54:
 1915              		.cfi_def_cfa_register 7
 1916 0cbe 7860     		str	r0, [r7, #4]
 883:openstack/02a-MAClow/IEEE802154Ecsl.c ****    bool listenForAck;
 884:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 885:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 886:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXACKOFFSET);
 1917              		.loc 1 886 0
 1918 0cc0 4FF02400 		mov	r0, #36
 1919 0cc4 FFF7FEFF 		bl	changeState
 887:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 888:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel tt4
 889:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 1920              		.loc 1 889 0
 1921 0cc8 FFF7FEFF 		bl	radiotimer_cancel
 890:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 891:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // turn off the radio
 892:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rfOff();
 1922              		.loc 1 892 0
 1923 0ccc FFF7FEFF 		bl	radio_rfOff
 893:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnTics+=(radio_getTimerValue()-ieee154e_vars.radioOnInit);
 1924              		.loc 1 893 0
 1925 0cd0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1926 0cd4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1927 0cd8 5C6B     		ldr	r4, [r3, #52]
 1928 0cda FFF7FEFF 		bl	radio_getTimerValue
 1929 0cde 0246     		mov	r2, r0
 1930 0ce0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1931 0ce4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1932 0ce8 1B6B     		ldr	r3, [r3, #48]
 1933 0cea D31A     		subs	r3, r2, r3
 1934 0cec E218     		adds	r2, r4, r3
 1935 0cee 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1936 0cf2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1937 0cf6 5A63     		str	r2, [r3, #52]
 894:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 895:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
 896:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //ieee154e_vars.lastCapturedTime = capturedTime;
 897:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 898:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // decides whether to listen for an ACK
 899:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (packetfunctions_isBroadcastMulticast(&ieee154e_vars.dataToSend->l2_nextORpreviousHop)==TRUE)
 1938              		.loc 1 899 0
 1939 0cf8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1940 0cfc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1941 0d00 5B69     		ldr	r3, [r3, #20]
 1942 0d02 03F13803 		add	r3, r3, #56
 1943 0d06 1846     		mov	r0, r3
 1944 0d08 FFF7FEFF 		bl	packetfunctions_isBroadcastMulticast
 1945 0d0c 0346     		mov	r3, r0
 1946 0d0e 002B     		cmp	r3, #0
 1947 0d10 03D0     		beq	.L112
 900:openstack/02a-MAClow/IEEE802154Ecsl.c ****       listenForAck = FALSE;
 1948              		.loc 1 900 0
 1949 0d12 4FF00003 		mov	r3, #0
 1950 0d16 FB73     		strb	r3, [r7, #15]
 1951 0d18 02E0     		b	.L113
 1952              	.L112:
 901:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
 902:openstack/02a-MAClow/IEEE802154Ecsl.c ****       listenForAck = TRUE;
 1953              		.loc 1 902 0
 1954 0d1a 4FF00103 		mov	r3, #1
 1955 0d1e FB73     		strb	r3, [r7, #15]
 1956              	.L113:
 903:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 904:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 905:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // CSL: TEST CODE
 906:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // toggle orange led to indicate TX.
 907:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if((ieee154e_vars.dataToSend->l2_frameType == IEEE154_TYPE_DATA) &&
 1957              		.loc 1 907 0
 1958 0d20 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1959 0d24 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1960 0d28 5B69     		ldr	r3, [r3, #20]
 1961 0d2a 93F84930 		ldrb	r3, [r3, #73]	@ zero_extendqisi2
 1962 0d2e 012B     		cmp	r3, #1
 1963 0d30 15D1     		bne	.L114
 908:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  (ieee154e_vars.dataToSend->owner == COMPONENT_SIXTOP_TO_IEEE802154E) &&
 1964              		.loc 1 908 0 discriminator 1
 1965 0d32 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1966 0d36 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1967 0d3a 5B69     		ldr	r3, [r3, #20]
 1968 0d3c 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 907:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if((ieee154e_vars.dataToSend->l2_frameType == IEEE154_TYPE_DATA) &&
 1969              		.loc 1 907 0 discriminator 1
 1970 0d3e 0A2B     		cmp	r3, #10
 1971 0d40 0DD1     		bne	.L114
 909:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  (ieee154e_vars.dataToSend->cslFlag == 123)) {
 1972              		.loc 1 909 0
 1973 0d42 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1974 0d46 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1975 0d4a 5B69     		ldr	r3, [r3, #20]
 1976 0d4c 93F8ED30 		ldrb	r3, [r3, #237]	@ zero_extendqisi2
 908:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  (ieee154e_vars.dataToSend->owner == COMPONENT_SIXTOP_TO_IEEE802154E) &&
 1977              		.loc 1 908 0
 1978 0d50 7B2B     		cmp	r3, #123
 1979 0d52 04D1     		bne	.L114
 910:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	 leds_sync_blink();
 1980              		.loc 1 910 0
 1981 0d54 FFF7FEFF 		bl	leds_sync_blink
 911:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	 listenForAck = FALSE;
 1982              		.loc 1 911 0
 1983 0d58 4FF00003 		mov	r3, #0
 1984 0d5c FB73     		strb	r3, [r7, #15]
 1985              	.L114:
 912:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 913:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // END TEST CODE
 914:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 915:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 916:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (listenForAck==TRUE) {
 1986              		.loc 1 916 0
 1987 0d5e FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 1988 0d60 002B     		cmp	r3, #0
 1989 0d62 0AD0     		beq	.L115
 917:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // arm tt5
 918:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radiotimer_schedule(DURATION_tt5);
 1990              		.loc 1 918 0
 1991 0d64 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1992 0d68 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1993 0d6c 5B6A     		ldr	r3, [r3, #36]
 1994 0d6e 03F17D03 		add	r3, r3, #125
 1995 0d72 1846     		mov	r0, r3
 1996 0d74 FFF7FEFF 		bl	radiotimer_schedule
 1997 0d78 09E0     		b	.L111
 1998              	.L115:
 919:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
 920:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // indicate succesful Tx to schedule to keep statistics
 921:openstack/02a-MAClow/IEEE802154Ecsl.c ****       schedule_indicateTx(&ieee154e_vars.asn,TRUE);
 1999              		.loc 1 921 0
 2000 0d7a 40F20000 		movw	r0, #:lower16:ieee154e_vars
 2001 0d7e C0F20000 		movt	r0, #:upper16:ieee154e_vars
 2002 0d82 4FF00101 		mov	r1, #1
 2003 0d86 FFF7FEFF 		bl	schedule_indicateTx
 922:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 923:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // CSL TEST CODE (comment notification)
 924:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // indicate to upper later the packet was sent successfully
 925:openstack/02a-MAClow/IEEE802154Ecsl.c ****       //notif_sendDone(ieee154e_vars.dataToSend,E_SUCCESS);
 926:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 927:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset local variable
 928:openstack/02a-MAClow/IEEE802154Ecsl.c ****       //ieee154e_vars.dataToSend = NULL;
 929:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // END TEST CODE
 930:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 931:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // abort
 932:openstack/02a-MAClow/IEEE802154Ecsl.c ****       endOps();
 2004              		.loc 1 932 0
 2005 0d8a FFF7FEFF 		bl	endOps
 2006              	.L111:
 933:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 934:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2007              		.loc 1 934 0
 2008 0d8e 07F11407 		add	r7, r7, #20
 2009 0d92 BD46     		mov	sp, r7
 2010 0d94 90BD     		pop	{r4, r7, pc}
 2011              		.cfi_endproc
 2012              	.LFE22:
 2014 0d96 00BF     		.align	2
 2015              		.global	activity_csl_data_ti6
 2016              		.thumb
 2017              		.thumb_func
 2019              	activity_csl_data_ti6:
 2020              	.LFB23:
 935:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 936:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 937:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti6].
 938:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 939:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 940:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The functionality is to prepare the radio for ACK reception.
 941:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 942:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti6() {
 2021              		.loc 1 942 0
 2022              		.cfi_startproc
 2023              		@ args = 0, pretend = 0, frame = 0
 2024              		@ frame_needed = 1, uses_anonymous_args = 0
 2025 0d98 80B5     		push	{r7, lr}
 2026              	.LCFI55:
 2027              		.cfi_def_cfa_offset 8
 2028              		.cfi_offset 7, -8
 2029              		.cfi_offset 14, -4
 2030 0d9a 00AF     		add	r7, sp, #0
 2031              	.LCFI56:
 2032              		.cfi_def_cfa_register 7
 943:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 944:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXACKPREPARE);
 2033              		.loc 1 944 0
 2034 0d9c 4FF02500 		mov	r0, #37
 2035 0da0 FFF7FEFF 		bl	changeState
 945:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 946:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // enable the radio in Rx mode. The radio is not actively listening yet.
 947:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rxEnable();
 2036              		.loc 1 947 0
 2037 0da4 FFF7FEFF 		bl	radio_rxEnable
 948:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 949:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //caputre init of radio for duty cycle calculation
 950:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnInit=radio_getTimerValue();
 2038              		.loc 1 950 0
 2039 0da8 FFF7FEFF 		bl	radio_getTimerValue
 2040 0dac 0246     		mov	r2, r0
 2041 0dae 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2042 0db2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2043 0db6 1A63     		str	r2, [r3, #48]
 951:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnThisSlot=TRUE;
 2044              		.loc 1 951 0
 2045 0db8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2046 0dbc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2047 0dc0 4FF00102 		mov	r2, #1
 2048 0dc4 83F83820 		strb	r2, [r3, #56]
 952:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 953:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt6
 954:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt6);
 2049              		.loc 1 954 0
 2050 0dc8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2051 0dcc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2052 0dd0 5B6A     		ldr	r3, [r3, #36]
 2053 0dd2 03F18703 		add	r3, r3, #135
 2054 0dd6 1846     		mov	r0, r3
 2055 0dd8 FFF7FEFF 		bl	radiotimer_schedule
 955:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 956:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 957:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXACKREADY);
 2056              		.loc 1 957 0
 2057 0ddc 4FF02600 		mov	r0, #38
 2058 0de0 FFF7FEFF 		bl	changeState
 958:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2059              		.loc 1 958 0
 2060 0de4 80BD     		pop	{r7, pc}
 2061              		.cfi_endproc
 2062              	.LFE23:
 2064 0de6 00BF     		.align	2
 2065              		.global	activity_csl_data_tie4
 2066              		.thumb
 2067              		.thumb_func
 2069              	activity_csl_data_tie4:
 2070              	.LFB24:
 959:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 960:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 961:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data tie4].
 962:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 963:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 964:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The functionality is to prepare the radio for ACK sending.
 965:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 966:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_tie4() {
 2071              		.loc 1 966 0
 2072              		.cfi_startproc
 2073              		@ args = 0, pretend = 0, frame = 0
 2074              		@ frame_needed = 1, uses_anonymous_args = 0
 2075 0de8 80B5     		push	{r7, lr}
 2076              	.LCFI57:
 2077              		.cfi_def_cfa_offset 8
 2078              		.cfi_offset 7, -8
 2079              		.cfi_offset 14, -4
 2080 0dea 00AF     		add	r7, sp, #0
 2081              	.LCFI58:
 2082              		.cfi_def_cfa_register 7
 967:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
 968:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXACKPREPARE_OVERFLOWS,
 969:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_vars.slo
 2083              		.loc 1 969 0
 2084 0dec 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2085 0df0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2086 0df4 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 968:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXACKPREPARE_OVERFLOWS,
 2087              		.loc 1 968 0
 2088 0df6 1A46     		mov	r2, r3
 2089 0df8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2090 0dfc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2091 0e00 DB88     		ldrh	r3, [r3, #6]
 2092 0e02 4FF00900 		mov	r0, #9
 2093 0e06 4FF02301 		mov	r1, #35
 2094 0e0a FFF7FEFF 		bl	openserial_printError
 970:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
 971:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 2095              		.loc 1 971 0
 2096 0e0e FFF7FEFF 		bl	endOps
 972:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2097              		.loc 1 972 0
 2098 0e12 80BD     		pop	{r7, pc}
 2099              		.cfi_endproc
 2100              	.LFE24:
 2102              		.align	2
 2103              		.global	activity_csl_data_ti7
 2104              		.thumb
 2105              		.thumb_func
 2107              	activity_csl_data_ti7:
 2108              	.LFB25:
 973:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 974:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 975:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti7].
 976:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 977:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 978:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The radio is configured and this interrupt gives it the "go" signal to start listening.
 979:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 980:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti7() {
 2109              		.loc 1 980 0
 2110              		.cfi_startproc
 2111              		@ args = 0, pretend = 0, frame = 0
 2112              		@ frame_needed = 1, uses_anonymous_args = 0
 2113 0e14 80B5     		push	{r7, lr}
 2114              	.LCFI59:
 2115              		.cfi_def_cfa_offset 8
 2116              		.cfi_offset 7, -8
 2117              		.cfi_offset 14, -4
 2118 0e16 00AF     		add	r7, sp, #0
 2119              	.LCFI60:
 2120              		.cfi_def_cfa_register 7
 981:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 982:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXACKLISTEN);
 2121              		.loc 1 982 0
 2122 0e18 4FF02700 		mov	r0, #39
 2123 0e1c FFF7FEFF 		bl	changeState
 983:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 984:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // start listening
 985:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rxNow();
 2124              		.loc 1 985 0
 2125 0e20 FFF7FEFF 		bl	radio_rxNow
 986:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 987:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt7
 988:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt7);
 2126              		.loc 1 988 0
 2127 0e24 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2128 0e28 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2129 0e2c 5B6A     		ldr	r3, [r3, #36]
 2130 0e2e 03F1A703 		add	r3, r3, #167
 2131 0e32 1846     		mov	r0, r3
 2132 0e34 FFF7FEFF 		bl	radiotimer_schedule
 989:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2133              		.loc 1 989 0
 2134 0e38 80BD     		pop	{r7, pc}
 2135              		.cfi_endproc
 2136              	.LFE25:
 2138 0e3a 00BF     		.align	2
 2139              		.global	activity_csl_data_tie5
 2140              		.thumb
 2141              		.thumb_func
 2143              	activity_csl_data_tie5:
 2144              	.LFB26:
 990:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 991:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 992:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data tie5].
 993:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 994:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 995:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to notify upper level, updating the number of remaining retries of the packe
 996:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 997:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_tie5() {
 2145              		.loc 1 997 0
 2146              		.cfi_startproc
 2147              		@ args = 0, pretend = 0, frame = 0
 2148              		@ frame_needed = 1, uses_anonymous_args = 0
 2149 0e3c 80B5     		push	{r7, lr}
 2150              	.LCFI61:
 2151              		.cfi_def_cfa_offset 8
 2152              		.cfi_offset 7, -8
 2153              		.cfi_offset 14, -4
 2154 0e3e 00AF     		add	r7, sp, #0
 2155              	.LCFI62:
 2156              		.cfi_def_cfa_register 7
 998:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // indicate transmit failed to schedule to keep stats
 999:openstack/02a-MAClow/IEEE802154Ecsl.c ****    schedule_indicateTx(&ieee154e_vars.asn,FALSE);
 2157              		.loc 1 999 0
 2158 0e40 40F20000 		movw	r0, #:lower16:ieee154e_vars
 2159 0e44 C0F20000 		movt	r0, #:upper16:ieee154e_vars
 2160 0e48 4FF00001 		mov	r1, #0
 2161 0e4c FFF7FEFF 		bl	schedule_indicateTx
1000:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1001:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // decrement transmits left counter
1002:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.dataToSend->l2_retriesLeft--;
 2162              		.loc 1 1002 0
 2163 0e50 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2164 0e54 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2165 0e58 5B69     		ldr	r3, [r3, #20]
 2166 0e5a 93F84B20 		ldrb	r2, [r3, #75]	@ zero_extendqisi2
 2167 0e5e 02F1FF32 		add	r2, r2, #-1
 2168 0e62 D2B2     		uxtb	r2, r2
 2169 0e64 83F84B20 		strb	r2, [r3, #75]
1003:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1004:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.dataToSend->l2_retriesLeft==0) {
 2170              		.loc 1 1004 0
 2171 0e68 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2172 0e6c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2173 0e70 5B69     		ldr	r3, [r3, #20]
 2174 0e72 93F84B30 		ldrb	r3, [r3, #75]	@ zero_extendqisi2
 2175 0e76 002B     		cmp	r3, #0
 2176 0e78 07D0     		beq	.L121
1005:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // indicate tx fail if no more retries left
1006:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // CSL testing commented
1007:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // notif_sendDone(ieee154e_vars.dataToSend,E_FAIL);
1008:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
1009:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // return packet to the virtual COMPONENT_SIXTOP_TO_IEEE802154E component
1010:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataToSend->owner = COMPONENT_SIXTOP_TO_IEEE802154E;
 2177              		.loc 1 1010 0
 2178 0e7a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2179 0e7e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2180 0e82 5B69     		ldr	r3, [r3, #20]
 2181 0e84 4FF00A02 		mov	r2, #10
 2182 0e88 5A70     		strb	r2, [r3, #1]
 2183              	.L121:
1011:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
1012:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1013:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // reset local variable
1014:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.dataToSend = NULL;
 2184              		.loc 1 1014 0
 2185 0e8a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2186 0e8e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2187 0e92 4FF00002 		mov	r2, #0
 2188 0e96 5A61     		str	r2, [r3, #20]
1015:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1016:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1017:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 2189              		.loc 1 1017 0
 2190 0e98 FFF7FEFF 		bl	endOps
1018:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2191              		.loc 1 1018 0
 2192 0e9c 80BD     		pop	{r7, pc}
 2193              		.cfi_endproc
 2194              	.LFE26:
 2196 0e9e 00BF     		.align	2
 2197              		.global	activity_csl_data_ti8
 2198              		.thumb
 2199              		.thumb_func
 2201              	activity_csl_data_ti8:
 2202              	.LFB27:
1019:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1020:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1021:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti8].
1022:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1023:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_startOfFrame" function when a start of frame ev
1024:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change the state, cancel #tt7 and arm #tt8 (max time to receive the ack p
1025:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1026:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti8(PORT_RADIOTIMER_WIDTH capturedTime) {
 2203              		.loc 1 1026 0
 2204              		.cfi_startproc
 2205              		@ args = 0, pretend = 0, frame = 8
 2206              		@ frame_needed = 1, uses_anonymous_args = 0
 2207 0ea0 80B5     		push	{r7, lr}
 2208              	.LCFI63:
 2209              		.cfi_def_cfa_offset 8
 2210              		.cfi_offset 7, -8
 2211              		.cfi_offset 14, -4
 2212 0ea2 82B0     		sub	sp, sp, #8
 2213              	.LCFI64:
 2214              		.cfi_def_cfa_offset 16
 2215 0ea4 00AF     		add	r7, sp, #0
 2216              	.LCFI65:
 2217              		.cfi_def_cfa_register 7
 2218 0ea6 7860     		str	r0, [r7, #4]
1027:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1028:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXACK);
 2219              		.loc 1 1028 0
 2220 0ea8 4FF02800 		mov	r0, #40
 2221 0eac FFF7FEFF 		bl	changeState
1029:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1030:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel tt7
1031:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 2222              		.loc 1 1031 0
 2223 0eb0 FFF7FEFF 		bl	radiotimer_cancel
1032:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1033:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
1034:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //ieee154e_vars.lastCapturedTime = capturedTime;
1035:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1036:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt8
1037:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt8);
 2224              		.loc 1 1037 0
 2225 0eb4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2226 0eb8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2227 0ebc 5B6A     		ldr	r3, [r3, #36]
 2228 0ebe 03F16203 		add	r3, r3, #98
 2229 0ec2 1846     		mov	r0, r3
 2230 0ec4 FFF7FEFF 		bl	radiotimer_schedule
1038:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2231              		.loc 1 1038 0
 2232 0ec8 07F10807 		add	r7, r7, #8
 2233 0ecc BD46     		mov	sp, r7
 2234 0ece 80BD     		pop	{r7, pc}
 2235              		.cfi_endproc
 2236              	.LFE27:
 2238              		.align	2
 2239              		.global	activity_csl_data_tie6
 2240              		.thumb
 2241              		.thumb_func
 2243              	activity_csl_data_tie6:
 2244              	.LFB28:
1039:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1040:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1041:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data tie6].
1042:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1043:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1044:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to finish and clean registers.
1045:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1046:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_tie6() {
 2245              		.loc 1 1046 0
 2246              		.cfi_startproc
 2247              		@ args = 0, pretend = 0, frame = 0
 2248              		@ frame_needed = 1, uses_anonymous_args = 0
 2249 0ed0 80B5     		push	{r7, lr}
 2250              	.LCFI66:
 2251              		.cfi_def_cfa_offset 8
 2252              		.cfi_offset 7, -8
 2253              		.cfi_offset 14, -4
 2254 0ed2 00AF     		add	r7, sp, #0
 2255              	.LCFI67:
 2256              		.cfi_def_cfa_register 7
1047:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1048:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 2257              		.loc 1 1048 0
 2258 0ed4 FFF7FEFF 		bl	endOps
1049:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2259              		.loc 1 1049 0
 2260 0ed8 80BD     		pop	{r7, pc}
 2261              		.cfi_endproc
 2262              	.LFE28:
 2264 0eda 00BF     		.align	2
 2265              		.global	activity_csl_data_ti9
 2266              		.thumb
 2267              		.thumb_func
 2269              	activity_csl_data_ti9:
 2270              	.LFB29:
1050:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1051:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1052:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1053:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti9].
1054:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1055:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_endOfFrame" function when a end of frame event 
1056:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change the state, cancel #tt8, analyze ack packet and notify upper layer.
1057:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1058:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti9(PORT_RADIOTIMER_WIDTH capturedTime) {
 2271              		.loc 1 1058 0
 2272              		.cfi_startproc
 2273              		@ args = 0, pretend = 0, frame = 80
 2274              		@ frame_needed = 1, uses_anonymous_args = 0
 2275 0edc B0B5     		push	{r4, r5, r7, lr}
 2276              	.LCFI68:
 2277              		.cfi_def_cfa_offset 16
 2278              		.cfi_offset 4, -16
 2279              		.cfi_offset 5, -12
 2280              		.cfi_offset 7, -8
 2281              		.cfi_offset 14, -4
 2282 0ede 96B0     		sub	sp, sp, #88
 2283              	.LCFI69:
 2284              		.cfi_def_cfa_offset 104
 2285 0ee0 02AF     		add	r7, sp, #8
 2286              	.LCFI70:
 2287              		.cfi_def_cfa 7, 96
 2288 0ee2 7860     		str	r0, [r7, #4]
1059:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802154_header_iht     ieee802514_header;
1060:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint16_t                  lenIE;
1061:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1062:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1063:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXPROC);
 2289              		.loc 1 1063 0
 2290 0ee4 4FF02900 		mov	r0, #41
 2291 0ee8 FFF7FEFF 		bl	changeState
1064:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1065:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel tt8
1066:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 2292              		.loc 1 1066 0
 2293 0eec FFF7FEFF 		bl	radiotimer_cancel
1067:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1068:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // turn off the radio
1069:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rfOff();
 2294              		.loc 1 1069 0
 2295 0ef0 FFF7FEFF 		bl	radio_rfOff
1070:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //compute tics radio on.
1071:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnTics+=(radio_getTimerValue()-ieee154e_vars.radioOnInit);
 2296              		.loc 1 1071 0
 2297 0ef4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2298 0ef8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2299 0efc 5C6B     		ldr	r4, [r3, #52]
 2300 0efe FFF7FEFF 		bl	radio_getTimerValue
 2301 0f02 0246     		mov	r2, r0
 2302 0f04 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2303 0f08 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2304 0f0c 1B6B     		ldr	r3, [r3, #48]
 2305 0f0e D31A     		subs	r3, r2, r3
 2306 0f10 E218     		adds	r2, r4, r3
 2307 0f12 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2308 0f16 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2309 0f1a 5A63     		str	r2, [r3, #52]
1072:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1073:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
1074:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //ieee154e_vars.lastCapturedTime = capturedTime;
1075:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1076:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // get a buffer to put the (received) ACK in
1077:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackReceived = openqueue_getFreePacketBuffer(COMPONENT_IEEE802154E);
 2310              		.loc 1 1077 0
 2311 0f1c 4FF00900 		mov	r0, #9
 2312 0f20 FFF7FEFF 		bl	openqueue_getFreePacketBuffer
 2313 0f24 0246     		mov	r2, r0
 2314 0f26 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2315 0f2a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2316 0f2e 1A62     		str	r2, [r3, #32]
1078:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.ackReceived==NULL) {
 2317              		.loc 1 1078 0
 2318 0f30 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2319 0f34 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2320 0f38 1B6A     		ldr	r3, [r3, #32]
 2321 0f3a 002B     		cmp	r3, #0
 2322 0f3c 0CD1     		bne	.L125
1079:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // log the error
1080:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openserial_printError(COMPONENT_IEEE802154E,ERR_NO_FREE_PACKET_BUFFER,
 2323              		.loc 1 1080 0
 2324 0f3e 4FF00900 		mov	r0, #9
 2325 0f42 4FF02C01 		mov	r1, #44
 2326 0f46 4FF00002 		mov	r2, #0
 2327 0f4a 4FF00003 		mov	r3, #0
 2328 0f4e FFF7FEFF 		bl	openserial_printError
1081:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)0,
1082:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)0);
1083:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // abort
1084:openstack/02a-MAClow/IEEE802154Ecsl.c ****       endOps();
 2329              		.loc 1 1084 0
 2330 0f52 FFF7FEFF 		bl	endOps
 2331 0f56 15E1     		b	.L124
 2332              	.L125:
1085:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return;
1086:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
1087:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1088:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // declare ownership over that packet
1089:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackReceived->creator = COMPONENT_IEEE802154E;
 2333              		.loc 1 1089 0
 2334 0f58 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2335 0f5c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2336 0f60 1B6A     		ldr	r3, [r3, #32]
 2337 0f62 4FF00902 		mov	r2, #9
 2338 0f66 1A70     		strb	r2, [r3, #0]
1090:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackReceived->owner   = COMPONENT_IEEE802154E;
 2339              		.loc 1 1090 0
 2340 0f68 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2341 0f6c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2342 0f70 1B6A     		ldr	r3, [r3, #32]
 2343 0f72 4FF00902 		mov	r2, #9
 2344 0f76 5A70     		strb	r2, [r3, #1]
1091:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1092:openstack/02a-MAClow/IEEE802154Ecsl.c ****    /*
1093:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The do-while loop that follows is a little parsing trick.
1094:openstack/02a-MAClow/IEEE802154Ecsl.c ****    Because it contains a while(0) condition, it gets executed only once.
1095:openstack/02a-MAClow/IEEE802154Ecsl.c ****    Below the do-while loop is some code to cleans up the ack variable.
1096:openstack/02a-MAClow/IEEE802154Ecsl.c ****    Anywhere in the do-while loop, a break statement can be called to jump to
1097:openstack/02a-MAClow/IEEE802154Ecsl.c ****    the clean up code early. If the loop ends without a break, the received
1098:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packet was correct. If it got aborted early (through a break), the packet
1099:openstack/02a-MAClow/IEEE802154Ecsl.c ****    was faulty.
1100:openstack/02a-MAClow/IEEE802154Ecsl.c ****    */
1101:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1102:openstack/02a-MAClow/IEEE802154Ecsl.c ****    do { // this "loop" is only executed once
1103:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1104:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // retrieve the received ack frame from the radio's Rx buffer
1105:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.ackReceived->payload = &(ieee154e_vars.ackReceived->packet[FIRST_FRAME_BYTE]);
 2345              		.loc 1 1105 0
 2346 0f78 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2347 0f7c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2348 0f80 1A6A     		ldr	r2, [r3, #32]
 2349 0f82 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2350 0f86 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2351 0f8a 1B6A     		ldr	r3, [r3, #32]
 2352 0f8c 03F16C03 		add	r3, r3, #108
 2353 0f90 5360     		str	r3, [r2, #4]
1106:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.ackReceived->payload,
 2354              		.loc 1 1106 0
 2355 0f92 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2356 0f96 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2357 0f9a 1B6A     		ldr	r3, [r3, #32]
 2358 0f9c 5968     		ldr	r1, [r3, #4]
1107:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.ackReceived->length,
 2359              		.loc 1 1107 0
 2360 0f9e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2361 0fa2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2362 0fa6 1B6A     		ldr	r3, [r3, #32]
1106:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.ackReceived->payload,
 2363              		.loc 1 1106 0
 2364 0fa8 03F10802 		add	r2, r3, #8
1108:openstack/02a-MAClow/IEEE802154Ecsl.c ****                              sizeof(ieee154e_vars.ackReceived->packet),
1109:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.ackReceived->l1_rssi,
 2365              		.loc 1 1109 0
 2366 0fac 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2367 0fb0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2368 0fb4 1B6A     		ldr	r3, [r3, #32]
1106:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.ackReceived->payload,
 2369              		.loc 1 1106 0
 2370 0fb6 03F16804 		add	r4, r3, #104
1110:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.ackReceived->l1_lqi,
 2371              		.loc 1 1110 0
 2372 0fba 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2373 0fbe C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2374 0fc2 1B6A     		ldr	r3, [r3, #32]
1106:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.ackReceived->payload,
 2375              		.loc 1 1106 0
 2376 0fc4 03F16900 		add	r0, r3, #105
1111:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.ackReceived->l1_crc);
 2377              		.loc 1 1111 0
 2378 0fc8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2379 0fcc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2380 0fd0 1B6A     		ldr	r3, [r3, #32]
1106:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.ackReceived->payload,
 2381              		.loc 1 1106 0
 2382 0fd2 03F16A03 		add	r3, r3, #106
 2383 0fd6 0090     		str	r0, [sp, #0]
 2384 0fd8 0193     		str	r3, [sp, #4]
 2385 0fda 0846     		mov	r0, r1
 2386 0fdc 1146     		mov	r1, r2
 2387 0fde 4FF08202 		mov	r2, #130
 2388 0fe2 2346     		mov	r3, r4
 2389 0fe4 FFF7FEFF 		bl	radio_getReceivedFrame
1112:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1113:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // break if wrong length
1114:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.ackReceived->length<LENGTH_CRC || ieee154e_vars.ackReceived->length>LENGTH_
 2390              		.loc 1 1114 0
 2391 0fe8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2392 0fec C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2393 0ff0 1B6A     		ldr	r3, [r3, #32]
 2394 0ff2 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 2395 0ff4 012B     		cmp	r3, #1
 2396 0ff6 07D9     		bls	.L127
 2397              		.loc 1 1114 0 is_stmt 0 discriminator 1
 2398 0ff8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2399 0ffc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2400 1000 1B6A     		ldr	r3, [r3, #32]
 2401 1002 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 2402 1004 802B     		cmp	r3, #128
 2403 1006 0ED9     		bls	.L128
 2404              	.L127:
1115:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // break from the do-while loop and execute the clean-up code below
1116:openstack/02a-MAClow/IEEE802154Ecsl.c ****         openserial_printError(COMPONENT_IEEE802154E,ERR_INVALIDPACKETFROMRADIO,
1117:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)1,
1118:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             ieee154e_vars.ackReceived->length);
 2405              		.loc 1 1118 0 is_stmt 1
 2406 1008 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2407 100c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2408 1010 1B6A     		ldr	r3, [r3, #32]
 2409 1012 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
1116:openstack/02a-MAClow/IEEE802154Ecsl.c ****         openserial_printError(COMPONENT_IEEE802154E,ERR_INVALIDPACKETFROMRADIO,
 2410              		.loc 1 1116 0
 2411 1014 4FF00900 		mov	r0, #9
 2412 1018 4FF03701 		mov	r1, #55
 2413 101c 4FF00102 		mov	r2, #1
 2414 1020 FFF7FEFF 		bl	openserial_printError
1119:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1120:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 2415              		.loc 1 1120 0
 2416 1024 9DE0     		b	.L129
 2417              	.L128:
1121:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1122:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1123:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // toss CRC (2 last bytes)
1124:openstack/02a-MAClow/IEEE802154Ecsl.c ****       packetfunctions_tossFooter(   ieee154e_vars.ackReceived, LENGTH_CRC);
 2418              		.loc 1 1124 0
 2419 1026 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2420 102a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2421 102e 1B6A     		ldr	r3, [r3, #32]
 2422 1030 1846     		mov	r0, r3
 2423 1032 4FF00201 		mov	r1, #2
 2424 1036 FFF7FEFF 		bl	packetfunctions_tossFooter
1125:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1126:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // break if invalid CRC
1127:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.ackReceived->l1_crc==FALSE) {
 2425              		.loc 1 1127 0
 2426 103a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2427 103e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2428 1042 1B6A     		ldr	r3, [r3, #32]
 2429 1044 93F86A30 		ldrb	r3, [r3, #106]	@ zero_extendqisi2
 2430 1048 83F00103 		eor	r3, r3, #1
 2431 104c DBB2     		uxtb	r3, r3
 2432 104e 002B     		cmp	r3, #0
 2433 1050 7ED1     		bne	.L135
 2434              	.L130:
1128:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // break from the do-while loop and execute the clean-up code below
1129:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
1130:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1131:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1132:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // parse the IEEE802.15.4 header (RX ACK)
1133:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee802154_retrieveHeader(ieee154e_vars.ackReceived,&ieee802514_header);
 2435              		.loc 1 1133 0
 2436 1052 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2437 1056 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2438 105a 1A6A     		ldr	r2, [r3, #32]
 2439 105c 07F11003 		add	r3, r7, #16
 2440 1060 1046     		mov	r0, r2
 2441 1062 1946     		mov	r1, r3
 2442 1064 FFF7FEFF 		bl	ieee802154_retrieveHeader
1134:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1135:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // break if invalid IEEE802.15.4 header
1136:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee802514_header.valid==FALSE) {
 2443              		.loc 1 1136 0
 2444 1068 3B7C     		ldrb	r3, [r7, #16]	@ zero_extendqisi2
 2445 106a 83F00103 		eor	r3, r3, #1
 2446 106e DBB2     		uxtb	r3, r3
 2447 1070 002B     		cmp	r3, #0
 2448 1072 6FD1     		bne	.L136
 2449              	.L131:
1137:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // break from the do-while loop and execute the clean-up code below
1138:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
1139:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1140:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1141:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // store header details in packet buffer
1142:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.ackReceived->l2_frameType  = ieee802514_header.frameType;
 2450              		.loc 1 1142 0
 2451 1074 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2452 1078 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2453 107c 1B6A     		ldr	r3, [r3, #32]
 2454 107e BA7C     		ldrb	r2, [r7, #18]	@ zero_extendqisi2
 2455 1080 83F84920 		strb	r2, [r3, #73]
1143:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.ackReceived->l2_dsn        = ieee802514_header.dsn;
 2456              		.loc 1 1143 0
 2457 1084 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2458 1088 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2459 108c 1B6A     		ldr	r3, [r3, #32]
 2460 108e 7A7E     		ldrb	r2, [r7, #25]	@ zero_extendqisi2
 2461 1090 83F84A20 		strb	r2, [r3, #74]
1144:openstack/02a-MAClow/IEEE802154Ecsl.c ****       memcpy(&(ieee154e_vars.ackReceived->l2_nextORpreviousHop),&(ieee802514_header.src),sizeof(ope
 2462              		.loc 1 1144 0
 2463 1094 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2464 1098 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2465 109c 1B6A     		ldr	r3, [r3, #32]
 2466 109e 03F13803 		add	r3, r3, #56
 2467 10a2 1D46     		mov	r5, r3
 2468 10a4 07F13C04 		add	r4, r7, #60
 2469 10a8 0FCC     		ldmia	r4!, {r0, r1, r2, r3}
 2470 10aa 2860     		str	r0, [r5, #0]	@ unaligned
 2471 10ac 6960     		str	r1, [r5, #4]	@ unaligned
 2472 10ae AA60     		str	r2, [r5, #8]	@ unaligned
 2473 10b0 EB60     		str	r3, [r5, #12]	@ unaligned
 2474 10b2 2378     		ldrb	r3, [r4, #0]
 2475 10b4 2B74     		strb	r3, [r5, #16]
1145:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1146:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // toss the IEEE802.15.4 header
1147:openstack/02a-MAClow/IEEE802154Ecsl.c ****       packetfunctions_tossHeader(ieee154e_vars.ackReceived,ieee802514_header.headerLength);
 2476              		.loc 1 1147 0
 2477 10b6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2478 10ba C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2479 10be 1A6A     		ldr	r2, [r3, #32]
 2480 10c0 7B7C     		ldrb	r3, [r7, #17]	@ zero_extendqisi2
 2481 10c2 1046     		mov	r0, r2
 2482 10c4 1946     		mov	r1, r3
 2483 10c6 FFF7FEFF 		bl	packetfunctions_tossHeader
1148:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1149:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // break if invalid ACK
1150:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (isValidAck(&ieee802514_header,ieee154e_vars.dataToSend)==FALSE) {
 2484              		.loc 1 1150 0
 2485 10ca 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2486 10ce C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2487 10d2 5B69     		ldr	r3, [r3, #20]
 2488 10d4 07F11002 		add	r2, r7, #16
 2489 10d8 1046     		mov	r0, r2
 2490 10da 1946     		mov	r1, r3
 2491 10dc FFF7FEFF 		bl	isValidAck
 2492 10e0 0346     		mov	r3, r0
 2493 10e2 83F00103 		eor	r3, r3, #1
 2494 10e6 DBB2     		uxtb	r3, r3
 2495 10e8 002B     		cmp	r3, #0
 2496 10ea 35D1     		bne	.L137
 2497              	.L132:
1151:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // break from the do-while loop and execute the clean-up code below
1152:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
1153:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1154:openstack/02a-MAClow/IEEE802154Ecsl.c ****       //hanlde IEs --xv poipoi
1155:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee802514_header.ieListPresent==FALSE){
 2498              		.loc 1 1155 0
 2499 10ec FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 2500 10ee 83F00103 		eor	r3, r3, #1
 2501 10f2 DBB2     		uxtb	r3, r3
 2502 10f4 002B     		cmp	r3, #0
 2503 10f6 31D1     		bne	.L138
 2504              	.L133:
1156:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break; //ack should contain IEs.
1157:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1158:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1159:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_processIEs(ieee154e_vars.ackReceived,&lenIE)==FALSE){
 2505              		.loc 1 1159 0
 2506 10f8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2507 10fc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2508 1100 1A6A     		ldr	r2, [r3, #32]
 2509 1102 07F10E03 		add	r3, r7, #14
 2510 1106 1046     		mov	r0, r2
 2511 1108 1946     		mov	r1, r3
 2512 110a FFF7FEFF 		bl	ieee154e_processIEs
 2513 110e 0346     		mov	r3, r0
 2514 1110 83F00103 		eor	r3, r3, #1
 2515 1114 DBB2     		uxtb	r3, r3
 2516 1116 002B     		cmp	r3, #0
 2517 1118 22D1     		bne	.L139
 2518              	.L134:
1160:openstack/02a-MAClow/IEEE802154Ecsl.c ****         // invalid IEs in ACK
1161:openstack/02a-MAClow/IEEE802154Ecsl.c ****         break;
1162:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1163:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1164:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // toss the IEs
1165:openstack/02a-MAClow/IEEE802154Ecsl.c ****       packetfunctions_tossHeader(ieee154e_vars.ackReceived,lenIE);
 2519              		.loc 1 1165 0
 2520 111a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2521 111e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2522 1122 1A6A     		ldr	r2, [r3, #32]
 2523 1124 FB89     		ldrh	r3, [r7, #14]
 2524 1126 DBB2     		uxtb	r3, r3
 2525 1128 1046     		mov	r0, r2
 2526 112a 1946     		mov	r1, r3
 2527 112c FFF7FEFF 		bl	packetfunctions_tossHeader
1166:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1167:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // inform schedule of successful transmission
1168:openstack/02a-MAClow/IEEE802154Ecsl.c ****       schedule_indicateTx(&ieee154e_vars.asn,TRUE);
 2528              		.loc 1 1168 0
 2529 1130 40F20000 		movw	r0, #:lower16:ieee154e_vars
 2530 1134 C0F20000 		movt	r0, #:upper16:ieee154e_vars
 2531 1138 4FF00101 		mov	r1, #1
 2532 113c FFF7FEFF 		bl	schedule_indicateTx
1169:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1170:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // inform upper layer
1171:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // CSL testing commented
1172:openstack/02a-MAClow/IEEE802154Ecsl.c ****       //notif_sendDone(ieee154e_vars.dataToSend,E_SUCCESS);
1173:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataToSend = NULL;
 2533              		.loc 1 1173 0
 2534 1140 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2535 1144 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2536 1148 4FF00002 		mov	r2, #0
 2537 114c 5A61     		str	r2, [r3, #20]
 2538 114e 08E0     		b	.L129
 2539              	.L135:
1129:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 2540              		.loc 1 1129 0
 2541 1150 00BF     		nop
 2542 1152 06E0     		b	.L129
 2543              	.L136:
1138:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 2544              		.loc 1 1138 0
 2545 1154 00BF     		nop
 2546 1156 04E0     		b	.L129
 2547              	.L137:
1152:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 2548              		.loc 1 1152 0
 2549 1158 00BF     		nop
 2550 115a 02E0     		b	.L129
 2551              	.L138:
1156:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break; //ack should contain IEs.
 2552              		.loc 1 1156 0
 2553 115c 00BF     		nop
 2554 115e 00E0     		b	.L129
 2555              	.L139:
1161:openstack/02a-MAClow/IEEE802154Ecsl.c ****         break;
 2556              		.loc 1 1161 0
 2557 1160 00BF     		nop
 2558              	.L129:
1174:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1175:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // in any case, execute the clean-up code below (processing of ACK done)
1176:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } while (0);
1177:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1178:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // free the received ack so corresponding RAM memory can be recycled
1179:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openqueue_freePacketBuffer(ieee154e_vars.ackReceived);
 2559              		.loc 1 1179 0
 2560 1162 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2561 1166 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2562 116a 1B6A     		ldr	r3, [r3, #32]
 2563 116c 1846     		mov	r0, r3
 2564 116e FFF7FEFF 		bl	openqueue_freePacketBuffer
1180:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1181:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clear local variable
1182:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackReceived = NULL;
 2565              		.loc 1 1182 0
 2566 1172 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2567 1176 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2568 117a 4FF00002 		mov	r2, #0
 2569 117e 1A62     		str	r2, [r3, #32]
1183:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1184:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // official end of Tx
1185:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 2570              		.loc 1 1185 0
 2571 1180 FFF7FEFF 		bl	endOps
 2572              	.L124:
1186:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2573              		.loc 1 1186 0
 2574 1184 07F15007 		add	r7, r7, #80
 2575 1188 BD46     		mov	sp, r7
 2576 118a B0BD     		pop	{r4, r5, r7, pc}
 2577              		.cfi_endproc
 2578              	.LFE29:
 2580              		.align	2
 2581              		.global	activity_csl_wakeup_ri1
 2582              		.thumb
 2583              		.thumb_func
 2585              	activity_csl_wakeup_ri1:
 2586              	.LFB30:
1187:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1188:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
1189:openstack/02a-MAClow/IEEE802154Ecsl.c **** //========================== CSL RX MODE ===============================
1190:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
1191:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1192:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1193:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1194:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [wake-up ri1].
1195:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1196:openstack/02a-MAClow/IEEE802154Ecsl.c ****  This method is invoked in ISR-mode from "isr_ieee154ecsl_newChannelSample" function when a new CSL
1197:openstack/02a-MAClow/IEEE802154Ecsl.c ****  
1198:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \note The FSM state should be S_SLEEP (initial state), raising an error in otherwise.
1199:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1200:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ri1() { // Activity for stage [ri1] on CSL RX Sampling.
 2587              		.loc 1 1200 0
 2588              		.cfi_startproc
 2589              		@ args = 0, pretend = 0, frame = 0
 2590              		@ frame_needed = 1, uses_anonymous_args = 0
 2591 118c 80B5     		push	{r7, lr}
 2592              	.LCFI71:
 2593              		.cfi_def_cfa_offset 8
 2594              		.cfi_offset 7, -8
 2595              		.cfi_offset 14, -4
 2596 118e 00AF     		add	r7, sp, #0
 2597              	.LCFI72:
 2598              		.cfi_def_cfa_register 7
1201:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1202:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // if the previous sample took too long or the state is incorrect, we will not be in the right 
1203:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // we register an error indicating the number of CSL sample where the problem have been detecte
1204:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   if (ieee154e_vars.state!=S_SLEEP) {
 2599              		.loc 1 1204 0
 2600 1190 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2601 1194 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2602 1198 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 2603 119a 002B     		cmp	r3, #0
 2604 119c 14D0     		beq	.L141
1205:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  // log the error
1206:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_START_CSL_SAMPLING,
1207:openstack/02a-MAClow/IEEE802154Ecsl.c **** 								(errorparameter_t)ieee154e_vars.state,
 2605              		.loc 1 1207 0
 2606 119e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2607 11a2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2608 11a6 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1206:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_START_CSL_SAMPLING,
 2609              		.loc 1 1206 0
 2610 11a8 1A46     		mov	r2, r3
1208:openstack/02a-MAClow/IEEE802154Ecsl.c **** 								(errorparameter_t)ieee154e_dbg.num_cslSamples);
 2611              		.loc 1 1208 0
 2612 11aa 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 2613 11ae C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 2614 11b2 1B69     		ldr	r3, [r3, #16]
1206:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_START_CSL_SAMPLING,
 2615              		.loc 1 1206 0
 2616 11b4 9BB2     		uxth	r3, r3
 2617 11b6 4FF00900 		mov	r0, #9
 2618 11ba 4FF03A01 		mov	r1, #58
 2619 11be FFF7FEFF 		bl	openserial_printError
1209:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1210:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  // Abort in case of error. The signature of the function has been changed (instead of endSlot()
1211:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  // functionality. However, this function is equal for CSL and not-CSL.
1212:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  endOps();
 2620              		.loc 1 1212 0
 2621 11c2 FFF7FEFF 		bl	endOps
1213:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  return;
 2622              		.loc 1 1213 0
 2623 11c6 17E0     		b	.L140
 2624              	.L141:
1214:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
1215:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1216:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // stop using serial
1217:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   openserial_stop();
 2625              		.loc 1 1217 0
 2626 11c8 FFF7FEFF 		bl	openserial_stop
1218:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1219:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // change state --> Next State will be S_CSLRXWAKEUPOFFSET in order to prepare for CSL Rx wake-
1220:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   changeState(S_CSLRXWAKEUPOFFSET);
 2627              		.loc 1 1220 0
 2628 11cc 4FF02A00 		mov	r0, #42
 2629 11d0 FFF7FEFF 		bl	changeState
1221:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1222:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // update CSL Mode to RX in order to avoid problems in FSM.
1223:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   ieee154e_vars.cslMode = CSL_RX_MODE;
 2630              		.loc 1 1223 0
 2631 11d4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2632 11d8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2633 11dc 4FF00102 		mov	r2, #1
 2634 11e0 83F84520 		strb	r2, [r3, #69]
1224:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1225:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // arm rt1
1226:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   radiotimer_schedule(DURATION_rt1);
 2635              		.loc 1 1226 0
 2636 11e4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2637 11e8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2638 11ec 5B6A     		ldr	r3, [r3, #36]
 2639 11ee 03F13703 		add	r3, r3, #55
 2640 11f2 1846     		mov	r0, r3
 2641 11f4 FFF7FEFF 		bl	radiotimer_schedule
 2642              	.L140:
1227:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1228:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2643              		.loc 1 1228 0
 2644 11f8 80BD     		pop	{r7, pc}
 2645              		.cfi_endproc
 2646              	.LFE30:
 2648 11fa 00BF     		.align	2
 2649              		.global	activity_csl_wakeup_ri2
 2650              		.thumb
 2651              		.thumb_func
 2653              	activity_csl_wakeup_ri2:
 2654              	.LFB31:
1229:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1230:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1231:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1232:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [wake-up ri2].
1233:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1234:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1235:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to prepare the radio for receiving packets.
1236:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1237:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ri2() { // Activity for stage [ri2] on CSL RX Sampling.
 2655              		.loc 1 1237 0
 2656              		.cfi_startproc
 2657              		@ args = 0, pretend = 0, frame = 0
 2658              		@ frame_needed = 1, uses_anonymous_args = 0
 2659 11fc 80B5     		push	{r7, lr}
 2660              	.LCFI73:
 2661              		.cfi_def_cfa_offset 8
 2662              		.cfi_offset 7, -8
 2663              		.cfi_offset 14, -4
 2664 11fe 00AF     		add	r7, sp, #0
 2665              	.LCFI74:
 2666              		.cfi_def_cfa_register 7
1238:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1239:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXWAKEUPPREPARE);
 2667              		.loc 1 1239 0
 2668 1200 4FF02B00 		mov	r0, #43
 2669 1204 FFF7FEFF 		bl	changeState
1240:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1241:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // We use always the same frequency so it is not necessary to change it on radio.
1242:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Enable the radio in Rx mode. The radio does not actively listen yet.
1243:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rxEnable();
 2670              		.loc 1 1243 0
 2671 1208 FFF7FEFF 		bl	radio_rxEnable
1244:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnInit=radio_getTimerValue();
 2672              		.loc 1 1244 0
 2673 120c FFF7FEFF 		bl	radio_getTimerValue
 2674 1210 0246     		mov	r2, r0
 2675 1212 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2676 1216 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2677 121a 1A63     		str	r2, [r3, #48]
1245:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnThisSlot=TRUE;
 2678              		.loc 1 1245 0
 2679 121c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2680 1220 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2681 1224 4FF00102 		mov	r2, #1
 2682 1228 83F83820 		strb	r2, [r3, #56]
1246:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1247:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt2
1248:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt2);
 2683              		.loc 1 1248 0
 2684 122c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2685 1230 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2686 1234 5B6A     		ldr	r3, [r3, #36]
 2687 1236 03F15803 		add	r3, r3, #88
 2688 123a 1846     		mov	r0, r3
 2689 123c FFF7FEFF 		bl	radiotimer_schedule
1249:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1250:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Change state.
1251:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // If this action is not performed before rt2 has expired, we need to manage the error in activi
1252:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // prepare has exceeded the maximum allowed time (duration_rt2).
1253:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXWAKEUPREADY);
 2690              		.loc 1 1253 0
 2691 1240 4FF02C00 		mov	r0, #44
 2692 1244 FFF7FEFF 		bl	changeState
1254:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2693              		.loc 1 1254 0
 2694 1248 80BD     		pop	{r7, pc}
 2695              		.cfi_endproc
 2696              	.LFE31:
 2698 124a 00BF     		.align	2
 2699              		.global	activity_csl_wakeup_rie1
 2700              		.thumb
 2701              		.thumb_func
 2703              	activity_csl_wakeup_rie1:
 2704              	.LFB32:
1255:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1256:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1257:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1258:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling error [wake-up rie1].
1259:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1260:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #rt2 expiring, i.e. timer fires while state = S_CSLRXWAKEUPPREPARE. This is 
1261:openstack/02a-MAClow/IEEE802154Ecsl.c ****   did not have enough time to execute. Chances are to set maxRxDataPrepare too small. The implement
1262:openstack/02a-MAClow/IEEE802154Ecsl.c ****   next CSL sample.
1263:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1264:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_rie1() {  // Activity for error event [rie1] on CSL RX Samplin
 2705              		.loc 1 1264 0
 2706              		.cfi_startproc
 2707              		@ args = 0, pretend = 0, frame = 0
 2708              		@ frame_needed = 1, uses_anonymous_args = 0
 2709 124c 80B5     		push	{r7, lr}
 2710              	.LCFI75:
 2711              		.cfi_def_cfa_offset 8
 2712              		.cfi_offset 7, -8
 2713              		.cfi_offset 14, -4
 2714 124e 00AF     		add	r7, sp, #0
 2715              	.LCFI76:
 2716              		.cfi_def_cfa_register 7
1265:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
1266:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXWAKEUPPREPARE_OVERFLOWS,
1267:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state,
 2717              		.loc 1 1267 0
 2718 1250 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2719 1254 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2720 1258 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1266:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXWAKEUPPREPARE_OVERFLOWS,
 2721              		.loc 1 1266 0
 2722 125a 1A46     		mov	r2, r3
1268:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_dbg.num_cslSamples);
 2723              		.loc 1 1268 0
 2724 125c 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 2725 1260 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 2726 1264 1B69     		ldr	r3, [r3, #16]
1266:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXWAKEUPPREPARE_OVERFLOWS,
 2727              		.loc 1 1266 0
 2728 1266 9BB2     		uxth	r3, r3
 2729 1268 4FF00900 		mov	r0, #9
 2730 126c 4FF03C01 		mov	r1, #60
 2731 1270 FFF7FEFF 		bl	openserial_printError
1269:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1270:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1271:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 2732              		.loc 1 1271 0
 2733 1274 FFF7FEFF 		bl	endOps
1272:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2734              		.loc 1 1272 0
 2735 1278 80BD     		pop	{r7, pc}
 2736              		.cfi_endproc
 2737              	.LFE32:
 2739 127a 00BF     		.align	2
 2740              		.global	activity_csl_wakeup_ri3
 2741              		.thumb
 2742              		.thumb_func
 2744              	activity_csl_wakeup_ri3:
 2745              	.LFB33:
1273:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1274:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1275:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1276:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [wake-up ri3].
1277:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1278:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1279:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The radio is configured and this interrupt gives it the "go" signal to start listening.
1280:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1281:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ri3() { // Activity for stage [ri3] on CSL RX Sampling.
 2746              		.loc 1 1281 0
 2747              		.cfi_startproc
 2748              		@ args = 0, pretend = 0, frame = 0
 2749              		@ frame_needed = 1, uses_anonymous_args = 0
 2750 127c 80B5     		push	{r7, lr}
 2751              	.LCFI77:
 2752              		.cfi_def_cfa_offset 8
 2753              		.cfi_offset 7, -8
 2754              		.cfi_offset 14, -4
 2755 127e 00AF     		add	r7, sp, #0
 2756              	.LCFI78:
 2757              		.cfi_def_cfa_register 7
1282:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1283:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXWAKEUPLISTEN);
 2758              		.loc 1 1283 0
 2759 1280 4FF02D00 		mov	r0, #45
 2760 1284 FFF7FEFF 		bl	changeState
1284:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1285:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // give the 'go' to receive
1286:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rxNow();
 2761              		.loc 1 1286 0
 2762 1288 FFF7FEFF 		bl	radio_rxNow
1287:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1288:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt3
1289:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt3);
 2763              		.loc 1 1289 0
 2764 128c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2765 1290 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2766 1294 5B6A     		ldr	r3, [r3, #36]
 2767 1296 03F24113 		addw	r3, r3, #321
 2768 129a 1846     		mov	r0, r3
 2769 129c FFF7FEFF 		bl	radiotimer_schedule
1290:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2770              		.loc 1 1290 0
 2771 12a0 80BD     		pop	{r7, pc}
 2772              		.cfi_endproc
 2773              	.LFE33:
 2775 12a2 00BF     		.align	2
 2776              		.global	activity_csl_wakeup_rie2
 2777              		.thumb
 2778              		.thumb_func
 2780              	activity_csl_wakeup_rie2:
 2781              	.LFB34:
1291:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1292:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1293:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1294:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling error [wake-up rie2].
1295:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1296:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #rt3 expiring, i.e. timer fires while state = S_CSLRXWAKEUPLISTEN. If no pac
1297:openstack/02a-MAClow/IEEE802154Ecsl.c ****   none will be received ever and it is safe to switch of the radio. This timer is set such that the
1298:openstack/02a-MAClow/IEEE802154Ecsl.c ****   duration (#TsLongGT).
1299:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1300:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_rie2() { // Activity for error event [rie2] on CSL RX Sampling
 2782              		.loc 1 1300 0
 2783              		.cfi_startproc
 2784              		@ args = 0, pretend = 0, frame = 0
 2785              		@ frame_needed = 1, uses_anonymous_args = 0
 2786 12a4 80B5     		push	{r7, lr}
 2787              	.LCFI79:
 2788              		.cfi_def_cfa_offset 8
 2789              		.cfi_offset 7, -8
 2790              		.cfi_offset 14, -4
 2791 12a6 00AF     		add	r7, sp, #0
 2792              	.LCFI80:
 2793              		.cfi_def_cfa_register 7
1301:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1302:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 2794              		.loc 1 1302 0
 2795 12a8 FFF7FEFF 		bl	endOps
1303:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2796              		.loc 1 1303 0
 2797 12ac 80BD     		pop	{r7, pc}
 2798              		.cfi_endproc
 2799              	.LFE34:
 2801 12ae 00BF     		.align	2
 2802              		.global	activity_csl_wakeup_ri4
 2803              		.thumb
 2804              		.thumb_func
 2806              	activity_csl_wakeup_ri4:
 2807              	.LFB35:
1304:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1305:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1306:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1307:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [wake-up ri4].
1308:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1309:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_startOfFrame" function when a start of frame ev
1310:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to capture the time, cancel #rt3 and arm #rt4 (max time to receive all the p
1311:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1312:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ri4(PORT_RADIOTIMER_WIDTH capturedTime) {  // Activity for sta
 2808              		.loc 1 1312 0
 2809              		.cfi_startproc
 2810              		@ args = 0, pretend = 0, frame = 8
 2811              		@ frame_needed = 1, uses_anonymous_args = 0
 2812 12b0 80B5     		push	{r7, lr}
 2813              	.LCFI81:
 2814              		.cfi_def_cfa_offset 8
 2815              		.cfi_offset 7, -8
 2816              		.cfi_offset 14, -4
 2817 12b2 82B0     		sub	sp, sp, #8
 2818              	.LCFI82:
 2819              		.cfi_def_cfa_offset 16
 2820 12b4 00AF     		add	r7, sp, #0
 2821              	.LCFI83:
 2822              		.cfi_def_cfa_register 7
 2823 12b6 7860     		str	r0, [r7, #4]
1313:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1314:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1315:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXWAKEUP);
 2824              		.loc 1 1315 0
 2825 12b8 4FF02E00 		mov	r0, #46
 2826 12bc FFF7FEFF 		bl	changeState
1316:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1317:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel rt3
1318:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 2827              		.loc 1 1318 0
 2828 12c0 FFF7FEFF 		bl	radiotimer_cancel
1319:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1320:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
1321:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.lastCapturedTime = capturedTime;
 2829              		.loc 1 1321 0
 2830 12c4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2831 12c8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2832 12cc 7A68     		ldr	r2, [r7, #4]
 2833 12ce 5A62     		str	r2, [r3, #36]
1322:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1323:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time to sync
1324:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.syncCapturedTime = capturedTime;
 2834              		.loc 1 1324 0
 2835 12d0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2836 12d4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2837 12d8 7A68     		ldr	r2, [r7, #4]
 2838 12da 9A62     		str	r2, [r3, #40]
1325:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1326:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt4);
 2839              		.loc 1 1326 0
 2840 12dc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2841 12e0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2842 12e4 5B6A     		ldr	r3, [r3, #36]
 2843 12e6 03F1A403 		add	r3, r3, #164
 2844 12ea 1846     		mov	r0, r3
 2845 12ec FFF7FEFF 		bl	radiotimer_schedule
1327:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2846              		.loc 1 1327 0
 2847 12f0 07F10807 		add	r7, r7, #8
 2848 12f4 BD46     		mov	sp, r7
 2849 12f6 80BD     		pop	{r7, pc}
 2850              		.cfi_endproc
 2851              	.LFE35:
 2853              		.align	2
 2854              		.global	activity_csl_wakeup_rie3
 2855              		.thumb
 2856              		.thumb_func
 2858              	activity_csl_wakeup_rie3:
 2859              	.LFB36:
1328:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1329:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1330:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1331:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling error [wake-up rie3].
1332:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1333:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #rt4 expiring, i.e. timer fires while state = S_CSLRXWAKEUP. This is an erro
1334:openstack/02a-MAClow/IEEE802154Ecsl.c ****   transmit the data packet. The implemented behaviour is to log the error and move on the next CSL 
1335:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1336:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_rie3() {
 2860              		.loc 1 1336 0
 2861              		.cfi_startproc
 2862              		@ args = 0, pretend = 0, frame = 0
 2863              		@ frame_needed = 1, uses_anonymous_args = 0
 2864 12f8 80B5     		push	{r7, lr}
 2865              	.LCFI84:
 2866              		.cfi_def_cfa_offset 8
 2867              		.cfi_offset 7, -8
 2868              		.cfi_offset 14, -4
 2869 12fa 00AF     		add	r7, sp, #0
 2870              	.LCFI85:
 2871              		.cfi_def_cfa_register 7
1337:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1338:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
1339:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDWAKEUPDURATION_OVERFLOWS,
1340:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state,
 2872              		.loc 1 1340 0
 2873 12fc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2874 1300 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2875 1304 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1339:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDWAKEUPDURATION_OVERFLOWS,
 2876              		.loc 1 1339 0
 2877 1306 1A46     		mov	r2, r3
1341:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_dbg.num_cslSamples);
 2878              		.loc 1 1341 0
 2879 1308 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 2880 130c C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 2881 1310 1B69     		ldr	r3, [r3, #16]
1339:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDWAKEUPDURATION_OVERFLOWS,
 2882              		.loc 1 1339 0
 2883 1312 9BB2     		uxth	r3, r3
 2884 1314 4FF00900 		mov	r0, #9
 2885 1318 4FF03D01 		mov	r1, #61
 2886 131c FFF7FEFF 		bl	openserial_printError
1342:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1343:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1344:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 2887              		.loc 1 1344 0
 2888 1320 FFF7FEFF 		bl	endOps
1345:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2889              		.loc 1 1345 0
 2890 1324 80BD     		pop	{r7, pc}
 2891              		.cfi_endproc
 2892              	.LFE36:
 2894 1326 00BF     		.align	2
 2895              		.global	activity_csl_wakeup_rie4
 2896              		.thumb
 2897              		.thumb_func
 2899              	activity_csl_wakeup_rie4:
 2900              	.LFB37:
1346:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1347:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1348:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling error [wake-up rie4].
1349:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1350:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by rztime+TsSlotDuration expiring, i.e. timer fires while state = S_CSLRXWAKEUP
1351:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The behaviour is to free mem used and restart CSL sampling.
1352:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1353:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_rie4() {
 2901              		.loc 1 1353 0
 2902              		.cfi_startproc
 2903              		@ args = 0, pretend = 0, frame = 0
 2904              		@ frame_needed = 1, uses_anonymous_args = 0
 2905 1328 80B5     		push	{r7, lr}
 2906              	.LCFI86:
 2907              		.cfi_def_cfa_offset 8
 2908              		.cfi_offset 7, -8
 2909              		.cfi_offset 14, -4
 2910 132a 00AF     		add	r7, sp, #0
 2911              	.LCFI87:
 2912              		.cfi_def_cfa_register 7
1354:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1355:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // free memory
1356:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openqueue_freePacketBuffer(ieee154e_vars.dataReceived);
 2913              		.loc 1 1356 0
 2914 132c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2915 1330 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2916 1334 9B69     		ldr	r3, [r3, #24]
 2917 1336 1846     		mov	r0, r3
 2918 1338 FFF7FEFF 		bl	openqueue_freePacketBuffer
1357:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1358:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clear local variable
1359:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.dataReceived = NULL;
 2919              		.loc 1 1359 0
 2920 133c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2921 1340 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2922 1344 4FF00002 		mov	r2, #0
 2923 1348 9A61     		str	r2, [r3, #24]
1360:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1361:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1362:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 2924              		.loc 1 1362 0
 2925 134a FFF7FEFF 		bl	endOps
1363:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2926              		.loc 1 1363 0
 2927 134e 80BD     		pop	{r7, pc}
 2928              		.cfi_endproc
 2929              	.LFE37:
 2931              		.align	2
 2932              		.global	activity_csl_wakeup_ri5
 2933              		.thumb
 2934              		.thumb_func
 2936              	activity_csl_wakeup_ri5:
 2937              	.LFB38:
1364:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1365:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1366:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1367:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [wake-up ri5].
1368:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1369:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_endOfFrame" function when a end of frame event 
1370:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change state, cancel #rt4, validate wake-up frame and destination, and ar
1371:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1372:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ri5(PORT_RADIOTIMER_WIDTH capturedTime) {
 2938              		.loc 1 1372 0
 2939              		.cfi_startproc
 2940              		@ args = 0, pretend = 0, frame = 120
 2941              		@ frame_needed = 1, uses_anonymous_args = 0
 2942 1350 90B5     		push	{r4, r7, lr}
 2943              	.LCFI88:
 2944              		.cfi_def_cfa_offset 12
 2945              		.cfi_offset 4, -12
 2946              		.cfi_offset 7, -8
 2947              		.cfi_offset 14, -4
 2948 1352 A1B0     		sub	sp, sp, #132
 2949              	.LCFI89:
 2950              		.cfi_def_cfa_offset 144
 2951 1354 02AF     		add	r7, sp, #8
 2952              	.LCFI90:
 2953              		.cfi_def_cfa 7, 136
 2954 1356 7860     		str	r0, [r7, #4]
1373:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1374:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// Only for CSL Testing due to we are hard-coding destination (neighbor) address on schedule, pack
1375:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	open_addr_t myID, myID16b;
1376:openstack/02a-MAClow/IEEE802154Ecsl.c ****     myID.addr_64b[0]=0x00;
 2955              		.loc 1 1376 0
 2956 1358 4FF00003 		mov	r3, #0
 2957 135c 87F86530 		strb	r3, [r7, #101]
1377:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.addr_64b[1]=0x11;
 2958              		.loc 1 1377 0
 2959 1360 4FF01103 		mov	r3, #17
 2960 1364 87F86630 		strb	r3, [r7, #102]
1378:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.addr_64b[2]=0x22;
 2961              		.loc 1 1378 0
 2962 1368 4FF02203 		mov	r3, #34
 2963 136c 87F86730 		strb	r3, [r7, #103]
1379:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.addr_64b[3]=0x33;
 2964              		.loc 1 1379 0
 2965 1370 4FF03303 		mov	r3, #51
 2966 1374 87F86830 		strb	r3, [r7, #104]
1380:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.addr_64b[4]=0x44;
 2967              		.loc 1 1380 0
 2968 1378 4FF04403 		mov	r3, #68
 2969 137c 87F86930 		strb	r3, [r7, #105]
1381:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.addr_64b[5]=0x55;
 2970              		.loc 1 1381 0
 2971 1380 4FF05503 		mov	r3, #85
 2972 1384 87F86A30 		strb	r3, [r7, #106]
1382:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.addr_64b[6]=0x66;
 2973              		.loc 1 1382 0
 2974 1388 4FF06603 		mov	r3, #102
 2975 138c 87F86B30 		strb	r3, [r7, #107]
1383:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.addr_64b[7]=0x77;
 2976              		.loc 1 1383 0
 2977 1390 4FF07703 		mov	r3, #119
 2978 1394 87F86C30 		strb	r3, [r7, #108]
1384:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1385:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.type=ADDR_64B;
 2979              		.loc 1 1385 0
 2980 1398 4FF00203 		mov	r3, #2
 2981 139c 87F86430 		strb	r3, [r7, #100]
1386:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1387:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// En este punto ya hemos recibido la trama por lo que hay que hacer las siguientes validaciones:
1388:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   1.- Cambiar el estado a S_CSLRXWAKEUPVALIDATE y cancelar el temporizador rt4.
1389:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   2.- Apagar la radio.
1390:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   3.- Analizar el mensaje recibido y parsear su cabecera.
1391:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   4.- Verificar que se trata de una trama de tipo wake-up.
1392:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   5.- Comprobar que el destinatario soy yo mismo.
1393:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//
1394:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// En caso afirmativo, utilizamos el Rendezvous time recibido para saber cuánto tiempo hay que do
1395:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// En caso negativo, desactivamos la radio e iniciamos de nuevo el proceso de channel sampling.
1396:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1397:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	ieee802154_header_iht ieee802514_header;
1398:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	uint16_t rztime;
1399:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1400:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // actualizamos el estado.
1401:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXWAKEUPVALIDATE);
 2982              		.loc 1 1401 0
 2983 13a0 4FF02F00 		mov	r0, #47
 2984 13a4 FFF7FEFF 		bl	changeState
1402:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1403:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancelamos el timer #rt4
1404:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 2985              		.loc 1 1404 0
 2986 13a8 FFF7FEFF 		bl	radiotimer_cancel
1405:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1406:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // apagamos la radio
1407:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rfOff();
 2987              		.loc 1 1407 0
 2988 13ac FFF7FEFF 		bl	radio_rfOff
1408:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1409:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // obtenemos un buffer en el cual poder guardar los datos recibidos.
1410:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.wakeupReceived = openqueue_getFreePacketBuffer(COMPONENT_IEEE802154E);
 2989              		.loc 1 1410 0
 2990 13b0 4FF00900 		mov	r0, #9
 2991 13b4 FFF7FEFF 		bl	openqueue_getFreePacketBuffer
 2992 13b8 0246     		mov	r2, r0
 2993 13ba 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2994 13be C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2995 13c2 1A64     		str	r2, [r3, #64]
1411:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.wakeupReceived==NULL) {
 2996              		.loc 1 1411 0
 2997 13c4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2998 13c8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2999 13cc 1B6C     		ldr	r3, [r3, #64]
 3000 13ce 002B     		cmp	r3, #0
 3001 13d0 0CD1     		bne	.L151
1412:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // registro del error & fin de operaciones.
1413:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openserial_printError(COMPONENT_IEEE802154E,ERR_NO_FREE_PACKET_BUFFER, (errorparameter_t)0, (
 3002              		.loc 1 1413 0
 3003 13d2 4FF00900 		mov	r0, #9
 3004 13d6 4FF02C01 		mov	r1, #44
 3005 13da 4FF00002 		mov	r2, #0
 3006 13de 4FF00003 		mov	r3, #0
 3007 13e2 FFF7FEFF 		bl	openserial_printError
1414:openstack/02a-MAClow/IEEE802154Ecsl.c ****       endOps();
 3008              		.loc 1 1414 0
 3009 13e6 FFF7FEFF 		bl	endOps
 3010 13ea 3EE1     		b	.L150
 3011              	.L151:
1415:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return;
1416:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
1417:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1418:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Declaración de propiedad sobre el paquete.
1419:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.wakeupReceived->creator = COMPONENT_IEEE802154E;
 3012              		.loc 1 1419 0
 3013 13ec 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3014 13f0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3015 13f4 1B6C     		ldr	r3, [r3, #64]
 3016 13f6 4FF00902 		mov	r2, #9
 3017 13fa 1A70     		strb	r2, [r3, #0]
1420:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.wakeupReceived->owner   = COMPONENT_IEEE802154E;
 3018              		.loc 1 1420 0
 3019 13fc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3020 1400 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3021 1404 1B6C     		ldr	r3, [r3, #64]
 3022 1406 4FF00902 		mov	r2, #9
 3023 140a 5A70     		strb	r2, [r3, #1]
1421:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1422:openstack/02a-MAClow/IEEE802154Ecsl.c ****    /*
1423:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The do-while loop that follows is a little parsing trick.
1424:openstack/02a-MAClow/IEEE802154Ecsl.c ****    Because it contains a while(0) condition, it gets executed only once.
1425:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The behavior is:
1426:openstack/02a-MAClow/IEEE802154Ecsl.c ****    - if a break occurs inside the do{} body, the error code below the loop gets executed. This indi
1427:openstack/02a-MAClow/IEEE802154Ecsl.c ****    - if a return occurs inside the do{} body, the error code below the loop does not get executed. 
1428:openstack/02a-MAClow/IEEE802154Ecsl.c ****    */
1429:openstack/02a-MAClow/IEEE802154Ecsl.c ****    do { // Este "loop" es ejecutado sólo en una ocasión.
1430:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1431:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Obtenemos la trama con los datos recibidos desde el buffer de recepción de la radio.
1432:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.wakeupReceived->payload = &(ieee154e_vars.wakeupReceived->packet[FIRST_FRAME_BY
 3024              		.loc 1 1432 0
 3025 140c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3026 1410 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3027 1414 1A6C     		ldr	r2, [r3, #64]
 3028 1416 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3029 141a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3030 141e 1B6C     		ldr	r3, [r3, #64]
 3031 1420 03F16C03 		add	r3, r3, #108
 3032 1424 5360     		str	r3, [r2, #4]
1433:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(      ieee154e_vars.wakeupReceived->payload,
 3033              		.loc 1 1433 0
 3034 1426 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3035 142a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3036 142e 1B6C     		ldr	r3, [r3, #64]
 3037 1430 5968     		ldr	r1, [r3, #4]
1434:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.wakeupReceived->length,
 3038              		.loc 1 1434 0
 3039 1432 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3040 1436 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3041 143a 1B6C     		ldr	r3, [r3, #64]
1433:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(      ieee154e_vars.wakeupReceived->payload,
 3042              		.loc 1 1433 0
 3043 143c 03F10802 		add	r2, r3, #8
1435:openstack/02a-MAClow/IEEE802154Ecsl.c ****                              sizeof(ieee154e_vars.wakeupReceived->packet),
1436:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.wakeupReceived->l1_rssi,
 3044              		.loc 1 1436 0
 3045 1440 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3046 1444 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3047 1448 1B6C     		ldr	r3, [r3, #64]
1433:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(      ieee154e_vars.wakeupReceived->payload,
 3048              		.loc 1 1433 0
 3049 144a 03F16804 		add	r4, r3, #104
1437:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.wakeupReceived->l1_lqi,
 3050              		.loc 1 1437 0
 3051 144e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3052 1452 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3053 1456 1B6C     		ldr	r3, [r3, #64]
1433:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(      ieee154e_vars.wakeupReceived->payload,
 3054              		.loc 1 1433 0
 3055 1458 03F16900 		add	r0, r3, #105
1438:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.wakeupReceived->l1_crc);
 3056              		.loc 1 1438 0
 3057 145c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3058 1460 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3059 1464 1B6C     		ldr	r3, [r3, #64]
1433:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(      ieee154e_vars.wakeupReceived->payload,
 3060              		.loc 1 1433 0
 3061 1466 03F16A03 		add	r3, r3, #106
 3062 146a 0090     		str	r0, [sp, #0]
 3063 146c 0193     		str	r3, [sp, #4]
 3064 146e 0846     		mov	r0, r1
 3065 1470 1146     		mov	r1, r2
 3066 1472 4FF08202 		mov	r2, #130
 3067 1476 2346     		mov	r3, r4
 3068 1478 FFF7FEFF 		bl	radio_getReceivedFrame
1439:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1440:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Finalizamos si la longitud no es correcta.
1441:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.wakeupReceived->length<LENGTH_CRC || ieee154e_vars.wakeupReceived->length>L
 3069              		.loc 1 1441 0
 3070 147c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3071 1480 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3072 1484 1B6C     		ldr	r3, [r3, #64]
 3073 1486 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 3074 1488 012B     		cmp	r3, #1
 3075 148a 07D9     		bls	.L153
 3076              		.loc 1 1441 0 is_stmt 0 discriminator 1
 3077 148c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3078 1490 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3079 1494 1B6C     		ldr	r3, [r3, #64]
 3080 1496 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 3081 1498 802B     		cmp	r3, #128
 3082 149a 0ED9     		bls	.L154
 3083              	.L153:
1442:openstack/02a-MAClow/IEEE802154Ecsl.c ****         openserial_printError(COMPONENT_IEEE802154E,ERR_INVALIDPACKETFROMRADIO, (errorparameter_t)2
 3084              		.loc 1 1442 0 is_stmt 1
 3085 149c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3086 14a0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3087 14a4 1B6C     		ldr	r3, [r3, #64]
 3088 14a6 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 3089 14a8 4FF00900 		mov	r0, #9
 3090 14ac 4FF03701 		mov	r1, #55
 3091 14b0 4FF00202 		mov	r2, #2
 3092 14b4 FFF7FEFF 		bl	openserial_printError
1443:openstack/02a-MAClow/IEEE802154Ecsl.c ****         break;
 3093              		.loc 1 1443 0
 3094 14b8 C6E0     		b	.L155
 3095              	.L154:
1444:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1445:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1446:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // toss CRC (2 últimos bytes)
1447:openstack/02a-MAClow/IEEE802154Ecsl.c ****       packetfunctions_tossFooter(ieee154e_vars.wakeupReceived, LENGTH_CRC);
 3096              		.loc 1 1447 0
 3097 14ba 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3098 14be C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3099 14c2 1B6C     		ldr	r3, [r3, #64]
 3100 14c4 1846     		mov	r0, r3
 3101 14c6 4FF00201 		mov	r1, #2
 3102 14ca FFF7FEFF 		bl	packetfunctions_tossFooter
1448:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1449:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // si CRC no es válido, finalizamos el proceso.
1450:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.wakeupReceived->l1_crc==FALSE) { break; }
 3103              		.loc 1 1450 0
 3104 14ce 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3105 14d2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3106 14d6 1B6C     		ldr	r3, [r3, #64]
 3107 14d8 93F86A30 		ldrb	r3, [r3, #106]	@ zero_extendqisi2
 3108 14dc 83F00103 		eor	r3, r3, #1
 3109 14e0 DBB2     		uxtb	r3, r3
 3110 14e2 002B     		cmp	r3, #0
 3111 14e4 40F0AB80 		bne	.L163
 3112              	.L156:
1451:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1452:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // parseamos la trama IEEE802.15.4 WAKE-UP y su cabecera.
1453:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee802154_retrieveWakeUpFrame(ieee154e_vars.wakeupReceived,&ieee802514_header,&rztime);
 3113              		.loc 1 1453 0
 3114 14e8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3115 14ec C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3116 14f0 196C     		ldr	r1, [r3, #64]
 3117 14f2 07F11002 		add	r2, r7, #16
 3118 14f6 07F10E03 		add	r3, r7, #14
 3119 14fa 0846     		mov	r0, r1
 3120 14fc 1146     		mov	r1, r2
 3121 14fe 1A46     		mov	r2, r3
 3122 1500 FFF7FEFF 		bl	ieee802154_retrieveWakeUpFrame
1454:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1455:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // En el caso de que no sea una cabecera IEEE802.15.4 válida, finalizamos el proceso.
1456:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee802514_header.valid==FALSE) { break; }
 3123              		.loc 1 1456 0
 3124 1504 3B7C     		ldrb	r3, [r7, #16]	@ zero_extendqisi2
 3125 1506 83F00103 		eor	r3, r3, #1
 3126 150a DBB2     		uxtb	r3, r3
 3127 150c 002B     		cmp	r3, #0
 3128 150e 40F09880 		bne	.L164
 3129              	.L157:
1457:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1458:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // CSL TEST CODE : Verify RZ Time
1459:openstack/02a-MAClow/IEEE802154Ecsl.c ****       //if (rztime <= 0x07D0) { // 2000
1460:openstack/02a-MAClow/IEEE802154Ecsl.c ****       //	  break;
1461:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // } else {
1462:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  //    changeState(S_CSLRXWAKEUPOFFSET);
1463:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  //	  radiotimer_schedule(DURATION_rt1);
1464:openstack/02a-MAClow/IEEE802154Ecsl.c ****       //	  break;
1465:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // }
1466:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // END CSL TEST CODE
1467:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1468:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Verificamos que se trata de una trama WAKE-UP, perteneciente a la misma PAN ID, y dirigida
1469:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if(ieee802514_header.frameType==IEEE154_TYPE_MULTIPURPOSE) {
 3130              		.loc 1 1469 0
 3131 1512 BB7C     		ldrb	r3, [r7, #18]	@ zero_extendqisi2
 3132 1514 052B     		cmp	r3, #5
 3133 1516 40F09680 		bne	.L165
1470:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	  // Comentado y sustituido para CSL TESTING ya que está hard-codeada la direccion.
1471:openstack/02a-MAClow/IEEE802154Ecsl.c ****      	  //if(packetfunctions_sameAddress(&ieee802514_header.dest,idmanager_getMyID(ADDR_16B)) &&
1472:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	  // CSL TEST
1473:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	  packetfunctions_mac64bToMac16b(&myID,&myID16b);
 3134              		.loc 1 1473 0
 3135 151a 07F16402 		add	r2, r7, #100
 3136 151e 07F15003 		add	r3, r7, #80
 3137 1522 1046     		mov	r0, r2
 3138 1524 1946     		mov	r1, r3
 3139 1526 FFF7FEFF 		bl	packetfunctions_mac64bToMac16b
1474:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	  if(packetfunctions_sameAddress(&ieee802514_header.dest, &myID16b) &&
 3140              		.loc 1 1474 0
 3141 152a 07F11003 		add	r3, r7, #16
 3142 152e 03F11B02 		add	r2, r3, #27
 3143 1532 07F15003 		add	r3, r7, #80
 3144 1536 1046     		mov	r0, r2
 3145 1538 1946     		mov	r1, r3
 3146 153a FFF7FEFF 		bl	packetfunctions_sameAddress
 3147 153e 0346     		mov	r3, r0
 3148 1540 002B     		cmp	r3, #0
 3149 1542 43D0     		beq	.L159
1475:openstack/02a-MAClow/IEEE802154Ecsl.c ****    		  // END CSL TEST
1476:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     packetfunctions_sameAddress(&ieee802514_header.panid,idmanager_getMyID(ADDR_PANID))) {
 3150              		.loc 1 1476 0 discriminator 1
 3151 1544 4FF00400 		mov	r0, #4
 3152 1548 FFF7FEFF 		bl	idmanager_getMyID
 3153 154c 0346     		mov	r3, r0
 3154 154e 07F11002 		add	r2, r7, #16
 3155 1552 02F10A02 		add	r2, r2, #10
 3156 1556 1046     		mov	r0, r2
 3157 1558 1946     		mov	r1, r3
 3158 155a FFF7FEFF 		bl	packetfunctions_sameAddress
 3159 155e 0346     		mov	r3, r0
1474:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	  if(packetfunctions_sameAddress(&ieee802514_header.dest, &myID16b) &&
 3160              		.loc 1 1474 0 discriminator 1
 3161 1560 002B     		cmp	r3, #0
 3162 1562 33D0     		beq	.L159
1477:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1478:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	   // En este caso, debemos dormir el tiempo indicado por RZ Time, estableciendo el estado a S
1479:openstack/02a-MAClow/IEEE802154Ecsl.c ****  	       changeState(S_CSLRXDATAOFFSET);
 3163              		.loc 1 1479 0
 3164 1564 4FF03000 		mov	r0, #48
 3165 1568 FFF7FEFF 		bl	changeState
1480:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1481:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	   // Tratamos el caso en el cual rztime_ie.time sea cero, es decir, sea la ultima trama wake-
1482:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	   if (rztime == 0) {
 3166              		.loc 1 1482 0
 3167 156c FB89     		ldrh	r3, [r7, #14]
 3168 156e 002B     		cmp	r3, #0
 3169 1570 0AD1     		bne	.L160
1483:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     // Establecemos el timer rt1 (consideramos el mismo tiempo de offset para la recepción d
1484:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     radiotimer_schedule(DURATION_rt1);
 3170              		.loc 1 1484 0
 3171 1572 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3172 1576 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3173 157a 5B6A     		ldr	r3, [r3, #36]
 3174 157c 03F13703 		add	r3, r3, #55
 3175 1580 1846     		mov	r0, r3
 3176 1582 FFF7FEFF 		bl	radiotimer_schedule
 3177 1586 0BE0     		b	.L161
 3178              	.L160:
1485:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	   } else {
1486:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     // Establecemos el timer al valor rt1 pero desplazado el tiempo indicado desde el rendezv
1487:openstack/02a-MAClow/IEEE802154Ecsl.c ****         	 radiotimer_schedule(DURATION_rt1 + rztime);
 3179              		.loc 1 1487 0
 3180 1588 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3181 158c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3182 1590 5A6A     		ldr	r2, [r3, #36]
 3183 1592 FB89     		ldrh	r3, [r7, #14]
 3184 1594 D318     		adds	r3, r2, r3
 3185 1596 03F13703 		add	r3, r3, #55
 3186 159a 1846     		mov	r0, r3
 3187 159c FFF7FEFF 		bl	radiotimer_schedule
 3188              	.L161:
1488:openstack/02a-MAClow/IEEE802154Ecsl.c ****            }
1489:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1490:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	   // registro del tiempo de captura
1491:openstack/02a-MAClow/IEEE802154Ecsl.c ****            ieee154e_vars.lastCapturedTime = capturedTime;
 3189              		.loc 1 1491 0
 3190 15a0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3191 15a4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3192 15a8 7A68     		ldr	r2, [r7, #4]
 3193 15aa 5A62     		str	r2, [r3, #36]
1492:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1493:openstack/02a-MAClow/IEEE802154Ecsl.c ****            // Descartamos el paquete una vez recibido y tratado.
1494:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1495:openstack/02a-MAClow/IEEE802154Ecsl.c ****            openqueue_freePacketBuffer(ieee154e_vars.wakeupReceived);
 3194              		.loc 1 1495 0
 3195 15ac 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3196 15b0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3197 15b4 1B6C     		ldr	r3, [r3, #64]
 3198 15b6 1846     		mov	r0, r3
 3199 15b8 FFF7FEFF 		bl	openqueue_freePacketBuffer
1496:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1497:openstack/02a-MAClow/IEEE802154Ecsl.c ****            // clear local variable
1498:openstack/02a-MAClow/IEEE802154Ecsl.c ****            ieee154e_vars.wakeupReceived = NULL;
 3200              		.loc 1 1498 0
 3201 15bc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3202 15c0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3203 15c4 4FF00002 		mov	r2, #0
 3204 15c8 1A64     		str	r2, [r3, #64]
 3205 15ca 4EE0     		b	.L150
 3206              	.L159:
1499:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1500:openstack/02a-MAClow/IEEE802154Ecsl.c ****            // retornamos para no ejecutar el codigo inferior y finalizar el proceso.
1501:openstack/02a-MAClow/IEEE802154Ecsl.c ****            return;
1502:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 }
1503:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 // En el caso que sea una trama dentro de mi PANID pero no dirigida a mi, entonces dormimos u
1504:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 //   - RZ time + Maximum length payload frame + secure ack frame (consideraremos un tiempo ig
1505:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 // dado que TsSlotDuration es el tiempo utilizado en OpenWSN-TSCH para enviar y recibir una t
1506:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 // en cualquier caso revisar estos timings mediante medidas y mecanismos más precisos (oscil
1507:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 else if( ! packetfunctions_sameAddress(&ieee802514_header.dest,idmanager_getMyID(ADDR_16B)) &
 3207              		.loc 1 1507 0
 3208 15cc 4FF00100 		mov	r0, #1
 3209 15d0 FFF7FEFF 		bl	idmanager_getMyID
 3210 15d4 0346     		mov	r3, r0
 3211 15d6 07F11002 		add	r2, r7, #16
 3212 15da 02F11B02 		add	r2, r2, #27
 3213 15de 1046     		mov	r0, r2
 3214 15e0 1946     		mov	r1, r3
 3215 15e2 FFF7FEFF 		bl	packetfunctions_sameAddress
 3216 15e6 0346     		mov	r3, r0
 3217 15e8 83F00103 		eor	r3, r3, #1
 3218 15ec DBB2     		uxtb	r3, r3
 3219 15ee 002B     		cmp	r3, #0
 3220 15f0 2AD0     		beq	.L155
1508:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	   		    packetfunctions_sameAddress(&ieee802514_header.panid,idmanager_getMyID(ADDR_PANID))) 
 3221              		.loc 1 1508 0 discriminator 1
 3222 15f2 4FF00400 		mov	r0, #4
 3223 15f6 FFF7FEFF 		bl	idmanager_getMyID
 3224 15fa 0346     		mov	r3, r0
 3225 15fc 07F11002 		add	r2, r7, #16
 3226 1600 02F10A02 		add	r2, r2, #10
 3227 1604 1046     		mov	r0, r2
 3228 1606 1946     		mov	r1, r3
 3229 1608 FFF7FEFF 		bl	packetfunctions_sameAddress
 3230 160c 0346     		mov	r3, r0
1507:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 else if( ! packetfunctions_sameAddress(&ieee802514_header.dest,idmanager_getMyID(ADDR_16B)) &
 3231              		.loc 1 1507 0 discriminator 1
 3232 160e 002B     		cmp	r3, #0
 3233 1610 1AD0     		beq	.L155
1509:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1510:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     // La limpieza del paquete y los datos recibidos será realizada en el metodo activity_cs
1511:openstack/02a-MAClow/IEEE802154Ecsl.c ****     		 radiotimer_schedule(rztime + TsSlotDuration);
 3234              		.loc 1 1511 0
 3235 1612 FB89     		ldrh	r3, [r7, #14]
 3236 1614 03F5F673 		add	r3, r3, #492
 3237 1618 1846     		mov	r0, r3
 3238 161a FFF7FEFF 		bl	radiotimer_schedule
1512:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1513:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     // Descartamos el paquete una vez recibido y tratado.
1514:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1515:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     openqueue_freePacketBuffer(ieee154e_vars.wakeupReceived);
 3239              		.loc 1 1515 0
 3240 161e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3241 1622 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3242 1626 1B6C     		ldr	r3, [r3, #64]
 3243 1628 1846     		mov	r0, r3
 3244 162a FFF7FEFF 		bl	openqueue_freePacketBuffer
1516:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1517:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     // clear local variable
1518:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     ieee154e_vars.wakeupReceived = NULL;
 3245              		.loc 1 1518 0
 3246 162e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3247 1632 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3248 1636 4FF00002 		mov	r2, #0
 3249 163a 1A64     		str	r2, [r3, #64]
 3250 163c 15E0     		b	.L150
 3251              	.L163:
1450:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.wakeupReceived->l1_crc==FALSE) { break; }
 3252              		.loc 1 1450 0
 3253 163e 00BF     		nop
 3254 1640 02E0     		b	.L155
 3255              	.L164:
1456:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee802514_header.valid==FALSE) { break; }
 3256              		.loc 1 1456 0
 3257 1642 00BF     		nop
 3258 1644 00E0     		b	.L155
 3259              	.L165:
1519:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1520:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     return;
1521:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 }
1522:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1523:openstack/02a-MAClow/IEEE802154Ecsl.c ****       else {
1524:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	  break; // cualquier otro tipo de trama recibida en este punto de la FSM es descartada.
 3260              		.loc 1 1524 0
 3261 1646 00BF     		nop
 3262              	.L155:
1525:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1526:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1527:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } while(0);
1528:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1529:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // En cualquier otro caso, descartamos el paquete e iniciamos de nuevo el proceso de channel sam
1530:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1531:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openqueue_freePacketBuffer(ieee154e_vars.wakeupReceived);
 3263              		.loc 1 1531 0
 3264 1648 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3265 164c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3266 1650 1B6C     		ldr	r3, [r3, #64]
 3267 1652 1846     		mov	r0, r3
 3268 1654 FFF7FEFF 		bl	openqueue_freePacketBuffer
1532:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1533:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clear local variable
1534:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.wakeupReceived = NULL;
 3269              		.loc 1 1534 0
 3270 1658 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3271 165c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3272 1660 4FF00002 		mov	r2, #0
 3273 1664 1A64     		str	r2, [r3, #64]
1535:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1536:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1537:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 3274              		.loc 1 1537 0
 3275 1666 FFF7FEFF 		bl	endOps
 3276              	.L150:
1538:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3277              		.loc 1 1538 0
 3278 166a 07F17C07 		add	r7, r7, #124
 3279 166e BD46     		mov	sp, r7
 3280 1670 90BD     		pop	{r4, r7, pc}
 3281              		.cfi_endproc
 3282              	.LFE38:
 3284 1672 00BF     		.align	2
 3285              		.global	activity_csl_data_ri2
 3286              		.thumb
 3287              		.thumb_func
 3289              	activity_csl_data_ri2:
 3290              	.LFB39:
1539:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1540:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1541:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1542:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri2].
1543:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1544:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1545:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to prepare the radio for receiving packets.
1546:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1547:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1548:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri2() {
 3291              		.loc 1 1548 0
 3292              		.cfi_startproc
 3293              		@ args = 0, pretend = 0, frame = 0
 3294              		@ frame_needed = 1, uses_anonymous_args = 0
 3295 1674 80B5     		push	{r7, lr}
 3296              	.LCFI91:
 3297              		.cfi_def_cfa_offset 8
 3298              		.cfi_offset 7, -8
 3299              		.cfi_offset 14, -4
 3300 1676 00AF     		add	r7, sp, #0
 3301              	.LCFI92:
 3302              		.cfi_def_cfa_register 7
1549:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1550:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXDATAPREPARE);
 3303              		.loc 1 1550 0
 3304 1678 4FF03100 		mov	r0, #49
 3305 167c FFF7FEFF 		bl	changeState
1551:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1552:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // We use always the same frequency so it is not necessary to change it on radio.
1553:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Enable the radio in Rx mode. The radio does not actively listen yet.
1554:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rxEnable();
 3306              		.loc 1 1554 0
 3307 1680 FFF7FEFF 		bl	radio_rxEnable
1555:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnInit=radio_getTimerValue();
 3308              		.loc 1 1555 0
 3309 1684 FFF7FEFF 		bl	radio_getTimerValue
 3310 1688 0246     		mov	r2, r0
 3311 168a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3312 168e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3313 1692 1A63     		str	r2, [r3, #48]
1556:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnThisSlot=TRUE;
 3314              		.loc 1 1556 0
 3315 1694 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3316 1698 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3317 169c 4FF00102 		mov	r2, #1
 3318 16a0 83F83820 		strb	r2, [r3, #56]
1557:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1558:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt2
1559:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt2);
 3319              		.loc 1 1559 0
 3320 16a4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3321 16a8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3322 16ac 5B6A     		ldr	r3, [r3, #36]
 3323 16ae 03F15803 		add	r3, r3, #88
 3324 16b2 1846     		mov	r0, r3
 3325 16b4 FFF7FEFF 		bl	radiotimer_schedule
1560:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1561:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1562:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // If this action is not performed before rt2 has expired, we need to manage the error in activi
1563:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // prepare has exceeded the maximum allowed time (duration_rt2).
1564:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXDATAREADY);
 3326              		.loc 1 1564 0
 3327 16b8 4FF03200 		mov	r0, #50
 3328 16bc FFF7FEFF 		bl	changeState
1565:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3329              		.loc 1 1565 0
 3330 16c0 80BD     		pop	{r7, pc}
 3331              		.cfi_endproc
 3332              	.LFE39:
 3334 16c2 00BF     		.align	2
 3335              		.global	activity_csl_data_rie1
 3336              		.thumb
 3337              		.thumb_func
 3339              	activity_csl_data_rie1:
 3340              	.LFB40:
1566:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1567:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1568:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1569:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling error [data_rie1].
1570:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1571:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #rt2 expiring, i.e. timer fires while state = S_CSLRXDATAPREPARE. This is re
1572:openstack/02a-MAClow/IEEE802154Ecsl.c ****   did not have enough time to execute. Chances are to set maxRxDataPrepare too small. The implement
1573:openstack/02a-MAClow/IEEE802154Ecsl.c ****   next CSL sample.
1574:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1575:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_rie1() {  // Activity for error event [rie1] on CSL RX Sampling.
 3341              		.loc 1 1575 0
 3342              		.cfi_startproc
 3343              		@ args = 0, pretend = 0, frame = 0
 3344              		@ frame_needed = 1, uses_anonymous_args = 0
 3345 16c4 80B5     		push	{r7, lr}
 3346              	.LCFI93:
 3347              		.cfi_def_cfa_offset 8
 3348              		.cfi_offset 7, -8
 3349              		.cfi_offset 14, -4
 3350 16c6 00AF     		add	r7, sp, #0
 3351              	.LCFI94:
 3352              		.cfi_def_cfa_register 7
1576:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
1577:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXDATAPREPARE_OVERFLOWS,
1578:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state,
 3353              		.loc 1 1578 0
 3354 16c8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3355 16cc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3356 16d0 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1577:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXDATAPREPARE_OVERFLOWS,
 3357              		.loc 1 1577 0
 3358 16d2 1A46     		mov	r2, r3
1579:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_dbg.num_cslSamples);
 3359              		.loc 1 1579 0
 3360 16d4 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 3361 16d8 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 3362 16dc 1B69     		ldr	r3, [r3, #16]
1577:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXDATAPREPARE_OVERFLOWS,
 3363              		.loc 1 1577 0
 3364 16de 9BB2     		uxth	r3, r3
 3365 16e0 4FF00900 		mov	r0, #9
 3366 16e4 4FF02401 		mov	r1, #36
 3367 16e8 FFF7FEFF 		bl	openserial_printError
1580:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1581:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 3368              		.loc 1 1581 0
 3369 16ec FFF7FEFF 		bl	endOps
1582:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3370              		.loc 1 1582 0
 3371 16f0 80BD     		pop	{r7, pc}
 3372              		.cfi_endproc
 3373              	.LFE40:
 3375 16f2 00BF     		.align	2
 3376              		.global	activity_csl_data_ri3
 3377              		.thumb
 3378              		.thumb_func
 3380              	activity_csl_data_ri3:
 3381              	.LFB41:
1583:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1584:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1585:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1586:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri3].
1587:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1588:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1589:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The radio is configured and this interrupt gives it the "go" signal to start listening.
1590:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1591:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri3() { // Activity for stage [data ri3] on CSL RX Sampling.
 3382              		.loc 1 1591 0
 3383              		.cfi_startproc
 3384              		@ args = 0, pretend = 0, frame = 0
 3385              		@ frame_needed = 1, uses_anonymous_args = 0
 3386 16f4 80B5     		push	{r7, lr}
 3387              	.LCFI95:
 3388              		.cfi_def_cfa_offset 8
 3389              		.cfi_offset 7, -8
 3390              		.cfi_offset 14, -4
 3391 16f6 00AF     		add	r7, sp, #0
 3392              	.LCFI96:
 3393              		.cfi_def_cfa_register 7
1592:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1593:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXDATALISTEN);
 3394              		.loc 1 1593 0
 3395 16f8 4FF03300 		mov	r0, #51
 3396 16fc FFF7FEFF 		bl	changeState
1594:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1595:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // give the 'go' to receive
1596:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rxNow();
 3397              		.loc 1 1596 0
 3398 1700 FFF7FEFF 		bl	radio_rxNow
1597:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1598:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt3
1599:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt3);
 3399              		.loc 1 1599 0
 3400 1704 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3401 1708 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3402 170c 5B6A     		ldr	r3, [r3, #36]
 3403 170e 03F24113 		addw	r3, r3, #321
 3404 1712 1846     		mov	r0, r3
 3405 1714 FFF7FEFF 		bl	radiotimer_schedule
1600:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3406              		.loc 1 1600 0
 3407 1718 80BD     		pop	{r7, pc}
 3408              		.cfi_endproc
 3409              	.LFE41:
 3411 171a 00BF     		.align	2
 3412              		.global	activity_csl_data_rie2
 3413              		.thumb
 3414              		.thumb_func
 3416              	activity_csl_data_rie2:
 3417              	.LFB42:
1601:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1602:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1603:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1604:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling error [data rie2].
1605:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1606:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #rt3 expiring, i.e. timer fires while state = S_CSLRXDATALISTEN. If no packe
1607:openstack/02a-MAClow/IEEE802154Ecsl.c ****   none will be received ever and it is safe to switch of the radio. This timer is set such that the
1608:openstack/02a-MAClow/IEEE802154Ecsl.c ****   duration (#TsLongGT).
1609:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1610:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_rie2() { // Activity for error event [data rie2] on CSL RX Sampl
 3418              		.loc 1 1610 0
 3419              		.cfi_startproc
 3420              		@ args = 0, pretend = 0, frame = 0
 3421              		@ frame_needed = 1, uses_anonymous_args = 0
 3422 171c 80B5     		push	{r7, lr}
 3423              	.LCFI97:
 3424              		.cfi_def_cfa_offset 8
 3425              		.cfi_offset 7, -8
 3426              		.cfi_offset 14, -4
 3427 171e 00AF     		add	r7, sp, #0
 3428              	.LCFI98:
 3429              		.cfi_def_cfa_register 7
1611:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1612:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 3430              		.loc 1 1612 0
 3431 1720 FFF7FEFF 		bl	endOps
1613:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3432              		.loc 1 1613 0
 3433 1724 80BD     		pop	{r7, pc}
 3434              		.cfi_endproc
 3435              	.LFE42:
 3437 1726 00BF     		.align	2
 3438              		.global	activity_csl_data_ri4
 3439              		.thumb
 3440              		.thumb_func
 3442              	activity_csl_data_ri4:
 3443              	.LFB43:
1614:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1615:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1616:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri4].
1617:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1618:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_startOfFrame" function when a start of frame ev
1619:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to capture the time, cancel #rt3 and arm #rt4 (max time to receive all the p
1620:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1621:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri4(PORT_RADIOTIMER_WIDTH capturedTime) {  // Activity for stage
 3444              		.loc 1 1621 0
 3445              		.cfi_startproc
 3446              		@ args = 0, pretend = 0, frame = 8
 3447              		@ frame_needed = 1, uses_anonymous_args = 0
 3448 1728 80B5     		push	{r7, lr}
 3449              	.LCFI99:
 3450              		.cfi_def_cfa_offset 8
 3451              		.cfi_offset 7, -8
 3452              		.cfi_offset 14, -4
 3453 172a 82B0     		sub	sp, sp, #8
 3454              	.LCFI100:
 3455              		.cfi_def_cfa_offset 16
 3456 172c 00AF     		add	r7, sp, #0
 3457              	.LCFI101:
 3458              		.cfi_def_cfa_register 7
 3459 172e 7860     		str	r0, [r7, #4]
1622:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1623:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1624:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXDATA);
 3460              		.loc 1 1624 0
 3461 1730 4FF03400 		mov	r0, #52
 3462 1734 FFF7FEFF 		bl	changeState
1625:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1626:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel rt3
1627:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 3463              		.loc 1 1627 0
 3464 1738 FFF7FEFF 		bl	radiotimer_cancel
1628:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1629:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
1630:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.lastCapturedTime = capturedTime;
 3465              		.loc 1 1630 0
 3466 173c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3467 1740 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3468 1744 7A68     		ldr	r2, [r7, #4]
 3469 1746 5A62     		str	r2, [r3, #36]
1631:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1632:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time to sync
1633:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.syncCapturedTime = capturedTime;
 3470              		.loc 1 1633 0
 3471 1748 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3472 174c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3473 1750 7A68     		ldr	r2, [r7, #4]
 3474 1752 9A62     		str	r2, [r3, #40]
1634:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1635:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt4);
 3475              		.loc 1 1635 0
 3476 1754 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3477 1758 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3478 175c 5B6A     		ldr	r3, [r3, #36]
 3479 175e 03F1A403 		add	r3, r3, #164
 3480 1762 1846     		mov	r0, r3
 3481 1764 FFF7FEFF 		bl	radiotimer_schedule
1636:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3482              		.loc 1 1636 0
 3483 1768 07F10807 		add	r7, r7, #8
 3484 176c BD46     		mov	sp, r7
 3485 176e 80BD     		pop	{r7, pc}
 3486              		.cfi_endproc
 3487              	.LFE43:
 3489              		.align	2
 3490              		.global	activity_csl_data_rie3
 3491              		.thumb
 3492              		.thumb_func
 3494              	activity_csl_data_rie3:
 3495              	.LFB44:
1637:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1638:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1639:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1640:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling error [data rie3].
1641:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1642:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #rt4 expiring, i.e. timer fires while state = S_CSLRXDATA. This is an error 
1643:openstack/02a-MAClow/IEEE802154Ecsl.c ****   transmit the data packet. The implemented behaviour is to log the error and move on the next CSL 
1644:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1645:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_rie3() {
 3496              		.loc 1 1645 0
 3497              		.cfi_startproc
 3498              		@ args = 0, pretend = 0, frame = 0
 3499              		@ frame_needed = 1, uses_anonymous_args = 0
 3500 1770 80B5     		push	{r7, lr}
 3501              	.LCFI102:
 3502              		.cfi_def_cfa_offset 8
 3503              		.cfi_offset 7, -8
 3504              		.cfi_offset 14, -4
 3505 1772 00AF     		add	r7, sp, #0
 3506              	.LCFI103:
 3507              		.cfi_def_cfa_register 7
1646:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1647:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
1648:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
1649:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state,
 3508              		.loc 1 1649 0
 3509 1774 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3510 1778 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3511 177c 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1648:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
 3512              		.loc 1 1648 0
 3513 177e 1A46     		mov	r2, r3
1650:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_dbg.num_cslSamples);
 3514              		.loc 1 1650 0
 3515 1780 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 3516 1784 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 3517 1788 1B69     		ldr	r3, [r3, #16]
1648:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
 3518              		.loc 1 1648 0
 3519 178a 9BB2     		uxth	r3, r3
 3520 178c 4FF00900 		mov	r0, #9
 3521 1790 4FF02601 		mov	r1, #38
 3522 1794 FFF7FEFF 		bl	openserial_printError
1651:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1652:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1653:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 3523              		.loc 1 1653 0
 3524 1798 FFF7FEFF 		bl	endOps
1654:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3525              		.loc 1 1654 0
 3526 179c 80BD     		pop	{r7, pc}
 3527              		.cfi_endproc
 3528              	.LFE44:
 3530 179e 00BF     		.align	2
 3531              		.global	activity_csl_data_ri5
 3532              		.thumb
 3533              		.thumb_func
 3535              	activity_csl_data_ri5:
 3536              	.LFB45:
1655:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1656:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1657:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri5].
1658:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1659:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_endOfFrame" function when a end of frame event 
1660:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change state, cancel #rt4, validate data frame, and transmit ACK.
1661:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1662:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri5(PORT_RADIOTIMER_WIDTH capturedTime) {
 3537              		.loc 1 1662 0
 3538              		.cfi_startproc
 3539              		@ args = 0, pretend = 0, frame = 80
 3540              		@ frame_needed = 1, uses_anonymous_args = 0
 3541 17a0 B0B5     		push	{r4, r5, r7, lr}
 3542              	.LCFI104:
 3543              		.cfi_def_cfa_offset 16
 3544              		.cfi_offset 4, -16
 3545              		.cfi_offset 5, -12
 3546              		.cfi_offset 7, -8
 3547              		.cfi_offset 14, -4
 3548 17a2 96B0     		sub	sp, sp, #88
 3549              	.LCFI105:
 3550              		.cfi_def_cfa_offset 104
 3551 17a4 02AF     		add	r7, sp, #8
 3552              	.LCFI106:
 3553              		.cfi_def_cfa 7, 96
 3554 17a6 7860     		str	r0, [r7, #4]
1663:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802154_header_iht ieee802514_header;
1664:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint16_t lenIE=0;
 3555              		.loc 1 1664 0
 3556 17a8 4FF00003 		mov	r3, #0
 3557 17ac FB81     		strh	r3, [r7, #14]	@ movhi
1665:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1666:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1667:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXACKOFFSET);
 3558              		.loc 1 1667 0
 3559 17ae 4FF03500 		mov	r0, #53
 3560 17b2 FFF7FEFF 		bl	changeState
1668:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1669:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel rt4
1670:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 3561              		.loc 1 1670 0
 3562 17b6 FFF7FEFF 		bl	radiotimer_cancel
1671:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1672:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // turn off the radio
1673:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rfOff();
 3563              		.loc 1 1673 0
 3564 17ba FFF7FEFF 		bl	radio_rfOff
1674:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnTics+=radio_getTimerValue()-ieee154e_vars.radioOnInit;
 3565              		.loc 1 1674 0
 3566 17be 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3567 17c2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3568 17c6 5C6B     		ldr	r4, [r3, #52]
 3569 17c8 FFF7FEFF 		bl	radio_getTimerValue
 3570 17cc 0246     		mov	r2, r0
 3571 17ce 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3572 17d2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3573 17d6 1B6B     		ldr	r3, [r3, #48]
 3574 17d8 D31A     		subs	r3, r2, r3
 3575 17da E218     		adds	r2, r4, r3
 3576 17dc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3577 17e0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3578 17e4 5A63     		str	r2, [r3, #52]
1675:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // get a buffer to put the (received) data in
1676:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.dataReceived = openqueue_getFreePacketBuffer(COMPONENT_IEEE802154E);
 3579              		.loc 1 1676 0
 3580 17e6 4FF00900 		mov	r0, #9
 3581 17ea FFF7FEFF 		bl	openqueue_getFreePacketBuffer
 3582 17ee 0246     		mov	r2, r0
 3583 17f0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3584 17f4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3585 17f8 9A61     		str	r2, [r3, #24]
1677:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.dataReceived==NULL) {
 3586              		.loc 1 1677 0
 3587 17fa 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3588 17fe C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3589 1802 9B69     		ldr	r3, [r3, #24]
 3590 1804 002B     		cmp	r3, #0
 3591 1806 0CD1     		bne	.L173
1678:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // log the error
1679:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openserial_printError(COMPONENT_IEEE802154E,ERR_NO_FREE_PACKET_BUFFER,
 3592              		.loc 1 1679 0
 3593 1808 4FF00900 		mov	r0, #9
 3594 180c 4FF02C01 		mov	r1, #44
 3595 1810 4FF00002 		mov	r2, #0
 3596 1814 4FF00003 		mov	r3, #0
 3597 1818 FFF7FEFF 		bl	openserial_printError
1680:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)0,
1681:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)0);
1682:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // abort
1683:openstack/02a-MAClow/IEEE802154Ecsl.c ****       endOps();
 3598              		.loc 1 1683 0
 3599 181c FFF7FEFF 		bl	endOps
 3600 1820 3CE1     		b	.L172
 3601              	.L173:
1684:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return;
1685:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
1686:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1687:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // declare ownership over that packet
1688:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.dataReceived->creator = COMPONENT_IEEE802154E;
 3602              		.loc 1 1688 0
 3603 1822 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3604 1826 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3605 182a 9B69     		ldr	r3, [r3, #24]
 3606 182c 4FF00902 		mov	r2, #9
 3607 1830 1A70     		strb	r2, [r3, #0]
1689:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.dataReceived->owner   = COMPONENT_IEEE802154E;
 3608              		.loc 1 1689 0
 3609 1832 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3610 1836 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3611 183a 9B69     		ldr	r3, [r3, #24]
 3612 183c 4FF00902 		mov	r2, #9
 3613 1840 5A70     		strb	r2, [r3, #1]
1690:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1691:openstack/02a-MAClow/IEEE802154Ecsl.c ****    /*
1692:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The do-while loop that follows is a little parsing trick.
1693:openstack/02a-MAClow/IEEE802154Ecsl.c ****    Because it contains a while(0) condition, it gets executed only once.
1694:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The behavior is:
1695:openstack/02a-MAClow/IEEE802154Ecsl.c ****    - if a break occurs inside the do{} body, the error code below the loop
1696:openstack/02a-MAClow/IEEE802154Ecsl.c ****      gets executed. This indicates something is wrong with the packet being
1697:openstack/02a-MAClow/IEEE802154Ecsl.c ****      parsed.
1698:openstack/02a-MAClow/IEEE802154Ecsl.c ****    - if a return occurs inside the do{} body, the error code below the loop
1699:openstack/02a-MAClow/IEEE802154Ecsl.c ****      does not get executed. This indicates the received packet is correct.
1700:openstack/02a-MAClow/IEEE802154Ecsl.c ****    */
1701:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1702:openstack/02a-MAClow/IEEE802154Ecsl.c ****    do { // this "loop" is only executed once
1703:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1704:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // retrieve the received data frame from the radio's Rx buffer
1705:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataReceived->payload = &(ieee154e_vars.dataReceived->packet[FIRST_FRAME_BYTE])
 3614              		.loc 1 1705 0
 3615 1842 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3616 1846 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3617 184a 9A69     		ldr	r2, [r3, #24]
 3618 184c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3619 1850 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3620 1854 9B69     		ldr	r3, [r3, #24]
 3621 1856 03F16C03 		add	r3, r3, #108
 3622 185a 5360     		str	r3, [r2, #4]
1706:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.dataReceived->payload,
 3623              		.loc 1 1706 0
 3624 185c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3625 1860 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3626 1864 9B69     		ldr	r3, [r3, #24]
 3627 1866 5968     		ldr	r1, [r3, #4]
1707:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.dataReceived->length,
 3628              		.loc 1 1707 0
 3629 1868 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3630 186c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3631 1870 9B69     		ldr	r3, [r3, #24]
1706:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.dataReceived->payload,
 3632              		.loc 1 1706 0
 3633 1872 03F10802 		add	r2, r3, #8
1708:openstack/02a-MAClow/IEEE802154Ecsl.c ****                              sizeof(ieee154e_vars.dataReceived->packet),
1709:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.dataReceived->l1_rssi,
 3634              		.loc 1 1709 0
 3635 1876 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3636 187a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3637 187e 9B69     		ldr	r3, [r3, #24]
1706:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.dataReceived->payload,
 3638              		.loc 1 1706 0
 3639 1880 03F16804 		add	r4, r3, #104
1710:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.dataReceived->l1_lqi,
 3640              		.loc 1 1710 0
 3641 1884 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3642 1888 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3643 188c 9B69     		ldr	r3, [r3, #24]
1706:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.dataReceived->payload,
 3644              		.loc 1 1706 0
 3645 188e 03F16900 		add	r0, r3, #105
1711:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.dataReceived->l1_crc);
 3646              		.loc 1 1711 0
 3647 1892 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3648 1896 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3649 189a 9B69     		ldr	r3, [r3, #24]
1706:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.dataReceived->payload,
 3650              		.loc 1 1706 0
 3651 189c 03F16A03 		add	r3, r3, #106
 3652 18a0 0090     		str	r0, [sp, #0]
 3653 18a2 0193     		str	r3, [sp, #4]
 3654 18a4 0846     		mov	r0, r1
 3655 18a6 1146     		mov	r1, r2
 3656 18a8 4FF08202 		mov	r2, #130
 3657 18ac 2346     		mov	r3, r4
 3658 18ae FFF7FEFF 		bl	radio_getReceivedFrame
1712:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1713:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // break if wrong length
1714:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.dataReceived->length<LENGTH_CRC || ieee154e_vars.dataReceived->length>LENGT
 3659              		.loc 1 1714 0
 3660 18b2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3661 18b6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3662 18ba 9B69     		ldr	r3, [r3, #24]
 3663 18bc 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 3664 18be 012B     		cmp	r3, #1
 3665 18c0 07D9     		bls	.L175
 3666              		.loc 1 1714 0 is_stmt 0 discriminator 1
 3667 18c2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3668 18c6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3669 18ca 9B69     		ldr	r3, [r3, #24]
 3670 18cc 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 3671 18ce 802B     		cmp	r3, #128
 3672 18d0 0ED9     		bls	.L176
 3673              	.L175:
1715:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // jump to the error code below this do-while loop
1716:openstack/02a-MAClow/IEEE802154Ecsl.c ****         openserial_printError(COMPONENT_IEEE802154E,ERR_INVALIDPACKETFROMRADIO,
1717:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)2,
1718:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             ieee154e_vars.dataReceived->length);
 3674              		.loc 1 1718 0 is_stmt 1
 3675 18d2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3676 18d6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3677 18da 9B69     		ldr	r3, [r3, #24]
 3678 18dc 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
1716:openstack/02a-MAClow/IEEE802154Ecsl.c ****         openserial_printError(COMPONENT_IEEE802154E,ERR_INVALIDPACKETFROMRADIO,
 3679              		.loc 1 1716 0
 3680 18de 4FF00900 		mov	r0, #9
 3681 18e2 4FF03701 		mov	r1, #55
 3682 18e6 4FF00202 		mov	r2, #2
 3683 18ea FFF7FEFF 		bl	openserial_printError
1719:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 3684              		.loc 1 1719 0
 3685 18ee C4E0     		b	.L177
 3686              	.L176:
1720:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1721:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1722:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // toss CRC (2 last bytes)
1723:openstack/02a-MAClow/IEEE802154Ecsl.c ****       packetfunctions_tossFooter(   ieee154e_vars.dataReceived, LENGTH_CRC);
 3687              		.loc 1 1723 0
 3688 18f0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3689 18f4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3690 18f8 9B69     		ldr	r3, [r3, #24]
 3691 18fa 1846     		mov	r0, r3
 3692 18fc 4FF00201 		mov	r1, #2
 3693 1900 FFF7FEFF 		bl	packetfunctions_tossFooter
1724:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1725:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // if CRC doesn't check, stop
1726:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.dataReceived->l1_crc==FALSE) {
 3694              		.loc 1 1726 0
 3695 1904 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3696 1908 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3697 190c 9B69     		ldr	r3, [r3, #24]
 3698 190e 93F86A30 		ldrb	r3, [r3, #106]	@ zero_extendqisi2
 3699 1912 83F00103 		eor	r3, r3, #1
 3700 1916 DBB2     		uxtb	r3, r3
 3701 1918 002B     		cmp	r3, #0
 3702 191a 40F0A980 		bne	.L185
 3703              	.L178:
1727:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // jump to the error code below this do-while loop
1728:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
1729:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1730:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1731:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // parse the IEEE802.15.4 header (RX DATA)
1732:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee802154_retrieveHeader(ieee154e_vars.dataReceived,&ieee802514_header);
 3704              		.loc 1 1732 0
 3705 191e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3706 1922 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3707 1926 9A69     		ldr	r2, [r3, #24]
 3708 1928 07F11003 		add	r3, r7, #16
 3709 192c 1046     		mov	r0, r2
 3710 192e 1946     		mov	r1, r3
 3711 1930 FFF7FEFF 		bl	ieee802154_retrieveHeader
1733:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1734:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // break if invalid IEEE802.15.4 header
1735:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee802514_header.valid==FALSE) {
 3712              		.loc 1 1735 0
 3713 1934 3B7C     		ldrb	r3, [r7, #16]	@ zero_extendqisi2
 3714 1936 83F00103 		eor	r3, r3, #1
 3715 193a DBB2     		uxtb	r3, r3
 3716 193c 002B     		cmp	r3, #0
 3717 193e 40F09980 		bne	.L186
 3718              	.L179:
1736:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // break from the do-while loop and execute the clean-up code below
1737:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
1738:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1739:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1740:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // store header details in packet buffer
1741:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataReceived->l2_frameType      = ieee802514_header.frameType;
 3719              		.loc 1 1741 0
 3720 1942 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3721 1946 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3722 194a 9B69     		ldr	r3, [r3, #24]
 3723 194c BA7C     		ldrb	r2, [r7, #18]	@ zero_extendqisi2
 3724 194e 83F84920 		strb	r2, [r3, #73]
1742:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataReceived->l2_dsn            = ieee802514_header.dsn;
 3725              		.loc 1 1742 0
 3726 1952 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3727 1956 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3728 195a 9B69     		ldr	r3, [r3, #24]
 3729 195c 7A7E     		ldrb	r2, [r7, #25]	@ zero_extendqisi2
 3730 195e 83F84A20 		strb	r2, [r3, #74]
1743:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataReceived->l2_IEListPresent  = ieee802514_header.ieListPresent;
 3731              		.loc 1 1743 0
 3732 1962 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3733 1966 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3734 196a 9B69     		ldr	r3, [r3, #24]
 3735 196c FA7D     		ldrb	r2, [r7, #23]	@ zero_extendqisi2
 3736 196e 83F86520 		strb	r2, [r3, #101]
1744:openstack/02a-MAClow/IEEE802154Ecsl.c ****       memcpy(&(ieee154e_vars.dataReceived->l2_nextORpreviousHop),&(ieee802514_header.src),sizeof(op
 3737              		.loc 1 1744 0
 3738 1972 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3739 1976 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3740 197a 9B69     		ldr	r3, [r3, #24]
 3741 197c 03F13803 		add	r3, r3, #56
 3742 1980 1D46     		mov	r5, r3
 3743 1982 07F13C04 		add	r4, r7, #60
 3744 1986 0FCC     		ldmia	r4!, {r0, r1, r2, r3}
 3745 1988 2860     		str	r0, [r5, #0]	@ unaligned
 3746 198a 6960     		str	r1, [r5, #4]	@ unaligned
 3747 198c AA60     		str	r2, [r5, #8]	@ unaligned
 3748 198e EB60     		str	r3, [r5, #12]	@ unaligned
 3749 1990 2378     		ldrb	r3, [r4, #0]
 3750 1992 2B74     		strb	r3, [r5, #16]
1745:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1746:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // toss the IEEE802.15.4 header
1747:openstack/02a-MAClow/IEEE802154Ecsl.c ****       packetfunctions_tossHeader(ieee154e_vars.dataReceived,ieee802514_header.headerLength);
 3751              		.loc 1 1747 0
 3752 1994 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3753 1998 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3754 199c 9A69     		ldr	r2, [r3, #24]
 3755 199e 7B7C     		ldrb	r3, [r7, #17]	@ zero_extendqisi2
 3756 19a0 1046     		mov	r0, r2
 3757 19a2 1946     		mov	r1, r3
 3758 19a4 FFF7FEFF 		bl	packetfunctions_tossHeader
1748:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1749:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // handle IEs xv poipoi
1750:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset join priority
1751:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // retrieve IE in sixtop
1752:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if ((ieee802514_header.valid==TRUE &&
 3759              		.loc 1 1752 0
 3760 19a8 3B7C     		ldrb	r3, [r7, #16]	@ zero_extendqisi2
1753:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header.ieListPresent==TRUE &&
1754:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header.frameType==IEEE154_TYPE_BEACON && // if it is not a beacon and have ie,
1755:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header.panid,idmanager_getMyID(ADDR_PANID)) &&
 3761              		.loc 1 1755 0
 3762 19aa 002B     		cmp	r3, #0
 3763 19ac 22D0     		beq	.L181
1753:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header.ieListPresent==TRUE &&
 3764              		.loc 1 1753 0
 3765 19ae FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
1752:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if ((ieee802514_header.valid==TRUE &&
 3766              		.loc 1 1752 0
 3767 19b0 002B     		cmp	r3, #0
 3768 19b2 1FD0     		beq	.L181
1754:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header.frameType==IEEE154_TYPE_BEACON && // if it is not a beacon and have ie,
 3769              		.loc 1 1754 0
 3770 19b4 BB7C     		ldrb	r3, [r7, #18]	@ zero_extendqisi2
1753:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header.ieListPresent==TRUE &&
 3771              		.loc 1 1753 0
 3772 19b6 002B     		cmp	r3, #0
 3773 19b8 1CD1     		bne	.L181
 3774              		.loc 1 1755 0
 3775 19ba 4FF00400 		mov	r0, #4
 3776 19be FFF7FEFF 		bl	idmanager_getMyID
 3777 19c2 0346     		mov	r3, r0
 3778 19c4 07F11002 		add	r2, r7, #16
 3779 19c8 02F10A02 		add	r2, r2, #10
 3780 19cc 1046     		mov	r0, r2
 3781 19ce 1946     		mov	r1, r3
 3782 19d0 FFF7FEFF 		bl	packetfunctions_sameAddress
 3783 19d4 0346     		mov	r3, r0
1754:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header.frameType==IEEE154_TYPE_BEACON && // if it is not a beacon and have ie,
 3784              		.loc 1 1754 0
 3785 19d6 002B     		cmp	r3, #0
 3786 19d8 0CD0     		beq	.L181
1756:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee154e_processIEs(ieee154e_vars.dataReceived,&lenIE))==FALSE) {
 3787              		.loc 1 1756 0
 3788 19da 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3789 19de C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3790 19e2 9A69     		ldr	r2, [r3, #24]
 3791 19e4 07F10E03 		add	r3, r7, #14
 3792 19e8 1046     		mov	r0, r2
 3793 19ea 1946     		mov	r1, r3
 3794 19ec FFF7FEFF 		bl	ieee154e_processIEs
 3795 19f0 0346     		mov	r3, r0
1755:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header.panid,idmanager_getMyID(ADDR_PANID)) &&
 3796              		.loc 1 1755 0
 3797 19f2 002B     		cmp	r3, #0
 3798              	.L181:
1757:openstack/02a-MAClow/IEEE802154Ecsl.c ****           //log  that the packet is not carrying IEs
1758:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1759:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1760:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // toss the IEs including Synch
1761:openstack/02a-MAClow/IEEE802154Ecsl.c ****       packetfunctions_tossHeader(ieee154e_vars.dataReceived,lenIE);
 3799              		.loc 1 1761 0
 3800 19f4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3801 19f8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3802 19fc 9A69     		ldr	r2, [r3, #24]
 3803 19fe FB89     		ldrh	r3, [r7, #14]
 3804 1a00 DBB2     		uxtb	r3, r3
 3805 1a02 1046     		mov	r0, r2
 3806 1a04 1946     		mov	r1, r3
 3807 1a06 FFF7FEFF 		bl	packetfunctions_tossHeader
1762:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1763:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // record the captured time
1764:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.lastCapturedTime = capturedTime;
 3808              		.loc 1 1764 0
 3809 1a0a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3810 1a0e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3811 1a12 7A68     		ldr	r2, [r7, #4]
 3812 1a14 5A62     		str	r2, [r3, #36]
1765:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1766:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // if I just received an invalid frame, stop
1767:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (isValidRxFrame(&ieee802514_header)==FALSE) {
 3813              		.loc 1 1767 0
 3814 1a16 07F11003 		add	r3, r7, #16
 3815 1a1a 1846     		mov	r0, r3
 3816 1a1c FFF7FEFF 		bl	isValidRxFrame
 3817 1a20 0346     		mov	r3, r0
 3818 1a22 83F00103 		eor	r3, r3, #1
 3819 1a26 DBB2     		uxtb	r3, r3
 3820 1a28 002B     		cmp	r3, #0
 3821 1a2a 25D1     		bne	.L187
 3822              	.L182:
1768:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // jump to the error code below this do-while loop
1769:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
1770:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1771:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1772:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // check if ack requested
1773:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee802514_header.ackRequested==1) {
 3823              		.loc 1 1773 0
 3824 1a2c 7B7D     		ldrb	r3, [r7, #21]	@ zero_extendqisi2
 3825 1a2e 002B     		cmp	r3, #0
 3826 1a30 0AD0     		beq	.L183
1774:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // arm rt5
1775:openstack/02a-MAClow/IEEE802154Ecsl.c ****          radiotimer_schedule(DURATION_rt5);
 3827              		.loc 1 1775 0
 3828 1a32 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3829 1a36 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3830 1a3a 5B6A     		ldr	r3, [r3, #36]
 3831 1a3c 03F17A03 		add	r3, r3, #122
 3832 1a40 1846     		mov	r0, r3
 3833 1a42 FFF7FEFF 		bl	radiotimer_schedule
 3834 1a46 29E0     		b	.L172
 3835              	.L183:
1776:openstack/02a-MAClow/IEEE802154Ecsl.c ****       } else {
1777:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // synchronize to the received packet if I'm not a DAGroot and this is my preferred parent
1778:openstack/02a-MAClow/IEEE802154Ecsl.c ****          //if (idmanager_getIsDAGroot()==FALSE && neighbors_isPreferredParent(&(ieee154e_vars.dataR
1779:openstack/02a-MAClow/IEEE802154Ecsl.c ****          //   synchronizePacket(ieee154e_vars.syncCapturedTime);
1780:openstack/02a-MAClow/IEEE802154Ecsl.c ****          //}
1781:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // indicate reception to upper layer (no ACK asked)
1782:openstack/02a-MAClow/IEEE802154Ecsl.c ****          notif_receive(ieee154e_vars.dataReceived, 1);
 3836              		.loc 1 1782 0
 3837 1a48 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3838 1a4c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3839 1a50 9B69     		ldr	r3, [r3, #24]
 3840 1a52 1846     		mov	r0, r3
 3841 1a54 4FF00101 		mov	r1, #1
 3842 1a58 FFF7FEFF 		bl	notif_receive
1783:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // reset local variable
1784:openstack/02a-MAClow/IEEE802154Ecsl.c ****          ieee154e_vars.dataReceived = NULL;
 3843              		.loc 1 1784 0
 3844 1a5c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3845 1a60 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3846 1a64 4FF00002 		mov	r2, #0
 3847 1a68 9A61     		str	r2, [r3, #24]
1785:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // abort
1786:openstack/02a-MAClow/IEEE802154Ecsl.c ****          endOps();
 3848              		.loc 1 1786 0
 3849 1a6a FFF7FEFF 		bl	endOps
 3850 1a6e 15E0     		b	.L172
 3851              	.L185:
1728:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 3852              		.loc 1 1728 0
 3853 1a70 00BF     		nop
 3854 1a72 02E0     		b	.L177
 3855              	.L186:
1737:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 3856              		.loc 1 1737 0
 3857 1a74 00BF     		nop
 3858 1a76 00E0     		b	.L177
 3859              	.L187:
1769:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 3860              		.loc 1 1769 0
 3861 1a78 00BF     		nop
 3862              	.L177:
1787:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1788:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1789:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // everything went well, return here not to execute the error code below
1790:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return;
1791:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1792:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } while(0);
1793:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1794:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // free the (invalid) received data so RAM memory can be recycled
1795:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openqueue_freePacketBuffer(ieee154e_vars.dataReceived);
 3863              		.loc 1 1795 0
 3864 1a7a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3865 1a7e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3866 1a82 9B69     		ldr	r3, [r3, #24]
 3867 1a84 1846     		mov	r0, r3
 3868 1a86 FFF7FEFF 		bl	openqueue_freePacketBuffer
1796:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1797:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clear local variable
1798:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.dataReceived = NULL;
 3869              		.loc 1 1798 0
 3870 1a8a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3871 1a8e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3872 1a92 4FF00002 		mov	r2, #0
 3873 1a96 9A61     		str	r2, [r3, #24]
1799:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1800:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1801:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 3874              		.loc 1 1801 0
 3875 1a98 FFF7FEFF 		bl	endOps
 3876              	.L172:
1802:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3877              		.loc 1 1802 0
 3878 1a9c 07F15007 		add	r7, r7, #80
 3879 1aa0 BD46     		mov	sp, r7
 3880 1aa2 B0BD     		pop	{r4, r5, r7, pc}
 3881              		.cfi_endproc
 3882              	.LFE45:
 3884              		.align	2
 3885              		.global	activity_csl_data_ri6
 3886              		.thumb
 3887              		.thumb_func
 3889              	activity_csl_data_ri6:
 3890              	.LFB46:
1803:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1804:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1805:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri6].
1806:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1807:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1808:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The functionality is to prepare the radio for ACK sending.
1809:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1810:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri6() {
 3891              		.loc 1 1810 0
 3892              		.cfi_startproc
 3893              		@ args = 0, pretend = 0, frame = 8
 3894              		@ frame_needed = 1, uses_anonymous_args = 0
 3895 1aa4 90B5     		push	{r4, r7, lr}
 3896              	.LCFI107:
 3897              		.cfi_def_cfa_offset 12
 3898              		.cfi_offset 4, -12
 3899              		.cfi_offset 7, -8
 3900              		.cfi_offset 14, -4
 3901 1aa6 87B0     		sub	sp, sp, #28
 3902              	.LCFI108:
 3903              		.cfi_def_cfa_offset 40
 3904 1aa8 04AF     		add	r7, sp, #16
 3905              	.LCFI109:
 3906              		.cfi_def_cfa 7, 24
1811:openstack/02a-MAClow/IEEE802154Ecsl.c ****    PORT_SIGNED_INT_WIDTH timeCorrection;
1812:openstack/02a-MAClow/IEEE802154Ecsl.c ****    header_IE_ht header_desc;
1813:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1814:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1815:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXACKPREPARE);
 3907              		.loc 1 1815 0
 3908 1aaa 4FF03600 		mov	r0, #54
 3909 1aae FFF7FEFF 		bl	changeState
1816:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1817:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // get a buffer to put the ack to send in
1818:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend = openqueue_getFreePacketBuffer(COMPONENT_IEEE802154E);
 3910              		.loc 1 1818 0
 3911 1ab2 4FF00900 		mov	r0, #9
 3912 1ab6 FFF7FEFF 		bl	openqueue_getFreePacketBuffer
 3913 1aba 0246     		mov	r2, r0
 3914 1abc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3915 1ac0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3916 1ac4 DA61     		str	r2, [r3, #28]
1819:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.ackToSend==NULL) {
 3917              		.loc 1 1819 0
 3918 1ac6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3919 1aca C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3920 1ace DB69     		ldr	r3, [r3, #28]
 3921 1ad0 002B     		cmp	r3, #0
 3922 1ad2 1DD1     		bne	.L189
1820:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // log the error
1821:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openserial_printError(COMPONENT_IEEE802154E,ERR_NO_FREE_PACKET_BUFFER, (errorparameter_t)0, (
 3923              		.loc 1 1821 0
 3924 1ad4 4FF00900 		mov	r0, #9
 3925 1ad8 4FF02C01 		mov	r1, #44
 3926 1adc 4FF00002 		mov	r2, #0
 3927 1ae0 4FF00003 		mov	r3, #0
 3928 1ae4 FFF7FEFF 		bl	openserial_printError
1822:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // indicate we received a packet anyway (we don't want to loose any)
1823:openstack/02a-MAClow/IEEE802154Ecsl.c ****       notif_receive(ieee154e_vars.dataReceived,2);
 3929              		.loc 1 1823 0
 3930 1ae8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3931 1aec C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3932 1af0 9B69     		ldr	r3, [r3, #24]
 3933 1af2 1846     		mov	r0, r3
 3934 1af4 4FF00201 		mov	r1, #2
 3935 1af8 FFF7FEFF 		bl	notif_receive
1824:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // free local variable
1825:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataReceived = NULL;
 3936              		.loc 1 1825 0
 3937 1afc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3938 1b00 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3939 1b04 4FF00002 		mov	r2, #0
 3940 1b08 9A61     		str	r2, [r3, #24]
1826:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // abort
1827:openstack/02a-MAClow/IEEE802154Ecsl.c ****       endOps();
 3941              		.loc 1 1827 0
 3942 1b0a FFF7FEFF 		bl	endOps
 3943 1b0e D3E0     		b	.L188
 3944              	.L189:
1828:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return;
1829:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
1830:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1831:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // declare ownership over that packet
1832:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend->creator = COMPONENT_IEEE802154E;
 3945              		.loc 1 1832 0
 3946 1b10 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3947 1b14 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3948 1b18 DB69     		ldr	r3, [r3, #28]
 3949 1b1a 4FF00902 		mov	r2, #9
 3950 1b1e 1A70     		strb	r2, [r3, #0]
1833:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend->owner   = COMPONENT_IEEE802154E;
 3951              		.loc 1 1833 0
 3952 1b20 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3953 1b24 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3954 1b28 DB69     		ldr	r3, [r3, #28]
 3955 1b2a 4FF00902 		mov	r2, #9
 3956 1b2e 5A70     		strb	r2, [r3, #1]
1834:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1835:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // calculate the time timeCorrection (this is the time when the packet arrive w.r.t the time it 
1836:openstack/02a-MAClow/IEEE802154Ecsl.c ****    timeCorrection = (PORT_SIGNED_INT_WIDTH)((PORT_SIGNED_INT_WIDTH)ieee154e_vars.syncCapturedTime-(
 3957              		.loc 1 1836 0
 3958 1b30 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3959 1b34 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3960 1b38 9B6A     		ldr	r3, [r3, #40]
 3961 1b3a A3F18303 		sub	r3, r3, #131
 3962 1b3e 7B60     		str	r3, [r7, #4]
1837:openstack/02a-MAClow/IEEE802154Ecsl.c ****     
1838:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // add the payload to the ACK (i.e. the timeCorrection)
1839:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packetfunctions_reserveHeaderSize(ieee154e_vars.ackToSend,sizeof(timecorrection_IE_ht));
 3963              		.loc 1 1839 0
 3964 1b40 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3965 1b44 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3966 1b48 DB69     		ldr	r3, [r3, #28]
 3967 1b4a 1846     		mov	r0, r3
 3968 1b4c 4FF00201 		mov	r1, #2
 3969 1b50 FFF7FEFF 		bl	packetfunctions_reserveHeaderSize
1840:openstack/02a-MAClow/IEEE802154Ecsl.c ****    timeCorrection  = -timeCorrection;
 3970              		.loc 1 1840 0
 3971 1b54 7B68     		ldr	r3, [r7, #4]
 3972 1b56 C3F10003 		rsb	r3, r3, #0
 3973 1b5a 7B60     		str	r3, [r7, #4]
1841:openstack/02a-MAClow/IEEE802154Ecsl.c ****    timeCorrection *= US_PER_TICK;
 3974              		.loc 1 1841 0
 3975 1b5c 7A68     		ldr	r2, [r7, #4]
 3976 1b5e 1346     		mov	r3, r2
 3977 1b60 4FEA0313 		lsl	r3, r3, #4
 3978 1b64 9B1A     		subs	r3, r3, r2
 3979 1b66 4FEA4303 		lsl	r3, r3, #1
 3980 1b6a 7B60     		str	r3, [r7, #4]
1842:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend->payload[0] = (uint8_t)((((uint16_t)timeCorrection)   ) & 0xff);
 3981              		.loc 1 1842 0
 3982 1b6c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3983 1b70 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3984 1b74 DB69     		ldr	r3, [r3, #28]
 3985 1b76 5B68     		ldr	r3, [r3, #4]
 3986 1b78 7A68     		ldr	r2, [r7, #4]
 3987 1b7a D2B2     		uxtb	r2, r2
 3988 1b7c 1A70     		strb	r2, [r3, #0]
1843:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend->payload[1] = (uint8_t)((((uint16_t)timeCorrection)>>8) & 0xff);
 3989              		.loc 1 1843 0
 3990 1b7e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3991 1b82 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3992 1b86 DB69     		ldr	r3, [r3, #28]
 3993 1b88 5B68     		ldr	r3, [r3, #4]
 3994 1b8a 03F10103 		add	r3, r3, #1
 3995 1b8e 7A68     		ldr	r2, [r7, #4]
 3996 1b90 92B2     		uxth	r2, r2
 3997 1b92 4FEA1222 		lsr	r2, r2, #8
 3998 1b96 92B2     		uxth	r2, r2
 3999 1b98 D2B2     		uxtb	r2, r2
 4000 1b9a 1A70     		strb	r2, [r3, #0]
1844:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1845:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // add header IE header -- xv poipoi -- pkt is filled in reverse order..
1846:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packetfunctions_reserveHeaderSize(ieee154e_vars.ackToSend,sizeof(header_IE_ht));
 4001              		.loc 1 1846 0
 4002 1b9c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4003 1ba0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4004 1ba4 DB69     		ldr	r3, [r3, #28]
 4005 1ba6 1846     		mov	r0, r3
 4006 1ba8 4FF00201 		mov	r1, #2
 4007 1bac FFF7FEFF 		bl	packetfunctions_reserveHeaderSize
1847:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //create the header for ack IE
1848:openstack/02a-MAClow/IEEE802154Ecsl.c ****    header_desc.length_elementid_type=(sizeof(timecorrection_IE_ht)<< IEEE802154E_DESC_LEN_HEADER_IE
 4008              		.loc 1 1848 0
 4009 1bb0 40F23C43 		movw	r3, #1084
 4010 1bb4 3B80     		strh	r3, [r7, #0]	@ movhi
1849:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                      (IEEE802154E_ACK_NACK_TIMECORRECTION_ELEMENTID << IEEE802154E_
1850:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                      IEEE802154E_DESC_TYPE_SHORT; 
1851:openstack/02a-MAClow/IEEE802154Ecsl.c ****    memcpy(ieee154e_vars.ackToSend->payload,&header_desc,sizeof(header_IE_ht));
 4011              		.loc 1 1851 0
 4012 1bb6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4013 1bba C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4014 1bbe DB69     		ldr	r3, [r3, #28]
 4015 1bc0 5B68     		ldr	r3, [r3, #4]
 4016 1bc2 3A46     		mov	r2, r7
 4017 1bc4 1288     		ldrh	r2, [r2, #0]	@ unaligned
 4018 1bc6 1A80     		strh	r2, [r3, #0]	@ unaligned
1852:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1853:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // prepend the IEEE802.15.4 header to the ACK
1854:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend->l2_frameType = IEEE154_TYPE_ACK;
 4019              		.loc 1 1854 0
 4020 1bc8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4021 1bcc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4022 1bd0 DB69     		ldr	r3, [r3, #28]
 4023 1bd2 4FF00202 		mov	r2, #2
 4024 1bd6 83F84920 		strb	r2, [r3, #73]
1855:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend->l2_dsn       = ieee154e_vars.dataReceived->l2_dsn;
 4025              		.loc 1 1855 0
 4026 1bda 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4027 1bde C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4028 1be2 DA69     		ldr	r2, [r3, #28]
 4029 1be4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4030 1be8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4031 1bec 9B69     		ldr	r3, [r3, #24]
 4032 1bee 93F84A30 		ldrb	r3, [r3, #74]	@ zero_extendqisi2
 4033 1bf2 82F84A30 		strb	r3, [r2, #74]
1856:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802154_prependHeader(ieee154e_vars.ackToSend,
 4034              		.loc 1 1856 0
 4035 1bf6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4036 1bfa C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4037 1bfe D969     		ldr	r1, [r3, #28]
1857:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             ieee154e_vars.ackToSend->l2_frameType,
 4038              		.loc 1 1857 0
 4039 1c00 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4040 1c04 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4041 1c08 DB69     		ldr	r3, [r3, #28]
1856:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802154_prependHeader(ieee154e_vars.ackToSend,
 4042              		.loc 1 1856 0
 4043 1c0a 93F84920 		ldrb	r2, [r3, #73]	@ zero_extendqisi2
1858:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             IEEE154_IELIST_YES,//ie in ack
1859:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             IEEE154_FRAMEVERSION,//enhanced ack
1860:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             IEEE154_SEC_NO_SECURITY,
1861:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             ieee154e_vars.dataReceived->l2_dsn,
 4044              		.loc 1 1861 0
 4045 1c0e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4046 1c12 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4047 1c16 9B69     		ldr	r3, [r3, #24]
1856:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802154_prependHeader(ieee154e_vars.ackToSend,
 4048              		.loc 1 1856 0
 4049 1c18 93F84A00 		ldrb	r0, [r3, #74]	@ zero_extendqisi2
1862:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             &(ieee154e_vars.dataReceived->l2_nextORpreviousHop)
 4050              		.loc 1 1862 0
 4051 1c1c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4052 1c20 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4053 1c24 9B69     		ldr	r3, [r3, #24]
1856:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802154_prependHeader(ieee154e_vars.ackToSend,
 4054              		.loc 1 1856 0
 4055 1c26 03F13803 		add	r3, r3, #56
 4056 1c2a 4FF00004 		mov	r4, #0
 4057 1c2e 0094     		str	r4, [sp, #0]
 4058 1c30 0190     		str	r0, [sp, #4]
 4059 1c32 0293     		str	r3, [sp, #8]
 4060 1c34 0846     		mov	r0, r1
 4061 1c36 1146     		mov	r1, r2
 4062 1c38 4FF00102 		mov	r2, #1
 4063 1c3c 4FF00203 		mov	r3, #2
 4064 1c40 FFF7FEFF 		bl	ieee802154_prependHeader
1863:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             );
1864:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1865:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // space for 2-byte CRC
1866:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packetfunctions_reserveFooterSize(ieee154e_vars.ackToSend,2);
 4065              		.loc 1 1866 0
 4066 1c44 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4067 1c48 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4068 1c4c DB69     		ldr	r3, [r3, #28]
 4069 1c4e 1846     		mov	r0, r3
 4070 1c50 4FF00201 		mov	r1, #2
 4071 1c54 FFF7FEFF 		bl	packetfunctions_reserveFooterSize
1867:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1868:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // load the packet in the radio's Tx buffer
1869:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_loadPacket(ieee154e_vars.ackToSend->payload,
 4072              		.loc 1 1869 0
 4073 1c58 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4074 1c5c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4075 1c60 DB69     		ldr	r3, [r3, #28]
 4076 1c62 5A68     		ldr	r2, [r3, #4]
1870:openstack/02a-MAClow/IEEE802154Ecsl.c ****                     ieee154e_vars.ackToSend->length);
 4077              		.loc 1 1870 0
 4078 1c64 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4079 1c68 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4080 1c6c DB69     		ldr	r3, [r3, #28]
1869:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_loadPacket(ieee154e_vars.ackToSend->payload,
 4081              		.loc 1 1869 0
 4082 1c6e 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4083 1c70 1046     		mov	r0, r2
 4084 1c72 1946     		mov	r1, r3
 4085 1c74 FFF7FEFF 		bl	radio_loadPacket
1871:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1872:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // enable the radio in Tx mode. This does not send that packet.
1873:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_txEnable();
 4086              		.loc 1 1873 0
 4087 1c78 FFF7FEFF 		bl	radio_txEnable
1874:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnInit=radio_getTimerValue();
 4088              		.loc 1 1874 0
 4089 1c7c FFF7FEFF 		bl	radio_getTimerValue
 4090 1c80 0246     		mov	r2, r0
 4091 1c82 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4092 1c86 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4093 1c8a 1A63     		str	r2, [r3, #48]
1875:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnThisSlot=TRUE;
 4094              		.loc 1 1875 0
 4095 1c8c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4096 1c90 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4097 1c94 4FF00102 		mov	r2, #1
 4098 1c98 83F83820 		strb	r2, [r3, #56]
1876:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt6
1877:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt6);
 4099              		.loc 1 1877 0
 4100 1c9c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4101 1ca0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4102 1ca4 5B6A     		ldr	r3, [r3, #36]
 4103 1ca6 03F19003 		add	r3, r3, #144
 4104 1caa 1846     		mov	r0, r3
 4105 1cac FFF7FEFF 		bl	radiotimer_schedule
1878:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1879:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1880:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXACKREADY);
 4106              		.loc 1 1880 0
 4107 1cb0 4FF03700 		mov	r0, #55
 4108 1cb4 FFF7FEFF 		bl	changeState
 4109              	.L188:
1881:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4110              		.loc 1 1881 0
 4111 1cb8 07F10C07 		add	r7, r7, #12
 4112 1cbc BD46     		mov	sp, r7
 4113 1cbe 90BD     		pop	{r4, r7, pc}
 4114              		.cfi_endproc
 4115              	.LFE46:
 4117              		.align	2
 4118              		.global	activity_csl_data_rie4
 4119              		.thumb
 4120              		.thumb_func
 4122              	activity_csl_data_rie4:
 4123              	.LFB47:
1882:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1883:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1884:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data rie4].
1885:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1886:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1887:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The functionality is to prepare the radio for ACK sending.
1888:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1889:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_rie4() {
 4124              		.loc 1 1889 0
 4125              		.cfi_startproc
 4126              		@ args = 0, pretend = 0, frame = 0
 4127              		@ frame_needed = 1, uses_anonymous_args = 0
 4128 1cc0 80B5     		push	{r7, lr}
 4129              	.LCFI110:
 4130              		.cfi_def_cfa_offset 8
 4131              		.cfi_offset 7, -8
 4132              		.cfi_offset 14, -4
 4133 1cc2 00AF     		add	r7, sp, #0
 4134              	.LCFI111:
 4135              		.cfi_def_cfa_register 7
1890:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
1891:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXACKPREPARE_OVERFLOWS,
1892:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		                 (errorparameter_t)ieee154e_vars.state,
 4136              		.loc 1 1892 0
 4137 1cc4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4138 1cc8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4139 1ccc 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1891:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXACKPREPARE_OVERFLOWS,
 4140              		.loc 1 1891 0
 4141 1cce 1A46     		mov	r2, r3
1893:openstack/02a-MAClow/IEEE802154Ecsl.c **** 						 (errorparameter_t)ieee154e_dbg.num_cslSamples);
 4142              		.loc 1 1893 0
 4143 1cd0 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 4144 1cd4 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 4145 1cd8 1B69     		ldr	r3, [r3, #16]
1891:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXACKPREPARE_OVERFLOWS,
 4146              		.loc 1 1891 0
 4147 1cda 9BB2     		uxth	r3, r3
 4148 1cdc 4FF00900 		mov	r0, #9
 4149 1ce0 4FF02501 		mov	r1, #37
 4150 1ce4 FFF7FEFF 		bl	openserial_printError
1894:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1895:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1896:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 4151              		.loc 1 1896 0
 4152 1ce8 FFF7FEFF 		bl	endOps
1897:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4153              		.loc 1 1897 0
 4154 1cec 80BD     		pop	{r7, pc}
 4155              		.cfi_endproc
 4156              	.LFE47:
 4158 1cee 00BF     		.align	2
 4159              		.global	activity_csl_data_ri7
 4160              		.thumb
 4161              		.thumb_func
 4163              	activity_csl_data_ri7:
 4164              	.LFB48:
1898:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1899:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1900:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri7].
1901:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1902:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1903:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The radio is configured and this interrupt gives it the "go" signal to start listening.
1904:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1905:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri7() {
 4165              		.loc 1 1905 0
 4166              		.cfi_startproc
 4167              		@ args = 0, pretend = 0, frame = 0
 4168              		@ frame_needed = 1, uses_anonymous_args = 0
 4169 1cf0 80B5     		push	{r7, lr}
 4170              	.LCFI112:
 4171              		.cfi_def_cfa_offset 8
 4172              		.cfi_offset 7, -8
 4173              		.cfi_offset 14, -4
 4174 1cf2 00AF     		add	r7, sp, #0
 4175              	.LCFI113:
 4176              		.cfi_def_cfa_register 7
1906:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1907:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXACKDELAY);
 4177              		.loc 1 1907 0
 4178 1cf4 4FF03800 		mov	r0, #56
 4179 1cf8 FFF7FEFF 		bl	changeState
1908:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1909:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt7
1910:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt7);
 4180              		.loc 1 1910 0
 4181 1cfc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4182 1d00 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4183 1d04 5B6A     		ldr	r3, [r3, #36]
 4184 1d06 03F1B103 		add	r3, r3, #177
 4185 1d0a 1846     		mov	r0, r3
 4186 1d0c FFF7FEFF 		bl	radiotimer_schedule
1911:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1912:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // give the 'go' to transmit
1913:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_txNow(); 
 4187              		.loc 1 1913 0
 4188 1d10 FFF7FEFF 		bl	radio_txNow
1914:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4189              		.loc 1 1914 0
 4190 1d14 80BD     		pop	{r7, pc}
 4191              		.cfi_endproc
 4192              	.LFE48:
 4194 1d16 00BF     		.align	2
 4195              		.global	activity_csl_data_rie5
 4196              		.thumb
 4197              		.thumb_func
 4199              	activity_csl_data_rie5:
 4200              	.LFB49:
1915:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1916:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1917:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data rie5].
1918:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1919:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1920:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The functionality is to prepare the radio for ACK sending.
1921:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1922:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_rie5() {
 4201              		.loc 1 1922 0
 4202              		.cfi_startproc
 4203              		@ args = 0, pretend = 0, frame = 0
 4204              		@ frame_needed = 1, uses_anonymous_args = 0
 4205 1d18 80B5     		push	{r7, lr}
 4206              	.LCFI114:
 4207              		.cfi_def_cfa_offset 8
 4208              		.cfi_offset 7, -8
 4209              		.cfi_offset 14, -4
 4210 1d1a 00AF     		add	r7, sp, #0
 4211              	.LCFI115:
 4212              		.cfi_def_cfa_register 7
1923:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
1924:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIOTX_OVERFLOWS,
1925:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state,
 4213              		.loc 1 1925 0
 4214 1d1c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4215 1d20 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4216 1d24 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1924:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIOTX_OVERFLOWS,
 4217              		.loc 1 1924 0
 4218 1d26 1A46     		mov	r2, r3
1926:openstack/02a-MAClow/IEEE802154Ecsl.c **** 						 (errorparameter_t)ieee154e_dbg.num_cslSamples);
 4219              		.loc 1 1926 0
 4220 1d28 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 4221 1d2c C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 4222 1d30 1B69     		ldr	r3, [r3, #16]
1924:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIOTX_OVERFLOWS,
 4223              		.loc 1 1924 0
 4224 1d32 9BB2     		uxth	r3, r3
 4225 1d34 4FF00900 		mov	r0, #9
 4226 1d38 4FF02801 		mov	r1, #40
 4227 1d3c FFF7FEFF 		bl	openserial_printError
1927:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1928:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 4228              		.loc 1 1928 0
 4229 1d40 FFF7FEFF 		bl	endOps
1929:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4230              		.loc 1 1929 0
 4231 1d44 80BD     		pop	{r7, pc}
 4232              		.cfi_endproc
 4233              	.LFE49:
 4235 1d46 00BF     		.align	2
 4236              		.global	activity_csl_data_ri8
 4237              		.thumb
 4238              		.thumb_func
 4240              	activity_csl_data_ri8:
 4241              	.LFB50:
1930:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1931:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1932:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri8].
1933:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1934:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_startOfFrame" function when a start of frame ev
1935:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change the state to set transmission, cancel #rt7 and arm #rt8 (max time 
1936:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1937:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri8(PORT_RADIOTIMER_WIDTH capturedTime) {
 4242              		.loc 1 1937 0
 4243              		.cfi_startproc
 4244              		@ args = 0, pretend = 0, frame = 8
 4245              		@ frame_needed = 1, uses_anonymous_args = 0
 4246 1d48 80B5     		push	{r7, lr}
 4247              	.LCFI116:
 4248              		.cfi_def_cfa_offset 8
 4249              		.cfi_offset 7, -8
 4250              		.cfi_offset 14, -4
 4251 1d4a 82B0     		sub	sp, sp, #8
 4252              	.LCFI117:
 4253              		.cfi_def_cfa_offset 16
 4254 1d4c 00AF     		add	r7, sp, #0
 4255              	.LCFI118:
 4256              		.cfi_def_cfa_register 7
 4257 1d4e 7860     		str	r0, [r7, #4]
1938:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1939:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXACK);
 4258              		.loc 1 1939 0
 4259 1d50 4FF03900 		mov	r0, #57
 4260 1d54 FFF7FEFF 		bl	changeState
1940:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1941:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel rt7
1942:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 4261              		.loc 1 1942 0
 4262 1d58 FFF7FEFF 		bl	radiotimer_cancel
1943:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1944:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
1945:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.lastCapturedTime = capturedTime;
 4263              		.loc 1 1945 0
 4264 1d5c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4265 1d60 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4266 1d64 7A68     		ldr	r2, [r7, #4]
 4267 1d66 5A62     		str	r2, [r3, #36]
1946:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1947:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt8
1948:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt8);
 4268              		.loc 1 1948 0
 4269 1d68 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4270 1d6c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4271 1d70 5B6A     		ldr	r3, [r3, #36]
 4272 1d72 03F16203 		add	r3, r3, #98
 4273 1d76 1846     		mov	r0, r3
 4274 1d78 FFF7FEFF 		bl	radiotimer_schedule
1949:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4275              		.loc 1 1949 0
 4276 1d7c 07F10807 		add	r7, r7, #8
 4277 1d80 BD46     		mov	sp, r7
 4278 1d82 80BD     		pop	{r7, pc}
 4279              		.cfi_endproc
 4280              	.LFE50:
 4282              		.align	2
 4283              		.global	activity_csl_data_rie6
 4284              		.thumb
 4285              		.thumb_func
 4287              	activity_csl_data_rie6:
 4288              	.LFB51:
1950:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1951:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1952:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data rie6].
1953:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1954:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1955:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to register an error when timer for sent ACK has expired.
1956:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1957:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_rie6() {
 4289              		.loc 1 1957 0
 4290              		.cfi_startproc
 4291              		@ args = 0, pretend = 0, frame = 0
 4292              		@ frame_needed = 1, uses_anonymous_args = 0
 4293 1d84 80B5     		push	{r7, lr}
 4294              	.LCFI119:
 4295              		.cfi_def_cfa_offset 8
 4296              		.cfi_offset 7, -8
 4297              		.cfi_offset 14, -4
 4298 1d86 00AF     		add	r7, sp, #0
 4299              	.LCFI120:
 4300              		.cfi_def_cfa_register 7
1958:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
1959:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDACKDURATION_OVERFLOWS,
1960:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state,
 4301              		.loc 1 1960 0
 4302 1d88 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4303 1d8c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4304 1d90 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1959:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDACKDURATION_OVERFLOWS,
 4305              		.loc 1 1959 0
 4306 1d92 1A46     		mov	r2, r3
1961:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_dbg.num_cslSamples);
 4307              		.loc 1 1961 0
 4308 1d94 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 4309 1d98 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 4310 1d9c 1B69     		ldr	r3, [r3, #16]
1959:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDACKDURATION_OVERFLOWS,
 4311              		.loc 1 1959 0
 4312 1d9e 9BB2     		uxth	r3, r3
 4313 1da0 4FF00900 		mov	r0, #9
 4314 1da4 4FF02901 		mov	r1, #41
 4315 1da8 FFF7FEFF 		bl	openserial_printError
1962:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1963:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 4316              		.loc 1 1963 0
 4317 1dac FFF7FEFF 		bl	endOps
1964:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4318              		.loc 1 1964 0
 4319 1db0 80BD     		pop	{r7, pc}
 4320              		.cfi_endproc
 4321              	.LFE51:
 4323 1db2 00BF     		.align	2
 4324              		.global	activity_csl_data_ri9
 4325              		.thumb
 4326              		.thumb_func
 4328              	activity_csl_data_ri9:
 4329              	.LFB52:
1965:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1966:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1967:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri9].
1968:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1969:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_endOfFrame" function when a end of frame event 
1970:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change the state, cancel #rt8, free ack packet and notify upper layer.
1971:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1972:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri9(PORT_RADIOTIMER_WIDTH capturedTime) {
 4330              		.loc 1 1972 0
 4331              		.cfi_startproc
 4332              		@ args = 0, pretend = 0, frame = 8
 4333              		@ frame_needed = 1, uses_anonymous_args = 0
 4334 1db4 80B5     		push	{r7, lr}
 4335              	.LCFI121:
 4336              		.cfi_def_cfa_offset 8
 4337              		.cfi_offset 7, -8
 4338              		.cfi_offset 14, -4
 4339 1db6 82B0     		sub	sp, sp, #8
 4340              	.LCFI122:
 4341              		.cfi_def_cfa_offset 16
 4342 1db8 00AF     		add	r7, sp, #0
 4343              	.LCFI123:
 4344              		.cfi_def_cfa_register 7
 4345 1dba 7860     		str	r0, [r7, #4]
1973:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1974:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXPROC);
 4346              		.loc 1 1974 0
 4347 1dbc 4FF03A00 		mov	r0, #58
 4348 1dc0 FFF7FEFF 		bl	changeState
1975:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1976:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel rt8
1977:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 4349              		.loc 1 1977 0
 4350 1dc4 FFF7FEFF 		bl	radiotimer_cancel
1978:openstack/02a-MAClow/IEEE802154Ecsl.c ****   
1979:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
1980:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.lastCapturedTime = capturedTime;
 4351              		.loc 1 1980 0
 4352 1dc8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4353 1dcc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4354 1dd0 7A68     		ldr	r2, [r7, #4]
 4355 1dd2 5A62     		str	r2, [r3, #36]
1981:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1982:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // free the ack we just sent so corresponding RAM memory can be recycled
1983:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openqueue_freePacketBuffer(ieee154e_vars.ackToSend);
 4356              		.loc 1 1983 0
 4357 1dd4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4358 1dd8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4359 1ddc DB69     		ldr	r3, [r3, #28]
 4360 1dde 1846     		mov	r0, r3
 4361 1de0 FFF7FEFF 		bl	openqueue_freePacketBuffer
1984:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1985:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clear local variable
1986:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend = NULL;
 4362              		.loc 1 1986 0
 4363 1de4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4364 1de8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4365 1dec 4FF00002 		mov	r2, #0
 4366 1df0 DA61     		str	r2, [r3, #28]
1987:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1988:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // synchronize to the received packet
1989:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //if (idmanager_getIsDAGroot()==FALSE && neighbors_isPreferredParent(&(ieee154e_vars.dataReceive
1990:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   synchronizePacket(ieee154e_vars.syncCapturedTime);
1991:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //}
1992:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1993:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // inform upper layer of reception (after ACK sent)
1994:openstack/02a-MAClow/IEEE802154Ecsl.c ****    notif_receive(ieee154e_vars.dataReceived,3);
 4367              		.loc 1 1994 0
 4368 1df2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4369 1df6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4370 1dfa 9B69     		ldr	r3, [r3, #24]
 4371 1dfc 1846     		mov	r0, r3
 4372 1dfe 4FF00301 		mov	r1, #3
 4373 1e02 FFF7FEFF 		bl	notif_receive
1995:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1996:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clear local variable
1997:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.dataReceived = NULL;
 4374              		.loc 1 1997 0
 4375 1e06 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4376 1e0a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4377 1e0e 4FF00002 		mov	r2, #0
 4378 1e12 9A61     		str	r2, [r3, #24]
1998:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1999:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // official end of Rx slot
2000:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 4379              		.loc 1 2000 0
 4380 1e14 FFF7FEFF 		bl	endOps
2001:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4381              		.loc 1 2001 0
 4382 1e18 07F10807 		add	r7, r7, #8
 4383 1e1c BD46     		mov	sp, r7
 4384 1e1e 80BD     		pop	{r7, pc}
 4385              		.cfi_endproc
 4386              	.LFE52:
 4388              		.align	2
 4389              		.global	ieee802154_createWakeUpFrame
 4390              		.thumb
 4391              		.thumb_func
 4393              	ieee802154_createWakeUpFrame:
 4394              	.LFB53:
2002:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2003:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2004:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2005:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================= WAKE-UP FRAMES ===============================
2006:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2007:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2008:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2009:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Prepend the IEEE802.15.4 MAC Wake-Up header to a (to be transmitted) packet.
2010:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2011:openstack/02a-MAClow/IEEE802154Ecsl.c **** Note that we are writing the field from the end of the header to the beginning.
2012:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2013:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in,out] msg              The message to append the header to.
2014:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in]     sequenceNumber   Sequence number of this frame.
2015:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in]     nextHop          Address of the next hop
2016:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in]     rztime           Rendezvoud time
2017:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2018:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2019:openstack/02a-MAClow/IEEE802154Ecsl.c **** void ieee802154_createWakeUpFrame(OpenQueueEntry_t*		msg,
2020:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                   uint8_t           	sequenceNumber,
2021:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                   open_addr_t*        	nextHop,
2022:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							      uint16_t				rztime) {
 4395              		.loc 1 2022 0
 4396              		.cfi_startproc
 4397              		@ args = 0, pretend = 0, frame = 40
 4398              		@ frame_needed = 1, uses_anonymous_args = 0
 4399 1e20 80B5     		push	{r7, lr}
 4400              	.LCFI124:
 4401              		.cfi_def_cfa_offset 8
 4402              		.cfi_offset 7, -8
 4403              		.cfi_offset 14, -4
 4404 1e22 8AB0     		sub	sp, sp, #40
 4405              	.LCFI125:
 4406              		.cfi_def_cfa_offset 48
 4407 1e24 00AF     		add	r7, sp, #0
 4408              	.LCFI126:
 4409              		.cfi_def_cfa_register 7
 4410 1e26 F860     		str	r0, [r7, #12]
 4411 1e28 7A60     		str	r2, [r7, #4]
 4412 1e2a 0A46     		mov	r2, r1
 4413 1e2c FA72     		strb	r2, [r7, #11]
 4414 1e2e 3B81     		strh	r3, [r7, #8]	@ movhi
2023:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2024:openstack/02a-MAClow/IEEE802154Ecsl.c ****     open_addr_t	nextHop16b;
2025:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2026:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// La estructura de una trama Wake-Up es la siguiente:
2027:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//
2028:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   - FRAME CONTROL: 1 byte
2029:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   - SEQ NUMBER (macDSN): 1 byte
2030:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   - PAN ID: 2 bytes
2031:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   - DEST ADDR: 2 bytes
2032:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   - RZ TIME IE: 2 bytes
2033:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   - IE LIST TERMINATOR: 2 bytes
2034:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//
2035:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//  | FRAME   |  SEQ   | PAN | DEST | RZ TIME  | IE LIST    |
2036:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//  | CONTROL | NUMBER |  ID | ADDR |  HDR IE  | TERMINATOR |
2037:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//
2038:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2039:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// Empezamos a escribir el payload de la trama wake-up empezando del final hacia adelante.
2040:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2041:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// IE LIST TERMINATOR, formado por 2 bytes con la siguiente estructura (0x3F80 o 0x3F00)
2042:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  - b0-b6 (Length) = 0
2043:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  - b7-b14 (Element ID) = 0x7e o 0x7f
2044:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  - b15 (Type) = 0
2045:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //
2046:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  b15 | b14 | b13 | b12 | b11 | b10 | b9 | b8 | b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 |
2047:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //   0  |  0  |  1  |  1  |  1  |  1  | 1  | 1  |  0 |  0 |  0 |  0 |  0 |  0 |  0 |  0 |
2048:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	packetfunctions_reserveHeaderSize(msg,sizeof(uint16_t));
 4415              		.loc 1 2048 0
 4416 1e30 F868     		ldr	r0, [r7, #12]
 4417 1e32 4FF00201 		mov	r1, #2
 4418 1e36 FFF7FEFF 		bl	packetfunctions_reserveHeaderSize
2049:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	*((uint16_t*)(msg->payload)) = 0x3F00;  // Element ID = 0x7e
 4419              		.loc 1 2049 0
 4420 1e3a FB68     		ldr	r3, [r7, #12]
 4421 1e3c 5B68     		ldr	r3, [r3, #4]
 4422 1e3e 4FF47C52 		mov	r2, #16128
 4423 1e42 1A80     		strh	r2, [r3, #0]	@ movhi
2050:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2051:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// RZ TIME IE, formado por 4 bytes con la siguiente estructura (0x0E82)
2052:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  - b0-b6 (Length) = 2
2053:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  - b7-b14 (Element ID) = 0x1D
2054:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  - b15 (Type) = 0
2055:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  - b16-b31 (IE Content) = time (2 bytes)
2056:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //
2057:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  b15 | b14 | b13 | b12 | b11 | b10 | b9 | b8 | b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 |
2058:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //   0  |  0  |  0  |  0  |  1  |  1  |  1 |  0 |  1 |  0 |  0 |  0 |  0 |  0 |  1 |  0 |
2059:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2060:openstack/02a-MAClow/IEEE802154Ecsl.c ****  	// rz time ie body (time)
2061:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	packetfunctions_reserveHeaderSize(msg,sizeof(uint16_t));
 4424              		.loc 1 2061 0
 4425 1e44 F868     		ldr	r0, [r7, #12]
 4426 1e46 4FF00201 		mov	r1, #2
 4427 1e4a FFF7FEFF 		bl	packetfunctions_reserveHeaderSize
2062:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	*((uint16_t*)(msg->payload)) = rztime;
 4428              		.loc 1 2062 0
 4429 1e4e FB68     		ldr	r3, [r7, #12]
 4430 1e50 5B68     		ldr	r3, [r3, #4]
 4431 1e52 3A89     		ldrh	r2, [r7, #8]	@ movhi
 4432 1e54 1A80     		strh	r2, [r3, #0]	@ movhi
2063:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2064:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// rz time ie header
2065:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	packetfunctions_reserveHeaderSize(msg,sizeof(uint16_t));
 4433              		.loc 1 2065 0
 4434 1e56 F868     		ldr	r0, [r7, #12]
 4435 1e58 4FF00201 		mov	r1, #2
 4436 1e5c FFF7FEFF 		bl	packetfunctions_reserveHeaderSize
2066:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	*((uint16_t*)(msg->payload)) = 0x0E82;
 4437              		.loc 1 2066 0
 4438 1e60 FB68     		ldr	r3, [r7, #12]
 4439 1e62 5B68     		ldr	r3, [r3, #4]
 4440 1e64 40F68262 		movw	r2, #3714
 4441 1e68 1A80     		strh	r2, [r3, #0]	@ movhi
2067:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2068:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// DEST ADDR
2069:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	if (nextHop->type == ADDR_16B) {
 4442              		.loc 1 2069 0
 4443 1e6a 7B68     		ldr	r3, [r7, #4]
 4444 1e6c 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 4445 1e6e 012B     		cmp	r3, #1
 4446 1e70 06D1     		bne	.L198
2070:openstack/02a-MAClow/IEEE802154Ecsl.c ****   	   packetfunctions_writeAddress(msg,nextHop,OW_LITTLE_ENDIAN);
 4447              		.loc 1 2070 0
 4448 1e72 F868     		ldr	r0, [r7, #12]
 4449 1e74 7968     		ldr	r1, [r7, #4]
 4450 1e76 4FF00102 		mov	r2, #1
 4451 1e7a FFF7FEFF 		bl	packetfunctions_writeAddress
 4452 1e7e 11E0     		b	.L199
 4453              	.L198:
2071:openstack/02a-MAClow/IEEE802154Ecsl.c ****     } else if (nextHop->type == ADDR_64B) {
 4454              		.loc 1 2071 0
 4455 1e80 7B68     		ldr	r3, [r7, #4]
 4456 1e82 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 4457 1e84 022B     		cmp	r3, #2
 4458 1e86 0DD1     		bne	.L199
2072:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   packetfunctions_mac64bToMac16b(nextHop, &nextHop16b);
 4459              		.loc 1 2072 0
 4460 1e88 07F11403 		add	r3, r7, #20
 4461 1e8c 7868     		ldr	r0, [r7, #4]
 4462 1e8e 1946     		mov	r1, r3
 4463 1e90 FFF7FEFF 		bl	packetfunctions_mac64bToMac16b
2073:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   packetfunctions_writeAddress(msg,&nextHop16b,OW_LITTLE_ENDIAN);
 4464              		.loc 1 2073 0
 4465 1e94 07F11403 		add	r3, r7, #20
 4466 1e98 F868     		ldr	r0, [r7, #12]
 4467 1e9a 1946     		mov	r1, r3
 4468 1e9c 4FF00102 		mov	r2, #1
 4469 1ea0 FFF7FEFF 		bl	packetfunctions_writeAddress
 4470              	.L199:
2074:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	}
2075:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2076:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// PAN ID
2077:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	packetfunctions_writeAddress(msg,idmanager_getMyID(ADDR_PANID),OW_LITTLE_ENDIAN);
 4471              		.loc 1 2077 0
 4472 1ea4 4FF00400 		mov	r0, #4
 4473 1ea8 FFF7FEFF 		bl	idmanager_getMyID
 4474 1eac 0346     		mov	r3, r0
 4475 1eae F868     		ldr	r0, [r7, #12]
 4476 1eb0 1946     		mov	r1, r3
 4477 1eb2 4FF00102 		mov	r2, #1
 4478 1eb6 FFF7FEFF 		bl	packetfunctions_writeAddress
2078:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2079:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// SEQ NUMBER
2080:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	packetfunctions_reserveHeaderSize(msg,sizeof(uint8_t));
 4479              		.loc 1 2080 0
 4480 1eba F868     		ldr	r0, [r7, #12]
 4481 1ebc 4FF00101 		mov	r1, #1
 4482 1ec0 FFF7FEFF 		bl	packetfunctions_reserveHeaderSize
2081:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	*((uint8_t*)(msg->payload)) = sequenceNumber;
 4483              		.loc 1 2081 0
 4484 1ec4 FB68     		ldr	r3, [r7, #12]
 4485 1ec6 5B68     		ldr	r3, [r3, #4]
 4486 1ec8 FA7A     		ldrb	r2, [r7, #11]
 4487 1eca 1A70     		strb	r2, [r3, #0]
2082:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2083:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// La estructura del FCF en la trama de wake-up es 0x55 = 01010101b:
2084:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// b0-b2 -- Frame Type (debe ser 101 para trama wake-up)
2085:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// b3 ----- Long Frame Control (debe ser 0 para indicar que se trata de un FCF de 1 byte como es e
2086:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// b4-b5 -- Dest Addr Mode (en este caso, short address por lo que tiene que valer 10).
2087:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// b6-b7 -- Src Addr Mode (en este caso, short address por lo que tiene que valer 10).
2088:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2089:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//  b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 |
2090:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   0 |  1 |  0 |  1 |  0 |  1 |  0 |  1 |
2091:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2092:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// FCF
2093:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	packetfunctions_reserveHeaderSize(msg,sizeof(uint8_t));
 4488              		.loc 1 2093 0
 4489 1ecc F868     		ldr	r0, [r7, #12]
 4490 1ece 4FF00101 		mov	r1, #1
 4491 1ed2 FFF7FEFF 		bl	packetfunctions_reserveHeaderSize
2094:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	*((uint8_t*)(msg->payload)) = 0x55;
 4492              		.loc 1 2094 0
 4493 1ed6 FB68     		ldr	r3, [r7, #12]
 4494 1ed8 5B68     		ldr	r3, [r3, #4]
 4495 1eda 4FF05502 		mov	r2, #85
 4496 1ede 1A70     		strb	r2, [r3, #0]
2095:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2096:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4497              		.loc 1 2096 0
 4498 1ee0 07F12807 		add	r7, r7, #40
 4499 1ee4 BD46     		mov	sp, r7
 4500 1ee6 80BD     		pop	{r7, pc}
 4501              		.cfi_endproc
 4502              	.LFE53:
 4504              		.align	2
 4505              		.global	ieee802154_retrieveWakeUpFrame
 4506              		.thumb
 4507              		.thumb_func
 4509              	ieee802154_retrieveWakeUpFrame:
 4510              	.LFB54:
2097:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2098:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2099:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Retrieve the IEEE802.15.4 MAC Wake-Up Frame header from a (just received) packet.
2100:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2101:openstack/02a-MAClow/IEEE802154Ecsl.c **** Note We are writing the fields from the beginning of the header to the end.
2102:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2103:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in,out] msg            The message just received.
2104:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[out] ieee802514_header The internal header to write the data to.
2105:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[out] rztime  		  Rendezvous time to wait for data packet.
2106:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2107:openstack/02a-MAClow/IEEE802154Ecsl.c **** void ieee802154_retrieveWakeUpFrame(OpenQueueEntry_t*      msg,
2108:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                     ieee802154_header_iht* ieee802514_header,
2109:openstack/02a-MAClow/IEEE802154Ecsl.c **** 									uint16_t* rztime) {
 4511              		.loc 1 2109 0
 4512              		.cfi_startproc
 4513              		@ args = 0, pretend = 0, frame = 24
 4514              		@ frame_needed = 1, uses_anonymous_args = 0
 4515 1ee8 80B5     		push	{r7, lr}
 4516              	.LCFI127:
 4517              		.cfi_def_cfa_offset 8
 4518              		.cfi_offset 7, -8
 4519              		.cfi_offset 14, -4
 4520 1eea 86B0     		sub	sp, sp, #24
 4521              	.LCFI128:
 4522              		.cfi_def_cfa_offset 32
 4523 1eec 00AF     		add	r7, sp, #0
 4524              	.LCFI129:
 4525              		.cfi_def_cfa_register 7
 4526 1eee F860     		str	r0, [r7, #12]
 4527 1ef0 B960     		str	r1, [r7, #8]
 4528 1ef2 7A60     		str	r2, [r7, #4]
2110:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t temp_8b, temp_8b1, temp_8b2;
2111:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t src_addr_mode, dst_addr_mode;
2112:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint16_t temp_16b;
2113:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2114:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2115:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // La estructura de una trama Wake-Up es la siguiente
2116:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2117:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - FRAME CONTROL: 1 byte
2118:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - SEQ NUMBER (macDSN): 1 byte
2119:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - PAN ID: 2 bytes
2120:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - DEST ADDR: 2 bytes
2121:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - RZ TIME IE: 2 bytes
2122:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - IE LIST TERMINATOR: 2 bytes
2123:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2124:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  | FRAME   |  SEQ   | PAN | DEST | RZ TIME  | IE LIST    |
2125:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  | CONTROL | NUMBER |  ID | ADDR |  HDR IE  | TERMINATOR |
2126:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2127:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2128:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Por defecto, se asume que la cabecera no es válida en el caso de
2129:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abandonar la función al ser el paquete más corto que la cabecera.
2130:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->valid=FALSE;
 4529              		.loc 1 2130 0
 4530 1ef4 BB68     		ldr	r3, [r7, #8]
 4531 1ef6 4FF00002 		mov	r2, #0
 4532 1efa 1A70     		strb	r2, [r3, #0]
2131:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength = 0;
 4533              		.loc 1 2131 0
 4534 1efc BB68     		ldr	r3, [r7, #8]
 4535 1efe 4FF00002 		mov	r2, #0
 4536 1f02 5A70     		strb	r2, [r3, #1]
2132:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2133:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Validamos que hay datos que leer.
2134:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; }
 4537              		.loc 1 2134 0
 4538 1f04 BB68     		ldr	r3, [r7, #8]
 4539 1f06 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 4540 1f08 FB68     		ldr	r3, [r7, #12]
 4541 1f0a 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4542 1f0c 9A42     		cmp	r2, r3
 4543 1f0e 00F25F81 		bhi	.L223
 4544              	.L201:
2135:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2136:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Frame Control Field (1 byte)
2137:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_8b = *((uint8_t*)(msg->payload)+ieee802514_header->headerLength);
 4545              		.loc 1 2137 0
 4546 1f12 FB68     		ldr	r3, [r7, #12]
 4547 1f14 5A68     		ldr	r2, [r3, #4]
 4548 1f16 BB68     		ldr	r3, [r7, #8]
 4549 1f18 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4550 1f1a D318     		adds	r3, r2, r3
 4551 1f1c 1B78     		ldrb	r3, [r3, #0]
 4552 1f1e FB75     		strb	r3, [r7, #23]
2138:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2139:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // La estructura del FCF en la trama de wake-up es 0x55 = 01010101b:
2140:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // b0-b2 -- Frame Type (debe ser 101 para trama wake-up)
2141:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // b3 ----- Long Frame Control (debe ser 0 para indicar que se trata de un FCF de 1 byte como es
2142:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // b4-b5 -- Dest Addr Mode (en este caso, short address por lo que tiene que valer 10).
2143:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // b6-b7 -- Src Addr Mode (en este caso, short address por lo que tiene que valer 10).
2144:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2145:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 |
2146:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   0 |  1 |  0 |  1 |  0 |  1 |  0 |  1 |
2147:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2148:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->frameType = (temp_8b >> IEEE154_FCF_FRAME_TYPE) & 0x07;//3b
 4553              		.loc 1 2148 0
 4554 1f20 FB7D     		ldrb	r3, [r7, #23]
 4555 1f22 03F00703 		and	r3, r3, #7
 4556 1f26 DAB2     		uxtb	r2, r3
 4557 1f28 BB68     		ldr	r3, [r7, #8]
 4558 1f2a 9A70     		strb	r2, [r3, #2]
2149:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2150:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Comprobamos que efectivamente se trata de una trama de tipo MULTIPURPOSE.
2151:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->frameType != IEEE154_TYPE_MULTIPURPOSE) {return; }
 4559              		.loc 1 2151 0
 4560 1f2c BB68     		ldr	r3, [r7, #8]
 4561 1f2e 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 4562 1f30 052B     		cmp	r3, #5
 4563 1f32 40F04F81 		bne	.L224
 4564              	.L203:
2152:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2153:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Verificamos que efectivamente el campo Long Frame Control tiene valor cero para indicar que e
2154:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_8b >> 3) & 0x01) { return; }
 4565              		.loc 1 2154 0
 4566 1f36 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 4567 1f38 4FEAD303 		lsr	r3, r3, #3
 4568 1f3c DBB2     		uxtb	r3, r3
 4569 1f3e 03F00103 		and	r3, r3, #1
 4570 1f42 002B     		cmp	r3, #0
 4571 1f44 40F04881 		bne	.L225
 4572              	.L204:
2155:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2156:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Recuperamos los Destination y Source Address Mode
2157:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2158:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Destination Address Mode
2159:openstack/02a-MAClow/IEEE802154Ecsl.c ****    dst_addr_mode = (temp_8b >> 4) & 0x03;
 4573              		.loc 1 2159 0
 4574 1f48 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 4575 1f4a 4FEA1313 		lsr	r3, r3, #4
 4576 1f4e DBB2     		uxtb	r3, r3
 4577 1f50 03F00303 		and	r3, r3, #3
 4578 1f54 BB75     		strb	r3, [r7, #22]
2160:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if(dst_addr_mode == 1) { // 01 en binario en bits b5-b4
 4579              		.loc 1 2160 0
 4580 1f56 BB7D     		ldrb	r3, [r7, #22]	@ zero_extendqisi2
 4581 1f58 012B     		cmp	r3, #1
 4582 1f5a 0BD1     		bne	.L205
2161:openstack/02a-MAClow/IEEE802154Ecsl.c ****      // Debería ser siempre este caso en las tramas wake-up por lo que se trata como error cualqui
2162:openstack/02a-MAClow/IEEE802154Ecsl.c ****      ieee802514_header->dest.type = ADDR_16B;
 4583              		.loc 1 2162 0
 4584 1f5c BB68     		ldr	r3, [r7, #8]
 4585 1f5e 4FF00102 		mov	r2, #1
 4586 1f62 DA76     		strb	r2, [r3, #27]
2163:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2164:openstack/02a-MAClow/IEEE802154Ecsl.c ****    else {
2165:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	 openserial_printError(COMPONENT_IEEE802154,ERR_IEEE154_UNSUPPORTED, (errorparameter_t)1, (errorpa
2166:openstack/02a-MAClow/IEEE802154Ecsl.c ****      return; // this is an invalid packet, return
2167:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2168:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2169:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Source Address Mode
2170:openstack/02a-MAClow/IEEE802154Ecsl.c ****    src_addr_mode = (temp_8b >> 6) & 0x03;
 4587              		.loc 1 2170 0
 4588 1f64 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 4589 1f66 4FEA9313 		lsr	r3, r3, #6
 4590 1f6a 7B75     		strb	r3, [r7, #21]
2171:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if(src_addr_mode == 1) { // 01 en binario en bits b7-b6
 4591              		.loc 1 2171 0
 4592 1f6c 7B7D     		ldrb	r3, [r7, #21]	@ zero_extendqisi2
 4593 1f6e 012B     		cmp	r3, #1
 4594 1f70 0BD0     		beq	.L206
 4595 1f72 1EE0     		b	.L221
 4596              	.L205:
2165:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	 openserial_printError(COMPONENT_IEEE802154,ERR_IEEE154_UNSUPPORTED, (errorparameter_t)1, (errorpa
 4597              		.loc 1 2165 0
 4598 1f74 BB7D     		ldrb	r3, [r7, #22]	@ zero_extendqisi2
 4599 1f76 9BB2     		uxth	r3, r3
 4600 1f78 4FF00800 		mov	r0, #8
 4601 1f7c 4FF01901 		mov	r1, #25
 4602 1f80 4FF00102 		mov	r2, #1
 4603 1f84 FFF7FEFF 		bl	openserial_printError
2166:openstack/02a-MAClow/IEEE802154Ecsl.c ****      return; // this is an invalid packet, return
 4604              		.loc 1 2166 0
 4605 1f88 3FE1     		b	.L200
 4606              	.L206:
2172:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Debería ser siempre este caso en las tramas wake-up por lo que se trata como error cualqu
2173:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee802514_header->src.type = ADDR_16B;
 4607              		.loc 1 2173 0
 4608 1f8a BB68     		ldr	r3, [r7, #8]
 4609 1f8c 4FF00102 		mov	r2, #1
 4610 1f90 83F82C20 		strb	r2, [r3, #44]
2174:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2175:openstack/02a-MAClow/IEEE802154Ecsl.c ****    else {
2176:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printError(COMPONENT_IEEE802154,ERR_IEEE154_UNSUPPORTED, (errorparameter_t)2, (errorp
2177:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return; // this is an invalid packet, return
2178:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2179:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2180:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2181:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // En este punto ya hemos analizado el contenido del primer byte de la cabecera correspondiente 
2182:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2183:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2184:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // A partir de este punto, la estructura del paquete es la siguiente:
2185:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - SEQ NUMBER (macDSN): 1 byte
2186:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - PAN ID: 2 bytes
2187:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - DEST ADDR: 2 bytes
2188:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - RZ TIME IE: 2 bytes
2189:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - IE LIST TERMINATOR: 2 bytes
2190:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2191:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2192:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2193:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Avanzamos 1 byte en el procesamiento de la cabecera.
2194:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 1;
 4611              		.loc 1 2194 0
 4612 1f94 BB68     		ldr	r3, [r7, #8]
 4613 1f96 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4614 1f98 03F10103 		add	r3, r3, #1
 4615 1f9c DAB2     		uxtb	r2, r3
 4616 1f9e BB68     		ldr	r3, [r7, #8]
 4617 1fa0 5A70     		strb	r2, [r3, #1]
2195:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2196:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Posicionamos dentro del paquete para leer el resto de elementos.
2197:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //temp_8b = *((uint8_t*)(msg->payload)+ieee802514_header->headerLength);
2198:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2199:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // 1.- SequenceNumber
2200:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4618              		.loc 1 2200 0
 4619 1fa2 BB68     		ldr	r3, [r7, #8]
 4620 1fa4 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 4621 1fa6 FB68     		ldr	r3, [r7, #12]
 4622 1fa8 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4623 1faa 9A42     		cmp	r2, r3
 4624 1fac 00F21681 		bhi	.L226
 4625 1fb0 0AE0     		b	.L222
 4626              	.L221:
2176:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printError(COMPONENT_IEEE802154,ERR_IEEE154_UNSUPPORTED, (errorparameter_t)2, (errorp
 4627              		.loc 1 2176 0
 4628 1fb2 7B7D     		ldrb	r3, [r7, #21]	@ zero_extendqisi2
 4629 1fb4 9BB2     		uxth	r3, r3
 4630 1fb6 4FF00800 		mov	r0, #8
 4631 1fba 4FF01901 		mov	r1, #25
 4632 1fbe 4FF00202 		mov	r2, #2
 4633 1fc2 FFF7FEFF 		bl	openserial_printError
2177:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return; // this is an invalid packet, return
 4634              		.loc 1 2177 0
 4635 1fc6 20E1     		b	.L200
 4636              	.L222:
2201:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->dsn  = *((uint8_t*)(msg->payload)+ieee802514_header->headerLength);
 4637              		.loc 1 2201 0
 4638 1fc8 FB68     		ldr	r3, [r7, #12]
 4639 1fca 5A68     		ldr	r2, [r3, #4]
 4640 1fcc BB68     		ldr	r3, [r7, #8]
 4641 1fce 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4642 1fd0 D318     		adds	r3, r2, r3
 4643 1fd2 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 4644 1fd4 BB68     		ldr	r3, [r7, #8]
 4645 1fd6 5A72     		strb	r2, [r3, #9]
2202:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 1;
 4646              		.loc 1 2202 0
 4647 1fd8 BB68     		ldr	r3, [r7, #8]
 4648 1fda 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4649 1fdc 03F10103 		add	r3, r3, #1
 4650 1fe0 DAB2     		uxtb	r2, r3
 4651 1fe2 BB68     		ldr	r3, [r7, #8]
 4652 1fe4 5A70     		strb	r2, [r3, #1]
2203:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2204:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // 2.- panID
2205:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4653              		.loc 1 2205 0
 4654 1fe6 BB68     		ldr	r3, [r7, #8]
 4655 1fe8 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 4656 1fea FB68     		ldr	r3, [r7, #12]
 4657 1fec 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4658 1fee 9A42     		cmp	r2, r3
 4659 1ff0 00F2F680 		bhi	.L227
 4660              	.L210:
2206:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packetfunctions_readAddress(((uint8_t*)(msg->payload)+ieee802514_header->headerLength), ADDR_PAN
 4661              		.loc 1 2206 0
 4662 1ff4 FB68     		ldr	r3, [r7, #12]
 4663 1ff6 5A68     		ldr	r2, [r3, #4]
 4664 1ff8 BB68     		ldr	r3, [r7, #8]
 4665 1ffa 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4666 1ffc D218     		adds	r2, r2, r3
 4667 1ffe BB68     		ldr	r3, [r7, #8]
 4668 2000 03F10A03 		add	r3, r3, #10
 4669 2004 1046     		mov	r0, r2
 4670 2006 4FF00401 		mov	r1, #4
 4671 200a 1A46     		mov	r2, r3
 4672 200c 4FF00103 		mov	r3, #1
 4673 2010 FFF7FEFF 		bl	packetfunctions_readAddress
2207:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 2;
 4674              		.loc 1 2207 0
 4675 2014 BB68     		ldr	r3, [r7, #8]
 4676 2016 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4677 2018 03F10203 		add	r3, r3, #2
 4678 201c DAB2     		uxtb	r2, r3
 4679 201e BB68     		ldr	r3, [r7, #8]
 4680 2020 5A70     		strb	r2, [r3, #1]
2208:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2209:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // 3.- Dest Addr
2210:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4681              		.loc 1 2210 0
 4682 2022 BB68     		ldr	r3, [r7, #8]
 4683 2024 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 4684 2026 FB68     		ldr	r3, [r7, #12]
 4685 2028 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4686 202a 9A42     		cmp	r2, r3
 4687 202c 00F2DA80 		bhi	.L228
 4688              	.L211:
2211:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2212:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // En este punto ya sabemos que el tipo de dirección tiene que ser ADDR_16B dado que cualquier 
2213:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // en la lectura del frame control field por lo que leemos los 2 bytes de la dirección del dest
2214:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packetfunctions_readAddress(((uint8_t*)(msg->payload)+ieee802514_header->headerLength), ADDR_16B
 4689              		.loc 1 2214 0
 4690 2030 FB68     		ldr	r3, [r7, #12]
 4691 2032 5A68     		ldr	r2, [r3, #4]
 4692 2034 BB68     		ldr	r3, [r7, #8]
 4693 2036 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4694 2038 D218     		adds	r2, r2, r3
 4695 203a BB68     		ldr	r3, [r7, #8]
 4696 203c 03F11B03 		add	r3, r3, #27
 4697 2040 1046     		mov	r0, r2
 4698 2042 4FF00101 		mov	r1, #1
 4699 2046 1A46     		mov	r2, r3
 4700 2048 4FF00103 		mov	r3, #1
 4701 204c FFF7FEFF 		bl	packetfunctions_readAddress
2215:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 2;
 4702              		.loc 1 2215 0
 4703 2050 BB68     		ldr	r3, [r7, #8]
 4704 2052 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4705 2054 03F10203 		add	r3, r3, #2
 4706 2058 DAB2     		uxtb	r2, r3
 4707 205a BB68     		ldr	r3, [r7, #8]
 4708 205c 5A70     		strb	r2, [r3, #1]
2216:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2217:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // 4.- RZ Time Header IE, formado por 4 bytes con la siguiente estructura (0x0E82)
2218:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  - b0-b6 (Length) = 2
2219:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  - b7-b14 (Element ID) = 0x1D
2220:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  - b15 (Type) = 0
2221:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  - b16-b31 (IE Content) = time (2 bytes)
2222:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2223:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  b15 | b14 | b13 | b12 | b11 | b10 | b9 | b8 | b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 |
2224:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   0  |  0  |  0  |  0  |  1  |  1  |  1 |  0 |  1 |  0 |  0 |  0 |  0 |  0 |  1 |  0 |
2225:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2226:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) {  return; } // no more to read!
 4709              		.loc 1 2226 0
 4710 205e BB68     		ldr	r3, [r7, #8]
 4711 2060 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 4712 2062 FB68     		ldr	r3, [r7, #12]
 4713 2064 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4714 2066 9A42     		cmp	r2, r3
 4715 2068 00F2BE80 		bhi	.L229
 4716              	.L212:
2227:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2228:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Verificamos longitud a valor 2 y el elementID a valor 0x1D. Lo hacemos leyendo los primeros 2
2229:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_8b1 = *((uint8_t*)(msg->payload)+ieee802514_header->headerLength);
 4717              		.loc 1 2229 0
 4718 206c FB68     		ldr	r3, [r7, #12]
 4719 206e 5A68     		ldr	r2, [r3, #4]
 4720 2070 BB68     		ldr	r3, [r7, #8]
 4721 2072 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4722 2074 D318     		adds	r3, r2, r3
 4723 2076 1B78     		ldrb	r3, [r3, #0]
 4724 2078 3B75     		strb	r3, [r7, #20]
2230:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 1;
 4725              		.loc 1 2230 0
 4726 207a BB68     		ldr	r3, [r7, #8]
 4727 207c 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4728 207e 03F10103 		add	r3, r3, #1
 4729 2082 DAB2     		uxtb	r2, r3
 4730 2084 BB68     		ldr	r3, [r7, #8]
 4731 2086 5A70     		strb	r2, [r3, #1]
2231:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2232:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_8b2 = *((uint8_t*)(msg->payload)+ieee802514_header->headerLength);
 4732              		.loc 1 2232 0
 4733 2088 FB68     		ldr	r3, [r7, #12]
 4734 208a 5A68     		ldr	r2, [r3, #4]
 4735 208c BB68     		ldr	r3, [r7, #8]
 4736 208e 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4737 2090 D318     		adds	r3, r2, r3
 4738 2092 1B78     		ldrb	r3, [r3, #0]
 4739 2094 FB74     		strb	r3, [r7, #19]
2233:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 1;
 4740              		.loc 1 2233 0
 4741 2096 BB68     		ldr	r3, [r7, #8]
 4742 2098 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4743 209a 03F10103 		add	r3, r3, #1
 4744 209e DAB2     		uxtb	r2, r3
 4745 20a0 BB68     		ldr	r3, [r7, #8]
 4746 20a2 5A70     		strb	r2, [r3, #1]
2234:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2235:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_16b = (temp_8b2 << 8) | temp_8b1;
 4747              		.loc 1 2235 0
 4748 20a4 FB7C     		ldrb	r3, [r7, #19]	@ zero_extendqisi2
 4749 20a6 4FEA0323 		lsl	r3, r3, #8
 4750 20aa 9AB2     		uxth	r2, r3
 4751 20ac 3B7D     		ldrb	r3, [r7, #20]	@ zero_extendqisi2
 4752 20ae 9BB2     		uxth	r3, r3
 4753 20b0 1343     		orrs	r3, r3, r2
 4754 20b2 9BB2     		uxth	r3, r3
 4755 20b4 3B82     		strh	r3, [r7, #16]	@ movhi
2236:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2237:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Comprobación de longitud a valor 2.
2238:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2239:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b & 0x007f) != 2) { return; }
 4756              		.loc 1 2239 0
 4757 20b6 3B8A     		ldrh	r3, [r7, #16]
 4758 20b8 03F07F03 		and	r3, r3, #127
 4759 20bc 022B     		cmp	r3, #2
 4760 20be 40F09580 		bne	.L230
 4761              	.L213:
2240:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2241:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Comprobación de element ID = 0x1D.
2242:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2243:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b >> 7) != 0x001d) { return; }
 4762              		.loc 1 2243 0
 4763 20c2 3B8A     		ldrh	r3, [r7, #16]
 4764 20c4 4FEAD313 		lsr	r3, r3, #7
 4765 20c8 9BB2     		uxth	r3, r3
 4766 20ca 1D2B     		cmp	r3, #29
 4767 20cc 40F09080 		bne	.L231
 4768              	.L214:
2244:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2245:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Comprobación del type = 0.
2246:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2247:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b >> 15) & 0x0001) { return; }
 4769              		.loc 1 2247 0
 4770 20d0 3B8A     		ldrh	r3, [r7, #16]
 4771 20d2 4FEAD333 		lsr	r3, r3, #15
 4772 20d6 9BB2     		uxth	r3, r3
 4773 20d8 03F00103 		and	r3, r3, #1
 4774 20dc 002B     		cmp	r3, #0
 4775 20de 40F08980 		bne	.L232
 4776              	.L215:
2248:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2249:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Obtención del IE Content (rztime).
2250:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4777              		.loc 1 2250 0
 4778 20e2 BB68     		ldr	r3, [r7, #8]
 4779 20e4 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 4780 20e6 FB68     		ldr	r3, [r7, #12]
 4781 20e8 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4782 20ea 9A42     		cmp	r2, r3
 4783 20ec 00F28480 		bhi	.L233
 4784              	.L216:
2251:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2252:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_8b1 = *((uint8_t*)(msg->payload)+ieee802514_header->headerLength);
 4785              		.loc 1 2252 0
 4786 20f0 FB68     		ldr	r3, [r7, #12]
 4787 20f2 5A68     		ldr	r2, [r3, #4]
 4788 20f4 BB68     		ldr	r3, [r7, #8]
 4789 20f6 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4790 20f8 D318     		adds	r3, r2, r3
 4791 20fa 1B78     		ldrb	r3, [r3, #0]
 4792 20fc 3B75     		strb	r3, [r7, #20]
2253:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 1;
 4793              		.loc 1 2253 0
 4794 20fe BB68     		ldr	r3, [r7, #8]
 4795 2100 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4796 2102 03F10103 		add	r3, r3, #1
 4797 2106 DAB2     		uxtb	r2, r3
 4798 2108 BB68     		ldr	r3, [r7, #8]
 4799 210a 5A70     		strb	r2, [r3, #1]
2254:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2255:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_8b2 = *((uint8_t*)(msg->payload)+ieee802514_header->headerLength);
 4800              		.loc 1 2255 0
 4801 210c FB68     		ldr	r3, [r7, #12]
 4802 210e 5A68     		ldr	r2, [r3, #4]
 4803 2110 BB68     		ldr	r3, [r7, #8]
 4804 2112 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4805 2114 D318     		adds	r3, r2, r3
 4806 2116 1B78     		ldrb	r3, [r3, #0]
 4807 2118 FB74     		strb	r3, [r7, #19]
2256:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 1;
 4808              		.loc 1 2256 0
 4809 211a BB68     		ldr	r3, [r7, #8]
 4810 211c 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4811 211e 03F10103 		add	r3, r3, #1
 4812 2122 DAB2     		uxtb	r2, r3
 4813 2124 BB68     		ldr	r3, [r7, #8]
 4814 2126 5A70     		strb	r2, [r3, #1]
2257:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2258:openstack/02a-MAClow/IEEE802154Ecsl.c ****    (*rztime) = (temp_8b2 << 8) | temp_8b1;
 4815              		.loc 1 2258 0
 4816 2128 FB7C     		ldrb	r3, [r7, #19]	@ zero_extendqisi2
 4817 212a 4FEA0323 		lsl	r3, r3, #8
 4818 212e 9AB2     		uxth	r2, r3
 4819 2130 3B7D     		ldrb	r3, [r7, #20]	@ zero_extendqisi2
 4820 2132 9BB2     		uxth	r3, r3
 4821 2134 1343     		orrs	r3, r3, r2
 4822 2136 9BB2     		uxth	r3, r3
 4823 2138 9AB2     		uxth	r2, r3
 4824 213a 7B68     		ldr	r3, [r7, #4]
 4825 213c 1A80     		strh	r2, [r3, #0]	@ movhi
2259:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2260:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // 5.- IE List Terminator, formado por 2 bytes con la siguiente estructura (0x3F80 o 0x3F00)
2261:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  - b0-b6 (Length) = 0
2262:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  - b7-b14 (Element ID) = 0x7e o 0x7f
2263:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  - b15 (Type) = 0
2264:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2265:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  b15 | b14 | b13 | b12 | b11 | b10 | b9 | b8 | b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 |
2266:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   0  |  0  |  1  |  1  |  1  |  1  | 1  | 1  |  0 |  0 |  0 |  0 |  0 |  0 |  0 |  0 |
2267:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2268:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4826              		.loc 1 2268 0
 4827 213e BB68     		ldr	r3, [r7, #8]
 4828 2140 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 4829 2142 FB68     		ldr	r3, [r7, #12]
 4830 2144 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4831 2146 9A42     		cmp	r2, r3
 4832 2148 58D8     		bhi	.L234
 4833              	.L217:
2269:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2270:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Verificamos longitud a valor 0 y el elementID a valor 0x7E o 0x7F. Lo hacemos leyendo los 2 b
2271:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_8b1 = *((uint8_t*)(msg->payload)+ieee802514_header->headerLength);
 4834              		.loc 1 2271 0
 4835 214a FB68     		ldr	r3, [r7, #12]
 4836 214c 5A68     		ldr	r2, [r3, #4]
 4837 214e BB68     		ldr	r3, [r7, #8]
 4838 2150 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4839 2152 D318     		adds	r3, r2, r3
 4840 2154 1B78     		ldrb	r3, [r3, #0]
 4841 2156 3B75     		strb	r3, [r7, #20]
2272:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 1;
 4842              		.loc 1 2272 0
 4843 2158 BB68     		ldr	r3, [r7, #8]
 4844 215a 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4845 215c 03F10103 		add	r3, r3, #1
 4846 2160 DAB2     		uxtb	r2, r3
 4847 2162 BB68     		ldr	r3, [r7, #8]
 4848 2164 5A70     		strb	r2, [r3, #1]
2273:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2274:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_8b2 = *((uint8_t*)(msg->payload)+ieee802514_header->headerLength);
 4849              		.loc 1 2274 0
 4850 2166 FB68     		ldr	r3, [r7, #12]
 4851 2168 5A68     		ldr	r2, [r3, #4]
 4852 216a BB68     		ldr	r3, [r7, #8]
 4853 216c 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4854 216e D318     		adds	r3, r2, r3
 4855 2170 1B78     		ldrb	r3, [r3, #0]
 4856 2172 FB74     		strb	r3, [r7, #19]
2275:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 1;
 4857              		.loc 1 2275 0
 4858 2174 BB68     		ldr	r3, [r7, #8]
 4859 2176 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4860 2178 03F10103 		add	r3, r3, #1
 4861 217c DAB2     		uxtb	r2, r3
 4862 217e BB68     		ldr	r3, [r7, #8]
 4863 2180 5A70     		strb	r2, [r3, #1]
2276:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2277:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_16b = (temp_8b2 << 8) | temp_8b1;
 4864              		.loc 1 2277 0
 4865 2182 FB7C     		ldrb	r3, [r7, #19]	@ zero_extendqisi2
 4866 2184 4FEA0323 		lsl	r3, r3, #8
 4867 2188 9AB2     		uxth	r2, r3
 4868 218a 3B7D     		ldrb	r3, [r7, #20]	@ zero_extendqisi2
 4869 218c 9BB2     		uxth	r3, r3
 4870 218e 1343     		orrs	r3, r3, r2
 4871 2190 9BB2     		uxth	r3, r3
 4872 2192 3B82     		strh	r3, [r7, #16]	@ movhi
2278:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2279:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Comprobación de longitud a valor 0.
2280:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2281:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (temp_16b & 0x007f) { return; }
 4873              		.loc 1 2281 0
 4874 2194 3B8A     		ldrh	r3, [r7, #16]
 4875 2196 03F07F03 		and	r3, r3, #127
 4876 219a 002B     		cmp	r3, #0
 4877 219c 30D1     		bne	.L235
 4878              	.L218:
2282:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2283:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Comprobación de element ID = 0x7E o 0x7F.
2284:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2285:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (((temp_16b >> 7) != 0x7e) && ((temp_16b >> 7) != 0x7f)) { return; }
 4879              		.loc 1 2285 0
 4880 219e 3B8A     		ldrh	r3, [r7, #16]
 4881 21a0 4FEAD313 		lsr	r3, r3, #7
 4882 21a4 9BB2     		uxth	r3, r3
 4883 21a6 7E2B     		cmp	r3, #126
 4884 21a8 05D0     		beq	.L219
 4885              		.loc 1 2285 0 is_stmt 0 discriminator 1
 4886 21aa 3B8A     		ldrh	r3, [r7, #16]
 4887 21ac 4FEAD313 		lsr	r3, r3, #7
 4888 21b0 9BB2     		uxth	r3, r3
 4889 21b2 7F2B     		cmp	r3, #127
 4890 21b4 26D1     		bne	.L236
 4891              	.L219:
2286:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2287:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Comprobación del type = 0.
2288:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2289:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b >> 15) & 0x0001) { return; }
 4892              		.loc 1 2289 0 is_stmt 1
 4893 21b6 3B8A     		ldrh	r3, [r7, #16]
 4894 21b8 4FEAD333 		lsr	r3, r3, #15
 4895 21bc 9BB2     		uxth	r3, r3
 4896 21be 03F00103 		and	r3, r3, #1
 4897 21c2 002B     		cmp	r3, #0
 4898 21c4 20D1     		bne	.L237
 4899              	.L220:
2290:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2291:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Por ultimo y en el caso de haber llegado aquí, consideramos la cabecera como válida.
2292:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->valid=TRUE;
 4900              		.loc 1 2292 0
 4901 21c6 BB68     		ldr	r3, [r7, #8]
 4902 21c8 4FF00102 		mov	r2, #1
 4903 21cc 1A70     		strb	r2, [r3, #0]
 4904 21ce 1CE0     		b	.L200
 4905              	.L223:
2134:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; }
 4906              		.loc 1 2134 0
 4907 21d0 00BF     		nop
 4908 21d2 1AE0     		b	.L200
 4909              	.L224:
2151:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->frameType != IEEE154_TYPE_MULTIPURPOSE) {return; }
 4910              		.loc 1 2151 0
 4911 21d4 00BF     		nop
 4912 21d6 18E0     		b	.L200
 4913              	.L225:
2154:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_8b >> 3) & 0x01) { return; }
 4914              		.loc 1 2154 0
 4915 21d8 00BF     		nop
 4916 21da 16E0     		b	.L200
 4917              	.L226:
2200:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4918              		.loc 1 2200 0
 4919 21dc 00BF     		nop
 4920 21de 14E0     		b	.L200
 4921              	.L227:
2205:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4922              		.loc 1 2205 0
 4923 21e0 00BF     		nop
 4924 21e2 12E0     		b	.L200
 4925              	.L228:
2210:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4926              		.loc 1 2210 0
 4927 21e4 00BF     		nop
 4928 21e6 10E0     		b	.L200
 4929              	.L229:
2226:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) {  return; } // no more to read!
 4930              		.loc 1 2226 0
 4931 21e8 00BF     		nop
 4932 21ea 0EE0     		b	.L200
 4933              	.L230:
2239:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b & 0x007f) != 2) { return; }
 4934              		.loc 1 2239 0
 4935 21ec 00BF     		nop
 4936 21ee 0CE0     		b	.L200
 4937              	.L231:
2243:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b >> 7) != 0x001d) { return; }
 4938              		.loc 1 2243 0
 4939 21f0 00BF     		nop
 4940 21f2 0AE0     		b	.L200
 4941              	.L232:
2247:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b >> 15) & 0x0001) { return; }
 4942              		.loc 1 2247 0
 4943 21f4 00BF     		nop
 4944 21f6 08E0     		b	.L200
 4945              	.L233:
2250:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4946              		.loc 1 2250 0
 4947 21f8 00BF     		nop
 4948 21fa 06E0     		b	.L200
 4949              	.L234:
2268:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4950              		.loc 1 2268 0
 4951 21fc 00BF     		nop
 4952 21fe 04E0     		b	.L200
 4953              	.L235:
2281:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (temp_16b & 0x007f) { return; }
 4954              		.loc 1 2281 0
 4955 2200 00BF     		nop
 4956 2202 02E0     		b	.L200
 4957              	.L236:
2285:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (((temp_16b >> 7) != 0x7e) && ((temp_16b >> 7) != 0x7f)) { return; }
 4958              		.loc 1 2285 0
 4959 2204 00BF     		nop
 4960 2206 00E0     		b	.L200
 4961              	.L237:
2289:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b >> 15) & 0x0001) { return; }
 4962              		.loc 1 2289 0
 4963 2208 00BF     		nop
 4964              	.L200:
2293:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4965              		.loc 1 2293 0
 4966 220a 07F11807 		add	r7, r7, #24
 4967 220e BD46     		mov	sp, r7
 4968 2210 80BD     		pop	{r7, pc}
 4969              		.cfi_endproc
 4970              	.LFE54:
 4972 2212 00BF     		.align	2
 4973              		.global	isValidRxFrame
 4974              		.thumb
 4975              		.thumb_func
 4977              	isValidRxFrame:
 4978              	.LFB55:
2294:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2295:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2296:openstack/02a-MAClow/IEEE802154Ecsl.c **** //====================  FRAME VALIDITY CHECK ===========================
2297:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2298:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2299:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2300:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Decides whether the packet I just received is valid received frame.
2301:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2302:openstack/02a-MAClow/IEEE802154Ecsl.c **** A valid Rx frame satisfies the following constraints:
2303:openstack/02a-MAClow/IEEE802154Ecsl.c **** - its IEEE802.15.4 header is well formatted
2304:openstack/02a-MAClow/IEEE802154Ecsl.c **** - it's a DATA of BEACON frame (i.e. not ACK and not COMMAND)
2305:openstack/02a-MAClow/IEEE802154Ecsl.c **** - it's sent on the same PANid as mine
2306:openstack/02a-MAClow/IEEE802154Ecsl.c **** - it's for me (unicast or broadcast)
2307:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2308:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in] ieee802514_header IEEE802.15.4 header of the packet I just received
2309:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2310:openstack/02a-MAClow/IEEE802154Ecsl.c **** \returns TRUE if packet is valid received frame, FALSE otherwise
2311:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2312:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE bool isValidRxFrame(ieee802154_header_iht* ieee802514_header) {
 4979              		.loc 1 2312 0
 4980              		.cfi_startproc
 4981              		@ args = 0, pretend = 0, frame = 8
 4982              		@ frame_needed = 1, uses_anonymous_args = 0
 4983 2214 90B5     		push	{r4, r7, lr}
 4984              	.LCFI130:
 4985              		.cfi_def_cfa_offset 12
 4986              		.cfi_offset 4, -12
 4987              		.cfi_offset 7, -8
 4988              		.cfi_offset 14, -4
 4989 2216 83B0     		sub	sp, sp, #12
 4990              	.LCFI131:
 4991              		.cfi_def_cfa_offset 24
 4992 2218 00AF     		add	r7, sp, #0
 4993              	.LCFI132:
 4994              		.cfi_def_cfa_register 7
 4995 221a 7860     		str	r0, [r7, #4]
2313:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee802514_header->valid==TRUE                                                           
 4996              		.loc 1 2313 0
 4997 221c 7B68     		ldr	r3, [r7, #4]
 4998 221e 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
2314:openstack/02a-MAClow/IEEE802154Ecsl.c ****           (
2315:openstack/02a-MAClow/IEEE802154Ecsl.c ****              ieee802514_header->frameType==IEEE154_TYPE_DATA                   ||
2316:openstack/02a-MAClow/IEEE802154Ecsl.c ****              ieee802514_header->frameType==IEEE154_TYPE_BEACON
2317:openstack/02a-MAClow/IEEE802154Ecsl.c ****           )                                                                                        
2318:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
 4999              		.loc 1 2318 0
 5000 2220 002B     		cmp	r3, #0
 5001 2222 2BD0     		beq	.L239
2315:openstack/02a-MAClow/IEEE802154Ecsl.c ****              ieee802514_header->frameType==IEEE154_TYPE_DATA                   ||
 5002              		.loc 1 2315 0
 5003 2224 7B68     		ldr	r3, [r7, #4]
 5004 2226 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
2313:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee802514_header->valid==TRUE                                                           
 5005              		.loc 1 2313 0
 5006 2228 012B     		cmp	r3, #1
 5007 222a 03D0     		beq	.L240
2316:openstack/02a-MAClow/IEEE802154Ecsl.c ****              ieee802514_header->frameType==IEEE154_TYPE_BEACON
 5008              		.loc 1 2316 0
 5009 222c 7B68     		ldr	r3, [r7, #4]
 5010 222e 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
2315:openstack/02a-MAClow/IEEE802154Ecsl.c ****              ieee802514_header->frameType==IEEE154_TYPE_DATA                   ||
 5011              		.loc 1 2315 0
 5012 2230 002B     		cmp	r3, #0
 5013 2232 23D1     		bne	.L239
 5014              	.L240:
 5015              		.loc 1 2318 0
 5016 2234 7B68     		ldr	r3, [r7, #4]
 5017 2236 03F10A04 		add	r4, r3, #10
 5018 223a 4FF00400 		mov	r0, #4
 5019 223e FFF7FEFF 		bl	idmanager_getMyID
 5020 2242 0346     		mov	r3, r0
 5021 2244 2046     		mov	r0, r4
 5022 2246 1946     		mov	r1, r3
 5023 2248 FFF7FEFF 		bl	packetfunctions_sameAddress
 5024 224c 0346     		mov	r3, r0
2317:openstack/02a-MAClow/IEEE802154Ecsl.c ****           )                                                                                        
 5025              		.loc 1 2317 0
 5026 224e 002B     		cmp	r3, #0
 5027 2250 14D0     		beq	.L239
2319:openstack/02a-MAClow/IEEE802154Ecsl.c ****           (
2320:openstack/02a-MAClow/IEEE802154Ecsl.c ****              idmanager_isMyAddress(&ieee802514_header->dest)                   ||
 5028              		.loc 1 2320 0
 5029 2252 7B68     		ldr	r3, [r7, #4]
 5030 2254 03F11B03 		add	r3, r3, #27
 5031 2258 1846     		mov	r0, r3
 5032 225a FFF7FEFF 		bl	idmanager_isMyAddress
 5033 225e 0346     		mov	r3, r0
2318:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
 5034              		.loc 1 2318 0
 5035 2260 002B     		cmp	r3, #0
 5036 2262 08D1     		bne	.L241
2321:openstack/02a-MAClow/IEEE802154Ecsl.c ****              packetfunctions_isBroadcastMulticast(&ieee802514_header->dest)
 5037              		.loc 1 2321 0
 5038 2264 7B68     		ldr	r3, [r7, #4]
 5039 2266 03F11B03 		add	r3, r3, #27
 5040 226a 1846     		mov	r0, r3
 5041 226c FFF7FEFF 		bl	packetfunctions_isBroadcastMulticast
 5042 2270 0346     		mov	r3, r0
2320:openstack/02a-MAClow/IEEE802154Ecsl.c ****              idmanager_isMyAddress(&ieee802514_header->dest)                   ||
 5043              		.loc 1 2320 0
 5044 2272 002B     		cmp	r3, #0
 5045 2274 02D0     		beq	.L239
 5046              	.L241:
2318:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
 5047              		.loc 1 2318 0 discriminator 2
 5048 2276 4FF00103 		mov	r3, #1
 5049 227a 01E0     		b	.L242
 5050              	.L239:
2318:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
 5051              		.loc 1 2318 0 is_stmt 0 discriminator 1
 5052 227c 4FF00003 		mov	r3, #0
 5053              	.L242:
2313:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee802514_header->valid==TRUE                                                           
 5054              		.loc 1 2313 0 is_stmt 1
 5055 2280 03F00103 		and	r3, r3, #1
 5056 2284 DBB2     		uxtb	r3, r3
2322:openstack/02a-MAClow/IEEE802154Ecsl.c ****           );
2323:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5057              		.loc 1 2323 0
 5058 2286 1846     		mov	r0, r3
 5059 2288 07F10C07 		add	r7, r7, #12
 5060 228c BD46     		mov	sp, r7
 5061 228e 90BD     		pop	{r4, r7, pc}
 5062              		.cfi_endproc
 5063              	.LFE55:
 5065              		.align	2
 5066              		.global	isValidAck
 5067              		.thumb
 5068              		.thumb_func
 5070              	isValidAck:
 5071              	.LFB56:
2324:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2325:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2326:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Decides whether the packet I just received is a valid ACK.
2327:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2328:openstack/02a-MAClow/IEEE802154Ecsl.c **** A packet is a valid ACK if it satisfies the following conditions:
2329:openstack/02a-MAClow/IEEE802154Ecsl.c **** - the IEEE802.15.4 header is valid
2330:openstack/02a-MAClow/IEEE802154Ecsl.c **** - the frame type is 'ACK'
2331:openstack/02a-MAClow/IEEE802154Ecsl.c **** - the sequence number in the ACK matches the sequence number of the packet sent
2332:openstack/02a-MAClow/IEEE802154Ecsl.c **** - the ACK contains my PANid
2333:openstack/02a-MAClow/IEEE802154Ecsl.c **** - the packet is unicast to me
2334:openstack/02a-MAClow/IEEE802154Ecsl.c **** - the packet comes from the neighbor I sent the data to
2335:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2336:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in] ieee802514_header IEEE802.15.4 header of the packet I just received
2337:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in] packetSent points to the packet I just sent
2338:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2339:openstack/02a-MAClow/IEEE802154Ecsl.c **** \returns TRUE if packet is a valid ACK, FALSE otherwise.
2340:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2341:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE bool isValidAck(ieee802154_header_iht* ieee802514_header, OpenQueueEntry_t* packetSent)
 5072              		.loc 1 2341 0
 5073              		.cfi_startproc
 5074              		@ args = 0, pretend = 0, frame = 8
 5075              		@ frame_needed = 1, uses_anonymous_args = 0
 5076 2290 90B5     		push	{r4, r7, lr}
 5077              	.LCFI133:
 5078              		.cfi_def_cfa_offset 12
 5079              		.cfi_offset 4, -12
 5080              		.cfi_offset 7, -8
 5081              		.cfi_offset 14, -4
 5082 2292 83B0     		sub	sp, sp, #12
 5083              	.LCFI134:
 5084              		.cfi_def_cfa_offset 24
 5085 2294 00AF     		add	r7, sp, #0
 5086              	.LCFI135:
 5087              		.cfi_def_cfa_register 7
 5088 2296 7860     		str	r0, [r7, #4]
 5089 2298 3960     		str	r1, [r7, #0]
2342:openstack/02a-MAClow/IEEE802154Ecsl.c ****    /*
2343:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee802514_header->valid==TRUE                                                           
2344:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header->frameType==IEEE154_TYPE_ACK                                           
2345:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header->dsn==packetSent->l2_dsn                                               
2346:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
2347:openstack/02a-MAClow/IEEE802154Ecsl.c ****           idmanager_isMyAddress(&ieee802514_header->dest)                                          
2348:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->src,&packetSent->l2_nextORpreviousHop);
2349:openstack/02a-MAClow/IEEE802154Ecsl.c ****    */
2350:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // poipoi don't check for seq num
2351:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee802514_header->valid==TRUE                                                           
 5090              		.loc 1 2351 0
 5091 229a 7B68     		ldr	r3, [r7, #4]
 5092 229c 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
2352:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header->frameType==IEEE154_TYPE_ACK                                           
2353:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
2354:openstack/02a-MAClow/IEEE802154Ecsl.c ****           idmanager_isMyAddress(&ieee802514_header->dest)                                          
 5093              		.loc 1 2354 0
 5094 229e 002B     		cmp	r3, #0
 5095 22a0 2BD0     		beq	.L245
2352:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header->frameType==IEEE154_TYPE_ACK                                           
 5096              		.loc 1 2352 0
 5097 22a2 7B68     		ldr	r3, [r7, #4]
 5098 22a4 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
2351:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee802514_header->valid==TRUE                                                           
 5099              		.loc 1 2351 0
 5100 22a6 022B     		cmp	r3, #2
 5101 22a8 27D1     		bne	.L245
2353:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
 5102              		.loc 1 2353 0
 5103 22aa 7B68     		ldr	r3, [r7, #4]
 5104 22ac 03F10A04 		add	r4, r3, #10
 5105 22b0 4FF00400 		mov	r0, #4
 5106 22b4 FFF7FEFF 		bl	idmanager_getMyID
 5107 22b8 0346     		mov	r3, r0
 5108 22ba 2046     		mov	r0, r4
 5109 22bc 1946     		mov	r1, r3
 5110 22be FFF7FEFF 		bl	packetfunctions_sameAddress
 5111 22c2 0346     		mov	r3, r0
2352:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header->frameType==IEEE154_TYPE_ACK                                           
 5112              		.loc 1 2352 0
 5113 22c4 002B     		cmp	r3, #0
 5114 22c6 18D0     		beq	.L245
 5115              		.loc 1 2354 0
 5116 22c8 7B68     		ldr	r3, [r7, #4]
 5117 22ca 03F11B03 		add	r3, r3, #27
 5118 22ce 1846     		mov	r0, r3
 5119 22d0 FFF7FEFF 		bl	idmanager_isMyAddress
 5120 22d4 0346     		mov	r3, r0
2353:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
 5121              		.loc 1 2353 0
 5122 22d6 002B     		cmp	r3, #0
 5123 22d8 0FD0     		beq	.L245
2355:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->src,&packetSent->l2_nextORpreviousHop);
 5124              		.loc 1 2355 0
 5125 22da 7B68     		ldr	r3, [r7, #4]
 5126 22dc 03F12C02 		add	r2, r3, #44
 5127 22e0 3B68     		ldr	r3, [r7, #0]
 5128 22e2 03F13803 		add	r3, r3, #56
 5129 22e6 1046     		mov	r0, r2
 5130 22e8 1946     		mov	r1, r3
 5131 22ea FFF7FEFF 		bl	packetfunctions_sameAddress
 5132 22ee 0346     		mov	r3, r0
2354:openstack/02a-MAClow/IEEE802154Ecsl.c ****           idmanager_isMyAddress(&ieee802514_header->dest)                                          
 5133              		.loc 1 2354 0
 5134 22f0 002B     		cmp	r3, #0
 5135 22f2 02D0     		beq	.L245
2354:openstack/02a-MAClow/IEEE802154Ecsl.c ****           idmanager_isMyAddress(&ieee802514_header->dest)                                          
 5136              		.loc 1 2354 0 is_stmt 0 discriminator 2
 5137 22f4 4FF00103 		mov	r3, #1
 5138 22f8 01E0     		b	.L246
 5139              	.L245:
2354:openstack/02a-MAClow/IEEE802154Ecsl.c ****           idmanager_isMyAddress(&ieee802514_header->dest)                                          
 5140              		.loc 1 2354 0 discriminator 1
 5141 22fa 4FF00003 		mov	r3, #0
 5142              	.L246:
2351:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee802514_header->valid==TRUE                                                           
 5143              		.loc 1 2351 0 is_stmt 1
 5144 22fe 03F00103 		and	r3, r3, #1
 5145 2302 DBB2     		uxtb	r3, r3
2356:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5146              		.loc 1 2356 0
 5147 2304 1846     		mov	r0, r3
 5148 2306 07F10C07 		add	r7, r7, #12
 5149 230a BD46     		mov	sp, r7
 5150 230c 90BD     		pop	{r4, r7, pc}
 5151              		.cfi_endproc
 5152              	.LFE56:
 5154 230e 00BF     		.align	2
 5155              		.global	incrementAsnOffset
 5156              		.thumb
 5157              		.thumb_func
 5159              	incrementAsnOffset:
 5160              	.LFB57:
2357:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2358:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2359:openstack/02a-MAClow/IEEE802154Ecsl.c **** //========================  ASN HANDLING ===============================
2360:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2361:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2362:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void incrementAsnOffset() {
 5161              		.loc 1 2362 0
 5162              		.cfi_startproc
 5163              		@ args = 0, pretend = 0, frame = 0
 5164              		@ frame_needed = 1, uses_anonymous_args = 0
 5165 2310 98B5     		push	{r3, r4, r7, lr}
 5166              	.LCFI136:
 5167              		.cfi_def_cfa_offset 16
 5168              		.cfi_offset 3, -16
 5169              		.cfi_offset 4, -12
 5170              		.cfi_offset 7, -8
 5171              		.cfi_offset 14, -4
 5172 2312 00AF     		add	r7, sp, #0
 5173              	.LCFI137:
 5174              		.cfi_def_cfa_register 7
2363:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // increment the asn
2364:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asn.bytes0and1++;
 5175              		.loc 1 2364 0
 5176 2314 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5177 2318 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5178 231c B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 5179 2320 9BB2     		uxth	r3, r3
 5180 2322 03F10103 		add	r3, r3, #1
 5181 2326 9AB2     		uxth	r2, r3
 5182 2328 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5183 232c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5184 2330 A3F80320 		strh	r2, [r3, #3]	@ unaligned
2365:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.asn.bytes0and1==0) {
 5185              		.loc 1 2365 0
 5186 2334 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5187 2338 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5188 233c B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 5189 2340 9BB2     		uxth	r3, r3
 5190 2342 002B     		cmp	r3, #0
 5191 2344 25D1     		bne	.L249
2366:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.asn.bytes2and3++;
 5192              		.loc 1 2366 0
 5193 2346 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5194 234a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5195 234e B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 5196 2352 9BB2     		uxth	r3, r3
 5197 2354 03F10103 		add	r3, r3, #1
 5198 2358 9AB2     		uxth	r2, r3
 5199 235a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5200 235e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5201 2362 A3F80120 		strh	r2, [r3, #1]	@ unaligned
2367:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.asn.bytes2and3==0) {
 5202              		.loc 1 2367 0
 5203 2366 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5204 236a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5205 236e B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 5206 2372 9BB2     		uxth	r3, r3
 5207 2374 002B     		cmp	r3, #0
 5208 2376 0CD1     		bne	.L249
2368:openstack/02a-MAClow/IEEE802154Ecsl.c ****          ieee154e_vars.asn.byte4++;
 5209              		.loc 1 2368 0
 5210 2378 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5211 237c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5212 2380 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 5213 2382 03F10103 		add	r3, r3, #1
 5214 2386 DAB2     		uxtb	r2, r3
 5215 2388 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5216 238c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5217 2390 1A70     		strb	r2, [r3, #0]
 5218              	.L249:
2369:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
2370:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2371:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // increment the offsets: Comment slot offset update.
2372:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.slotOffset  = (ieee154e_vars.slotOffset+1)%schedule_getFrameLength();
 5219              		.loc 1 2372 0
 5220 2392 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5221 2396 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5222 239a DB88     		ldrh	r3, [r3, #6]
 5223 239c 03F10104 		add	r4, r3, #1
 5224 23a0 FFF7FEFF 		bl	schedule_getFrameLength
 5225 23a4 0346     		mov	r3, r0
 5226 23a6 94FBF3F2 		sdiv	r2, r4, r3
 5227 23aa 03FB02F3 		mul	r3, r3, r2
 5228 23ae E31A     		subs	r3, r4, r3
 5229 23b0 9AB2     		uxth	r2, r3
 5230 23b2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5231 23b6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5232 23ba DA80     		strh	r2, [r3, #6]	@ movhi
2373:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asnOffset   = (ieee154e_vars.asnOffset+1)%16;
 5233              		.loc 1 2373 0
 5234 23bc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5235 23c0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5236 23c4 93F82D30 		ldrb	r3, [r3, #45]	@ zero_extendqisi2
 5237 23c8 03F10102 		add	r2, r3, #1
 5238 23cc 4FF00F03 		mov	r3, #15
 5239 23d0 C8F20003 		movt	r3, 32768
 5240 23d4 1340     		ands	r3, r3, r2
 5241 23d6 002B     		cmp	r3, #0
 5242 23d8 05DA     		bge	.L250
 5243 23da 03F1FF33 		add	r3, r3, #-1
 5244 23de 63F00F03 		orn	r3, r3, #15
 5245 23e2 03F10103 		add	r3, r3, #1
 5246              	.L250:
 5247 23e6 DAB2     		uxtb	r2, r3
 5248 23e8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5249 23ec C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5250 23f0 83F82D20 		strb	r2, [r3, #45]
2374:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5251              		.loc 1 2374 0
 5252 23f4 98BD     		pop	{r3, r4, r7, pc}
 5253              		.cfi_endproc
 5254              	.LFE57:
 5256 23f6 00BF     		.align	2
 5257              		.global	ieee154e_getAsn
 5258              		.thumb
 5259              		.thumb_func
 5261              	ieee154e_getAsn:
 5262              	.LFB58:
2375:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2376:openstack/02a-MAClow/IEEE802154Ecsl.c **** //from upper layer that want to send the ASN to compute timing or latency
2377:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void ieee154e_getAsn(uint8_t* array) {
 5263              		.loc 1 2377 0
 5264              		.cfi_startproc
 5265              		@ args = 0, pretend = 0, frame = 8
 5266              		@ frame_needed = 1, uses_anonymous_args = 0
 5267              		@ link register save eliminated.
 5268 23f8 80B4     		push	{r7}
 5269              	.LCFI138:
 5270              		.cfi_def_cfa_offset 4
 5271              		.cfi_offset 7, -4
 5272 23fa 83B0     		sub	sp, sp, #12
 5273              	.LCFI139:
 5274              		.cfi_def_cfa_offset 16
 5275 23fc 00AF     		add	r7, sp, #0
 5276              	.LCFI140:
 5277              		.cfi_def_cfa_register 7
 5278 23fe 7860     		str	r0, [r7, #4]
2378:openstack/02a-MAClow/IEEE802154Ecsl.c ****    array[0]         = (ieee154e_vars.asn.bytes0and1     & 0xff);
 5279              		.loc 1 2378 0
 5280 2400 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5281 2404 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5282 2408 B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 5283 240c 9BB2     		uxth	r3, r3
 5284 240e DAB2     		uxtb	r2, r3
 5285 2410 7B68     		ldr	r3, [r7, #4]
 5286 2412 1A70     		strb	r2, [r3, #0]
2379:openstack/02a-MAClow/IEEE802154Ecsl.c ****    array[1]         = (ieee154e_vars.asn.bytes0and1/256 & 0xff);
 5287              		.loc 1 2379 0
 5288 2414 7B68     		ldr	r3, [r7, #4]
 5289 2416 03F10102 		add	r2, r3, #1
 5290 241a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5291 241e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5292 2422 B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 5293 2426 9BB2     		uxth	r3, r3
 5294 2428 4FEA1323 		lsr	r3, r3, #8
 5295 242c 9BB2     		uxth	r3, r3
 5296 242e DBB2     		uxtb	r3, r3
 5297 2430 1370     		strb	r3, [r2, #0]
2380:openstack/02a-MAClow/IEEE802154Ecsl.c ****    array[2]         = (ieee154e_vars.asn.bytes2and3     & 0xff);
 5298              		.loc 1 2380 0
 5299 2432 7B68     		ldr	r3, [r7, #4]
 5300 2434 03F10202 		add	r2, r3, #2
 5301 2438 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5302 243c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5303 2440 B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 5304 2444 9BB2     		uxth	r3, r3
 5305 2446 DBB2     		uxtb	r3, r3
 5306 2448 1370     		strb	r3, [r2, #0]
2381:openstack/02a-MAClow/IEEE802154Ecsl.c ****    array[3]         = (ieee154e_vars.asn.bytes2and3/256 & 0xff);
 5307              		.loc 1 2381 0
 5308 244a 7B68     		ldr	r3, [r7, #4]
 5309 244c 03F10302 		add	r2, r3, #3
 5310 2450 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5311 2454 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5312 2458 B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 5313 245c 9BB2     		uxth	r3, r3
 5314 245e 4FEA1323 		lsr	r3, r3, #8
 5315 2462 9BB2     		uxth	r3, r3
 5316 2464 DBB2     		uxtb	r3, r3
 5317 2466 1370     		strb	r3, [r2, #0]
2382:openstack/02a-MAClow/IEEE802154Ecsl.c ****    array[4]         =  ieee154e_vars.asn.byte4;
 5318              		.loc 1 2382 0
 5319 2468 7B68     		ldr	r3, [r7, #4]
 5320 246a 03F10402 		add	r2, r3, #4
 5321 246e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5322 2472 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5323 2476 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 5324 2478 1370     		strb	r3, [r2, #0]
2383:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5325              		.loc 1 2383 0
 5326 247a 07F10C07 		add	r7, r7, #12
 5327 247e BD46     		mov	sp, r7
 5328 2480 80BC     		pop	{r7}
 5329 2482 7047     		bx	lr
 5330              		.cfi_endproc
 5331              	.LFE58:
 5333              		.align	2
 5334              		.global	synchronizeAck
 5335              		.thumb
 5336              		.thumb_func
 5338              	synchronizeAck:
 5339              	.LFB59:
2384:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2385:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2386:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================  SYNCHRONIZATION ==============================
2387:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2388:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2389:openstack/02a-MAClow/IEEE802154Ecsl.c **** void synchronizeAck(PORT_SIGNED_INT_WIDTH timeCorrection) {
 5340              		.loc 1 2389 0
 5341              		.cfi_startproc
 5342              		@ args = 0, pretend = 0, frame = 16
 5343              		@ frame_needed = 1, uses_anonymous_args = 0
 5344 2484 90B5     		push	{r4, r7, lr}
 5345              	.LCFI141:
 5346              		.cfi_def_cfa_offset 12
 5347              		.cfi_offset 4, -12
 5348              		.cfi_offset 7, -8
 5349              		.cfi_offset 14, -4
 5350 2486 87B0     		sub	sp, sp, #28
 5351              	.LCFI142:
 5352              		.cfi_def_cfa_offset 40
 5353 2488 02AF     		add	r7, sp, #8
 5354              	.LCFI143:
 5355              		.cfi_def_cfa 7, 32
 5356 248a 7860     		str	r0, [r7, #4]
2390:openstack/02a-MAClow/IEEE802154Ecsl.c ****    PORT_RADIOTIMER_WIDTH newPeriod;
2391:openstack/02a-MAClow/IEEE802154Ecsl.c ****    PORT_RADIOTIMER_WIDTH currentPeriod;
2392:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
2393:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // calculate new period
2394:openstack/02a-MAClow/IEEE802154Ecsl.c ****    currentPeriod                  =  radio_getTimerPeriod();
 5357              		.loc 1 2394 0
 5358 248c FFF7FEFF 		bl	radio_getTimerPeriod
 5359 2490 F860     		str	r0, [r7, #12]
2395:openstack/02a-MAClow/IEEE802154Ecsl.c ****    newPeriod                      =  (PORT_RADIOTIMER_WIDTH)((PORT_SIGNED_INT_WIDTH)currentPeriod-t
 5360              		.loc 1 2395 0
 5361 2492 FA68     		ldr	r2, [r7, #12]
 5362 2494 7B68     		ldr	r3, [r7, #4]
 5363 2496 D31A     		subs	r3, r2, r3
 5364 2498 BB60     		str	r3, [r7, #8]
2396:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2397:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // resynchronize by applying the new period
2398:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_setTimerPeriod(newPeriod);
 5365              		.loc 1 2398 0
 5366 249a B868     		ldr	r0, [r7, #8]
 5367 249c FFF7FEFF 		bl	radio_setTimerPeriod
2399:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
2400:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // reset the de-synchronization timeout
2401:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.deSyncTimeout    = DESYNCTIMEOUT;
 5368              		.loc 1 2401 0
 5369 24a0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5370 24a4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5371 24a8 40F61D12 		movw	r2, #2333
 5372 24ac DA60     		str	r2, [r3, #12]
2402:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
2403:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // indicate time correction to adaptive sync module
2404:openstack/02a-MAClow/IEEE802154Ecsl.c ****    adaptive_sync_indicateTimeCorrection((-timeCorrection),ieee154e_vars.ackReceived->l2_nextORprevi
 5373              		.loc 1 2404 0
 5374 24ae 7B68     		ldr	r3, [r7, #4]
 5375 24b0 9BB2     		uxth	r3, r3
 5376 24b2 C3F10003 		rsb	r3, r3, #0
 5377 24b6 9BB2     		uxth	r3, r3
 5378 24b8 99B2     		uxth	r1, r3
 5379 24ba 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5380 24be C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5381 24c2 1A6A     		ldr	r2, [r3, #32]
 5382 24c4 0CB2     		sxth	r4, r1
 5383 24c6 6B46     		mov	r3, sp
 5384 24c8 02F14401 		add	r1, r2, #68
 5385 24cc 03C9     		ldmia	r1, {r0, r1}
 5386 24ce 1860     		str	r0, [r3, #0]
 5387 24d0 03F10403 		add	r3, r3, #4
 5388 24d4 1970     		strb	r1, [r3, #0]
 5389 24d6 02F13803 		add	r3, r2, #56
 5390 24da 0ECB     		ldmia	r3, {r1, r2, r3}
 5391 24dc 2046     		mov	r0, r4
 5392 24de FFF7FEFF 		bl	adaptive_sync_indicateTimeCorrection
2405:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
2406:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log a large timeCorrection
2407:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (
2408:openstack/02a-MAClow/IEEE802154Ecsl.c ****          ieee154e_vars.isSync==TRUE &&
 5393              		.loc 1 2408 0
 5394 24e2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5395 24e6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5396 24ea 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
2407:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (
 5397              		.loc 1 2407 0
 5398 24ec 002B     		cmp	r3, #0
 5399 24ee 11D0     		beq	.L253
 5400              		.loc 1 2408 0
 5401 24f0 7B68     		ldr	r3, [r7, #4]
 5402 24f2 13F1050F 		cmn	r3, #5
 5403 24f6 02DB     		blt	.L254
2409:openstack/02a-MAClow/IEEE802154Ecsl.c ****          (
2410:openstack/02a-MAClow/IEEE802154Ecsl.c ****             timeCorrection<-LIMITLARGETIMECORRECTION ||
 5404              		.loc 1 2410 0
 5405 24f8 7B68     		ldr	r3, [r7, #4]
 5406 24fa 052B     		cmp	r3, #5
 5407 24fc 0ADD     		ble	.L253
 5408              	.L254:
2411:openstack/02a-MAClow/IEEE802154Ecsl.c ****             timeCorrection> LIMITLARGETIMECORRECTION
2412:openstack/02a-MAClow/IEEE802154Ecsl.c ****          )
2413:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ) {
2414:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openserial_printError(COMPONENT_IEEE802154E,ERR_LARGE_TIMECORRECTION,
 5409              		.loc 1 2414 0
 5410 24fe 7B68     		ldr	r3, [r7, #4]
 5411 2500 9BB2     		uxth	r3, r3
 5412 2502 4FF00900 		mov	r0, #9
 5413 2506 4FF01C01 		mov	r1, #28
 5414 250a 1A46     		mov	r2, r3
 5415 250c 4FF00103 		mov	r3, #1
 5416 2510 FFF7FEFF 		bl	openserial_printError
 5417              	.L253:
2415:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)timeCorrection,
2416:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)1);
2417:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2418:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // update the stats
2419:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.numSyncAck++;
 5418              		.loc 1 2419 0
 5419 2514 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5420 2518 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5421 251c 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 5422 251e 03F10103 		add	r3, r3, #1
 5423 2522 DAB2     		uxtb	r2, r3
 5424 2524 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5425 2528 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5426 252c 5A70     		strb	r2, [r3, #1]
2420:openstack/02a-MAClow/IEEE802154Ecsl.c ****    updateStats(timeCorrection);
 5427              		.loc 1 2420 0
 5428 252e 7868     		ldr	r0, [r7, #4]
 5429 2530 FFF7FEFF 		bl	updateStats
2421:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
2422:openstack/02a-MAClow/IEEE802154Ecsl.c **** #ifdef OPENSIM
2423:openstack/02a-MAClow/IEEE802154Ecsl.c ****    debugpins_syncAck_set();
2424:openstack/02a-MAClow/IEEE802154Ecsl.c ****    debugpins_syncAck_clr();
2425:openstack/02a-MAClow/IEEE802154Ecsl.c **** #endif
2426:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5430              		.loc 1 2426 0
 5431 2534 07F11407 		add	r7, r7, #20
 5432 2538 BD46     		mov	sp, r7
 5433 253a 90BD     		pop	{r4, r7, pc}
 5434              		.cfi_endproc
 5435              	.LFE59:
 5437              		.align	2
 5438              		.global	changeIsSync
 5439              		.thumb
 5440              		.thumb_func
 5442              	changeIsSync:
 5443              	.LFB60:
2427:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2428:openstack/02a-MAClow/IEEE802154Ecsl.c **** void changeIsSync(bool newIsSync) {
 5444              		.loc 1 2428 0
 5445              		.cfi_startproc
 5446              		@ args = 0, pretend = 0, frame = 8
 5447              		@ frame_needed = 1, uses_anonymous_args = 0
 5448 253c 80B5     		push	{r7, lr}
 5449              	.LCFI144:
 5450              		.cfi_def_cfa_offset 8
 5451              		.cfi_offset 7, -8
 5452              		.cfi_offset 14, -4
 5453 253e 82B0     		sub	sp, sp, #8
 5454              	.LCFI145:
 5455              		.cfi_def_cfa_offset 16
 5456 2540 00AF     		add	r7, sp, #0
 5457              	.LCFI146:
 5458              		.cfi_def_cfa_register 7
 5459 2542 0346     		mov	r3, r0
 5460 2544 FB71     		strb	r3, [r7, #7]
2429:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.isSync = newIsSync;
 5461              		.loc 1 2429 0
 5462 2546 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5463 254a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5464 254e FA79     		ldrb	r2, [r7, #7]
 5465 2550 1A74     		strb	r2, [r3, #16]
2430:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
2431:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.isSync==TRUE) {
 5466              		.loc 1 2431 0
 5467 2552 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5468 2556 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5469 255a 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
 5470 255c 002B     		cmp	r3, #0
 5471 255e 04D0     		beq	.L256
2432:openstack/02a-MAClow/IEEE802154Ecsl.c ****       leds_sync_on();
 5472              		.loc 1 2432 0
 5473 2560 FFF7FEFF 		bl	leds_sync_on
2433:openstack/02a-MAClow/IEEE802154Ecsl.c ****       resetStats();
 5474              		.loc 1 2433 0
 5475 2564 FFF7FEFF 		bl	resetStats
 5476 2568 03E0     		b	.L255
 5477              	.L256:
2434:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
2435:openstack/02a-MAClow/IEEE802154Ecsl.c ****       leds_sync_off();
 5478              		.loc 1 2435 0
 5479 256a FFF7FEFF 		bl	leds_sync_off
2436:openstack/02a-MAClow/IEEE802154Ecsl.c ****       schedule_resetBackoff();
 5480              		.loc 1 2436 0
 5481 256e FFF7FEFF 		bl	schedule_resetBackoff
 5482              	.L255:
2437:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2438:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5483              		.loc 1 2438 0
 5484 2572 07F10807 		add	r7, r7, #8
 5485 2576 BD46     		mov	sp, r7
 5486 2578 80BD     		pop	{r7, pc}
 5487              		.cfi_endproc
 5488              	.LFE60:
 5490 257a 00BF     		.align	2
 5491              		.global	notif_sendDone
 5492              		.thumb
 5493              		.thumb_func
 5495              	notif_sendDone:
 5496              	.LFB61:
2439:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2440:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2441:openstack/02a-MAClow/IEEE802154Ecsl.c **** //=====================  NOTIFY UPPER LAYER  ===========================
2442:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2443:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2444:openstack/02a-MAClow/IEEE802154Ecsl.c **** void notif_sendDone(OpenQueueEntry_t* packetSent, owerror_t error) {
 5497              		.loc 1 2444 0
 5498              		.cfi_startproc
 5499              		@ args = 0, pretend = 0, frame = 8
 5500              		@ frame_needed = 1, uses_anonymous_args = 0
 5501 257c 80B5     		push	{r7, lr}
 5502              	.LCFI147:
 5503              		.cfi_def_cfa_offset 8
 5504              		.cfi_offset 7, -8
 5505              		.cfi_offset 14, -4
 5506 257e 82B0     		sub	sp, sp, #8
 5507              	.LCFI148:
 5508              		.cfi_def_cfa_offset 16
 5509 2580 00AF     		add	r7, sp, #0
 5510              	.LCFI149:
 5511              		.cfi_def_cfa_register 7
 5512 2582 7860     		str	r0, [r7, #4]
 5513 2584 0B46     		mov	r3, r1
 5514 2586 FB70     		strb	r3, [r7, #3]
2445:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the outcome of the trasmission attempt
2446:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packetSent->l2_sendDoneError   = error;
 5515              		.loc 1 2446 0
 5516 2588 7B68     		ldr	r3, [r7, #4]
 5517 258a FA78     		ldrb	r2, [r7, #3]
 5518 258c 83F83720 		strb	r2, [r3, #55]
2447:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the current ASN
2448:openstack/02a-MAClow/IEEE802154Ecsl.c ****    memcpy(&packetSent->l2_asn,&ieee154e_vars.asn,sizeof(asn_t));
 5519              		.loc 1 2448 0
 5520 2590 7B68     		ldr	r3, [r7, #4]
 5521 2592 03F14D02 		add	r2, r3, #77
 5522 2596 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5523 259a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5524 259e 1868     		ldr	r0, [r3, #0]	@ unaligned
 5525 25a0 1060     		str	r0, [r2, #0]	@ unaligned
 5526 25a2 1B79     		ldrb	r3, [r3, #4]
 5527 25a4 1371     		strb	r3, [r2, #4]
2449:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // associate this packet with the virtual component
2450:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // COMPONENT_IEEE802154E_TO_RES so RES can knows it's for it
2451:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packetSent->owner              = COMPONENT_IEEE802154E_TO_SIXTOP;
 5528              		.loc 1 2451 0
 5529 25a6 7B68     		ldr	r3, [r7, #4]
 5530 25a8 4FF00B02 		mov	r2, #11
 5531 25ac 5A70     		strb	r2, [r3, #1]
2452:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // post RES's sendDone task
2453:openstack/02a-MAClow/IEEE802154Ecsl.c ****    scheduler_push_task(task_sixtopNotifSendDone,TASKPRIO_SIXTOP_NOTIF_TXDONE);
 5532              		.loc 1 2453 0
 5533 25ae 40F20000 		movw	r0, #:lower16:task_sixtopNotifSendDone
 5534 25b2 C0F20000 		movt	r0, #:upper16:task_sixtopNotifSendDone
 5535 25b6 4FF00201 		mov	r1, #2
 5536 25ba FFF7FEFF 		bl	scheduler_push_task
2454:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // wake up the scheduler
2455:openstack/02a-MAClow/IEEE802154Ecsl.c ****    SCHEDULER_WAKEUP();
2456:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5537              		.loc 1 2456 0
 5538 25be 07F10807 		add	r7, r7, #8
 5539 25c2 BD46     		mov	sp, r7
 5540 25c4 80BD     		pop	{r7, pc}
 5541              		.cfi_endproc
 5542              	.LFE61:
 5544 25c6 00BF     		.align	2
 5545              		.global	notif_receive
 5546              		.thumb
 5547              		.thumb_func
 5549              	notif_receive:
 5550              	.LFB62:
2457:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2458:openstack/02a-MAClow/IEEE802154Ecsl.c **** // Modified notif_receive signature to add action for CSL testing purposes.
2459:openstack/02a-MAClow/IEEE802154Ecsl.c **** // Packet is removed on endOps in order to not fill all the slots on queue due
2460:openstack/02a-MAClow/IEEE802154Ecsl.c **** // to no sixtop action is defined for receive and process incoming packets.
2461:openstack/02a-MAClow/IEEE802154Ecsl.c **** // Then, we comment this actions here and add remove packet on endOps method.
2462:openstack/02a-MAClow/IEEE802154Ecsl.c **** void notif_receive(OpenQueueEntry_t* packetReceived, uint8_t action) {
 5551              		.loc 1 2462 0
 5552              		.cfi_startproc
 5553              		@ args = 0, pretend = 0, frame = 8
 5554              		@ frame_needed = 1, uses_anonymous_args = 0
 5555 25c8 80B5     		push	{r7, lr}
 5556              	.LCFI150:
 5557              		.cfi_def_cfa_offset 8
 5558              		.cfi_offset 7, -8
 5559              		.cfi_offset 14, -4
 5560 25ca 82B0     		sub	sp, sp, #8
 5561              	.LCFI151:
 5562              		.cfi_def_cfa_offset 16
 5563 25cc 00AF     		add	r7, sp, #0
 5564              	.LCFI152:
 5565              		.cfi_def_cfa_register 7
 5566 25ce 7860     		str	r0, [r7, #4]
 5567 25d0 0B46     		mov	r3, r1
 5568 25d2 FB70     		strb	r3, [r7, #3]
2463:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the current ASN
2464:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //memcpy(&packetReceived->l2_asn, &ieee154e_vars.asn, sizeof(asn_t));
2465:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2466:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // indicate reception to the schedule, to keep statistics
2467:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //schedule_indicateRx(&packetReceived->l2_asn);
2468:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2469:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // associate this packet with the virtual component
2470:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // COMPONENT_IEEE802154E_TO_SIXTOP so sixtop can knows it's for it
2471:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //packetReceived->owner          = COMPONENT_IEEE802154E_TO_SIXTOP;
2472:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2473:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // post RES's Receive task
2474:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //scheduler_push_task(task_sixtopNotifReceive,TASKPRIO_SIXTOP_NOTIF_RX);
2475:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2476:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // CSL Testing purposes
2477:openstack/02a-MAClow/IEEE802154Ecsl.c ****    switch(action) {
 5569              		.loc 1 2477 0
 5570 25d4 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 5571 25d6 03F1FF33 		add	r3, r3, #-1
 5572 25da 032B     		cmp	r3, #3
 5573 25dc 13D8     		bhi	.L260
 5574 25de 01A2     		adr	r2, .L264
 5575 25e0 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 5576              		.align	2
 5577              	.L264:
 5578 25e4 F5250000 		.word	.L261+1
 5579 25e8 FB250000 		.word	.L262+1
 5580 25ec F5250000 		.word	.L261+1
 5581 25f0 01260000 		.word	.L263+1
 5582              	.L261:
2478:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // OK. verde toggle
2479:openstack/02a-MAClow/IEEE802154Ecsl.c ****    case 1:
2480:openstack/02a-MAClow/IEEE802154Ecsl.c ****    case 3: leds_radio_toggle(); break;
 5583              		.loc 1 2480 0
 5584 25f4 FFF7FEFF 		bl	leds_radio_toggle
 5585 25f8 07E0     		b	.L259
 5586              	.L262:
2481:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Error ACK. naranja toggle
2482:openstack/02a-MAClow/IEEE802154Ecsl.c ****    case 2: leds_sync_toggle();  break;
 5587              		.loc 1 2482 0
 5588 25fa FFF7FEFF 		bl	leds_sync_toggle
 5589 25fe 04E0     		b	.L259
 5590              	.L263:
2483:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Error EndOps
2484:openstack/02a-MAClow/IEEE802154Ecsl.c ****    case 4: leds_error_toggle(); break;
 5591              		.loc 1 2484 0
 5592 2600 FFF7FEFF 		bl	leds_error_toggle
 5593 2604 01E0     		b	.L259
 5594              	.L260:
2485:openstack/02a-MAClow/IEEE802154Ecsl.c ****    default: leds_all_off();
 5595              		.loc 1 2485 0
 5596 2606 FFF7FEFF 		bl	leds_all_off
 5597              	.L259:
2486:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2487:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2488:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // wake up the scheduler
2489:openstack/02a-MAClow/IEEE802154Ecsl.c ****    SCHEDULER_WAKEUP();
2490:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5598              		.loc 1 2490 0
 5599 260a 07F10807 		add	r7, r7, #8
 5600 260e BD46     		mov	sp, r7
 5601 2610 80BD     		pop	{r7, pc}
 5602              		.cfi_endproc
 5603              	.LFE62:
 5605 2612 00BF     		.align	2
 5606              		.global	resetStats
 5607              		.thumb
 5608              		.thumb_func
 5610              	resetStats:
 5611              	.LFB63:
2491:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2492:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2493:openstack/02a-MAClow/IEEE802154Ecsl.c **** //============================== STATS =================================
2494:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2495:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2496:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void resetStats() {
 5612              		.loc 1 2496 0
 5613              		.cfi_startproc
 5614              		@ args = 0, pretend = 0, frame = 0
 5615              		@ frame_needed = 1, uses_anonymous_args = 0
 5616              		@ link register save eliminated.
 5617 2614 80B4     		push	{r7}
 5618              	.LCFI153:
 5619              		.cfi_def_cfa_offset 4
 5620              		.cfi_offset 7, -4
 5621 2616 00AF     		add	r7, sp, #0
 5622              	.LCFI154:
 5623              		.cfi_def_cfa_register 7
2497:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.numSyncPkt      =    0;
 5624              		.loc 1 2497 0
 5625 2618 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5626 261c C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5627 2620 4FF00002 		mov	r2, #0
 5628 2624 1A70     		strb	r2, [r3, #0]
2498:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.numSyncAck      =    0;
 5629              		.loc 1 2498 0
 5630 2626 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5631 262a C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5632 262e 4FF00002 		mov	r2, #0
 5633 2632 5A70     		strb	r2, [r3, #1]
2499:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.minCorrection   =  127;
 5634              		.loc 1 2499 0
 5635 2634 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5636 2638 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5637 263c 4FF07F02 		mov	r2, #127
 5638 2640 5A80     		strh	r2, [r3, #2]	@ movhi
2500:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.maxCorrection   = -127;
 5639              		.loc 1 2500 0
 5640 2642 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5641 2646 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5642 264a 4FF68172 		movw	r2, #65409
 5643 264e 9A80     		strh	r2, [r3, #4]	@ movhi
2501:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.numTicsOn       =    0;
 5644              		.loc 1 2501 0
 5645 2650 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5646 2654 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5647 2658 4FF00002 		mov	r2, #0
 5648 265c DA71     		strb	r2, [r3, #7]
 5649 265e 9A68     		ldr	r2, [r3, #8]
 5650 2660 02F07F42 		and	r2, r2, #-16777216
 5651 2664 9A60     		str	r2, [r3, #8]
2502:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.numTicsTotal    =    0;
 5652              		.loc 1 2502 0
 5653 2666 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5654 266a C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5655 266e 4FF00002 		mov	r2, #0
 5656 2672 DA72     		strb	r2, [r3, #11]
 5657 2674 DA68     		ldr	r2, [r3, #12]
 5658 2676 02F07F42 		and	r2, r2, #-16777216
 5659 267a DA60     		str	r2, [r3, #12]
2503:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // do not reset the number of de-synchronizations
2504:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5660              		.loc 1 2504 0
 5661 267c BD46     		mov	sp, r7
 5662 267e 80BC     		pop	{r7}
 5663 2680 7047     		bx	lr
 5664              		.cfi_endproc
 5665              	.LFE63:
 5667 2682 00BF     		.align	2
 5668              		.global	updateStats
 5669              		.thumb
 5670              		.thumb_func
 5672              	updateStats:
 5673              	.LFB64:
2505:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2506:openstack/02a-MAClow/IEEE802154Ecsl.c **** void updateStats(PORT_SIGNED_INT_WIDTH timeCorrection) {
 5674              		.loc 1 2506 0
 5675              		.cfi_startproc
 5676              		@ args = 0, pretend = 0, frame = 8
 5677              		@ frame_needed = 1, uses_anonymous_args = 0
 5678              		@ link register save eliminated.
 5679 2684 80B4     		push	{r7}
 5680              	.LCFI155:
 5681              		.cfi_def_cfa_offset 4
 5682              		.cfi_offset 7, -4
 5683 2686 83B0     		sub	sp, sp, #12
 5684              	.LCFI156:
 5685              		.cfi_def_cfa_offset 16
 5686 2688 00AF     		add	r7, sp, #0
 5687              	.LCFI157:
 5688              		.cfi_def_cfa_register 7
 5689 268a 7860     		str	r0, [r7, #4]
2507:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // update minCorrection
2508:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (timeCorrection<ieee154e_stats.minCorrection) {
 5690              		.loc 1 2508 0
 5691 268c 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5692 2690 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5693 2694 5B88     		ldrh	r3, [r3, #2]
 5694 2696 1AB2     		sxth	r2, r3
 5695 2698 7B68     		ldr	r3, [r7, #4]
 5696 269a 9A42     		cmp	r2, r3
 5697 269c 06DD     		ble	.L268
2509:openstack/02a-MAClow/IEEE802154Ecsl.c ****      ieee154e_stats.minCorrection = timeCorrection;
 5698              		.loc 1 2509 0
 5699 269e 7B68     		ldr	r3, [r7, #4]
 5700 26a0 9AB2     		uxth	r2, r3
 5701 26a2 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5702 26a6 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5703 26aa 5A80     		strh	r2, [r3, #2]	@ movhi
 5704              	.L268:
2510:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2511:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // update maxConnection
2512:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if(timeCorrection>ieee154e_stats.maxCorrection) {
 5705              		.loc 1 2512 0
 5706 26ac 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5707 26b0 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5708 26b4 9B88     		ldrh	r3, [r3, #4]
 5709 26b6 1AB2     		sxth	r2, r3
 5710 26b8 7B68     		ldr	r3, [r7, #4]
 5711 26ba 9A42     		cmp	r2, r3
 5712 26bc 06DA     		bge	.L267
2513:openstack/02a-MAClow/IEEE802154Ecsl.c ****      ieee154e_stats.maxCorrection = timeCorrection;
 5713              		.loc 1 2513 0
 5714 26be 7B68     		ldr	r3, [r7, #4]
 5715 26c0 9AB2     		uxth	r2, r3
 5716 26c2 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5717 26c6 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5718 26ca 9A80     		strh	r2, [r3, #4]	@ movhi
 5719              	.L267:
2514:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2515:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5720              		.loc 1 2515 0
 5721 26cc 07F10C07 		add	r7, r7, #12
 5722 26d0 BD46     		mov	sp, r7
 5723 26d2 80BC     		pop	{r7}
 5724 26d4 7047     		bx	lr
 5725              		.cfi_endproc
 5726              	.LFE64:
 5728 26d6 00BF     		.align	2
 5729              		.global	changeState
 5730              		.thumb
 5731              		.thumb_func
 5733              	changeState:
 5734              	.LFB65:
2516:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2517:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2518:openstack/02a-MAClow/IEEE802154Ecsl.c **** //============================== MISC ==================================
2519:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2520:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2521:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2522:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Changes the state of the IEEE802.15.4e FSM.
2523:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2524:openstack/02a-MAClow/IEEE802154Ecsl.c **** Besides simply updating the state global variable,
2525:openstack/02a-MAClow/IEEE802154Ecsl.c **** this function toggles the FSM debug pin.
2526:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2527:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in] newstate The state the IEEE802.15.4e FSM is now in.
2528:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2529:openstack/02a-MAClow/IEEE802154Ecsl.c **** void changeState(ieee154e_state_t newstate) {
 5735              		.loc 1 2529 0
 5736              		.cfi_startproc
 5737              		@ args = 0, pretend = 0, frame = 8
 5738              		@ frame_needed = 1, uses_anonymous_args = 0
 5739 26d8 80B5     		push	{r7, lr}
 5740              	.LCFI158:
 5741              		.cfi_def_cfa_offset 8
 5742              		.cfi_offset 7, -8
 5743              		.cfi_offset 14, -4
 5744 26da 82B0     		sub	sp, sp, #8
 5745              	.LCFI159:
 5746              		.cfi_def_cfa_offset 16
 5747 26dc 00AF     		add	r7, sp, #0
 5748              	.LCFI160:
 5749              		.cfi_def_cfa_register 7
 5750 26de 0346     		mov	r3, r0
 5751 26e0 FB71     		strb	r3, [r7, #7]
2530:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // update the state
2531:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.state = newstate;
 5752              		.loc 1 2531 0
 5753 26e2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5754 26e6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5755 26ea FA79     		ldrb	r2, [r7, #7]
 5756 26ec 5A74     		strb	r2, [r3, #17]
2532:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // wiggle the FSM debug pin
2533:openstack/02a-MAClow/IEEE802154Ecsl.c ****    switch (ieee154e_vars.state) {
 5757              		.loc 1 2533 0
 5758 26ee 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5759 26f2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5760 26f6 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 5761 26f8 3B2B     		cmp	r3, #59
 5762 26fa 00F28480 		bhi	.L270
 5763 26fe 01A2     		adr	r2, .L275
 5764 2700 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 5765              		.align	2
 5766              	.L275:
 5767 2704 FB270000 		.word	.L272+1
 5768 2708 07280000 		.word	.L270+1
 5769 270c 07280000 		.word	.L270+1
 5770 2710 07280000 		.word	.L270+1
 5771 2714 07280000 		.word	.L270+1
 5772 2718 07280000 		.word	.L270+1
 5773 271c 07280000 		.word	.L270+1
 5774 2720 07280000 		.word	.L270+1
 5775 2724 07280000 		.word	.L270+1
 5776 2728 07280000 		.word	.L270+1
 5777 272c 07280000 		.word	.L270+1
 5778 2730 07280000 		.word	.L270+1
 5779 2734 07280000 		.word	.L270+1
 5780 2738 07280000 		.word	.L270+1
 5781 273c 07280000 		.word	.L270+1
 5782 2740 07280000 		.word	.L270+1
 5783 2744 07280000 		.word	.L270+1
 5784 2748 07280000 		.word	.L270+1
 5785 274c 07280000 		.word	.L270+1
 5786 2750 07280000 		.word	.L270+1
 5787 2754 07280000 		.word	.L270+1
 5788 2758 07280000 		.word	.L270+1
 5789 275c 07280000 		.word	.L270+1
 5790 2760 07280000 		.word	.L270+1
 5791 2764 07280000 		.word	.L270+1
 5792 2768 07280000 		.word	.L270+1
 5793 276c F5270000 		.word	.L273+1
 5794 2770 01280000 		.word	.L274+1
 5795 2774 01280000 		.word	.L274+1
 5796 2778 01280000 		.word	.L274+1
 5797 277c 01280000 		.word	.L274+1
 5798 2780 F5270000 		.word	.L273+1
 5799 2784 01280000 		.word	.L274+1
 5800 2788 01280000 		.word	.L274+1
 5801 278c 01280000 		.word	.L274+1
 5802 2790 01280000 		.word	.L274+1
 5803 2794 01280000 		.word	.L274+1
 5804 2798 01280000 		.word	.L274+1
 5805 279c 01280000 		.word	.L274+1
 5806 27a0 01280000 		.word	.L274+1
 5807 27a4 01280000 		.word	.L274+1
 5808 27a8 01280000 		.word	.L274+1
 5809 27ac FB270000 		.word	.L272+1
 5810 27b0 01280000 		.word	.L274+1
 5811 27b4 01280000 		.word	.L274+1
 5812 27b8 01280000 		.word	.L274+1
 5813 27bc 01280000 		.word	.L274+1
 5814 27c0 01280000 		.word	.L274+1
 5815 27c4 FB270000 		.word	.L272+1
 5816 27c8 01280000 		.word	.L274+1
 5817 27cc 01280000 		.word	.L274+1
 5818 27d0 01280000 		.word	.L274+1
 5819 27d4 01280000 		.word	.L274+1
 5820 27d8 01280000 		.word	.L274+1
 5821 27dc 01280000 		.word	.L274+1
 5822 27e0 01280000 		.word	.L274+1
 5823 27e4 01280000 		.word	.L274+1
 5824 27e8 01280000 		.word	.L274+1
 5825 27ec 01280000 		.word	.L274+1
 5826 27f0 F5270000 		.word	.L273+1
 5827              	.L273:
2534:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXWAKEUPOFFSET:
2535:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXDATAPREOFFSET:
2536:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXDATAOFFSET:
2537:openstack/02a-MAClow/IEEE802154Ecsl.c ****          debugpins_fsm_set();
 5828              		.loc 1 2537 0
 5829 27f4 FFF7FEFF 		bl	debugpins_fsm_set
2538:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 5830              		.loc 1 2538 0
 5831 27f8 05E0     		b	.L270
 5832              	.L272:
2539:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_SLEEP:
2540:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXDATAOFFSET:
2541:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXWAKEUPOFFSET:
2542:openstack/02a-MAClow/IEEE802154Ecsl.c ****          debugpins_fsm_clr();
 5833              		.loc 1 2542 0
 5834 27fa FFF7FEFF 		bl	debugpins_fsm_clr
2543:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 5835              		.loc 1 2543 0
 5836 27fe 02E0     		b	.L270
 5837              	.L274:
2544:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2545:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // ------- TX STATES -------
2546:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2547:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Estados usados para la transmisión de tramas WAKE-UP previas a la trama de datos (Wake-Up
2548:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXWAKEUPPREPARE:
2549:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXWAKEUPREADY:
2550:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXWAKEUPDELAY:
2551:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXWAKEUP:
2552:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2553:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Estados usados para la transmisión del paquete de datos y la recepción del ACK.
2554:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXDATAPREPARE:
2555:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXDATAREADY:
2556:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXDATADELAY:
2557:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXDATA:
2558:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2559:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXACKOFFSET:
2560:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXACKPREPARE:
2561:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXACKREADY:
2562:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXACKLISTEN:
2563:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXACK:
2564:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXPROC:
2565:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2566:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // ------- RX STATES -------
2567:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2568:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Estados usados para la recepción y tratamiento de la trama de WAKE-UP.
2569:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXWAKEUPPREPARE:
2570:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXWAKEUPREADY:
2571:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXWAKEUPLISTEN:
2572:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXWAKEUP:
2573:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXWAKEUPVALIDATE:
2574:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2575:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Estados usados para la recepción del paquete de datos y la transmisión del ACK.
2576:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXDATAPREPARE:
2577:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXDATAREADY:
2578:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXDATALISTEN:
2579:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXDATA:
2580:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2581:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXACKOFFSET:
2582:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXACKPREPARE:
2583:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXACKREADY:
2584:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXACKDELAY:
2585:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXACK:
2586:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXPROC:
2587:openstack/02a-MAClow/IEEE802154Ecsl.c ****          debugpins_fsm_toggle();
 5838              		.loc 1 2587 0
 5839 2800 FFF7FEFF 		bl	debugpins_fsm_toggle
2588:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 5840              		.loc 1 2588 0
 5841 2804 00BF     		nop
 5842              	.L270:
2589:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2590:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5843              		.loc 1 2590 0
 5844 2806 07F10807 		add	r7, r7, #8
 5845 280a BD46     		mov	sp, r7
 5846 280c 80BD     		pop	{r7, pc}
 5847              		.cfi_endproc
 5848              	.LFE65:
 5850 280e 00BF     		.align	2
 5851              		.global	debugPrint_asn
 5852              		.thumb
 5853              		.thumb_func
 5855              	debugPrint_asn:
 5856              	.LFB66:
2591:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2592:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2593:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Trigger this module to print status information, over serial.
2594:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2595:openstack/02a-MAClow/IEEE802154Ecsl.c **** debugPrint_* functions are used by the openserial module to continuously print
2596:openstack/02a-MAClow/IEEE802154Ecsl.c **** status information about several modules in the OpenWSN stack.
2597:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2598:openstack/02a-MAClow/IEEE802154Ecsl.c **** \returns TRUE if this function printed something, FALSE otherwise.
2599:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2600:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool debugPrint_asn() {
 5857              		.loc 1 2600 0
 5858              		.cfi_startproc
 5859              		@ args = 0, pretend = 0, frame = 8
 5860              		@ frame_needed = 1, uses_anonymous_args = 0
 5861 2810 80B5     		push	{r7, lr}
 5862              	.LCFI161:
 5863              		.cfi_def_cfa_offset 8
 5864              		.cfi_offset 7, -8
 5865              		.cfi_offset 14, -4
 5866 2812 82B0     		sub	sp, sp, #8
 5867              	.LCFI162:
 5868              		.cfi_def_cfa_offset 16
 5869 2814 00AF     		add	r7, sp, #0
 5870              	.LCFI163:
 5871              		.cfi_def_cfa_register 7
2601:openstack/02a-MAClow/IEEE802154Ecsl.c ****    asn_t output;
2602:openstack/02a-MAClow/IEEE802154Ecsl.c ****    output.byte4         =  ieee154e_vars.asn.byte4;
 5872              		.loc 1 2602 0
 5873 2816 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5874 281a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5875 281e 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 5876 2820 3B70     		strb	r3, [r7, #0]
2603:openstack/02a-MAClow/IEEE802154Ecsl.c ****    output.bytes2and3    =  ieee154e_vars.asn.bytes2and3;
 5877              		.loc 1 2603 0
 5878 2822 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5879 2826 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5880 282a B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 5881 282e 9BB2     		uxth	r3, r3
 5882 2830 A7F80130 		strh	r3, [r7, #1]	@ unaligned
2604:openstack/02a-MAClow/IEEE802154Ecsl.c ****    output.bytes0and1    =  ieee154e_vars.asn.bytes0and1;
 5883              		.loc 1 2604 0
 5884 2834 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5885 2838 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5886 283c B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 5887 2840 9BB2     		uxth	r3, r3
 5888 2842 A7F80330 		strh	r3, [r7, #3]	@ unaligned
2605:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printStatus(STATUS_ASN,(uint8_t*)&output,sizeof(output));
 5889              		.loc 1 2605 0
 5890 2846 3B46     		mov	r3, r7
 5891 2848 4FF00400 		mov	r0, #4
 5892 284c 1946     		mov	r1, r3
 5893 284e 4FF00502 		mov	r2, #5
 5894 2852 FFF7FEFF 		bl	openserial_printStatus
2606:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return TRUE;
 5895              		.loc 1 2606 0
 5896 2856 4FF00103 		mov	r3, #1
2607:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5897              		.loc 1 2607 0
 5898 285a 1846     		mov	r0, r3
 5899 285c 07F10807 		add	r7, r7, #8
 5900 2860 BD46     		mov	sp, r7
 5901 2862 80BD     		pop	{r7, pc}
 5902              		.cfi_endproc
 5903              	.LFE66:
 5905              		.align	2
 5906              		.global	debugPrint_isSync
 5907              		.thumb
 5908              		.thumb_func
 5910              	debugPrint_isSync:
 5911              	.LFB67:
2608:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2609:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2610:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Trigger this module to print status information, over serial.
2611:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2612:openstack/02a-MAClow/IEEE802154Ecsl.c **** debugPrint_* functions are used by the openserial module to continuously print
2613:openstack/02a-MAClow/IEEE802154Ecsl.c **** status information about several modules in the OpenWSN stack.
2614:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2615:openstack/02a-MAClow/IEEE802154Ecsl.c **** \returns TRUE if this function printed something, FALSE otherwise.
2616:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2617:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool debugPrint_isSync() {
 5912              		.loc 1 2617 0
 5913              		.cfi_startproc
 5914              		@ args = 0, pretend = 0, frame = 8
 5915              		@ frame_needed = 1, uses_anonymous_args = 0
 5916 2864 80B5     		push	{r7, lr}
 5917              	.LCFI164:
 5918              		.cfi_def_cfa_offset 8
 5919              		.cfi_offset 7, -8
 5920              		.cfi_offset 14, -4
 5921 2866 82B0     		sub	sp, sp, #8
 5922              	.LCFI165:
 5923              		.cfi_def_cfa_offset 16
 5924 2868 00AF     		add	r7, sp, #0
 5925              	.LCFI166:
 5926              		.cfi_def_cfa_register 7
2618:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t output=0;
 5927              		.loc 1 2618 0
 5928 286a 4FF00003 		mov	r3, #0
 5929 286e FB71     		strb	r3, [r7, #7]
2619:openstack/02a-MAClow/IEEE802154Ecsl.c ****    output = ieee154e_vars.isSync;
 5930              		.loc 1 2619 0
 5931 2870 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5932 2874 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5933 2878 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
 5934 287a FB71     		strb	r3, [r7, #7]
2620:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printStatus(STATUS_ISSYNC,(uint8_t*)&output,sizeof(uint8_t));
 5935              		.loc 1 2620 0
 5936 287c 07F10703 		add	r3, r7, #7
 5937 2880 4FF00000 		mov	r0, #0
 5938 2884 1946     		mov	r1, r3
 5939 2886 4FF00102 		mov	r2, #1
 5940 288a FFF7FEFF 		bl	openserial_printStatus
2621:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return TRUE;
 5941              		.loc 1 2621 0
 5942 288e 4FF00103 		mov	r3, #1
2622:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5943              		.loc 1 2622 0
 5944 2892 1846     		mov	r0, r3
 5945 2894 07F10807 		add	r7, r7, #8
 5946 2898 BD46     		mov	sp, r7
 5947 289a 80BD     		pop	{r7, pc}
 5948              		.cfi_endproc
 5949              	.LFE67:
 5951              		.align	2
 5952              		.global	debugPrint_macStats
 5953              		.thumb
 5954              		.thumb_func
 5956              	debugPrint_macStats:
 5957              	.LFB68:
2623:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2624:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2625:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Trigger this module to print status information, over serial.
2626:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2627:openstack/02a-MAClow/IEEE802154Ecsl.c **** debugPrint_* functions are used by the openserial module to continuously print
2628:openstack/02a-MAClow/IEEE802154Ecsl.c **** status information about several modules in the OpenWSN stack.
2629:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2630:openstack/02a-MAClow/IEEE802154Ecsl.c **** \returns TRUE if this function printed something, FALSE otherwise.
2631:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2632:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool debugPrint_macStats() {
 5958              		.loc 1 2632 0
 5959              		.cfi_startproc
 5960              		@ args = 0, pretend = 0, frame = 0
 5961              		@ frame_needed = 1, uses_anonymous_args = 0
 5962 289c 80B5     		push	{r7, lr}
 5963              	.LCFI167:
 5964              		.cfi_def_cfa_offset 8
 5965              		.cfi_offset 7, -8
 5966              		.cfi_offset 14, -4
 5967 289e 00AF     		add	r7, sp, #0
 5968              	.LCFI168:
 5969              		.cfi_def_cfa_register 7
2633:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // send current stats over serial
2634:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printStatus(STATUS_MACSTATS,(uint8_t*)&ieee154e_stats,sizeof(ieee154e_stats_t));
 5970              		.loc 1 2634 0
 5971 28a0 4FF00500 		mov	r0, #5
 5972 28a4 40F20001 		movw	r1, #:lower16:ieee154e_stats
 5973 28a8 C0F20001 		movt	r1, #:upper16:ieee154e_stats
 5974 28ac 4FF00F02 		mov	r2, #15
 5975 28b0 FFF7FEFF 		bl	openserial_printStatus
2635:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return TRUE;
 5976              		.loc 1 2635 0
 5977 28b4 4FF00103 		mov	r3, #1
2636:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5978              		.loc 1 2636 0
 5979 28b8 1846     		mov	r0, r3
 5980 28ba 80BD     		pop	{r7, pc}
 5981              		.cfi_endproc
 5982              	.LFE68:
 5984              		.align	2
 5985              		.global	endOps
 5986              		.thumb
 5987              		.thumb_func
 5989              	endOps:
 5990              	.LFB69:
2637:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2638:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2639:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2640:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Housekeeping tasks to do at the end of each slot.
2641:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2642:openstack/02a-MAClow/IEEE802154Ecsl.c **** This functions is called once in each slot, when there is nothing more
2643:openstack/02a-MAClow/IEEE802154Ecsl.c **** to do. This might be when an error occured, or when everything went well.
2644:openstack/02a-MAClow/IEEE802154Ecsl.c **** This function resets the state of the FSM so it is ready for the next slot.
2645:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2646:openstack/02a-MAClow/IEEE802154Ecsl.c **** Note that by the time this function is called, any received packet should already
2647:openstack/02a-MAClow/IEEE802154Ecsl.c **** have been sent to the upper layer. Similarly, in a Tx slot, the sendDone
2648:openstack/02a-MAClow/IEEE802154Ecsl.c **** function should already have been done. If this is not the case, this function
2649:openstack/02a-MAClow/IEEE802154Ecsl.c **** will do that for you, but assume that something went wrong.
2650:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2651:openstack/02a-MAClow/IEEE802154Ecsl.c **** void endOps() {
 5991              		.loc 1 2651 0
 5992              		.cfi_startproc
 5993              		@ args = 0, pretend = 0, frame = 0
 5994              		@ frame_needed = 1, uses_anonymous_args = 0
 5995 28bc 80B5     		push	{r7, lr}
 5996              	.LCFI169:
 5997              		.cfi_def_cfa_offset 8
 5998              		.cfi_offset 7, -8
 5999              		.cfi_offset 14, -4
 6000 28be 00AF     		add	r7, sp, #0
 6001              	.LCFI170:
 6002              		.cfi_def_cfa_register 7
2652:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2653:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // turn off the radio
2654:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rfOff();
 6003              		.loc 1 2654 0
 6004 28c0 FFF7FEFF 		bl	radio_rfOff
2655:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2656:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clear any pending timer
2657:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 6005              		.loc 1 2657 0
 6006 28c4 FFF7FEFF 		bl	radiotimer_cancel
2658:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2659:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // reset capturedTimes
2660:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.lastCapturedTime = 0;
 6007              		.loc 1 2660 0
 6008 28c8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6009 28cc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6010 28d0 4FF00002 		mov	r2, #0
 6011 28d4 5A62     		str	r2, [r3, #36]
2661:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.syncCapturedTime = 0;
 6012              		.loc 1 2661 0
 6013 28d6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6014 28da C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6015 28de 4FF00002 		mov	r2, #0
 6016 28e2 9A62     		str	r2, [r3, #40]
2662:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2663:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //clear vars for duty cycle on this slot
2664:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnTics=0;
 6017              		.loc 1 2664 0
 6018 28e4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6019 28e8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6020 28ec 4FF00002 		mov	r2, #0
 6021 28f0 5A63     		str	r2, [r3, #52]
2665:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnThisSlot=FALSE;
 6022              		.loc 1 2665 0
 6023 28f2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6024 28f6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6025 28fa 4FF00002 		mov	r2, #0
 6026 28fe 83F83820 		strb	r2, [r3, #56]
2666:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2667:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clean up dataToSend
2668:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.dataToSend!=NULL) {
 6027              		.loc 1 2668 0
 6028 2902 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6029 2906 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6030 290a 5B69     		ldr	r3, [r3, #20]
 6031 290c 002B     		cmp	r3, #0
 6032 290e 33D0     		beq	.L283
2669:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // if everything went well, dataToSend was set to NULL in ti9
2670:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // getting here means transmit failed
2671:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2672:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // indicate Tx fail to schedule to update stats
2673:openstack/02a-MAClow/IEEE802154Ecsl.c ****       schedule_indicateTx(&ieee154e_vars.asn,FALSE);
 6033              		.loc 1 2673 0
 6034 2910 40F20000 		movw	r0, #:lower16:ieee154e_vars
 6035 2914 C0F20000 		movt	r0, #:upper16:ieee154e_vars
 6036 2918 4FF00001 		mov	r1, #0
 6037 291c FFF7FEFF 		bl	schedule_indicateTx
2674:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2675:openstack/02a-MAClow/IEEE802154Ecsl.c ****       //decrement transmits left counter
2676:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataToSend->l2_retriesLeft--;
 6038              		.loc 1 2676 0
 6039 2920 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6040 2924 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6041 2928 5B69     		ldr	r3, [r3, #20]
 6042 292a 93F84B20 		ldrb	r2, [r3, #75]	@ zero_extendqisi2
 6043 292e 02F1FF32 		add	r2, r2, #-1
 6044 2932 D2B2     		uxtb	r2, r2
 6045 2934 83F84B20 		strb	r2, [r3, #75]
2677:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2678:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.dataToSend->l2_retriesLeft==0) {
 6046              		.loc 1 2678 0
 6047 2938 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6048 293c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6049 2940 5B69     		ldr	r3, [r3, #20]
 6050 2942 93F84B30 		ldrb	r3, [r3, #75]	@ zero_extendqisi2
 6051 2946 002B     		cmp	r3, #0
 6052 2948 07D0     		beq	.L284
2679:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 // CSL TEST CODE (comment)
2680:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // indicate tx fail if no more retries left
2681:openstack/02a-MAClow/IEEE802154Ecsl.c ****          //notif_sendDone(ieee154e_vars.dataToSend,E_FAIL);
2682:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 // END TEST CODE
2683:openstack/02a-MAClow/IEEE802154Ecsl.c ****       } else {
2684:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // return packet to the virtual COMPONENT_SIXTOP_TO_IEEE802154E component
2685:openstack/02a-MAClow/IEEE802154Ecsl.c ****          ieee154e_vars.dataToSend->owner = COMPONENT_SIXTOP_TO_IEEE802154E;
 6053              		.loc 1 2685 0
 6054 294a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6055 294e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6056 2952 5B69     		ldr	r3, [r3, #20]
 6057 2954 4FF00A02 		mov	r2, #10
 6058 2958 5A70     		strb	r2, [r3, #1]
 6059              	.L284:
2686:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
2687:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2688:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // CSL - Remove packet for testing because no high entity for packet processing.
2689:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openqueue_freePacketBuffer(ieee154e_vars.dataToSend);
 6060              		.loc 1 2689 0
 6061 295a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6062 295e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6063 2962 5B69     		ldr	r3, [r3, #20]
 6064 2964 1846     		mov	r0, r3
 6065 2966 FFF7FEFF 		bl	openqueue_freePacketBuffer
2690:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2691:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset local variable
2692:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataToSend = NULL;
 6066              		.loc 1 2692 0
 6067 296a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6068 296e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6069 2972 4FF00002 		mov	r2, #0
 6070 2976 5A61     		str	r2, [r3, #20]
 6071              	.L283:
2693:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2694:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2695:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clean up dataReceived
2696:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.dataReceived!=NULL) {
 6072              		.loc 1 2696 0
 6073 2978 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6074 297c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6075 2980 9B69     		ldr	r3, [r3, #24]
 6076 2982 002B     		cmp	r3, #0
 6077 2984 18D0     		beq	.L285
2697:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // assume something went wrong. If everything went well, dataReceived
2698:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // would have been set to NULL in ri9.
2699:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // indicate  "received packet" to upper layer since we don't want to loose packets
2700:openstack/02a-MAClow/IEEE802154Ecsl.c ****       notif_receive(ieee154e_vars.dataReceived,4);
 6078              		.loc 1 2700 0
 6079 2986 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6080 298a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6081 298e 9B69     		ldr	r3, [r3, #24]
 6082 2990 1846     		mov	r0, r3
 6083 2992 4FF00401 		mov	r1, #4
 6084 2996 FFF7FEFF 		bl	notif_receive
2701:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2702:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // CSL - Remove packet for testing because no high entity for packet processing.
2703:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openqueue_freePacketBuffer(ieee154e_vars.dataReceived);
 6085              		.loc 1 2703 0
 6086 299a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6087 299e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6088 29a2 9B69     		ldr	r3, [r3, #24]
 6089 29a4 1846     		mov	r0, r3
 6090 29a6 FFF7FEFF 		bl	openqueue_freePacketBuffer
2704:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2705:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset local variable
2706:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataReceived = NULL;
 6091              		.loc 1 2706 0
 6092 29aa 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6093 29ae C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6094 29b2 4FF00002 		mov	r2, #0
 6095 29b6 9A61     		str	r2, [r3, #24]
 6096              	.L285:
2707:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2708:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2709:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clean up ackToSend
2710:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.ackToSend!=NULL) {
 6097              		.loc 1 2710 0
 6098 29b8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6099 29bc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6100 29c0 DB69     		ldr	r3, [r3, #28]
 6101 29c2 002B     		cmp	r3, #0
 6102 29c4 0ED0     		beq	.L286
2711:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // free ackToSend so corresponding RAM memory can be recycled
2712:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openqueue_freePacketBuffer(ieee154e_vars.ackToSend);
 6103              		.loc 1 2712 0
 6104 29c6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6105 29ca C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6106 29ce DB69     		ldr	r3, [r3, #28]
 6107 29d0 1846     		mov	r0, r3
 6108 29d2 FFF7FEFF 		bl	openqueue_freePacketBuffer
2713:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset local variable
2714:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.ackToSend = NULL;
 6109              		.loc 1 2714 0
 6110 29d6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6111 29da C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6112 29de 4FF00002 		mov	r2, #0
 6113 29e2 DA61     		str	r2, [r3, #28]
 6114              	.L286:
2715:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2716:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2717:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clean up ackReceived
2718:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.ackReceived!=NULL) {
 6115              		.loc 1 2718 0
 6116 29e4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6117 29e8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6118 29ec 1B6A     		ldr	r3, [r3, #32]
 6119 29ee 002B     		cmp	r3, #0
 6120 29f0 0ED0     		beq	.L287
2719:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // free ackReceived so corresponding RAM memory can be recycled
2720:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openqueue_freePacketBuffer(ieee154e_vars.ackReceived);
 6121              		.loc 1 2720 0
 6122 29f2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6123 29f6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6124 29fa 1B6A     		ldr	r3, [r3, #32]
 6125 29fc 1846     		mov	r0, r3
 6126 29fe FFF7FEFF 		bl	openqueue_freePacketBuffer
2721:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset local variable
2722:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.ackReceived = NULL;
 6127              		.loc 1 2722 0
 6128 2a02 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6129 2a06 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6130 2a0a 4FF00002 		mov	r2, #0
 6131 2a0e 1A62     		str	r2, [r3, #32]
 6132              	.L287:
2723:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2724:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2725:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clean up wakeupSend
2726:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.wakeupToSend!=NULL) {
 6133              		.loc 1 2726 0
 6134 2a10 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6135 2a14 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6136 2a18 DB6B     		ldr	r3, [r3, #60]
 6137 2a1a 002B     		cmp	r3, #0
 6138 2a1c 0ED0     		beq	.L288
2727:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // free wakeupToSend so corresponding RAM memory can be recycled
2728:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openqueue_freePacketBuffer(ieee154e_vars.wakeupToSend);
 6139              		.loc 1 2728 0
 6140 2a1e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6141 2a22 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6142 2a26 DB6B     		ldr	r3, [r3, #60]
 6143 2a28 1846     		mov	r0, r3
 6144 2a2a FFF7FEFF 		bl	openqueue_freePacketBuffer
2729:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset local variable
2730:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.wakeupToSend = NULL;
 6145              		.loc 1 2730 0
 6146 2a2e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6147 2a32 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6148 2a36 4FF00002 		mov	r2, #0
 6149 2a3a DA63     		str	r2, [r3, #60]
 6150              	.L288:
2731:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2732:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2733:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clean up wakeupReceived
2734:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.wakeupReceived !=NULL) {
 6151              		.loc 1 2734 0
 6152 2a3c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6153 2a40 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6154 2a44 1B6C     		ldr	r3, [r3, #64]
 6155 2a46 002B     		cmp	r3, #0
 6156 2a48 0ED0     		beq	.L289
2735:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // free wakeupReceived so corresponding RAM memory can be recycled
2736:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openqueue_freePacketBuffer(ieee154e_vars.wakeupReceived);
 6157              		.loc 1 2736 0
 6158 2a4a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6159 2a4e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6160 2a52 1B6C     		ldr	r3, [r3, #64]
 6161 2a54 1846     		mov	r0, r3
 6162 2a56 FFF7FEFF 		bl	openqueue_freePacketBuffer
2737:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset local variable
2738:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.wakeupReceived = NULL;
 6163              		.loc 1 2738 0
 6164 2a5a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6165 2a5e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6166 2a62 4FF00002 		mov	r2, #0
 6167 2a66 1A64     		str	r2, [r3, #64]
 6168              	.L289:
2739:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2740:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2741:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
2742:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_SLEEP);
 6169              		.loc 1 2742 0
 6170 2a68 4FF00000 		mov	r0, #0
 6171 2a6c FFF7FEFF 		bl	changeState
2743:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2744:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // update CSL Mode to SLEEP in order to allow new TX or RX.
2745:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.cslMode = CSL_SLEEP_MODE;
 6172              		.loc 1 2745 0
 6173 2a70 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6174 2a74 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6175 2a78 4FF00002 		mov	r2, #0
 6176 2a7c 83F84520 		strb	r2, [r3, #69]
2746:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2747:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 6177              		.loc 1 2747 0
 6178 2a80 80BD     		pop	{r7, pc}
 6179              		.cfi_endproc
 6180              	.LFE69:
 6182 2a82 00BF     		.align	2
 6183              		.global	ieee154e_isSynch
 6184              		.thumb
 6185              		.thumb_func
 6187              	ieee154e_isSynch:
 6188              	.LFB70:
2748:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2749:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool ieee154e_isSynch(){
 6189              		.loc 1 2749 0
 6190              		.cfi_startproc
 6191              		@ args = 0, pretend = 0, frame = 0
 6192              		@ frame_needed = 1, uses_anonymous_args = 0
 6193              		@ link register save eliminated.
 6194 2a84 80B4     		push	{r7}
 6195              	.LCFI171:
 6196              		.cfi_def_cfa_offset 4
 6197              		.cfi_offset 7, -4
 6198 2a86 00AF     		add	r7, sp, #0
 6199              	.LCFI172:
 6200              		.cfi_def_cfa_register 7
2750:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee154e_vars.isSync;
 6201              		.loc 1 2750 0
 6202 2a88 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6203 2a8c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6204 2a90 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
2751:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 6205              		.loc 1 2751 0
 6206 2a92 1846     		mov	r0, r3
 6207 2a94 BD46     		mov	sp, r7
 6208 2a96 80BC     		pop	{r7}
 6209 2a98 7047     		bx	lr
 6210              		.cfi_endproc
 6211              	.LFE70:
 6213 2a9a 00BF     		.align	2
 6214              		.global	ieee154e_processIEs
 6215              		.thumb
 6216              		.thumb_func
 6218              	ieee154e_processIEs:
 6219              	.LFB71:
2752:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2753:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE bool ieee154e_processIEs(OpenQueueEntry_t* pkt, uint16_t* lenIE) {
 6220              		.loc 1 2753 0
 6221              		.cfi_startproc
 6222              		@ args = 0, pretend = 0, frame = 32
 6223              		@ frame_needed = 1, uses_anonymous_args = 0
 6224 2a9c 80B5     		push	{r7, lr}
 6225              	.LCFI173:
 6226              		.cfi_def_cfa_offset 8
 6227              		.cfi_offset 7, -8
 6228              		.cfi_offset 14, -4
 6229 2a9e 88B0     		sub	sp, sp, #32
 6230              	.LCFI174:
 6231              		.cfi_def_cfa_offset 40
 6232 2aa0 00AF     		add	r7, sp, #0
 6233              	.LCFI175:
 6234              		.cfi_def_cfa_register 7
 6235 2aa2 7860     		str	r0, [r7, #4]
 6236 2aa4 3960     		str	r1, [r7, #0]
2754:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t               ptr;
2755:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t               byte0;
2756:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t               byte1;
2757:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t               temp_8b;
2758:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t               gr_elem_id;
2759:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t               subid;
2760:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint16_t              temp_16b;
2761:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint16_t              len;
2762:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint16_t              sublen;
2763:openstack/02a-MAClow/IEEE802154Ecsl.c ****    PORT_SIGNED_INT_WIDTH timeCorrection;
2764:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2765:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ptr=0;
 6237              		.loc 1 2765 0
 6238 2aa6 4FF00003 		mov	r3, #0
 6239 2aaa FB73     		strb	r3, [r7, #15]
2766:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2767:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //===== header or payload IE header
2768:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2769:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //candidate IE header  if type ==0 header IE if type==1 payload IE
2770:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_8b    = *((uint8_t*)(pkt->payload)+ptr);
 6240              		.loc 1 2770 0
 6241 2aac 7B68     		ldr	r3, [r7, #4]
 6242 2aae 5A68     		ldr	r2, [r3, #4]
 6243 2ab0 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6244 2ab2 D318     		adds	r3, r2, r3
 6245 2ab4 1B78     		ldrb	r3, [r3, #0]
 6246 2ab6 7B76     		strb	r3, [r7, #25]
2771:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ptr++;
 6247              		.loc 1 2771 0
 6248 2ab8 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6249 2aba 03F10103 		add	r3, r3, #1
 6250 2abe DBB2     		uxtb	r3, r3
 6251 2ac0 FB73     		strb	r3, [r7, #15]
2772:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2773:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_16b   = temp_8b + ((*((uint8_t*)(pkt->payload)+ptr))<< 8);
 6252              		.loc 1 2773 0
 6253 2ac2 7B7E     		ldrb	r3, [r7, #25]	@ zero_extendqisi2
 6254 2ac4 9AB2     		uxth	r2, r3
 6255 2ac6 7B68     		ldr	r3, [r7, #4]
 6256 2ac8 5968     		ldr	r1, [r3, #4]
 6257 2aca FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6258 2acc CB18     		adds	r3, r1, r3
 6259 2ace 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 6260 2ad0 4FEA0323 		lsl	r3, r3, #8
 6261 2ad4 9BB2     		uxth	r3, r3
 6262 2ad6 D318     		adds	r3, r2, r3
 6263 2ad8 FB82     		strh	r3, [r7, #22]	@ movhi
2774:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ptr++;
 6264              		.loc 1 2774 0
 6265 2ada FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6266 2adc 03F10103 		add	r3, r3, #1
 6267 2ae0 DBB2     		uxtb	r3, r3
 6268 2ae2 FB73     		strb	r3, [r7, #15]
2775:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2776:openstack/02a-MAClow/IEEE802154Ecsl.c ****    *lenIE     = ptr;
 6269              		.loc 1 2776 0
 6270 2ae4 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6271 2ae6 1A46     		mov	r2, r3
 6272 2ae8 3B68     		ldr	r3, [r7, #0]
 6273 2aea 1A80     		strh	r2, [r3, #0]	@ movhi
2777:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2778:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b & IEEE802154E_DESC_TYPE_PAYLOAD_IE) == IEEE802154E_DESC_TYPE_PAYLOAD_IE){
 6274              		.loc 1 2778 0
 6275 2aec FB8A     		ldrh	r3, [r7, #22]
 6276 2aee 03F00103 		and	r3, r3, #1
 6277 2af2 002B     		cmp	r3, #0
 6278 2af4 0AD0     		beq	.L293
2779:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // payload IE
2780:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2781:openstack/02a-MAClow/IEEE802154Ecsl.c ****       len          = (temp_16b & IEEE802154E_DESC_LEN_PAYLOAD_IE_MASK)>>IEEE802154E_DESC_LEN_PAYLOA
 6279              		.loc 1 2781 0
 6280 2af6 FB8A     		ldrh	r3, [r7, #22]
 6281 2af8 4FEA5313 		lsr	r3, r3, #5
 6282 2afc BB83     		strh	r3, [r7, #28]	@ movhi
2782:openstack/02a-MAClow/IEEE802154Ecsl.c ****       gr_elem_id   = (temp_16b & IEEE802154E_DESC_GROUPID_PAYLOAD_IE_MASK)>>IEEE802154E_DESC_GROUPI
 6283              		.loc 1 2782 0
 6284 2afe FB8A     		ldrh	r3, [r7, #22]
 6285 2b00 03F01E03 		and	r3, r3, #30
 6286 2b04 4FEA6303 		asr	r3, r3, #1
 6287 2b08 FB77     		strb	r3, [r7, #31]
 6288 2b0a 09E0     		b	.L294
 6289              	.L293:
2783:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
2784:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // header IE
2785:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2786:openstack/02a-MAClow/IEEE802154Ecsl.c ****       len          = (temp_16b & IEEE802154E_DESC_LEN_HEADER_IE_MASK)>>IEEE802154E_DESC_LEN_HEADER_
 6290              		.loc 1 2786 0
 6291 2b0c FB8A     		ldrh	r3, [r7, #22]
 6292 2b0e 4FEA5323 		lsr	r3, r3, #9
 6293 2b12 BB83     		strh	r3, [r7, #28]	@ movhi
2787:openstack/02a-MAClow/IEEE802154Ecsl.c ****       gr_elem_id   = (temp_16b & IEEE802154E_DESC_ELEMENTID_HEADER_IE_MASK)>>IEEE802154E_DESC_ELEME
 6294              		.loc 1 2787 0
 6295 2b14 FB8A     		ldrh	r3, [r7, #22]
 6296 2b16 03F4FF73 		and	r3, r3, #510
 6297 2b1a 4FEA6303 		asr	r3, r3, #1
 6298 2b1e FB77     		strb	r3, [r7, #31]
 6299              	.L294:
2788:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2789:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2790:openstack/02a-MAClow/IEEE802154Ecsl.c ****    *lenIE         += len;
 6300              		.loc 1 2790 0
 6301 2b20 3B68     		ldr	r3, [r7, #0]
 6302 2b22 1A88     		ldrh	r2, [r3, #0]
 6303 2b24 BB8B     		ldrh	r3, [r7, #28]	@ movhi
 6304 2b26 D318     		adds	r3, r2, r3
 6305 2b28 9AB2     		uxth	r2, r3
 6306 2b2a 3B68     		ldr	r3, [r7, #0]
 6307 2b2c 1A80     		strh	r2, [r3, #0]	@ movhi
2791:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2792:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //===== sub-elements
2793:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2794:openstack/02a-MAClow/IEEE802154Ecsl.c ****    switch(gr_elem_id){
 6308              		.loc 1 2794 0
 6309 2b2e FB7F     		ldrb	r3, [r7, #31]	@ zero_extendqisi2
 6310 2b30 012B     		cmp	r3, #1
 6311 2b32 02D0     		beq	.L296
 6312 2b34 1E2B     		cmp	r3, #30
 6313 2b36 78D0     		beq	.L297
 6314 2b38 BEE0     		b	.L311
 6315              	.L296:
2795:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2796:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case IEEE802154E_MLME_IE_GROUPID:
2797:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // MLME IE
2798:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2799:openstack/02a-MAClow/IEEE802154Ecsl.c ****          do {
2800:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2801:openstack/02a-MAClow/IEEE802154Ecsl.c ****             //read sub IE header
2802:openstack/02a-MAClow/IEEE802154Ecsl.c ****             temp_8b     = *((uint8_t*)(pkt->payload)+ptr);
 6316              		.loc 1 2802 0
 6317 2b3a 7B68     		ldr	r3, [r7, #4]
 6318 2b3c 5A68     		ldr	r2, [r3, #4]
 6319 2b3e FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6320 2b40 D318     		adds	r3, r2, r3
 6321 2b42 1B78     		ldrb	r3, [r3, #0]
 6322 2b44 7B76     		strb	r3, [r7, #25]
2803:openstack/02a-MAClow/IEEE802154Ecsl.c ****             ptr         = ptr + 1;
 6323              		.loc 1 2803 0
 6324 2b46 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6325 2b48 03F10103 		add	r3, r3, #1
 6326 2b4c DBB2     		uxtb	r3, r3
 6327 2b4e FB73     		strb	r3, [r7, #15]
2804:openstack/02a-MAClow/IEEE802154Ecsl.c ****             temp_16b    = temp_8b  +(*((uint8_t*)(pkt->payload)+ptr) << 8);
 6328              		.loc 1 2804 0
 6329 2b50 7B7E     		ldrb	r3, [r7, #25]	@ zero_extendqisi2
 6330 2b52 9AB2     		uxth	r2, r3
 6331 2b54 7B68     		ldr	r3, [r7, #4]
 6332 2b56 5968     		ldr	r1, [r3, #4]
 6333 2b58 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6334 2b5a CB18     		adds	r3, r1, r3
 6335 2b5c 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 6336 2b5e 4FEA0323 		lsl	r3, r3, #8
 6337 2b62 9BB2     		uxth	r3, r3
 6338 2b64 D318     		adds	r3, r2, r3
 6339 2b66 FB82     		strh	r3, [r7, #22]	@ movhi
2805:openstack/02a-MAClow/IEEE802154Ecsl.c ****             ptr         = ptr + 1;
 6340              		.loc 1 2805 0
 6341 2b68 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6342 2b6a 03F10103 		add	r3, r3, #1
 6343 2b6e DBB2     		uxtb	r3, r3
 6344 2b70 FB73     		strb	r3, [r7, #15]
2806:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2807:openstack/02a-MAClow/IEEE802154Ecsl.c ****             len         = len - 2; //remove header fields len
 6345              		.loc 1 2807 0
 6346 2b72 BB8B     		ldrh	r3, [r7, #28]	@ movhi
 6347 2b74 A3F10203 		sub	r3, r3, #2
 6348 2b78 BB83     		strh	r3, [r7, #28]	@ movhi
2808:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2809:openstack/02a-MAClow/IEEE802154Ecsl.c ****             if ((temp_16b & IEEE802154E_DESC_TYPE_LONG) == IEEE802154E_DESC_TYPE_LONG){
 6349              		.loc 1 2809 0
 6350 2b7a FB8A     		ldrh	r3, [r7, #22]
 6351 2b7c 03F00103 		and	r3, r3, #1
 6352 2b80 002B     		cmp	r3, #0
 6353 2b82 0AD0     		beq	.L298
2810:openstack/02a-MAClow/IEEE802154Ecsl.c ****                // long sub-IE
2811:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2812:openstack/02a-MAClow/IEEE802154Ecsl.c ****                sublen   = (temp_16b & IEEE802154E_DESC_LEN_LONG_MLME_IE_MASK)>>IEEE802154E_DESC_LEN
 6354              		.loc 1 2812 0
 6355 2b84 FB8A     		ldrh	r3, [r7, #22]
 6356 2b86 4FEA5313 		lsr	r3, r3, #5
 6357 2b8a 7B83     		strh	r3, [r7, #26]	@ movhi
2813:openstack/02a-MAClow/IEEE802154Ecsl.c ****                subid    = (temp_16b & IEEE802154E_DESC_SUBID_LONG_MLME_IE_MASK)>>IEEE802154E_DESC_S
 6358              		.loc 1 2813 0
 6359 2b8c FB8A     		ldrh	r3, [r7, #22]
 6360 2b8e 03F01E03 		and	r3, r3, #30
 6361 2b92 4FEA6303 		asr	r3, r3, #1
 6362 2b96 BB77     		strb	r3, [r7, #30]
 6363 2b98 09E0     		b	.L299
 6364              	.L298:
2814:openstack/02a-MAClow/IEEE802154Ecsl.c ****             } else {
2815:openstack/02a-MAClow/IEEE802154Ecsl.c ****                // short sub-IE
2816:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2817:openstack/02a-MAClow/IEEE802154Ecsl.c ****                sublen   = (temp_16b & IEEE802154E_DESC_LEN_SHORT_MLME_IE_MASK)>>IEEE802154E_DESC_LE
 6365              		.loc 1 2817 0
 6366 2b9a FB8A     		ldrh	r3, [r7, #22]
 6367 2b9c 4FEA1323 		lsr	r3, r3, #8
 6368 2ba0 7B83     		strh	r3, [r7, #26]	@ movhi
2818:openstack/02a-MAClow/IEEE802154Ecsl.c ****                subid    = (temp_16b & IEEE802154E_DESC_SUBID_SHORT_MLME_IE_MASK)>>IEEE802154E_DESC_
 6369              		.loc 1 2818 0
 6370 2ba2 FB8A     		ldrh	r3, [r7, #22]
 6371 2ba4 03F0FE03 		and	r3, r3, #254
 6372 2ba8 4FEA6303 		asr	r3, r3, #1
 6373 2bac BB77     		strb	r3, [r7, #30]
 6374              	.L299:
2819:openstack/02a-MAClow/IEEE802154Ecsl.c ****             }
2820:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2821:openstack/02a-MAClow/IEEE802154Ecsl.c ****             switch(subid){
 6375              		.loc 1 2821 0
 6376 2bae BB7F     		ldrb	r3, [r7, #30]	@ zero_extendqisi2
 6377 2bb0 1B2B     		cmp	r3, #27
 6378 2bb2 25D0     		beq	.L302
 6379 2bb4 1C2B     		cmp	r3, #28
 6380 2bb6 2DD0     		beq	.L313
 6381 2bb8 1A2B     		cmp	r3, #26
 6382 2bba 28D1     		bne	.L312
 6383              	.L301:
2822:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2823:openstack/02a-MAClow/IEEE802154Ecsl.c ****                case IEEE802154E_MLME_SYNC_IE_SUBID:
2824:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   // Sync IE: ASN and Join Priority
2825:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2826:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   if (idmanager_getIsDAGroot()==FALSE) {
 6384              		.loc 1 2826 0
 6385 2bbc FFF7FEFF 		bl	idmanager_getIsDAGroot
 6386 2bc0 0346     		mov	r3, r0
 6387 2bc2 83F00103 		eor	r3, r3, #1
 6388 2bc6 DBB2     		uxtb	r3, r3
 6389 2bc8 002B     		cmp	r3, #0
 6390 2bca 25D0     		beq	.L314
2827:openstack/02a-MAClow/IEEE802154Ecsl.c ****                      // ASN
2828:openstack/02a-MAClow/IEEE802154Ecsl.c ****                      asnStoreFromAdv((uint8_t*)(pkt->payload)+ptr);
 6391              		.loc 1 2828 0
 6392 2bcc 7B68     		ldr	r3, [r7, #4]
 6393 2bce 5A68     		ldr	r2, [r3, #4]
 6394 2bd0 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6395 2bd2 D318     		adds	r3, r2, r3
 6396 2bd4 1846     		mov	r0, r3
 6397 2bd6 FFF7FEFF 		bl	asnStoreFromAdv
2829:openstack/02a-MAClow/IEEE802154Ecsl.c ****                      ptr = ptr + 5;
 6398              		.loc 1 2829 0
 6399 2bda FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6400 2bdc 03F10503 		add	r3, r3, #5
 6401 2be0 DBB2     		uxtb	r3, r3
 6402 2be2 FB73     		strb	r3, [r7, #15]
2830:openstack/02a-MAClow/IEEE802154Ecsl.c ****                      // join priority
2831:openstack/02a-MAClow/IEEE802154Ecsl.c ****                      joinPriorityStoreFromAdv(*((uint8_t*)(pkt->payload)+ptr));
 6403              		.loc 1 2831 0
 6404 2be4 7B68     		ldr	r3, [r7, #4]
 6405 2be6 5A68     		ldr	r2, [r3, #4]
 6406 2be8 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6407 2bea D318     		adds	r3, r2, r3
 6408 2bec 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 6409 2bee 1846     		mov	r0, r3
 6410 2bf0 FFF7FEFF 		bl	joinPriorityStoreFromAdv
2832:openstack/02a-MAClow/IEEE802154Ecsl.c ****                      ptr = ptr + 1;
 6411              		.loc 1 2832 0
 6412 2bf4 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6413 2bf6 03F10103 		add	r3, r3, #1
 6414 2bfa DBB2     		uxtb	r3, r3
 6415 2bfc FB73     		strb	r3, [r7, #15]
2833:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   }
2834:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   break;
 6416              		.loc 1 2834 0
 6417 2bfe 0BE0     		b	.L314
 6418              	.L302:
2835:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2836:openstack/02a-MAClow/IEEE802154Ecsl.c ****                case IEEE802154E_MLME_SLOTFRAME_LINK_IE_SUBID:
2837:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   processIE_retrieveSlotframeLinkIE(pkt,&ptr);
 6419              		.loc 1 2837 0
 6420 2c00 07F10F03 		add	r3, r7, #15
 6421 2c04 7868     		ldr	r0, [r7, #4]
 6422 2c06 1946     		mov	r1, r3
 6423 2c08 FFF7FEFF 		bl	processIE_retrieveSlotframeLinkIE
2838:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   break;
 6424              		.loc 1 2838 0
 6425 2c0c 05E0     		b	.L305
 6426              	.L312:
2839:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2840:openstack/02a-MAClow/IEEE802154Ecsl.c ****                case IEEE802154E_MLME_TIMESLOT_IE_SUBID:
2841:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   // to do
2842:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   break;
2843:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2844:openstack/02a-MAClow/IEEE802154Ecsl.c ****                default:
2845:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   return FALSE;
 6427              		.loc 1 2845 0
 6428 2c0e 4FF00003 		mov	r3, #0
 6429 2c12 6AE0     		b	.L310
 6430              	.L313:
2842:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   break;
 6431              		.loc 1 2842 0
 6432 2c14 00BF     		nop
 6433 2c16 00E0     		b	.L305
 6434              	.L314:
2834:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   break;
 6435              		.loc 1 2834 0
 6436 2c18 00BF     		nop
 6437              	.L305:
2846:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   break;
2847:openstack/02a-MAClow/IEEE802154Ecsl.c ****             }
2848:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2849:openstack/02a-MAClow/IEEE802154Ecsl.c ****             len = len - sublen;
 6438              		.loc 1 2849 0
 6439 2c1a BA8B     		ldrh	r2, [r7, #28]	@ movhi
 6440 2c1c 7B8B     		ldrh	r3, [r7, #26]	@ movhi
 6441 2c1e D31A     		subs	r3, r2, r3
 6442 2c20 BB83     		strh	r3, [r7, #28]	@ movhi
2850:openstack/02a-MAClow/IEEE802154Ecsl.c ****          } while(len>0);
 6443              		.loc 1 2850 0
 6444 2c22 BB8B     		ldrh	r3, [r7, #28]
 6445 2c24 002B     		cmp	r3, #0
 6446 2c26 88D1     		bne	.L296
2851:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2852:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 6447              		.loc 1 2852 0
 6448 2c28 4EE0     		b	.L307
 6449              	.L297:
2853:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2854:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case IEEE802154E_ACK_NACK_TIMECORRECTION_ELEMENTID:
2855:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // timecorrection IE
2856:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2857:openstack/02a-MAClow/IEEE802154Ecsl.c ****          if (
2858:openstack/02a-MAClow/IEEE802154Ecsl.c ****                idmanager_getIsDAGroot()==FALSE &&
 6450              		.loc 1 2858 0
 6451 2c2a FFF7FEFF 		bl	idmanager_getIsDAGroot
 6452 2c2e 0346     		mov	r3, r0
 6453 2c30 83F00103 		eor	r3, r3, #1
 6454 2c34 DBB2     		uxtb	r3, r3
2857:openstack/02a-MAClow/IEEE802154Ecsl.c ****          if (
 6455              		.loc 1 2857 0
 6456 2c36 002B     		cmp	r3, #0
 6457 2c38 45D0     		beq	.L315
2859:openstack/02a-MAClow/IEEE802154Ecsl.c ****                neighbors_isPreferredParent(&(pkt->l2_nextORpreviousHop))
 6458              		.loc 1 2859 0
 6459 2c3a 7B68     		ldr	r3, [r7, #4]
 6460 2c3c 03F13803 		add	r3, r3, #56
 6461 2c40 1846     		mov	r0, r3
 6462 2c42 FFF7FEFF 		bl	neighbors_isPreferredParent
 6463 2c46 0346     		mov	r3, r0
2858:openstack/02a-MAClow/IEEE802154Ecsl.c ****                idmanager_getIsDAGroot()==FALSE &&
 6464              		.loc 1 2858 0
 6465 2c48 002B     		cmp	r3, #0
 6466 2c4a 3CD0     		beq	.L315
2860:openstack/02a-MAClow/IEEE802154Ecsl.c ****             ) {
2861:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2862:openstack/02a-MAClow/IEEE802154Ecsl.c ****             byte0 = *((uint8_t*)(pkt->payload)+ptr);
 6467              		.loc 1 2862 0
 6468 2c4c 7B68     		ldr	r3, [r7, #4]
 6469 2c4e 5A68     		ldr	r2, [r3, #4]
 6470 2c50 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6471 2c52 D318     		adds	r3, r2, r3
 6472 2c54 1B78     		ldrb	r3, [r3, #0]
 6473 2c56 7B75     		strb	r3, [r7, #21]
2863:openstack/02a-MAClow/IEEE802154Ecsl.c ****             ptr++;
 6474              		.loc 1 2863 0
 6475 2c58 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6476 2c5a 03F10103 		add	r3, r3, #1
 6477 2c5e DBB2     		uxtb	r3, r3
 6478 2c60 FB73     		strb	r3, [r7, #15]
2864:openstack/02a-MAClow/IEEE802154Ecsl.c ****             byte1 = *((uint8_t*)(pkt->payload)+ptr);
 6479              		.loc 1 2864 0
 6480 2c62 7B68     		ldr	r3, [r7, #4]
 6481 2c64 5A68     		ldr	r2, [r3, #4]
 6482 2c66 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6483 2c68 D318     		adds	r3, r2, r3
 6484 2c6a 1B78     		ldrb	r3, [r3, #0]
 6485 2c6c 3B75     		strb	r3, [r7, #20]
2865:openstack/02a-MAClow/IEEE802154Ecsl.c ****             ptr++;
 6486              		.loc 1 2865 0
 6487 2c6e FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6488 2c70 03F10103 		add	r3, r3, #1
 6489 2c74 DBB2     		uxtb	r3, r3
 6490 2c76 FB73     		strb	r3, [r7, #15]
2866:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2867:openstack/02a-MAClow/IEEE802154Ecsl.c ****             timeCorrection  = (int16_t)((uint16_t)byte1<<8 | (uint16_t)byte0);
 6491              		.loc 1 2867 0
 6492 2c78 3B7D     		ldrb	r3, [r7, #20]	@ zero_extendqisi2
 6493 2c7a 4FEA0323 		lsl	r3, r3, #8
 6494 2c7e 9AB2     		uxth	r2, r3
 6495 2c80 7B7D     		ldrb	r3, [r7, #21]	@ zero_extendqisi2
 6496 2c82 9BB2     		uxth	r3, r3
 6497 2c84 1343     		orrs	r3, r3, r2
 6498 2c86 9BB2     		uxth	r3, r3
 6499 2c88 1BB2     		sxth	r3, r3
 6500 2c8a 3B61     		str	r3, [r7, #16]
2868:openstack/02a-MAClow/IEEE802154Ecsl.c ****             timeCorrection  = (timeCorrection / (PORT_SIGNED_INT_WIDTH)US_PER_TICK);
 6501              		.loc 1 2868 0
 6502 2c8c 3B69     		ldr	r3, [r7, #16]
 6503 2c8e 48F68902 		movw	r2, #34953
 6504 2c92 C8F68802 		movt	r2, 34952
 6505 2c96 82FB0312 		smull	r1, r2, r2, r3
 6506 2c9a D218     		adds	r2, r2, r3
 6507 2c9c 4FEA2212 		asr	r2, r2, #4
 6508 2ca0 4FEAE373 		asr	r3, r3, #31
 6509 2ca4 D31A     		subs	r3, r2, r3
 6510 2ca6 3B61     		str	r3, [r7, #16]
2869:openstack/02a-MAClow/IEEE802154Ecsl.c ****             timeCorrection  = -timeCorrection;
 6511              		.loc 1 2869 0
 6512 2ca8 3B69     		ldr	r3, [r7, #16]
 6513 2caa C3F10003 		rsb	r3, r3, #0
 6514 2cae 3B61     		str	r3, [r7, #16]
2870:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2871:openstack/02a-MAClow/IEEE802154Ecsl.c ****             synchronizeAck(timeCorrection);
 6515              		.loc 1 2871 0
 6516 2cb0 3869     		ldr	r0, [r7, #16]
 6517 2cb2 FFF7FEFF 		bl	synchronizeAck
2872:openstack/02a-MAClow/IEEE802154Ecsl.c ****          }
2873:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 6518              		.loc 1 2873 0
 6519 2cb6 06E0     		b	.L315
 6520              	.L311:
2874:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2875:openstack/02a-MAClow/IEEE802154Ecsl.c ****       default:
2876:openstack/02a-MAClow/IEEE802154Ecsl.c ****          *lenIE = 0; //no header or not recognized.
 6521              		.loc 1 2876 0
 6522 2cb8 3B68     		ldr	r3, [r7, #0]
 6523 2cba 4FF00002 		mov	r2, #0
 6524 2cbe 1A80     		strh	r2, [r3, #0]	@ movhi
2877:openstack/02a-MAClow/IEEE802154Ecsl.c ****          return FALSE;
 6525              		.loc 1 2877 0
 6526 2cc0 4FF00003 		mov	r3, #0
 6527 2cc4 11E0     		b	.L310
 6528              	.L315:
2873:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 6529              		.loc 1 2873 0
 6530 2cc6 00BF     		nop
 6531              	.L307:
2878:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2879:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2880:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if(*lenIE>127) {
 6532              		.loc 1 2880 0
 6533 2cc8 3B68     		ldr	r3, [r7, #0]
 6534 2cca 1B88     		ldrh	r3, [r3, #0]
 6535 2ccc 7F2B     		cmp	r3, #127
 6536 2cce 0AD9     		bls	.L309
2881:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // log the error
2882:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openserial_printError(
 6537              		.loc 1 2882 0
 6538 2cd0 3B68     		ldr	r3, [r7, #0]
 6539 2cd2 1B88     		ldrh	r3, [r3, #0]
 6540 2cd4 4FF00900 		mov	r0, #9
 6541 2cd8 4FF03301 		mov	r1, #51
 6542 2cdc 1A46     		mov	r2, r3
 6543 2cde 4FF00103 		mov	r3, #1
 6544 2ce2 FFF7FEFF 		bl	openserial_printError
 6545              	.L309:
2883:openstack/02a-MAClow/IEEE802154Ecsl.c ****          COMPONENT_IEEE802154E,
2884:openstack/02a-MAClow/IEEE802154Ecsl.c ****          ERR_HEADER_TOO_LONG,
2885:openstack/02a-MAClow/IEEE802154Ecsl.c ****          (errorparameter_t)*lenIE,
2886:openstack/02a-MAClow/IEEE802154Ecsl.c ****          (errorparameter_t)1
2887:openstack/02a-MAClow/IEEE802154Ecsl.c ****       );
2888:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2889:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return TRUE;
 6546              		.loc 1 2889 0
 6547 2ce6 4FF00103 		mov	r3, #1
 6548              	.L310:
2890:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 6549              		.loc 1 2890 0
 6550 2cea 1846     		mov	r0, r3
 6551 2cec 07F12007 		add	r7, r7, #32
 6552 2cf0 BD46     		mov	sp, r7
 6553 2cf2 80BD     		pop	{r7, pc}
 6554              		.cfi_endproc
 6555              	.LFE71:
 6557              		.align	2
 6558              		.global	joinPriorityStoreFromAdv
 6559              		.thumb
 6560              		.thumb_func
 6562              	joinPriorityStoreFromAdv:
 6563              	.LFB72:
2891:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2892:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void joinPriorityStoreFromAdv(uint8_t jp){
 6564              		.loc 1 2892 0
 6565              		.cfi_startproc
 6566              		@ args = 0, pretend = 0, frame = 8
 6567              		@ frame_needed = 1, uses_anonymous_args = 0
 6568              		@ link register save eliminated.
 6569 2cf4 80B4     		push	{r7}
 6570              	.LCFI176:
 6571              		.cfi_def_cfa_offset 4
 6572              		.cfi_offset 7, -4
 6573 2cf6 83B0     		sub	sp, sp, #12
 6574              	.LCFI177:
 6575              		.cfi_def_cfa_offset 16
 6576 2cf8 00AF     		add	r7, sp, #0
 6577              	.LCFI178:
 6578              		.cfi_def_cfa_register 7
 6579 2cfa 0346     		mov	r3, r0
 6580 2cfc FB71     		strb	r3, [r7, #7]
2893:openstack/02a-MAClow/IEEE802154Ecsl.c ****   ieee154e_vars.dataReceived->l2_joinPriority = jp;
 6581              		.loc 1 2893 0
 6582 2cfe 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6583 2d02 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6584 2d06 9B69     		ldr	r3, [r3, #24]
 6585 2d08 FA79     		ldrb	r2, [r7, #7]
 6586 2d0a 83F86420 		strb	r2, [r3, #100]
2894:openstack/02a-MAClow/IEEE802154Ecsl.c ****   ieee154e_vars.dataReceived->l2_joinPriorityPresent = TRUE;
 6587              		.loc 1 2894 0
 6588 2d0e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6589 2d12 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6590 2d16 9B69     		ldr	r3, [r3, #24]
 6591 2d18 4FF00102 		mov	r2, #1
 6592 2d1c 83F86620 		strb	r2, [r3, #102]
2895:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 6593              		.loc 1 2895 0
 6594 2d20 07F10C07 		add	r7, r7, #12
 6595 2d24 BD46     		mov	sp, r7
 6596 2d26 80BC     		pop	{r7}
 6597 2d28 7047     		bx	lr
 6598              		.cfi_endproc
 6599              	.LFE72:
 6601 2d2a 00BF     		.align	2
 6602              		.global	asnStoreFromAdv
 6603              		.thumb
 6604              		.thumb_func
 6606              	asnStoreFromAdv:
 6607              	.LFB73:
2896:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2897:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void asnStoreFromAdv(uint8_t* asn) {
 6608              		.loc 1 2897 0
 6609              		.cfi_startproc
 6610              		@ args = 0, pretend = 0, frame = 8
 6611              		@ frame_needed = 1, uses_anonymous_args = 0
 6612 2d2c 90B5     		push	{r4, r7, lr}
 6613              	.LCFI179:
 6614              		.cfi_def_cfa_offset 12
 6615              		.cfi_offset 4, -12
 6616              		.cfi_offset 7, -8
 6617              		.cfi_offset 14, -4
 6618 2d2e 83B0     		sub	sp, sp, #12
 6619              	.LCFI180:
 6620              		.cfi_def_cfa_offset 24
 6621 2d30 00AF     		add	r7, sp, #0
 6622              	.LCFI181:
 6623              		.cfi_def_cfa_register 7
 6624 2d32 7860     		str	r0, [r7, #4]
2898:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2899:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // store the ASN
2900:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asn.bytes0and1   =     asn[0]+
 6625              		.loc 1 2900 0
 6626 2d34 7B68     		ldr	r3, [r7, #4]
 6627 2d36 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 6628 2d38 1A46     		mov	r2, r3
2901:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                     256*asn[1];
 6629              		.loc 1 2901 0
 6630 2d3a 7B68     		ldr	r3, [r7, #4]
 6631 2d3c 03F10103 		add	r3, r3, #1
 6632 2d40 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
2900:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asn.bytes0and1   =     asn[0]+
 6633              		.loc 1 2900 0
 6634 2d42 4FEA0323 		lsl	r3, r3, #8
 6635 2d46 9BB2     		uxth	r3, r3
 6636 2d48 D318     		adds	r3, r2, r3
 6637 2d4a 9AB2     		uxth	r2, r3
 6638 2d4c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6639 2d50 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6640 2d54 A3F80320 		strh	r2, [r3, #3]	@ unaligned
2902:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asn.bytes2and3   =     asn[2]+
 6641              		.loc 1 2902 0
 6642 2d58 7B68     		ldr	r3, [r7, #4]
 6643 2d5a 03F10203 		add	r3, r3, #2
 6644 2d5e 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 6645 2d60 1A46     		mov	r2, r3
2903:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                     256*asn[3];
 6646              		.loc 1 2903 0
 6647 2d62 7B68     		ldr	r3, [r7, #4]
 6648 2d64 03F10303 		add	r3, r3, #3
 6649 2d68 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
2902:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asn.bytes2and3   =     asn[2]+
 6650              		.loc 1 2902 0
 6651 2d6a 4FEA0323 		lsl	r3, r3, #8
 6652 2d6e 9BB2     		uxth	r3, r3
 6653 2d70 D318     		adds	r3, r2, r3
 6654 2d72 9AB2     		uxth	r2, r3
 6655 2d74 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6656 2d78 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6657 2d7c A3F80120 		strh	r2, [r3, #1]	@ unaligned
2904:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asn.byte4        =     asn[4];
 6658              		.loc 1 2904 0
 6659 2d80 7B68     		ldr	r3, [r7, #4]
 6660 2d82 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 6661 2d84 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6662 2d88 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6663 2d8c 1A70     		strb	r2, [r3, #0]
2905:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2906:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // determine the current slotOffset
2907:openstack/02a-MAClow/IEEE802154Ecsl.c ****    /*
2908:openstack/02a-MAClow/IEEE802154Ecsl.c ****    Note: this is a bit of a hack. Normally, slotOffset=ASN%slotlength. But since
2909:openstack/02a-MAClow/IEEE802154Ecsl.c ****    the ADV is exchanged in slot 0, we know that we're currently at slotOffset==0
2910:openstack/02a-MAClow/IEEE802154Ecsl.c ****    */
2911:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.slotOffset       = 0;
 6664              		.loc 1 2911 0
 6665 2d8e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6666 2d92 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6667 2d96 4FF00002 		mov	r2, #0
 6668 2d9a DA80     		strh	r2, [r3, #6]	@ movhi
2912:openstack/02a-MAClow/IEEE802154Ecsl.c ****    schedule_syncSlotOffset(ieee154e_vars.slotOffset);
 6669              		.loc 1 2912 0
 6670 2d9c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6671 2da0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6672 2da4 DB88     		ldrh	r3, [r3, #6]
 6673 2da6 1846     		mov	r0, r3
 6674 2da8 FFF7FEFF 		bl	schedule_syncSlotOffset
2913:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.nextActiveSlotOffset = schedule_getNextActiveSlotOffset();
 6675              		.loc 1 2913 0
 6676 2dac FFF7FEFF 		bl	schedule_getNextActiveSlotOffset
 6677 2db0 0346     		mov	r3, r0
 6678 2db2 1A46     		mov	r2, r3
 6679 2db4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6680 2db8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6681 2dbc 1A81     		strh	r2, [r3, #8]	@ movhi
2914:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2915:openstack/02a-MAClow/IEEE802154Ecsl.c ****    /*
2916:openstack/02a-MAClow/IEEE802154Ecsl.c ****    infer the asnOffset based on the fact that
2917:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.freq = 11 + (asnOffset + channelOffset)%16
2918:openstack/02a-MAClow/IEEE802154Ecsl.c ****    */
2919:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asnOffset = ieee154e_vars.freq - 11 - schedule_getChannelOffset();
 6682              		.loc 1 2919 0
 6683 2dbe 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6684 2dc2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6685 2dc6 93F82C40 		ldrb	r4, [r3, #44]	@ zero_extendqisi2
 6686 2dca FFF7FEFF 		bl	schedule_getChannelOffset
 6687 2dce 0346     		mov	r3, r0
 6688 2dd0 E31A     		subs	r3, r4, r3
 6689 2dd2 DBB2     		uxtb	r3, r3
 6690 2dd4 A3F10B03 		sub	r3, r3, #11
 6691 2dd8 DAB2     		uxtb	r2, r3
 6692 2dda 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6693 2dde C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6694 2de2 83F82D20 		strb	r2, [r3, #45]
2920:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 6695              		.loc 1 2920 0
 6696 2de6 07F10C07 		add	r7, r7, #12
 6697 2dea BD46     		mov	sp, r7
 6698 2dec 90BD     		pop	{r4, r7, pc}
 6699              		.cfi_endproc
 6700              	.LFE73:
 6702 2dee 00BF     		.align	2
 6703              		.global	ieee154e_asnDiff
 6704              		.thumb
 6705              		.thumb_func
 6707              	ieee154e_asnDiff:
 6708              	.LFB74:
2921:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2922:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2923:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2924:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2925:openstack/02a-MAClow/IEEE802154Ecsl.c **** /brief Difference between some older ASN and the current ASN.
2926:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2927:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in] someASN some ASN to compare to the current
2928:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2929:openstack/02a-MAClow/IEEE802154Ecsl.c **** \returns The ASN difference, or 0xffff if more than 65535 different
2930:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2931:openstack/02a-MAClow/IEEE802154Ecsl.c **** PORT_RADIOTIMER_WIDTH ieee154e_asnDiff(asn_t* someASN) {
 6709              		.loc 1 2931 0
 6710              		.cfi_startproc
 6711              		@ args = 0, pretend = 0, frame = 16
 6712              		@ frame_needed = 1, uses_anonymous_args = 0
 6713 2df0 80B5     		push	{r7, lr}
 6714              	.LCFI182:
 6715              		.cfi_def_cfa_offset 8
 6716              		.cfi_offset 7, -8
 6717              		.cfi_offset 14, -4
 6718 2df2 84B0     		sub	sp, sp, #16
 6719              	.LCFI183:
 6720              		.cfi_def_cfa_offset 24
 6721 2df4 00AF     		add	r7, sp, #0
 6722              	.LCFI184:
 6723              		.cfi_def_cfa_register 7
 6724 2df6 7860     		str	r0, [r7, #4]
2932:openstack/02a-MAClow/IEEE802154Ecsl.c ****    PORT_RADIOTIMER_WIDTH diff;
2933:openstack/02a-MAClow/IEEE802154Ecsl.c ****    INTERRUPT_DECLARATION();
2934:openstack/02a-MAClow/IEEE802154Ecsl.c ****    DISABLE_INTERRUPTS();
 6725              		.loc 1 2934 0
 6726 2df8 FFF7FEFF 		bl	IntMasterDisable
2935:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.asn.byte4 != someASN->byte4) {
 6727              		.loc 1 2935 0
 6728 2dfc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6729 2e00 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6730 2e04 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 6731 2e06 7B68     		ldr	r3, [r7, #4]
 6732 2e08 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 6733 2e0a 9A42     		cmp	r2, r3
 6734 2e0c 04D0     		beq	.L319
2936:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ENABLE_INTERRUPTS();
 6735              		.loc 1 2936 0
 6736 2e0e FFF7FEFF 		bl	IntMasterEnable
2937:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return (PORT_RADIOTIMER_WIDTH)0xFFFFFFFF;;
 6737              		.loc 1 2937 0
 6738 2e12 4FF0FF33 		mov	r3, #-1
 6739 2e16 4CE0     		b	.L320
 6740              	.L319:
2938:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2939:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2940:openstack/02a-MAClow/IEEE802154Ecsl.c ****    diff = 0;
 6741              		.loc 1 2940 0
 6742 2e18 4FF00003 		mov	r3, #0
 6743 2e1c FB60     		str	r3, [r7, #12]
2941:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.asn.bytes2and3 == someASN->bytes2and3) {
 6744              		.loc 1 2941 0
 6745 2e1e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6746 2e22 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6747 2e26 B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 6748 2e2a 9AB2     		uxth	r2, r3
 6749 2e2c 7B68     		ldr	r3, [r7, #4]
 6750 2e2e B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 6751 2e32 9BB2     		uxth	r3, r3
 6752 2e34 9A42     		cmp	r2, r3
 6753 2e36 0FD1     		bne	.L321
2942:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ENABLE_INTERRUPTS();
 6754              		.loc 1 2942 0
 6755 2e38 FFF7FEFF 		bl	IntMasterEnable
2943:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return ieee154e_vars.asn.bytes0and1-someASN->bytes0and1;
 6756              		.loc 1 2943 0
 6757 2e3c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6758 2e40 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6759 2e44 B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 6760 2e48 9BB2     		uxth	r3, r3
 6761 2e4a 1A46     		mov	r2, r3
 6762 2e4c 7B68     		ldr	r3, [r7, #4]
 6763 2e4e B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 6764 2e52 9BB2     		uxth	r3, r3
 6765 2e54 D31A     		subs	r3, r2, r3
 6766 2e56 2CE0     		b	.L320
 6767              	.L321:
2944:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else if (ieee154e_vars.asn.bytes2and3-someASN->bytes2and3==1) {
 6768              		.loc 1 2944 0
 6769 2e58 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6770 2e5c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6771 2e60 B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 6772 2e64 9BB2     		uxth	r3, r3
 6773 2e66 1A46     		mov	r2, r3
 6774 2e68 7B68     		ldr	r3, [r7, #4]
 6775 2e6a B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 6776 2e6e 9BB2     		uxth	r3, r3
 6777 2e70 D31A     		subs	r3, r2, r3
 6778 2e72 012B     		cmp	r3, #1
 6779 2e74 17D1     		bne	.L322
2945:openstack/02a-MAClow/IEEE802154Ecsl.c ****       diff  = ieee154e_vars.asn.bytes0and1;
 6780              		.loc 1 2945 0
 6781 2e76 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6782 2e7a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6783 2e7e B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 6784 2e82 9BB2     		uxth	r3, r3
 6785 2e84 FB60     		str	r3, [r7, #12]
2946:openstack/02a-MAClow/IEEE802154Ecsl.c ****       diff += 0xffff-someASN->bytes0and1;
 6786              		.loc 1 2946 0
 6787 2e86 7B68     		ldr	r3, [r7, #4]
 6788 2e88 B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 6789 2e8c 9BB2     		uxth	r3, r3
 6790 2e8e FA68     		ldr	r2, [r7, #12]
 6791 2e90 D31A     		subs	r3, r2, r3
 6792 2e92 03F57F43 		add	r3, r3, #65280
 6793 2e96 03F1FF03 		add	r3, r3, #255
 6794 2e9a FB60     		str	r3, [r7, #12]
2947:openstack/02a-MAClow/IEEE802154Ecsl.c ****       diff += 1;
 6795              		.loc 1 2947 0
 6796 2e9c FB68     		ldr	r3, [r7, #12]
 6797 2e9e 03F10103 		add	r3, r3, #1
 6798 2ea2 FB60     		str	r3, [r7, #12]
 6799 2ea4 02E0     		b	.L323
 6800              	.L322:
2948:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
2949:openstack/02a-MAClow/IEEE802154Ecsl.c ****       diff = (PORT_RADIOTIMER_WIDTH)0xFFFFFFFF;;
 6801              		.loc 1 2949 0
 6802 2ea6 4FF0FF33 		mov	r3, #-1
 6803 2eaa FB60     		str	r3, [r7, #12]
 6804              	.L323:
2950:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2951:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ENABLE_INTERRUPTS();
 6805              		.loc 1 2951 0
 6806 2eac FFF7FEFF 		bl	IntMasterEnable
2952:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return diff;
 6807              		.loc 1 2952 0
 6808 2eb0 FB68     		ldr	r3, [r7, #12]
 6809              	.L320:
2953:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 6810              		.loc 1 2953 0
 6811 2eb2 1846     		mov	r0, r3
 6812 2eb4 07F11007 		add	r7, r7, #16
 6813 2eb8 BD46     		mov	sp, r7
 6814 2eba 80BD     		pop	{r7, pc}
 6815              		.cfi_endproc
 6816              	.LFE74:
 6818              	.Letext0:
 6819              		.file 2 "/opt/gcc-arm-none-eabi-4_7-2013q3/bin/../lib/gcc/arm-none-eabi/4.7.4/../../../../arm-none
 6820              		.file 3 "inc/opendefs.h"
 6821              		.file 4 "openstack/02b-MAChigh/schedule.h"
 6822              		.file 5 "openstack/02b-MAChigh/processIE.h"
 6823              		.file 6 "openstack/02a-MAClow/IEEE802154Ecsl.h"
 6824              		.file 7 "openstack/02a-MAClow/IEEE802154.h"
 6825              		.file 8 "kernel/scheduler.h"
 6826              		.file 9 "bsp/boards/OpenMote-CC2538/board_info.h"
 6827              		.file 10 "openstack/03b-IPv6/icmpv6rpl.h"
DEFINED SYMBOLS
                            *ABS*:00000000 IEEE802154Ecsl.c
     /tmp/ccPPYFRx.s:19     .rodata:00000000 $d
     /tmp/ccPPYFRx.s:22     .rodata:00000000 rreg_uriquery
     /tmp/ccPPYFRx.s:27     .rodata:00000008 infoBoardname
     /tmp/ccPPYFRx.s:32     .rodata:00000010 infouCName
     /tmp/ccPPYFRx.s:37     .rodata:00000018 infoRadioName
     /tmp/ccPPYFRx.s:42     .rodata:00000024 infoStackName
     /tmp/ccPPYFRx.s:47     .rodata:00000030 all_routers_multicast
                            *COM*:0000004c ieee154e_vars
                            *COM*:0000000f ieee154e_stats
                            *COM*:00000014 ieee154e_dbg
     /tmp/ccPPYFRx.s:68     .text:00000000 $t
     /tmp/ccPPYFRx.s:73     .text:00000000 ieee154e_init
     /tmp/ccPPYFRx.s:5442   .text:0000253c changeIsSync
     /tmp/ccPPYFRx.s:5610   .text:00002614 resetStats
     /tmp/ccPPYFRx.s:162    .text:000000b8 isr_ieee154ecsl_newChannelSample
     /tmp/ccPPYFRx.s:223    .text:0000011c isr_ieee154ecsl_timer
     /tmp/ccPPYFRx.s:510    .text:0000036c ieee154ecsl_startOfFrame
     /tmp/ccPPYFRx.s:663    .text:000004a4 ieee154ecsl_endOfFrame
     /tmp/ccPPYFRx.s:2585   .text:0000118c activity_csl_wakeup_ri1
     /tmp/ccPPYFRx.s:254    .text:00000148 $d
     /tmp/ccPPYFRx.s:2653   .text:000011fc activity_csl_wakeup_ri2
     /tmp/ccPPYFRx.s:272    .text:00000188 $t
     /tmp/ccPPYFRx.s:2703   .text:0000124c activity_csl_wakeup_rie1
     /tmp/ccPPYFRx.s:2744   .text:0000127c activity_csl_wakeup_ri3
     /tmp/ccPPYFRx.s:2780   .text:000012a4 activity_csl_wakeup_rie2
     /tmp/ccPPYFRx.s:2858   .text:000012f8 activity_csl_wakeup_rie3
     /tmp/ccPPYFRx.s:2899   .text:00001328 activity_csl_wakeup_rie4
     /tmp/ccPPYFRx.s:3289   .text:00001674 activity_csl_data_ri2
     /tmp/ccPPYFRx.s:3339   .text:000016c4 activity_csl_data_rie1
     /tmp/ccPPYFRx.s:3380   .text:000016f4 activity_csl_data_ri3
     /tmp/ccPPYFRx.s:3416   .text:0000171c activity_csl_data_rie2
     /tmp/ccPPYFRx.s:3494   .text:00001770 activity_csl_data_rie3
     /tmp/ccPPYFRx.s:3889   .text:00001aa4 activity_csl_data_ri6
     /tmp/ccPPYFRx.s:4122   .text:00001cc0 activity_csl_data_rie4
     /tmp/ccPPYFRx.s:4163   .text:00001cf0 activity_csl_data_ri7
     /tmp/ccPPYFRx.s:4199   .text:00001d18 activity_csl_data_rie5
     /tmp/ccPPYFRx.s:4287   .text:00001d84 activity_csl_data_rie6
     /tmp/ccPPYFRx.s:5989   .text:000028bc endOps
     /tmp/ccPPYFRx.s:373    .text:00000240 $d
     /tmp/ccPPYFRx.s:1158   .text:00000830 activity_csl_wakeup_ti2
     /tmp/ccPPYFRx.s:409    .text:000002c8 $t
     /tmp/ccPPYFRx.s:1366   .text:00000a28 activity_csl_wakeup_tie1
     /tmp/ccPPYFRx.s:1404   .text:00000a54 activity_csl_wakeup_ti3
     /tmp/ccPPYFRx.s:1440   .text:00000a7c activity_csl_wakeup_tie2
     /tmp/ccPPYFRx.s:1525   .text:00000ae4 activity_csl_wakeup_tie3
     /tmp/ccPPYFRx.s:1608   .text:00000b48 activity_csl_data_ti1
     /tmp/ccPPYFRx.s:1642   .text:00000b6c activity_csl_data_ti2
     /tmp/ccPPYFRx.s:1706   .text:00000bdc activity_csl_data_tie1
     /tmp/ccPPYFRx.s:1744   .text:00000c08 activity_csl_data_ti3
     /tmp/ccPPYFRx.s:1780   .text:00000c30 activity_csl_data_tie2
     /tmp/ccPPYFRx.s:1860   .text:00000c8c activity_csl_data_tie3
     /tmp/ccPPYFRx.s:2019   .text:00000d98 activity_csl_data_ti6
     /tmp/ccPPYFRx.s:2069   .text:00000de8 activity_csl_data_tie4
     /tmp/ccPPYFRx.s:2107   .text:00000e14 activity_csl_data_ti7
     /tmp/ccPPYFRx.s:2143   .text:00000e3c activity_csl_data_tie5
     /tmp/ccPPYFRx.s:2243   .text:00000ed0 activity_csl_data_tie6
     /tmp/ccPPYFRx.s:545    .text:0000039c $d
     /tmp/ccPPYFRx.s:559    .text:000003cc $t
     /tmp/ccPPYFRx.s:2806   .text:000012b0 activity_csl_wakeup_ri4
     /tmp/ccPPYFRx.s:3442   .text:00001728 activity_csl_data_ri4
     /tmp/ccPPYFRx.s:4240   .text:00001d48 activity_csl_data_ri8
     /tmp/ccPPYFRx.s:596    .text:00000414 $d
     /tmp/ccPPYFRx.s:609    .text:00000440 $t
     /tmp/ccPPYFRx.s:2201   .text:00000ea0 activity_csl_data_ti8
     /tmp/ccPPYFRx.s:1478   .text:00000aa8 activity_csl_wakeup_ti4
     /tmp/ccPPYFRx.s:1818   .text:00000c5c activity_csl_data_ti4
     /tmp/ccPPYFRx.s:2936   .text:00001350 activity_csl_wakeup_ri5
     /tmp/ccPPYFRx.s:3535   .text:000017a0 activity_csl_data_ri5
     /tmp/ccPPYFRx.s:4328   .text:00001db4 activity_csl_data_ri9
     /tmp/ccPPYFRx.s:1563   .text:00000b10 activity_csl_wakeup_ti5
     /tmp/ccPPYFRx.s:1898   .text:00000cb8 activity_csl_data_ti5
     /tmp/ccPPYFRx.s:2269   .text:00000edc activity_csl_data_ti9
     /tmp/ccPPYFRx.s:806    .text:000005a0 isr_ieee154ecsl_txtimer_cb
     /tmp/ccPPYFRx.s:1017   .text:0000071c activity_csl_wakeup_ti1
     /tmp/ccPPYFRx.s:856    .text:000005e4 isr_ieee154ecsl_addPacketToQueueForTestingCslTx_cb
     /tmp/ccPPYFRx.s:5159   .text:00002310 incrementAsnOffset
     /tmp/ccPPYFRx.s:5733   .text:000026d8 changeState
     /tmp/ccPPYFRx.s:4393   .text:00001e20 ieee802154_createWakeUpFrame
     /tmp/ccPPYFRx.s:5070   .text:00002290 isValidAck
     /tmp/ccPPYFRx.s:6218   .text:00002a9c ieee154e_processIEs
     /tmp/ccPPYFRx.s:4509   .text:00001ee8 ieee802154_retrieveWakeUpFrame
     /tmp/ccPPYFRx.s:4977   .text:00002214 isValidRxFrame
     /tmp/ccPPYFRx.s:5549   .text:000025c8 notif_receive
     /tmp/ccPPYFRx.s:5261   .text:000023f8 ieee154e_getAsn
     /tmp/ccPPYFRx.s:5338   .text:00002484 synchronizeAck
     /tmp/ccPPYFRx.s:5672   .text:00002684 updateStats
     /tmp/ccPPYFRx.s:5495   .text:0000257c notif_sendDone
     /tmp/ccPPYFRx.s:5578   .text:000025e4 $d
     /tmp/ccPPYFRx.s:5584   .text:000025f4 $t
     /tmp/ccPPYFRx.s:5767   .text:00002704 $d
     /tmp/ccPPYFRx.s:5829   .text:000027f4 $t
     /tmp/ccPPYFRx.s:5855   .text:00002810 debugPrint_asn
     /tmp/ccPPYFRx.s:5910   .text:00002864 debugPrint_isSync
     /tmp/ccPPYFRx.s:5956   .text:0000289c debugPrint_macStats
     /tmp/ccPPYFRx.s:6187   .text:00002a84 ieee154e_isSynch
     /tmp/ccPPYFRx.s:6606   .text:00002d2c asnStoreFromAdv
     /tmp/ccPPYFRx.s:6562   .text:00002cf4 joinPriorityStoreFromAdv
     /tmp/ccPPYFRx.s:6707   .text:00002df0 ieee154e_asnDiff
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.1.e96eee74da26538b12ac9582e3798382
                           .group:00000000 wm4.newlib.h.8.a9901dc52d1357e3e94003403d43f8b5
                           .group:00000000 wm4.features.h.22.b72b3baab2bb2eab3661375590100b6b
                           .group:00000000 wm4.config.h.193.5fb8ef056cdff92dec3dee9552839d8c
                           .group:00000000 wm4._ansi.h.23.b5bb84d7ba97d82b5b1dc1826a7ae811
                           .group:00000000 wm4.stdint.h.20.54ad762faa59e3c05491630641c8d8bf
                           .group:00000000 wm4.toolchain_defs.h.2.e4ebbe6e0a48032a9b79077dc42e1ffd
                           .group:00000000 wm4._default_types.h.6.5e12cd604db8ce00b62bb2f02708eaf3
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4.stddef.h.349.31f4c5baff3fa2689010b32028da9c47
                           .group:00000000 wm4.reent.h.16.9e42f0e588b85e70b2bf6572af57ce64
                           .group:00000000 wm4.stddef.h.187.9e651b6b8b16e149c1353259404973ea
                           .group:00000000 wm4.string.h.17.f8d12df81104836a3f2a5d589ae830d8
                           .group:00000000 wm4.stdbool.h.29.1c9ee6859ce8145f7838a4f2549ccec2
                           .group:00000000 wm4.hw_types.h.67.b10589a0806dcc2d274d6fab6b736519
                           .group:00000000 wm4.interrupt.h.41.272fc4ec0e276feb439e7974d0f77eaf
                           .group:00000000 wm4.board_info.h.21.2f0cbb5ab4c556c54c487f727dca8532
                           .group:00000000 wm4.opendefs.h.19.05852eb648ac65e48c7817e5cbf03346
                           .group:00000000 wm4.schedule.h.2.74f699399ee9cbf3b59178f1204d8511
                           .group:00000000 wm4.processIE.h.2.1848f1e3c653035e9779472584ce0441
                           .group:00000000 wm4.opentimers.h.8.044f2d040a134cdb0ddb58adfc2508be
                           .group:00000000 wm4.IEEE802154Ecsl.h.21.9b3cd0c823c4cebe26b24d119729e7b5
                           .group:00000000 wm4.idmanager.h.2.8c0e2159b32ef3125cbb1e984805cbfe
                           .group:00000000 wm4.openserial.h.8.8c63e3800d2936b44b5370ce1aae62b7
                           .group:00000000 wm4.scheduler.h.2.ca320b72942c5204a6e225e3c9c0814e
                           .group:00000000 wm4.icmpv6rpl.h.2.0ce84dbe8c203c7079b39e7e96c7c01e
                           .group:00000000 wm4.neighbors.h.15.9f35f180a0332d1bc442efb0ec51905c
                           .group:00000000 wm4.sixtop.h.2.0b8613e8e48e9109b53e6143f3ed1895

UNDEFINED SYMBOLS
memset
idmanager_getIsDAGroot
radio_rfOn
radio_setOverflowCb
radio_setCompareCb
radio_setStartFrameCb
radio_setEndFrameCb
radio_startTimer
radio_setTimerPeriod
openserial_printInfo
openserial_printError
leds_all_off
openqueue_macGetDataPacket
openqueue_getFreePacketBuffer
ieee802154_prependHeader
packetfunctions_reserveFooterSize
debugpins_slot_toggle
debugpins_frame_toggle
schedule_advanceSlot
openserial_stop
schedule_getType
schedule_getOkToSend
schedule_getNeighbor
radiotimer_schedule
radio_loadPacket
radio_txEnable
radio_getTimerValue
radio_txNow
radiotimer_cancel
radio_rfOff
packetfunctions_isBroadcastMulticast
leds_sync_blink
schedule_indicateTx
radio_rxEnable
radio_rxNow
radio_getReceivedFrame
packetfunctions_tossFooter
ieee802154_retrieveHeader
packetfunctions_tossHeader
openqueue_freePacketBuffer
packetfunctions_mac64bToMac16b
packetfunctions_sameAddress
idmanager_getMyID
packetfunctions_reserveHeaderSize
packetfunctions_writeAddress
packetfunctions_readAddress
idmanager_isMyAddress
schedule_getFrameLength
radio_getTimerPeriod
adaptive_sync_indicateTimeCorrection
leds_sync_on
leds_sync_off
schedule_resetBackoff
task_sixtopNotifSendDone
scheduler_push_task
leds_radio_toggle
leds_sync_toggle
leds_error_toggle
debugpins_fsm_set
debugpins_fsm_clr
debugpins_fsm_toggle
openserial_printStatus
processIE_retrieveSlotframeLinkIE
neighbors_isPreferredParent
schedule_syncSlotOffset
schedule_getNextActiveSlotOffset
schedule_getChannelOffset
IntMasterDisable
IntMasterEnable
