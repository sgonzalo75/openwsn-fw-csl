   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"IEEE802154Ecsl.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.rodata
  19              		.align	2
  22              	rreg_uriquery:
  23 0000 683D7563 		.ascii	"h=ucb\000"
  23      6200
  24 0006 0000     		.align	2
  27              	infoBoardname:
  28 0008 43433235 		.ascii	"CC2538\000"
  28      333800
  29 000f 00       		.align	2
  32              	infouCName:
  33 0010 43433235 		.ascii	"CC2538\000"
  33      333800
  34 0017 00       		.align	2
  37              	infoRadioName:
  38 0018 43433235 		.ascii	"CC2538 SoC\000"
  38      33382053 
  38      6F4300
  39 0023 00       		.align	2
  42              	infoStackName:
  43 0024 4F70656E 		.ascii	"OpenWSN \000"
  43      57534E20 
  43      00
  44 002d 000000   		.align	2
  47              	all_routers_multicast:
  48 0030 FF       		.byte	-1
  49 0031 02       		.byte	2
  50 0032 00       		.byte	0
  51 0033 00       		.byte	0
  52 0034 00       		.byte	0
  53 0035 00       		.byte	0
  54 0036 00       		.byte	0
  55 0037 00       		.byte	0
  56 0038 00       		.byte	0
  57 0039 00       		.byte	0
  58 003a 00       		.byte	0
  59 003b 00       		.byte	0
  60 003c 00       		.byte	0
  61 003d 00       		.byte	0
  62 003e 00       		.byte	0
  63 003f 02       		.byte	2
  64              		.comm	ieee154e_vars,76,4
  65              		.comm	ieee154e_stats,15,4
  66              		.comm	ieee154e_dbg,20,4
  67              		.text
  68              		.align	2
  69              		.global	ieee154e_init
  70              		.thumb
  71              		.thumb_func
  73              	ieee154e_init:
  74              	.LFB0:
  75              		.file 1 "openstack/02a-MAClow/IEEE802154Ecsl.c"
   1:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "IEEE802154Ecsl.h"
   2:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
   3:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "opendefs.h"
   4:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "radio.h"
   5:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "radiotimer.h"
   6:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "IEEE802154.h"
   7:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "openqueue.h"
   8:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "idmanager.h"
   9:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "openserial.h"
  10:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "schedule.h"
  11:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "packetfunctions.h"
  12:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "scheduler.h"
  13:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "leds.h"
  14:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "neighbors.h"
  15:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "debugpins.h"
  16:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "sixtop.h"
  17:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "adaptive_sync.h"
  18:openstack/02a-MAClow/IEEE802154Ecsl.c **** #include "processIE.h"
  19:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  20:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
  21:openstack/02a-MAClow/IEEE802154Ecsl.c **** //=========================== VARIABLES ================================
  22:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
  23:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  24:openstack/02a-MAClow/IEEE802154Ecsl.c **** ieee154e_vars_t	   ieee154e_vars;
  25:openstack/02a-MAClow/IEEE802154Ecsl.c **** ieee154e_stats_t   ieee154e_stats;
  26:openstack/02a-MAClow/IEEE802154Ecsl.c **** ieee154e_dbg_t     ieee154e_dbg;
  27:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  28:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
  29:openstack/02a-MAClow/IEEE802154Ecsl.c **** //========================== PROTOTYPES ================================
  30:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
  31:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  32:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CSL]: FSM activities prototypes.
  33:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  34:openstack/02a-MAClow/IEEE802154Ecsl.c **** // TX-MODE: CSL Frame sending activities prototypes
  35:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ti1(void);
  36:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ti2(void);
  37:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_tie1(void);
  38:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ti3(void);
  39:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_tie2(void);
  40:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ti4(PORT_RADIOTIMER_WIDTH capturedTime);
  41:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_tie3(void);
  42:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ti5(PORT_RADIOTIMER_WIDTH capturedTime);
  43:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  44:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti1(void);
  45:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti2(void);
  46:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_tie1(void);
  47:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti3(void);
  48:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_tie2(void);
  49:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti4(PORT_RADIOTIMER_WIDTH capturedTime);
  50:openstack/02a-MAClow/IEEE802154Ecsl.c **** void	activity_csl_data_tie3(void);
  51:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti5(PORT_RADIOTIMER_WIDTH capturedTime);
  52:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti6(void);
  53:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_tie4(void);
  54:openstack/02a-MAClow/IEEE802154Ecsl.c **** void	activity_csl_data_ti7(void);
  55:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_tie5(void);
  56:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti8(PORT_RADIOTIMER_WIDTH capturedTime);
  57:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_tie6(void);
  58:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ti9(PORT_RADIOTIMER_WIDTH capturedTime);
  59:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  60:openstack/02a-MAClow/IEEE802154Ecsl.c **** // RX-MODE: CSL Sampling activities prototypes
  61:openstack/02a-MAClow/IEEE802154Ecsl.c **** void 	activity_csl_wakeup_ri1(void);
  62:openstack/02a-MAClow/IEEE802154Ecsl.c **** void 	activity_csl_wakeup_ri2(void);
  63:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_rie1(void);
  64:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ri3(void);
  65:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_rie2(void);
  66:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ri4(PORT_RADIOTIMER_WIDTH capturedTime);
  67:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_rie3(void);
  68:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_ri5(PORT_RADIOTIMER_WIDTH capturedTime);
  69:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_wakeup_rie4(void);
  70:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  71:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ri2(void);
  72:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_rie1(void);
  73:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ri3(void);
  74:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_rie2(void);
  75:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ri4(PORT_RADIOTIMER_WIDTH capturedTime);
  76:openstack/02a-MAClow/IEEE802154Ecsl.c **** void	activity_csl_data_rie3(void);
  77:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ri5(PORT_RADIOTIMER_WIDTH capturedTime);
  78:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ri6(void);
  79:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_rie4(void);
  80:openstack/02a-MAClow/IEEE802154Ecsl.c **** void	activity_csl_data_ri7(void);
  81:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_rie5(void);
  82:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ri8(PORT_RADIOTIMER_WIDTH capturedTime);
  83:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_rie6(void);
  84:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    activity_csl_data_ri9(PORT_RADIOTIMER_WIDTH capturedTime);
  85:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  86:openstack/02a-MAClow/IEEE802154Ecsl.c **** // frame validity check
  87:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool     isValidRxFrame(ieee802154_header_iht* ieee802514_header);
  88:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool     isValidAck(ieee802154_header_iht*     ieee802514_header,
  89:openstack/02a-MAClow/IEEE802154Ecsl.c ****                     OpenQueueEntry_t*          packetSent);
  90:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     changeIsSync(bool newIsSync);
  91:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  92:openstack/02a-MAClow/IEEE802154Ecsl.c **** // statistics
  93:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     resetStats(void);
  94:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     updateStats(PORT_SIGNED_INT_WIDTH timeCorrection);
  95:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
  96:openstack/02a-MAClow/IEEE802154Ecsl.c **** // notifying upper layer
  97:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     notif_sendDone(OpenQueueEntry_t* packetSent, owerror_t error);
  98:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     notif_receive(OpenQueueEntry_t* packetReceived, uint8_t action);
  99:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 100:openstack/02a-MAClow/IEEE802154Ecsl.c **** // IEs Handling
 101:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool     ieee154e_processIEs(OpenQueueEntry_t* pkt, uint16_t* lenIE);
 102:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 103:openstack/02a-MAClow/IEEE802154Ecsl.c **** // ASN handling
 104:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     incrementAsnOffset(void);
 105:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     asnStoreFromAdv(uint8_t* asn);
 106:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     joinPriorityStoreFromAdv(uint8_t jp);
 107:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 108:openstack/02a-MAClow/IEEE802154Ecsl.c **** // misc
 109:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     changeState(ieee154e_state_t newstate);
 110:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     endOps(void);
 111:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool     debugPrint_asn(void);
 112:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool     debugPrint_isSync(void);
 113:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 114:openstack/02a-MAClow/IEEE802154Ecsl.c **** // CSL Sampling interrupts
 115:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     isr_ieee154ecsl_newChannelSample(void);
 116:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     isr_ieee154ecsl_timer(void);
 117:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 118:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CSL]: queue checking for local transmissions
 119:openstack/02a-MAClow/IEEE802154Ecsl.c **** void 	 isr_ieee154ecsl_txtimer_cb(void);
 120:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 121:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CSL-TEST]: Testing callback to put a packet on queue for testing CSL Tx mode.
 122:openstack/02a-MAClow/IEEE802154Ecsl.c **** void     isr_ieee154ecsl_addPacketToQueueForTestingCslTx_cb (void);
 123:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 124:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CSL]: Wake-up frames prototypes (create and retrieve methods).
 125:openstack/02a-MAClow/IEEE802154Ecsl.c **** void 	ieee802154_retrieveWakeUpFrame(OpenQueueEntry_t* msg, ieee802154_header_iht* ieee802514_heade
 126:openstack/02a-MAClow/IEEE802154Ecsl.c **** void    ieee802154_createWakeUpFrame(OpenQueueEntry_t* msg, uint8_t sequenceNumber, open_addr_t* ne
 127:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 128:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 129:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
 130:openstack/02a-MAClow/IEEE802154Ecsl.c **** //========================== INITIALIZATION ============================
 131:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
 132:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 133:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 134:openstack/02a-MAClow/IEEE802154Ecsl.c ****   \brief This function initializes this module.
 135:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 136:openstack/02a-MAClow/IEEE802154Ecsl.c ****   Call this function once before any other function in this module, possibly during boot-up.
 137:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 138:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CSL]: Modificaciones sobre método inicial referidas a los temporizadores y al estado inicial.
 139:openstack/02a-MAClow/IEEE802154Ecsl.c **** void ieee154e_init() {
  76              		.loc 1 139 0
  77              		.cfi_startproc
  78              		@ args = 0, pretend = 0, frame = 0
  79              		@ frame_needed = 1, uses_anonymous_args = 0
  80 0000 80B5     		push	{r7, lr}
  81              	.LCFI0:
  82              		.cfi_def_cfa_offset 8
  83              		.cfi_offset 7, -8
  84              		.cfi_offset 14, -4
  85 0002 00AF     		add	r7, sp, #0
  86              	.LCFI1:
  87              		.cfi_def_cfa_register 7
 140:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
 141:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // initialize variables
 142:openstack/02a-MAClow/IEEE802154Ecsl.c ****    memset(&ieee154e_vars,0,sizeof(ieee154e_vars_t));
  88              		.loc 1 142 0
  89 0004 40F20000 		movw	r0, #:lower16:ieee154e_vars
  90 0008 C0F20000 		movt	r0, #:upper16:ieee154e_vars
  91 000c 4FF00001 		mov	r1, #0
  92 0010 4FF04C02 		mov	r2, #76
  93 0014 FFF7FEFF 		bl	memset
 143:openstack/02a-MAClow/IEEE802154Ecsl.c ****    memset(&ieee154e_dbg,0,sizeof(ieee154e_dbg_t));
  94              		.loc 1 143 0
  95 0018 40F20000 		movw	r0, #:lower16:ieee154e_dbg
  96 001c C0F20000 		movt	r0, #:upper16:ieee154e_dbg
  97 0020 4FF00001 		mov	r1, #0
  98 0024 4FF01402 		mov	r2, #20
  99 0028 FFF7FEFF 		bl	memset
 144:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
 145:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (idmanager_getIsDAGroot()==TRUE) {
 100              		.loc 1 145 0
 101 002c FFF7FEFF 		bl	idmanager_getIsDAGroot
 102 0030 0346     		mov	r3, r0
 103 0032 002B     		cmp	r3, #0
 104 0034 04D0     		beq	.L2
 146:openstack/02a-MAClow/IEEE802154Ecsl.c ****       changeIsSync(TRUE);
 105              		.loc 1 146 0
 106 0036 4FF00100 		mov	r0, #1
 107 003a FFF7FEFF 		bl	changeIsSync
 108 003e 03E0     		b	.L3
 109              	.L2:
 147:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
 148:openstack/02a-MAClow/IEEE802154Ecsl.c ****       changeIsSync(FALSE);
 110              		.loc 1 148 0
 111 0040 4FF00000 		mov	r0, #0
 112 0044 FFF7FEFF 		bl	changeIsSync
 113              	.L3:
 149:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 150:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
 151:openstack/02a-MAClow/IEEE802154Ecsl.c ****    resetStats();
 114              		.loc 1 151 0
 115 0048 FFF7FEFF 		bl	resetStats
 152:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.numDeSync                 = 0;
 116              		.loc 1 152 0
 117 004c 40F20003 		movw	r3, #:lower16:ieee154e_stats
 118 0050 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 119 0054 4FF00002 		mov	r2, #0
 120 0058 9A71     		strb	r2, [r3, #6]
 153:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
 154:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // [CSL]: update CSL Mode to SLEEP in order to allow RX o TX.
 155:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.cslMode = CSL_SLEEP_MODE;
 121              		.loc 1 155 0
 122 005a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 123 005e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 124 0062 4FF00002 		mov	r2, #0
 125 0066 83F84520 		strb	r2, [r3, #69]
 156:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // [CSL]: Set initial DSN counter for wake-up sequence frames.
 157:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.cslDSN	 = 0;
 126              		.loc 1 157 0
 127 006a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 128 006e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 129 0072 4FF00002 		mov	r2, #0
 130 0076 83F84420 		strb	r2, [r3, #68]
 158:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 159:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // switch radio on - Does this function really do anything?. Its contents are commented...
 160:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rfOn();
 131              		.loc 1 160 0
 132 007a FFF7FEFF 		bl	radio_rfOn
 161:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
 162:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // set callback functions for the radio
 163:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_setOverflowCb(isr_ieee154ecsl_newChannelSample); // CSL - Fires every macCSLPeriod for sam
 133              		.loc 1 163 0
 134 007e 40F20000 		movw	r0, #:lower16:isr_ieee154ecsl_newChannelSample
 135 0082 C0F20000 		movt	r0, #:upper16:isr_ieee154ecsl_newChannelSample
 136 0086 FFF7FEFF 		bl	radio_setOverflowCb
 164:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_setCompareCb(isr_ieee154ecsl_timer);             // CSL - Fires for FSM state changing.
 137              		.loc 1 164 0
 138 008a 40F20000 		movw	r0, #:lower16:isr_ieee154ecsl_timer
 139 008e C0F20000 		movt	r0, #:upper16:isr_ieee154ecsl_timer
 140 0092 FFF7FEFF 		bl	radio_setCompareCb
 165:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_setStartFrameCb(ieee154ecsl_startOfFrame);       // CSL – Fires on start of frame detect
 141              		.loc 1 165 0
 142 0096 40F20000 		movw	r0, #:lower16:ieee154ecsl_startOfFrame
 143 009a C0F20000 		movt	r0, #:upper16:ieee154ecsl_startOfFrame
 144 009e FFF7FEFF 		bl	radio_setStartFrameCb
 166:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_setEndFrameCb(ieee154ecsl_endOfFrame);           // CSL – Fires on end of frame detected
 145              		.loc 1 166 0
 146 00a2 40F20000 		movw	r0, #:lower16:ieee154ecsl_endOfFrame
 147 00a6 C0F20000 		movt	r0, #:upper16:ieee154ecsl_endOfFrame
 148 00aa FFF7FEFF 		bl	radio_setEndFrameCb
 167:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 168:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // [CSL]: set timer for checking frames on local queue to transmit.
 169:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.txTimer = opentimers_start(macCSLTxChkFreq, TIMER_PERIODIC, TIME_TICS, isr_ieee154
 149              		.loc 1 169 0
 150 00ae 40F2AE70 		movw	r0, #1966
 151 00b2 4FF00001 		mov	r1, #0
 152 00b6 4FF00102 		mov	r2, #1
 153 00ba 40F20003 		movw	r3, #:lower16:isr_ieee154ecsl_txtimer_cb
 154 00be C0F20003 		movt	r3, #:upper16:isr_ieee154ecsl_txtimer_cb
 155 00c2 FFF7FEFF 		bl	opentimers_start
 156 00c6 0346     		mov	r3, r0
 157 00c8 1A46     		mov	r2, r3
 158 00ca 40F20003 		movw	r3, #:lower16:ieee154e_vars
 159 00ce C0F20003 		movt	r3, #:upper16:ieee154e_vars
 160 00d2 83F84620 		strb	r2, [r3, #70]
 170:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 171:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // [CSL-TEST]: set timer for callback to add packet to queue for testing CSL TX (every 5 seconds
 172:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.cslTxTestTimer = opentimers_start(2000, TIMER_PERIODIC, TIME_MS, isr_ieee154ecsl_a
 161              		.loc 1 172 0
 162 00d6 4FF4FA60 		mov	r0, #2000
 163 00da 4FF00001 		mov	r1, #0
 164 00de 4FF00002 		mov	r2, #0
 165 00e2 40F20003 		movw	r3, #:lower16:isr_ieee154ecsl_addPacketToQueueForTestingCslTx_cb
 166 00e6 C0F20003 		movt	r3, #:upper16:isr_ieee154ecsl_addPacketToQueueForTestingCslTx_cb
 167 00ea FFF7FEFF 		bl	opentimers_start
 168 00ee 0346     		mov	r3, r0
 169 00f0 1A46     		mov	r2, r3
 170 00f2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 171 00f6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 172 00fa 83F84720 		strb	r2, [r3, #71]
 173:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 174:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // [CSL]: have the radio start its timer for channel sampling (macCSLPeriod)
 175:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_startTimer(macCSLPeriod);
 173              		.loc 1 175 0
 174 00fe 41F69A10 		movw	r0, #6554
 175 0102 FFF7FEFF 		bl	radio_startTimer
 176:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 176              		.loc 1 176 0
 177 0106 80BD     		pop	{r7, pc}
 178              		.cfi_endproc
 179              	.LFE0:
 181              		.align	2
 182              		.global	isr_ieee154ecsl_newChannelSample
 183              		.thumb
 184              		.thumb_func
 186              	isr_ieee154ecsl_newChannelSample:
 187              	.LFB1:
 177:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 178:openstack/02a-MAClow/IEEE802154Ecsl.c **** //=========================== public ==========================================
 179:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 180:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
 181:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================  EVENTS & CALLBACKS ===========================
 182:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
 183:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 184:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 185:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Indicates a new CSL Channel Sample has just started.
 186:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 187:openstack/02a-MAClow/IEEE802154Ecsl.c **** This function executes in ISR mode, when the new CSÑ Channel Sample timer fires.
 188:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 189:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CSL]: Callback indicating the start of a new CSL channel sample.
 190:openstack/02a-MAClow/IEEE802154Ecsl.c **** void isr_ieee154ecsl_newChannelSample() {
 188              		.loc 1 190 0
 189              		.cfi_startproc
 190              		@ args = 0, pretend = 0, frame = 0
 191              		@ frame_needed = 1, uses_anonymous_args = 0
 192 0108 80B5     		push	{r7, lr}
 193              	.LCFI2:
 194              		.cfi_def_cfa_offset 8
 195              		.cfi_offset 7, -8
 196              		.cfi_offset 14, -4
 197 010a 00AF     		add	r7, sp, #0
 198              	.LCFI3:
 199              		.cfi_def_cfa_register 7
 191:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Establish the new timer for the next channel sample
 192:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_setTimerPeriod(macCSLPeriod);
 200              		.loc 1 192 0
 201 010c 41F69A10 		movw	r0, #6554
 202 0110 FFF7FEFF 		bl	radio_setTimerPeriod
 193:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 194:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Verificamos que no estamos ya en un proceso de TX o RX previo.
 195:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if(ieee154e_vars.cslMode == CSL_SLEEP_MODE) {
 203              		.loc 1 195 0
 204 0114 40F20003 		movw	r3, #:lower16:ieee154e_vars
 205 0118 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 206 011c 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 207 0120 002B     		cmp	r3, #0
 208 0122 02D1     		bne	.L5
 196:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // We call the first activity on FSM for channel sampling (CSL FSM RX mode)
 197:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  activity_csl_wakeup_ri1();
 209              		.loc 1 197 0
 210 0124 FFF7FEFF 		bl	activity_csl_wakeup_ri1
 211 0128 12E0     		b	.L6
 212              	.L5:
 198:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
 199:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // log the info about a operation in progress
 200:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printInfo(COMPONENT_IEEE802154E,ERR_MAC_OPERATION_IN_PROGRESS,
 201:openstack/02a-MAClow/IEEE802154Ecsl.c **** 						  (errorparameter_t)ieee154e_vars.cslMode, (errorparameter_t)ieee154e_dbg.num_cslSamples);
 213              		.loc 1 201 0
 214 012a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 215 012e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 216 0132 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 200:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printInfo(COMPONENT_IEEE802154E,ERR_MAC_OPERATION_IN_PROGRESS,
 217              		.loc 1 200 0
 218 0136 1A46     		mov	r2, r3
 219              		.loc 1 201 0
 220 0138 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 221 013c C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 222 0140 1B69     		ldr	r3, [r3, #16]
 200:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printInfo(COMPONENT_IEEE802154E,ERR_MAC_OPERATION_IN_PROGRESS,
 223              		.loc 1 200 0
 224 0142 9BB2     		uxth	r3, r3
 225 0144 4FF00900 		mov	r0, #9
 226 0148 4FF04001 		mov	r1, #64
 227 014c FFF7FEFF 		bl	openserial_printInfo
 228              	.L6:
 202:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 203:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 204:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Increment the number of cslSamples.
 205:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_dbg.num_cslSamples++;
 229              		.loc 1 205 0
 230 0150 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 231 0154 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 232 0158 1B69     		ldr	r3, [r3, #16]
 233 015a 03F10102 		add	r2, r3, #1
 234 015e 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 235 0162 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 236 0166 1A61     		str	r2, [r3, #16]
 206:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 237              		.loc 1 206 0
 238 0168 80BD     		pop	{r7, pc}
 239              		.cfi_endproc
 240              	.LFE1:
 242 016a 00BF     		.align	2
 243              		.global	isr_ieee154ecsl_timer
 244              		.thumb
 245              		.thumb_func
 247              	isr_ieee154ecsl_timer:
 248              	.LFB2:
 207:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 208:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 209:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Indicates the FSM timer has fired.
 210:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 211:openstack/02a-MAClow/IEEE802154Ecsl.c **** This function executes in ISR mode, when the FSM timer fires.
 212:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 213:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CSL]: Callback to select the next FSM action.
 214:openstack/02a-MAClow/IEEE802154Ecsl.c **** void isr_ieee154ecsl_timer() {
 249              		.loc 1 214 0
 250              		.cfi_startproc
 251              		@ args = 0, pretend = 0, frame = 0
 252              		@ frame_needed = 1, uses_anonymous_args = 0
 253 016c 80B5     		push	{r7, lr}
 254              	.LCFI4:
 255              		.cfi_def_cfa_offset 8
 256              		.cfi_offset 7, -8
 257              		.cfi_offset 14, -4
 258 016e 00AF     		add	r7, sp, #0
 259              	.LCFI5:
 260              		.cfi_def_cfa_register 7
 215:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.cslMode == CSL_RX_MODE)  { // Current CSL operation mode is channel sampling a
 261              		.loc 1 215 0
 262 0170 40F20003 		movw	r3, #:lower16:ieee154e_vars
 263 0174 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 264 0178 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 265 017c 012B     		cmp	r3, #1
 266 017e 71D1     		bne	.L8
 216:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   switch (ieee154e_vars.state) {
 267              		.loc 1 216 0
 268 0180 40F20003 		movw	r3, #:lower16:ieee154e_vars
 269 0184 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 270 0188 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 271 018a A3F12B03 		sub	r3, r3, #43
 272 018e 0F2B     		cmp	r3, #15
 273 0190 53D8     		bhi	.L9
 274 0192 01A2     		adr	r2, .L26
 275 0194 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 276              		.align	2
 277              	.L26:
 278 0198 D9010000 		.word	.L10+1
 279 019c DF010000 		.word	.L11+1
 280 01a0 E5010000 		.word	.L12+1
 281 01a4 EB010000 		.word	.L13+1
 282 01a8 F1010000 		.word	.L14+1
 283 01ac F7010000 		.word	.L15+1
 284 01b0 FD010000 		.word	.L16+1
 285 01b4 03020000 		.word	.L17+1
 286 01b8 09020000 		.word	.L18+1
 287 01bc 0F020000 		.word	.L19+1
 288 01c0 15020000 		.word	.L20+1
 289 01c4 1B020000 		.word	.L21+1
 290 01c8 21020000 		.word	.L22+1
 291 01cc 27020000 		.word	.L23+1
 292 01d0 2D020000 		.word	.L24+1
 293 01d4 33020000 		.word	.L25+1
 294              	.L10:
 217:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      // RX-MODE
 218:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUPOFFSET:      activity_csl_wakeup_ri2();  break;
 295              		.loc 1 218 0
 296 01d8 FFF7FEFF 		bl	activity_csl_wakeup_ri2
 297 01dc BBE0     		b	.L28
 298              	.L11:
 219:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUPPREPARE:     activity_csl_wakeup_rie1(); break;
 299              		.loc 1 219 0
 300 01de FFF7FEFF 		bl	activity_csl_wakeup_rie1
 301 01e2 B8E0     		b	.L28
 302              	.L12:
 220:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUPREADY:       activity_csl_wakeup_ri3();  break;
 303              		.loc 1 220 0
 304 01e4 FFF7FEFF 		bl	activity_csl_wakeup_ri3
 305 01e8 B5E0     		b	.L28
 306              	.L13:
 221:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUPLISTEN:      activity_csl_wakeup_rie2(); break;
 307              		.loc 1 221 0
 308 01ea FFF7FEFF 		bl	activity_csl_wakeup_rie2
 309 01ee B2E0     		b	.L28
 310              	.L14:
 222:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUP:			 activity_csl_wakeup_rie3(); break;
 311              		.loc 1 222 0
 312 01f0 FFF7FEFF 		bl	activity_csl_wakeup_rie3
 313 01f4 AFE0     		b	.L28
 314              	.L15:
 223:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUPVALIDATE: 	 activity_csl_wakeup_rie4(); break;
 315              		.loc 1 223 0
 316 01f6 FFF7FEFF 		bl	activity_csl_wakeup_rie4
 317 01fa ACE0     		b	.L28
 318              	.L16:
 224:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 225:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXDATAOFFSET:    	 activity_csl_data_ri2();    break;
 319              		.loc 1 225 0
 320 01fc FFF7FEFF 		bl	activity_csl_data_ri2
 321 0200 A9E0     		b	.L28
 322              	.L17:
 226:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXDATAPREPARE:       activity_csl_data_rie1();   break;
 323              		.loc 1 226 0
 324 0202 FFF7FEFF 		bl	activity_csl_data_rie1
 325 0206 A6E0     		b	.L28
 326              	.L18:
 227:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXDATAREADY:         activity_csl_data_ri3();    break;
 327              		.loc 1 227 0
 328 0208 FFF7FEFF 		bl	activity_csl_data_ri3
 329 020c A3E0     		b	.L28
 330              	.L19:
 228:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXDATALISTEN:        activity_csl_data_rie2();   break;
 331              		.loc 1 228 0
 332 020e FFF7FEFF 		bl	activity_csl_data_rie2
 333 0212 A0E0     		b	.L28
 334              	.L20:
 229:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXDATA:			     activity_csl_data_rie3();   break;
 335              		.loc 1 229 0
 336 0214 FFF7FEFF 		bl	activity_csl_data_rie3
 337 0218 9DE0     		b	.L28
 338              	.L21:
 230:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 231:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLTXACKOFFSET: 	     activity_csl_data_ri6();    break;
 339              		.loc 1 231 0
 340 021a FFF7FEFF 		bl	activity_csl_data_ri6
 341 021e 9AE0     		b	.L28
 342              	.L22:
 232:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLTXACKPREPARE:        activity_csl_data_rie4();   break;
 343              		.loc 1 232 0
 344 0220 FFF7FEFF 		bl	activity_csl_data_rie4
 345 0224 97E0     		b	.L28
 346              	.L23:
 233:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLTXACKREADY:          activity_csl_data_ri7();    break;
 347              		.loc 1 233 0
 348 0226 FFF7FEFF 		bl	activity_csl_data_ri7
 349 022a 94E0     		b	.L28
 350              	.L24:
 234:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLTXACKDELAY:          activity_csl_data_rie5();   break;
 351              		.loc 1 234 0
 352 022c FFF7FEFF 		bl	activity_csl_data_rie5
 353 0230 91E0     		b	.L28
 354              	.L25:
 235:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLTXACK:               activity_csl_data_rie6();   break;
 355              		.loc 1 235 0
 356 0232 FFF7FEFF 		bl	activity_csl_data_rie6
 357 0236 00BF     		nop
 358 0238 8DE0     		b	.L28
 359              	.L9:
 236:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  default:
 237:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 // log the error
 238:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_TIMERFIRES,
 239:openstack/02a-MAClow/IEEE802154Ecsl.c **** 								   (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_dbg.num_cslSamples);
 360              		.loc 1 239 0
 361 023a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 362 023e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 363 0242 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 238:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_TIMERFIRES,
 364              		.loc 1 238 0
 365 0244 1A46     		mov	r2, r3
 366              		.loc 1 239 0
 367 0246 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 368 024a C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 369 024e 1B69     		ldr	r3, [r3, #16]
 238:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_TIMERFIRES,
 370              		.loc 1 238 0
 371 0250 9BB2     		uxth	r3, r3
 372 0252 4FF00900 		mov	r0, #9
 373 0256 4FF03B01 		mov	r1, #59
 374 025a FFF7FEFF 		bl	openserial_printError
 240:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 // abort
 241:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 endOps();
 375              		.loc 1 241 0
 376 025e FFF7FEFF 		bl	endOps
 242:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 break;
 377              		.loc 1 242 0
 378 0262 78E0     		b	.L28
 379              	.L8:
 243:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 244:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else if (ieee154e_vars.cslMode == CSL_TX_MODE)  { // Current CSL operation mode is frame TX.
 380              		.loc 1 244 0
 381 0264 40F20003 		movw	r3, #:lower16:ieee154e_vars
 382 0268 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 383 026c 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 384 0270 022B     		cmp	r3, #2
 385 0272 70D1     		bne	.L28
 245:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   switch (ieee154e_vars.state) {
 386              		.loc 1 245 0
 387 0274 40F20003 		movw	r3, #:lower16:ieee154e_vars
 388 0278 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 389 027c 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 390 027e A3F11A03 		sub	r3, r3, #26
 391 0282 0F2B     		cmp	r3, #15
 392 0284 52D8     		bhi	.L29
 393 0286 01A2     		adr	r2, .L46
 394 0288 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 395              		.align	2
 396              	.L46:
 397 028c CD020000 		.word	.L30+1
 398 0290 D3020000 		.word	.L31+1
 399 0294 D9020000 		.word	.L32+1
 400 0298 DF020000 		.word	.L33+1
 401 029c E5020000 		.word	.L34+1
 402 02a0 EB020000 		.word	.L35+1
 403 02a4 F1020000 		.word	.L36+1
 404 02a8 F7020000 		.word	.L37+1
 405 02ac FD020000 		.word	.L38+1
 406 02b0 03030000 		.word	.L39+1
 407 02b4 09030000 		.word	.L40+1
 408 02b8 0F030000 		.word	.L41+1
 409 02bc 15030000 		.word	.L42+1
 410 02c0 1B030000 		.word	.L43+1
 411 02c4 21030000 		.word	.L44+1
 412 02c8 27030000 		.word	.L45+1
 413              	.L30:
 246:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      // TX-MODE
 247:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXWAKEUPOFFSET:		 activity_csl_wakeup_ti2();  break;
 414              		.loc 1 247 0
 415 02cc FFF7FEFF 		bl	activity_csl_wakeup_ti2
 416 02d0 41E0     		b	.L28
 417              	.L31:
 248:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXWAKEUPPREPARE:	 activity_csl_wakeup_tie1(); break;
 418              		.loc 1 248 0
 419 02d2 FFF7FEFF 		bl	activity_csl_wakeup_tie1
 420 02d6 3EE0     		b	.L28
 421              	.L32:
 249:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXWAKEUPREADY:	     activity_csl_wakeup_ti3();  break;
 422              		.loc 1 249 0
 423 02d8 FFF7FEFF 		bl	activity_csl_wakeup_ti3
 424 02dc 3BE0     		b	.L28
 425              	.L33:
 250:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXWAKEUPDELAY:	     activity_csl_wakeup_tie2(); break;
 426              		.loc 1 250 0
 427 02de FFF7FEFF 		bl	activity_csl_wakeup_tie2
 428 02e2 38E0     		b	.L28
 429              	.L34:
 251:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXWAKEUP: 	         activity_csl_wakeup_tie3(); break;
 430              		.loc 1 251 0
 431 02e4 FFF7FEFF 		bl	activity_csl_wakeup_tie3
 432 02e8 35E0     		b	.L28
 433              	.L35:
 252:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 253:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXDATAPREOFFSET:	 activity_csl_data_ti1();	 break;
 434              		.loc 1 253 0
 435 02ea FFF7FEFF 		bl	activity_csl_data_ti1
 436 02ee 32E0     		b	.L28
 437              	.L36:
 254:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXDATAOFFSET:        activity_csl_data_ti2();    break;
 438              		.loc 1 254 0
 439 02f0 FFF7FEFF 		bl	activity_csl_data_ti2
 440 02f4 2FE0     		b	.L28
 441              	.L37:
 255:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXDATAPREPARE:	     activity_csl_data_tie1(); 	 break;
 442              		.loc 1 255 0
 443 02f6 FFF7FEFF 		bl	activity_csl_data_tie1
 444 02fa 2CE0     		b	.L28
 445              	.L38:
 256:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXDATAREADY:	     activity_csl_data_ti3(); 	 break;
 446              		.loc 1 256 0
 447 02fc FFF7FEFF 		bl	activity_csl_data_ti3
 448 0300 29E0     		b	.L28
 449              	.L39:
 257:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXDATADELAY:	     activity_csl_data_tie2(); 	 break;
 450              		.loc 1 257 0
 451 0302 FFF7FEFF 		bl	activity_csl_data_tie2
 452 0306 26E0     		b	.L28
 453              	.L40:
 258:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXDATA: 	         activity_csl_data_tie3();	 break;
 454              		.loc 1 258 0
 455 0308 FFF7FEFF 		bl	activity_csl_data_tie3
 456 030c 23E0     		b	.L28
 457              	.L41:
 259:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 260:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLRXACKOFFSET: 	     activity_csl_data_ti6();	 break;
 458              		.loc 1 260 0
 459 030e FFF7FEFF 		bl	activity_csl_data_ti6
 460 0312 20E0     		b	.L28
 461              	.L42:
 261:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLRXACKPREPARE:	     activity_csl_data_tie4(); 	 break;
 462              		.loc 1 261 0
 463 0314 FFF7FEFF 		bl	activity_csl_data_tie4
 464 0318 1DE0     		b	.L28
 465              	.L43:
 262:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLRXACKREADY: 	     activity_csl_data_ti7(); 	 break;
 466              		.loc 1 262 0
 467 031a FFF7FEFF 		bl	activity_csl_data_ti7
 468 031e 1AE0     		b	.L28
 469              	.L44:
 263:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLRXACKLISTEN: 	     activity_csl_data_tie5(); 	 break;
 470              		.loc 1 263 0
 471 0320 FFF7FEFF 		bl	activity_csl_data_tie5
 472 0324 17E0     		b	.L28
 473              	.L45:
 264:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLRXACK:     	         activity_csl_data_tie6(); 	 break;
 474              		.loc 1 264 0
 475 0326 FFF7FEFF 		bl	activity_csl_data_tie6
 476 032a 14E0     		b	.L28
 477              	.L29:
 265:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 266:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  default:
 267:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 // log the error
 268:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_TIMERFIRES,
 269:openstack/02a-MAClow/IEEE802154Ecsl.c **** 								   (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_dbg.num_cslSamples);
 478              		.loc 1 269 0
 479 032c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 480 0330 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 481 0334 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 268:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_TIMERFIRES,
 482              		.loc 1 268 0
 483 0336 1A46     		mov	r2, r3
 484              		.loc 1 269 0
 485 0338 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 486 033c C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 487 0340 1B69     		ldr	r3, [r3, #16]
 268:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_TIMERFIRES,
 488              		.loc 1 268 0
 489 0342 9BB2     		uxth	r3, r3
 490 0344 4FF00900 		mov	r0, #9
 491 0348 4FF03B01 		mov	r1, #59
 492 034c FFF7FEFF 		bl	openserial_printError
 270:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 // abort
 271:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 endOps();
 493              		.loc 1 271 0
 494 0350 FFF7FEFF 		bl	endOps
 272:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			 break;
 495              		.loc 1 272 0
 496 0354 00BF     		nop
 497              	.L28:
 273:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 274:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 275:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_dbg.num_timer++;
 498              		.loc 1 275 0
 499 0356 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 500 035a C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 501 035e 5B68     		ldr	r3, [r3, #4]
 502 0360 03F10102 		add	r2, r3, #1
 503 0364 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 504 0368 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 505 036c 5A60     		str	r2, [r3, #4]
 276:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 506              		.loc 1 276 0
 507 036e 80BD     		pop	{r7, pc}
 508              		.cfi_endproc
 509              	.LFE2:
 511              		.align	2
 512              		.global	ieee154ecsl_startOfFrame
 513              		.thumb
 514              		.thumb_func
 516              	ieee154ecsl_startOfFrame:
 517              	.LFB3:
 277:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 278:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CSL] – Callback fired after receive a start of frame on radio.
 279:openstack/02a-MAClow/IEEE802154Ecsl.c **** void ieee154ecsl_startOfFrame(PORT_RADIOTIMER_WIDTH capturedTime) {
 518              		.loc 1 279 0
 519              		.cfi_startproc
 520              		@ args = 0, pretend = 0, frame = 8
 521              		@ frame_needed = 1, uses_anonymous_args = 0
 522 0370 80B5     		push	{r7, lr}
 523              	.LCFI6:
 524              		.cfi_def_cfa_offset 8
 525              		.cfi_offset 7, -8
 526              		.cfi_offset 14, -4
 527 0372 82B0     		sub	sp, sp, #8
 528              	.LCFI7:
 529              		.cfi_def_cfa_offset 16
 530 0374 00AF     		add	r7, sp, #0
 531              	.LCFI8:
 532              		.cfi_def_cfa_register 7
 533 0376 7860     		str	r0, [r7, #4]
 280:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	if(ieee154e_vars.cslMode == CSL_RX_MODE)  { // Current CSL operation mode is channel sampling and 
 534              		.loc 1 280 0
 535 0378 40F20003 		movw	r3, #:lower16:ieee154e_vars
 536 037c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 537 0380 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 538 0384 012B     		cmp	r3, #1
 539 0386 33D1     		bne	.L48
 281:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   switch (ieee154e_vars.state) {
 540              		.loc 1 281 0
 541 0388 40F20003 		movw	r3, #:lower16:ieee154e_vars
 542 038c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 543 0390 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 544 0392 A3F12E03 		sub	r3, r3, #46
 545 0396 0B2B     		cmp	r3, #11
 546 0398 27D8     		bhi	.L49
 547 039a 01A2     		adr	r2, .L53
 548 039c 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 549              		.align	2
 550              	.L53:
 551 03a0 D1030000 		.word	.L50+1
 552 03a4 D1030000 		.word	.L50+1
 553 03a8 EB030000 		.word	.L49+1
 554 03ac EB030000 		.word	.L49+1
 555 03b0 EB030000 		.word	.L49+1
 556 03b4 D9030000 		.word	.L51+1
 557 03b8 D9030000 		.word	.L51+1
 558 03bc EB030000 		.word	.L49+1
 559 03c0 EB030000 		.word	.L49+1
 560 03c4 EB030000 		.word	.L49+1
 561 03c8 EB030000 		.word	.L49+1
 562 03cc E1030000 		.word	.L52+1
 563              	.L50:
 282:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  // RX MODE
 283:openstack/02a-MAClow/IEEE802154Ecsl.c ****           /*
 284:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   It is possible to receive in this state for radio where there is no way of differentiated betw
 285:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   (e.g. CC2420). We must therefore expect to the start of a packet in this "ready" state.
 286:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  */
 287:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUP:    			 // no break!
 288:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXWAKEUPLISTEN:	 	     activity_csl_wakeup_ri4(capturedTime); break;
 564              		.loc 1 288 0
 565 03d0 7868     		ldr	r0, [r7, #4]
 566 03d2 FFF7FEFF 		bl	activity_csl_wakeup_ri4
 567 03d6 58E0     		b	.L55
 568              	.L51:
 289:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 290:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXDATAREADY:		     // no break!
 291:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLRXDATALISTEN:            activity_csl_data_ri4(capturedTime);   break;
 569              		.loc 1 291 0
 570 03d8 7868     		ldr	r0, [r7, #4]
 571 03da FFF7FEFF 		bl	activity_csl_data_ri4
 572 03de 54E0     		b	.L55
 573              	.L52:
 292:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 293:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  case S_CSLTXACKDELAY:              activity_csl_data_ri8(capturedTime);   break;
 574              		.loc 1 293 0
 575 03e0 7868     		ldr	r0, [r7, #4]
 576 03e2 FFF7FEFF 		bl	activity_csl_data_ri8
 577 03e6 00BF     		nop
 578 03e8 4FE0     		b	.L55
 579              	.L49:
 294:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  default:
 295:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			// log the error
 296:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			//openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_SAMPLE,
 297:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			//					  (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_dbg.num_cslSamples);
 298:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			// abort
 299:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			endOps();
 580              		.loc 1 299 0
 581 03ea FFF7FEFF 		bl	endOps
 300:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			break;
 582              		.loc 1 300 0
 583 03ee 4CE0     		b	.L55
 584              	.L48:
 301:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		}
 302:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	} else if (ieee154e_vars.cslMode == CSL_TX_MODE)  { // Current CSL operation mode is frame TX.
 585              		.loc 1 302 0
 586 03f0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 587 03f4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 588 03f8 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 589 03fc 022B     		cmp	r3, #2
 590 03fe 44D1     		bne	.L55
 303:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   switch (ieee154e_vars.state) {
 591              		.loc 1 303 0
 592 0400 40F20003 		movw	r3, #:lower16:ieee154e_vars
 593 0404 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 594 0408 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 595 040a A3F11D03 		sub	r3, r3, #29
 596 040e 0B2B     		cmp	r3, #11
 597 0410 26D8     		bhi	.L56
 598 0412 01A2     		adr	r2, .L60
 599 0414 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 600              		.align	2
 601              	.L60:
 602 0418 51040000 		.word	.L57+1
 603 041c 61040000 		.word	.L56+1
 604 0420 61040000 		.word	.L56+1
 605 0424 61040000 		.word	.L56+1
 606 0428 61040000 		.word	.L56+1
 607 042c 61040000 		.word	.L56+1
 608 0430 59040000 		.word	.L58+1
 609 0434 61040000 		.word	.L56+1
 610 0438 61040000 		.word	.L56+1
 611 043c 61040000 		.word	.L56+1
 612 0440 49040000 		.word	.L59+1
 613 0444 49040000 		.word	.L59+1
 614              	.L59:
 304:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  // TX MODE
 305:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 306:openstack/02a-MAClow/IEEE802154Ecsl.c ****           /*
 307:openstack/02a-MAClow/IEEE802154Ecsl.c ****           It is possible to receive in this state for radio where there is no way of differentiated
 308:openstack/02a-MAClow/IEEE802154Ecsl.c ****           (e.g. CC2420). We must therefore expect to the start of a packet in this "ready" state.
 309:openstack/02a-MAClow/IEEE802154Ecsl.c ****           */
 310:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLRXACKREADY:               // no break!
 311:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLRXACKLISTEN:              activity_csl_data_ti8(capturedTime);  break;
 615              		.loc 1 311 0
 616 0448 7868     		ldr	r0, [r7, #4]
 617 044a FFF7FEFF 		bl	activity_csl_data_ti8
 618 044e 1CE0     		b	.L55
 619              	.L57:
 312:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 313:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXWAKEUPDELAY:            activity_csl_wakeup_ti4(capturedTime); break;
 620              		.loc 1 313 0
 621 0450 7868     		ldr	r0, [r7, #4]
 622 0452 FFF7FEFF 		bl	activity_csl_wakeup_ti4
 623 0456 18E0     		b	.L55
 624              	.L58:
 314:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      case S_CSLTXDATADELAY:              activity_csl_data_ti4(capturedTime);   break;
 625              		.loc 1 314 0
 626 0458 7868     		ldr	r0, [r7, #4]
 627 045a FFF7FEFF 		bl	activity_csl_data_ti4
 628 045e 14E0     		b	.L55
 629              	.L56:
 315:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 316:openstack/02a-MAClow/IEEE802154Ecsl.c ****           default:
 317:openstack/02a-MAClow/IEEE802154Ecsl.c ****    			// log the error
 318:openstack/02a-MAClow/IEEE802154Ecsl.c ****    			openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_SAMPLE,
 319:openstack/02a-MAClow/IEEE802154Ecsl.c ****    								  (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_dbg.num_cslSamples);
 630              		.loc 1 319 0
 631 0460 40F20003 		movw	r3, #:lower16:ieee154e_vars
 632 0464 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 633 0468 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 318:openstack/02a-MAClow/IEEE802154Ecsl.c ****    			openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_SAMPLE,
 634              		.loc 1 318 0
 635 046a 1A46     		mov	r2, r3
 636              		.loc 1 319 0
 637 046c 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 638 0470 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 639 0474 1B69     		ldr	r3, [r3, #16]
 318:openstack/02a-MAClow/IEEE802154Ecsl.c ****    			openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_SAMPLE,
 640              		.loc 1 318 0
 641 0476 9BB2     		uxth	r3, r3
 642 0478 4FF00900 		mov	r0, #9
 643 047c 4FF03E01 		mov	r1, #62
 644 0480 FFF7FEFF 		bl	openserial_printError
 320:openstack/02a-MAClow/IEEE802154Ecsl.c ****    			// abort
 321:openstack/02a-MAClow/IEEE802154Ecsl.c ****    			endOps();
 645              		.loc 1 321 0
 646 0484 FFF7FEFF 		bl	endOps
 322:openstack/02a-MAClow/IEEE802154Ecsl.c ****    			break;
 647              		.loc 1 322 0
 648 0488 00BF     		nop
 649              	.L55:
 323:openstack/02a-MAClow/IEEE802154Ecsl.c ****    		}
 324:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	}
 325:openstack/02a-MAClow/IEEE802154Ecsl.c ****   ieee154e_dbg.num_startOfFrame++;
 650              		.loc 1 325 0
 651 048a 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 652 048e C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 653 0492 9B68     		ldr	r3, [r3, #8]
 654 0494 03F10102 		add	r2, r3, #1
 655 0498 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 656 049c C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 657 04a0 9A60     		str	r2, [r3, #8]
 326:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 658              		.loc 1 326 0
 659 04a2 07F10807 		add	r7, r7, #8
 660 04a6 BD46     		mov	sp, r7
 661 04a8 80BD     		pop	{r7, pc}
 662              		.cfi_endproc
 663              	.LFE3:
 665 04aa 00BF     		.align	2
 666              		.global	ieee154ecsl_endOfFrame
 667              		.thumb
 668              		.thumb_func
 670              	ieee154ecsl_endOfFrame:
 671              	.LFB4:
 327:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 328:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CSL] – Callback fired after receive a end of frame on radio.
 329:openstack/02a-MAClow/IEEE802154Ecsl.c **** void ieee154ecsl_endOfFrame(PORT_RADIOTIMER_WIDTH capturedTime) {
 672              		.loc 1 329 0
 673              		.cfi_startproc
 674              		@ args = 0, pretend = 0, frame = 8
 675              		@ frame_needed = 1, uses_anonymous_args = 0
 676 04ac 80B5     		push	{r7, lr}
 677              	.LCFI9:
 678              		.cfi_def_cfa_offset 8
 679              		.cfi_offset 7, -8
 680              		.cfi_offset 14, -4
 681 04ae 82B0     		sub	sp, sp, #8
 682              	.LCFI10:
 683              		.cfi_def_cfa_offset 16
 684 04b0 00AF     		add	r7, sp, #0
 685              	.LCFI11:
 686              		.cfi_def_cfa_register 7
 687 04b2 7860     		str	r0, [r7, #4]
 330:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	if(ieee154e_vars.cslMode == CSL_RX_MODE)  { // Current CSL operation mode is channel sampling and 
 688              		.loc 1 330 0
 689 04b4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 690 04b8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 691 04bc 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 692 04c0 012B     		cmp	r3, #1
 693 04c2 2CD1     		bne	.L62
 331:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   switch (ieee154e_vars.state) {
 694              		.loc 1 331 0
 695 04c4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 696 04c8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 697 04cc 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 698 04ce 352B     		cmp	r3, #53
 699 04d0 07D0     		beq	.L65
 700 04d2 3A2B     		cmp	r3, #58
 701 04d4 09D0     		beq	.L66
 702 04d6 2F2B     		cmp	r3, #47
 703 04d8 0CD1     		bne	.L73
 704              	.L64:
 332:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		 // RX MODE
 333:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		 case S_CSLRXWAKEUP:           activity_csl_wakeup_ri5(capturedTime);  break;
 705              		.loc 1 333 0
 706 04da 7868     		ldr	r0, [r7, #4]
 707 04dc FFF7FEFF 		bl	activity_csl_wakeup_ri5
 708 04e0 51E0     		b	.L68
 709              	.L65:
 334:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		 case S_CSLRXDATA:             activity_csl_data_ri5(capturedTime);    break;
 710              		.loc 1 334 0
 711 04e2 7868     		ldr	r0, [r7, #4]
 712 04e4 FFF7FEFF 		bl	activity_csl_data_ri5
 713 04e8 4DE0     		b	.L68
 714              	.L66:
 335:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		 case S_CSLTXACK:              activity_csl_data_ri9(capturedTime);    break;
 715              		.loc 1 335 0
 716 04ea 7868     		ldr	r0, [r7, #4]
 717 04ec FFF7FEFF 		bl	activity_csl_data_ri9
 718 04f0 00BF     		nop
 719 04f2 48E0     		b	.L68
 720              	.L73:
 336:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		 default:
 337:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			// log the error
 338:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_ENDOFFRAME,
 339:openstack/02a-MAClow/IEEE802154Ecsl.c **** 								  (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_dbg.num_cslSamples);
 721              		.loc 1 339 0
 722 04f4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 723 04f8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 724 04fc 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 338:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_ENDOFFRAME,
 725              		.loc 1 338 0
 726 04fe 1A46     		mov	r2, r3
 727              		.loc 1 339 0
 728 0500 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 729 0504 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 730 0508 1B69     		ldr	r3, [r3, #16]
 338:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_ENDOFFRAME,
 731              		.loc 1 338 0
 732 050a 9BB2     		uxth	r3, r3
 733 050c 4FF00900 		mov	r0, #9
 734 0510 4FF03F01 		mov	r1, #63
 735 0514 FFF7FEFF 		bl	openserial_printError
 340:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			// abort
 341:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			endOps();
 736              		.loc 1 341 0
 737 0518 FFF7FEFF 		bl	endOps
 342:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			break;
 738              		.loc 1 342 0
 739 051c 33E0     		b	.L68
 740              	.L62:
 343:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 344:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	} else if (ieee154e_vars.cslMode == CSL_TX_MODE)  { // Current CSL operation mode is frame TX.
 741              		.loc 1 344 0
 742 051e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 743 0522 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 744 0526 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 745 052a 022B     		cmp	r3, #2
 746 052c 2BD1     		bne	.L68
 345:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  switch (ieee154e_vars.state) {
 747              		.loc 1 345 0
 748 052e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 749 0532 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 750 0536 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 751 0538 242B     		cmp	r3, #36
 752 053a 07D0     		beq	.L71
 753 053c 292B     		cmp	r3, #41
 754 053e 09D0     		beq	.L72
 755 0540 1E2B     		cmp	r3, #30
 756 0542 0BD1     		bne	.L74
 757              	.L70:
 346:openstack/02a-MAClow/IEEE802154Ecsl.c ****         // TX MODE
 347:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	    case S_CSLTXWAKEUP:            activity_csl_wakeup_ti5(capturedTime); break;
 758              		.loc 1 347 0
 759 0544 7868     		ldr	r0, [r7, #4]
 760 0546 FFF7FEFF 		bl	activity_csl_wakeup_ti5
 761 054a 1CE0     		b	.L68
 762              	.L71:
 348:openstack/02a-MAClow/IEEE802154Ecsl.c ****         case S_CSLTXDATA:              activity_csl_data_ti5(capturedTime);   break;
 763              		.loc 1 348 0
 764 054c 7868     		ldr	r0, [r7, #4]
 765 054e FFF7FEFF 		bl	activity_csl_data_ti5
 766 0552 18E0     		b	.L68
 767              	.L72:
 349:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	    case S_CSLRXACK:               activity_csl_data_ti9(capturedTime);   break;
 768              		.loc 1 349 0
 769 0554 7868     		ldr	r0, [r7, #4]
 770 0556 FFF7FEFF 		bl	activity_csl_data_ti9
 771 055a 14E0     		b	.L68
 772              	.L74:
 350:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	    default:
 351:openstack/02a-MAClow/IEEE802154Ecsl.c ****            // log the error
 352:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_ENDOFFRAME,
 353:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			   				    (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_dbg.num_cslSamples)
 773              		.loc 1 353 0
 774 055c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 775 0560 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 776 0564 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 352:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_ENDOFFRAME,
 777              		.loc 1 352 0
 778 0566 1A46     		mov	r2, r3
 779              		.loc 1 353 0
 780 0568 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 781 056c C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 782 0570 1B69     		ldr	r3, [r3, #16]
 352:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_CSL_ENDOFFRAME,
 783              		.loc 1 352 0
 784 0572 9BB2     		uxth	r3, r3
 785 0574 4FF00900 		mov	r0, #9
 786 0578 4FF03F01 		mov	r1, #63
 787 057c FFF7FEFF 		bl	openserial_printError
 354:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	   // abort
 355:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   endOps();
 788              		.loc 1 355 0
 789 0580 FFF7FEFF 		bl	endOps
 356:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   break;
 790              		.loc 1 356 0
 791 0584 00BF     		nop
 792              	.L68:
 357:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  }
 358:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	}
 359:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_dbg.num_endOfFrame++;
 793              		.loc 1 359 0
 794 0586 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 795 058a C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 796 058e DB68     		ldr	r3, [r3, #12]
 797 0590 03F10102 		add	r2, r3, #1
 798 0594 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 799 0598 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 800 059c DA60     		str	r2, [r3, #12]
 360:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 801              		.loc 1 360 0
 802 059e 07F10807 		add	r7, r7, #8
 803 05a2 BD46     		mov	sp, r7
 804 05a4 80BD     		pop	{r7, pc}
 805              		.cfi_endproc
 806              	.LFE4:
 808 05a6 00BF     		.align	2
 809              		.global	isr_ieee154ecsl_txtimer_cb
 810              		.thumb
 811              		.thumb_func
 813              	isr_ieee154ecsl_txtimer_cb:
 814              	.LFB5:
 361:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 362:openstack/02a-MAClow/IEEE802154Ecsl.c **** // tx timer interrupt callbacks
 363:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 364:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CSL]: Callback to check pending data to be sent.
 365:openstack/02a-MAClow/IEEE802154Ecsl.c **** void isr_ieee154ecsl_txtimer_cb() {
 815              		.loc 1 365 0
 816              		.cfi_startproc
 817              		@ args = 0, pretend = 0, frame = 0
 818              		@ frame_needed = 1, uses_anonymous_args = 0
 819 05a8 80B5     		push	{r7, lr}
 820              	.LCFI12:
 821              		.cfi_def_cfa_offset 8
 822              		.cfi_offset 7, -8
 823              		.cfi_offset 14, -4
 824 05aa 00AF     		add	r7, sp, #0
 825              	.LCFI13:
 826              		.cfi_def_cfa_register 7
 366:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 367:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// Verificamos que no estamos ya en un proceso de TX o RX previo.
 368:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if(ieee154e_vars.cslMode == CSL_SLEEP_MODE) {
 827              		.loc 1 368 0
 828 05ac 40F20003 		movw	r3, #:lower16:ieee154e_vars
 829 05b0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 830 05b4 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 831 05b8 002B     		cmp	r3, #0
 832 05ba 02D1     		bne	.L76
 369:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // We call the first activity on FSM for channel sampling (CSL FSM RX mode)
 370:openstack/02a-MAClow/IEEE802154Ecsl.c ****       activity_csl_wakeup_ti1();
 833              		.loc 1 370 0
 834 05bc FFF7FEFF 		bl	activity_csl_wakeup_ti1
 835 05c0 12E0     		b	.L75
 836              	.L76:
 371:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 372:openstack/02a-MAClow/IEEE802154Ecsl.c ****    else {
 373:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // log the info about a operation in progress
 374:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printInfo(COMPONENT_IEEE802154E,ERR_MAC_OPERATION_IN_PROGRESS,
 375:openstack/02a-MAClow/IEEE802154Ecsl.c **** 						  (errorparameter_t)ieee154e_vars.cslMode, (errorparameter_t)ieee154e_dbg.num_cslSamples);
 837              		.loc 1 375 0
 838 05c2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 839 05c6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 840 05ca 93F84530 		ldrb	r3, [r3, #69]	@ zero_extendqisi2
 374:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printInfo(COMPONENT_IEEE802154E,ERR_MAC_OPERATION_IN_PROGRESS,
 841              		.loc 1 374 0
 842 05ce 1A46     		mov	r2, r3
 843              		.loc 1 375 0
 844 05d0 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 845 05d4 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 846 05d8 1B69     		ldr	r3, [r3, #16]
 374:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printInfo(COMPONENT_IEEE802154E,ERR_MAC_OPERATION_IN_PROGRESS,
 847              		.loc 1 374 0
 848 05da 9BB2     		uxth	r3, r3
 849 05dc 4FF00900 		mov	r0, #9
 850 05e0 4FF04001 		mov	r1, #64
 851 05e4 FFF7FEFF 		bl	openserial_printInfo
 852              	.L75:
 376:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 377:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 853              		.loc 1 377 0
 854 05e8 80BD     		pop	{r7, pc}
 855              		.cfi_endproc
 856              	.LFE5:
 858 05ea 00BF     		.align	2
 859              		.global	isr_ieee154ecsl_addPacketToQueueForTestingCslTx_cb
 860              		.thumb
 861              		.thumb_func
 863              	isr_ieee154ecsl_addPacketToQueueForTestingCslTx_cb:
 864              	.LFB6:
 378:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 379:openstack/02a-MAClow/IEEE802154Ecsl.c **** // test timer interrupt callback to put a new packet on queue for testing CSL TX mode.
 380:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 381:openstack/02a-MAClow/IEEE802154Ecsl.c **** void isr_ieee154ecsl_addPacketToQueueForTestingCslTx_cb () {
 865              		.loc 1 381 0
 866              		.cfi_startproc
 867              		@ args = 0, pretend = 0, frame = 24
 868              		@ frame_needed = 1, uses_anonymous_args = 0
 869 05ec B0B5     		push	{r4, r5, r7, lr}
 870              	.LCFI14:
 871              		.cfi_def_cfa_offset 16
 872              		.cfi_offset 4, -16
 873              		.cfi_offset 5, -12
 874              		.cfi_offset 7, -8
 875              		.cfi_offset 14, -4
 876 05ee 8AB0     		sub	sp, sp, #40
 877              	.LCFI15:
 878              		.cfi_def_cfa_offset 56
 879 05f0 04AF     		add	r7, sp, #16
 880              	.LCFI16:
 881              		.cfi_def_cfa 7, 40
 382:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 383:openstack/02a-MAClow/IEEE802154Ecsl.c ****   OpenQueueEntry_t* pkt;
 384:openstack/02a-MAClow/IEEE802154Ecsl.c ****   open_addr_t neighbor;
 385:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 386:openstack/02a-MAClow/IEEE802154Ecsl.c ****   // Simulate a ficticious address for CSL testing.
 387:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[0]=0x00;
 882              		.loc 1 387 0
 883 05f2 4FF00003 		mov	r3, #0
 884 05f6 7B70     		strb	r3, [r7, #1]
 388:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[1]=0x11;
 885              		.loc 1 388 0
 886 05f8 4FF01103 		mov	r3, #17
 887 05fc BB70     		strb	r3, [r7, #2]
 389:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[2]=0x22;
 888              		.loc 1 389 0
 889 05fe 4FF02203 		mov	r3, #34
 890 0602 FB70     		strb	r3, [r7, #3]
 390:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[3]=0x33;
 891              		.loc 1 390 0
 892 0604 4FF03303 		mov	r3, #51
 893 0608 3B71     		strb	r3, [r7, #4]
 391:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[4]=0x44;
 894              		.loc 1 391 0
 895 060a 4FF04403 		mov	r3, #68
 896 060e 7B71     		strb	r3, [r7, #5]
 392:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[5]=0x55;
 897              		.loc 1 392 0
 898 0610 4FF05503 		mov	r3, #85
 899 0614 BB71     		strb	r3, [r7, #6]
 393:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[6]=0x66;
 900              		.loc 1 393 0
 901 0616 4FF06603 		mov	r3, #102
 902 061a FB71     		strb	r3, [r7, #7]
 394:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.addr_64b[7]=0x77;
 903              		.loc 1 394 0
 904 061c 4FF07703 		mov	r3, #119
 905 0620 3B72     		strb	r3, [r7, #8]
 395:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 396:openstack/02a-MAClow/IEEE802154Ecsl.c ****   neighbor.type=ADDR_64B;
 906              		.loc 1 396 0
 907 0622 4FF00203 		mov	r3, #2
 908 0626 3B70     		strb	r3, [r7, #0]
 397:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 398:openstack/02a-MAClow/IEEE802154Ecsl.c ****   // Switch off all the leds.
 399:openstack/02a-MAClow/IEEE802154Ecsl.c ****   leds_all_off();
 909              		.loc 1 399 0
 910 0628 FFF7FEFF 		bl	leds_all_off
 400:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 401:openstack/02a-MAClow/IEEE802154Ecsl.c ****   // CREATE DATA PACKET ONLY IF NOT ALREADY EXISTS ON QUEUE.
 402:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 403:openstack/02a-MAClow/IEEE802154Ecsl.c ****   if (openqueue_macGetDataPacket(&neighbor) == NULL) {
 911              		.loc 1 403 0
 912 062c 3B46     		mov	r3, r7
 913 062e 1846     		mov	r0, r3
 914 0630 FFF7FEFF 		bl	openqueue_macGetDataPacket
 915 0634 0346     		mov	r3, r0
 916 0636 002B     		cmp	r3, #0
 917 0638 6FD1     		bne	.L78
 404:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 405:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // get freebuffer.
 406:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt = openqueue_getFreePacketBuffer(COMPONENT_IEEE802154E);
 918              		.loc 1 406 0
 919 063a 4FF00900 		mov	r0, #9
 920 063e FFF7FEFF 		bl	openqueue_getFreePacketBuffer
 921 0642 7861     		str	r0, [r7, #20]
 407:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  if(pkt==NULL) {
 922              		.loc 1 407 0
 923 0644 7B69     		ldr	r3, [r7, #20]
 924 0646 002B     		cmp	r3, #0
 925 0648 0CD1     		bne	.L80
 408:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		// registro del error & fin de operaciones.
 409:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		openserial_printError(COMPONENT_IEEE802154E,ERR_NO_FREE_PACKET_BUFFER, (errorparameter_t)0, (erro
 926              		.loc 1 409 0
 927 064a 4FF00900 		mov	r0, #9
 928 064e 4FF02C01 		mov	r1, #44
 929 0652 4FF00002 		mov	r2, #0
 930 0656 4FF00003 		mov	r3, #0
 931 065a FFF7FEFF 		bl	openserial_printError
 410:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		endOps();
 932              		.loc 1 410 0
 933 065e FFF7FEFF 		bl	endOps
 934 0662 5AE0     		b	.L78
 935              	.L80:
 411:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		return;
 412:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  }
 413:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 414:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // Declaración de propiedad sobre el paquete.
 415:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->creator = COMPONENT_SIXTOP_TO_IEEE802154E;
 936              		.loc 1 415 0
 937 0664 7B69     		ldr	r3, [r7, #20]
 938 0666 4FF00A02 		mov	r2, #10
 939 066a 1A70     		strb	r2, [r3, #0]
 416:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->owner   = COMPONENT_SIXTOP_TO_IEEE802154E;
 940              		.loc 1 416 0
 941 066c 7B69     		ldr	r3, [r7, #20]
 942 066e 4FF00A02 		mov	r2, #10
 943 0672 5A70     		strb	r2, [r3, #1]
 417:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 418:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // Frame type (data frame).
 419:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->l2_frameType=IEEE154_TYPE_DATA;
 944              		.loc 1 419 0
 945 0674 7B69     		ldr	r3, [r7, #20]
 946 0676 4FF00102 		mov	r2, #1
 947 067a 83F84920 		strb	r2, [r3, #73]
 420:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 421:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // Flag created only to discriminate and toggle led indicator (only for TESTING)
 422:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->cslFlag=123;
 948              		.loc 1 422 0
 949 067e 7B69     		ldr	r3, [r7, #20]
 950 0680 4FF07B02 		mov	r2, #123
 951 0684 83F8ED20 		strb	r2, [r3, #237]
 423:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 424:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // Neighbor address.
 425:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  memcpy(&(pkt->l2_nextORpreviousHop),&neighbor,sizeof(open_addr_t));
 952              		.loc 1 425 0
 953 0688 7B69     		ldr	r3, [r7, #20]
 954 068a 03F13803 		add	r3, r3, #56
 955 068e 1D46     		mov	r5, r3
 956 0690 3C46     		mov	r4, r7
 957 0692 0FCC     		ldmia	r4!, {r0, r1, r2, r3}
 958 0694 2860     		str	r0, [r5, #0]	@ unaligned
 959 0696 6960     		str	r1, [r5, #4]	@ unaligned
 960 0698 AA60     		str	r2, [r5, #8]	@ unaligned
 961 069a EB60     		str	r3, [r5, #12]	@ unaligned
 962 069c 2378     		ldrb	r3, [r4, #0]
 963 069e 2B74     		strb	r3, [r5, #16]
 426:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 427:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // TX retries
 428:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->l2_retriesLeft = TXRETRIES;
 964              		.loc 1 428 0
 965 06a0 7B69     		ldr	r3, [r7, #20]
 966 06a2 4FF00302 		mov	r2, #3
 967 06a6 83F84B20 		strb	r2, [r3, #75]
 429:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 430:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // record this packet's dsn (for matching the ACK)
 431:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->l2_dsn = ieee154e_vars.cslDSN++;
 968              		.loc 1 431 0
 969 06aa 40F20003 		movw	r3, #:lower16:ieee154e_vars
 970 06ae C0F20003 		movt	r3, #:upper16:ieee154e_vars
 971 06b2 93F84430 		ldrb	r3, [r3, #68]	@ zero_extendqisi2
 972 06b6 7A69     		ldr	r2, [r7, #20]
 973 06b8 1946     		mov	r1, r3
 974 06ba 82F84A10 		strb	r1, [r2, #74]
 975 06be 03F10103 		add	r3, r3, #1
 976 06c2 DAB2     		uxtb	r2, r3
 977 06c4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 978 06c8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 979 06cc 83F84420 		strb	r2, [r3, #68]
 432:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 433:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // this is a new packet which I never attempted to send
 434:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->l2_numTxAttempts = 0;
 980              		.loc 1 434 0
 981 06d0 7B69     		ldr	r3, [r7, #20]
 982 06d2 4FF00002 		mov	r2, #0
 983 06d6 83F84C20 		strb	r2, [r3, #76]
 435:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 436:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // transmit with the default TX power
 437:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  pkt->l1_txPower = TX_POWER;
 984              		.loc 1 437 0
 985 06da 7B69     		ldr	r3, [r7, #20]
 986 06dc 4FF01F02 		mov	r2, #31
 987 06e0 83F86720 		strb	r2, [r3, #103]
 438:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 439:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // add a IEEE802.15.4 header
 440:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  ieee802154_prependHeader(pkt,
 441:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							   pkt->l2_frameType,
 988              		.loc 1 441 0
 989 06e4 7B69     		ldr	r3, [r7, #20]
 440:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  ieee802154_prependHeader(pkt,
 990              		.loc 1 440 0
 991 06e6 93F84930 		ldrb	r3, [r3, #73]	@ zero_extendqisi2
 442:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							   IEEE154_IELIST_NO,
 443:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							   IEEE154_FRAMEVERSION,
 444:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							   IEEE154_SEC_NO_SECURITY,
 445:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							   pkt->l2_dsn,
 992              		.loc 1 445 0
 993 06ea 7A69     		ldr	r2, [r7, #20]
 440:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  ieee802154_prependHeader(pkt,
 994              		.loc 1 440 0
 995 06ec 92F84A10 		ldrb	r1, [r2, #74]	@ zero_extendqisi2
 996 06f0 7A69     		ldr	r2, [r7, #20]
 997 06f2 02F13802 		add	r2, r2, #56
 998 06f6 4FF00000 		mov	r0, #0
 999 06fa 0090     		str	r0, [sp, #0]
 1000 06fc 0191     		str	r1, [sp, #4]
 1001 06fe 0292     		str	r2, [sp, #8]
 1002 0700 7869     		ldr	r0, [r7, #20]
 1003 0702 1946     		mov	r1, r3
 1004 0704 4FF00002 		mov	r2, #0
 1005 0708 4FF00203 		mov	r3, #2
 1006 070c FFF7FEFF 		bl	ieee802154_prependHeader
 446:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							   &(pkt->l2_nextORpreviousHop)
 447:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							   );
 448:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 449:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // reserve space for 2-byte CRC
 450:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  packetfunctions_reserveFooterSize(pkt,2);
 1007              		.loc 1 450 0
 1008 0710 7869     		ldr	r0, [r7, #20]
 1009 0712 4FF00201 		mov	r1, #2
 1010 0716 FFF7FEFF 		bl	packetfunctions_reserveFooterSize
 1011              	.L78:
 451:openstack/02a-MAClow/IEEE802154Ecsl.c ****   }
 452:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 453:openstack/02a-MAClow/IEEE802154Ecsl.c ****   return;
 454:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1012              		.loc 1 454 0
 1013 071a 07F11807 		add	r7, r7, #24
 1014 071e BD46     		mov	sp, r7
 1015 0720 B0BD     		pop	{r4, r5, r7, pc}
 1016              		.cfi_endproc
 1017              	.LFE6:
 1019 0722 00BF     		.align	2
 1020              		.global	activity_csl_wakeup_ti1
 1021              		.thumb
 1022              		.thumb_func
 1024              	activity_csl_wakeup_ti1:
 1025              	.LFB7:
 455:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 456:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 457:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
 458:openstack/02a-MAClow/IEEE802154Ecsl.c **** //========================== CSL TX MODE ===============================
 459:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
 460:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 461:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 462:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [wake-up ti1].
 463:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 464:openstack/02a-MAClow/IEEE802154Ecsl.c ****  This method is invoked in ISR-mode from "isr_ieee154ecsl_txtimer_cb" function when TX Timer is fir
 465:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 466:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 467:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ti1() {
 1026              		.loc 1 467 0
 1027              		.cfi_startproc
 1028              		@ args = 0, pretend = 0, frame = 24
 1029              		@ frame_needed = 1, uses_anonymous_args = 0
 1030 0724 80B5     		push	{r7, lr}
 1031              	.LCFI17:
 1032              		.cfi_def_cfa_offset 8
 1033              		.cfi_offset 7, -8
 1034              		.cfi_offset 14, -4
 1035 0726 86B0     		sub	sp, sp, #24
 1036              	.LCFI18:
 1037              		.cfi_def_cfa_offset 32
 1038 0728 00AF     		add	r7, sp, #0
 1039              	.LCFI19:
 1040              		.cfi_def_cfa_register 7
 468:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   cellType_t  cellType;
 469:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   open_addr_t neighbor;
 470:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 471:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // update CSL Mode to TX in order to avoid problems in FSM.
 472:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   ieee154e_vars.cslMode = CSL_TX_MODE;
 1041              		.loc 1 472 0
 1042 072a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1043 072e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1044 0732 4FF00202 		mov	r2, #2
 1045 0736 83F84520 		strb	r2, [r3, #69]
 473:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 474:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // Las acciones que realizaremos son las siguientes:
 475:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   //  - Avanzar el schedule para posicionar la siguiente posición en éste, el cual marcará la 
 476:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   //  - Verificar el estado actual dentro de la FSM para comprobar que efectivamente nos encontra
 477:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   //  - Si no hay problema en ambos, verificamos el tipo de slot en el schedule y preparamos un p
 478:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   //    destino asociado a dicho slot.
 479:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 480:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // increment ASN (do this first so debug pins are in sync)
 481:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   incrementAsnOffset();
 1046              		.loc 1 481 0
 1047 073a FFF7FEFF 		bl	incrementAsnOffset
 482:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 483:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // wiggle debug pins
 484:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   debugpins_slot_toggle();
 1048              		.loc 1 484 0
 1049 073e FFF7FEFF 		bl	debugpins_slot_toggle
 485:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   if (ieee154e_vars.slotOffset==0) {
 1050              		.loc 1 485 0
 1051 0742 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1052 0746 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1053 074a DB88     		ldrh	r3, [r3, #6]
 1054 074c 002B     		cmp	r3, #0
 1055 074e 01D1     		bne	.L83
 486:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      debugpins_frame_toggle();
 1056              		.loc 1 486 0
 1057 0750 FFF7FEFF 		bl	debugpins_frame_toggle
 1058              	.L83:
 487:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 488:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 489:openstack/02a-MAClow/IEEE802154Ecsl.c ****        // if the previous slot took too long, we will not be in the right state
 490:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   if (ieee154e_vars.state!=S_SLEEP) {
 1059              		.loc 1 490 0
 1060 0754 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1061 0758 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1062 075c 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 1063 075e 002B     		cmp	r3, #0
 1064 0760 14D0     		beq	.L84
 491:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      // log the error
 492:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_STARTSLOT,
 493:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	                            (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_dbg.
 1065              		.loc 1 493 0
 1066 0762 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1067 0766 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1068 076a 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 492:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_STARTSLOT,
 1069              		.loc 1 492 0
 1070 076c 1A46     		mov	r2, r3
 1071              		.loc 1 493 0
 1072 076e 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 1073 0772 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 1074 0776 1B69     		ldr	r3, [r3, #16]
 492:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_STARTSLOT,
 1075              		.loc 1 492 0
 1076 0778 9BB2     		uxth	r3, r3
 1077 077a 4FF00900 		mov	r0, #9
 1078 077e 4FF01E01 		mov	r1, #30
 1079 0782 FFF7FEFF 		bl	openserial_printError
 494:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      // abort
 495:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      endOps();
 1080              		.loc 1 495 0
 1081 0786 FFF7FEFF 		bl	endOps
 1082 078a 51E0     		b	.L82
 1083              	.L84:
 496:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	      return;
 497:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 498:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 499:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // advance the schedule
 500:openstack/02a-MAClow/IEEE802154Ecsl.c ****        schedule_advanceSlot();
 1084              		.loc 1 500 0
 1085 078c FFF7FEFF 		bl	schedule_advanceSlot
 501:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 502:openstack/02a-MAClow/IEEE802154Ecsl.c ****        // stop using serial
 503:openstack/02a-MAClow/IEEE802154Ecsl.c ****        openserial_stop();
 1086              		.loc 1 503 0
 1087 0790 FFF7FEFF 		bl	openserial_stop
 504:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 505:openstack/02a-MAClow/IEEE802154Ecsl.c ****        // check the schedule to see what type of slot this is
 506:openstack/02a-MAClow/IEEE802154Ecsl.c ****        cellType = schedule_getType();
 1088              		.loc 1 506 0
 1089 0794 FFF7FEFF 		bl	schedule_getType
 1090 0798 0346     		mov	r3, r0
 1091 079a FB75     		strb	r3, [r7, #23]
 507:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 508:openstack/02a-MAClow/IEEE802154Ecsl.c ****        // check whether we can send
 509:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   if (schedule_getOkToSend()) {
 1092              		.loc 1 509 0
 1093 079c FFF7FEFF 		bl	schedule_getOkToSend
 1094 07a0 0346     		mov	r3, r0
 1095 07a2 002B     		cmp	r3, #0
 1096 07a4 10D0     		beq	.L86
 510:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       schedule_getNeighbor(&neighbor);
 1097              		.loc 1 510 0
 1098 07a6 07F10403 		add	r3, r7, #4
 1099 07aa 1846     		mov	r0, r3
 1100 07ac FFF7FEFF 		bl	schedule_getNeighbor
 511:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       ieee154e_vars.dataToSend = openqueue_macGetDataPacket(&neighbor);
 1101              		.loc 1 511 0
 1102 07b0 07F10403 		add	r3, r7, #4
 1103 07b4 1846     		mov	r0, r3
 1104 07b6 FFF7FEFF 		bl	openqueue_macGetDataPacket
 1105 07ba 0246     		mov	r2, r0
 1106 07bc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1107 07c0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1108 07c4 5A61     		str	r2, [r3, #20]
 1109 07c6 06E0     		b	.L87
 1110              	.L86:
 512:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   } else {
 513:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       ieee154e_vars.dataToSend = NULL;
 1111              		.loc 1 513 0
 1112 07c8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1113 07cc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1114 07d0 4FF00002 		mov	r2, #0
 1115 07d4 5A61     		str	r2, [r3, #20]
 1116              	.L87:
 514:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 515:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   if((ieee154e_vars.dataToSend!=NULL) && (cellType == CELLTYPE_TX)) {   // If I have a packet to 
 1117              		.loc 1 515 0
 1118 07d6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1119 07da C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1120 07de 5B69     		ldr	r3, [r3, #20]
 1121 07e0 002B     		cmp	r3, #0
 1122 07e2 1DD0     		beq	.L88
 1123              		.loc 1 515 0 is_stmt 0 discriminator 1
 1124 07e4 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 1125 07e6 022B     		cmp	r3, #2
 1126 07e8 1AD1     		bne	.L88
 516:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       // change state to start sending CSL preamble before send the data packet.
 517:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       changeState(S_CSLTXWAKEUPOFFSET);
 1127              		.loc 1 517 0 is_stmt 1
 1128 07ea 4FF01A00 		mov	r0, #26
 1129 07ee FFF7FEFF 		bl	changeState
 518:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 519:openstack/02a-MAClow/IEEE802154Ecsl.c ****            // record that I will attempt to transmit this packet
 520:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       ieee154e_vars.dataToSend->l2_numTxAttempts++;
 1130              		.loc 1 520 0
 1131 07f2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1132 07f6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1133 07fa 5B69     		ldr	r3, [r3, #20]
 1134 07fc 93F84C20 		ldrb	r2, [r3, #76]	@ zero_extendqisi2
 1135 0800 02F10102 		add	r2, r2, #1
 1136 0804 D2B2     		uxtb	r2, r2
 1137 0806 83F84C20 		strb	r2, [r3, #76]
 521:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 522:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       // arm tt1
 523:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       radiotimer_schedule(DURATION_tt1);
 1138              		.loc 1 523 0
 1139 080a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1140 080e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1141 0812 5B6A     		ldr	r3, [r3, #36]
 1142 0814 03F13A03 		add	r3, r3, #58
 1143 0818 1846     		mov	r0, r3
 1144 081a FFF7FEFF 		bl	radiotimer_schedule
 1145 081e 07E0     		b	.L82
 1146              	.L88:
 524:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   } else {
 525:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	       // abort because slot is not TX or there is no data to send, so we reset TX Mode state
 526:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   ieee154e_vars.cslMode = CSL_SLEEP_MODE;
 1147              		.loc 1 526 0
 1148 0820 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1149 0824 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1150 0828 4FF00002 		mov	r2, #0
 1151 082c 83F84520 		strb	r2, [r3, #69]
 1152              	.L82:
 527:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 528:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1153              		.loc 1 528 0
 1154 0830 07F11807 		add	r7, r7, #24
 1155 0834 BD46     		mov	sp, r7
 1156 0836 80BD     		pop	{r7, pc}
 1157              		.cfi_endproc
 1158              	.LFE7:
 1160              		.align	2
 1161              		.global	activity_csl_wakeup_ti2
 1162              		.thumb
 1163              		.thumb_func
 1165              	activity_csl_wakeup_ti2:
 1166              	.LFB8:
 529:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 530:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 531:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 532:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [wake-up ti2].
 533:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 534:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 535:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to prepare the radio for sending packets.
 536:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 537:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ti2() {
 1167              		.loc 1 537 0
 1168              		.cfi_startproc
 1169              		@ args = 0, pretend = 0, frame = 24
 1170              		@ frame_needed = 1, uses_anonymous_args = 0
 1171 0838 80B5     		push	{r7, lr}
 1172              	.LCFI20:
 1173              		.cfi_def_cfa_offset 8
 1174              		.cfi_offset 7, -8
 1175              		.cfi_offset 14, -4
 1176 083a 86B0     		sub	sp, sp, #24
 1177              	.LCFI21:
 1178              		.cfi_def_cfa_offset 32
 1179 083c 00AF     		add	r7, sp, #0
 1180              	.LCFI22:
 1181              		.cfi_def_cfa_register 7
 538:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 539:openstack/02a-MAClow/IEEE802154Ecsl.c ****    open_addr_t neighbor;
 540:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 541:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // El tiempo de rendezvous que será necesario esperar será macCSLMaxPeriod al tratarse de
 542:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // una comunicación en modo TX no sincronizado.
 543:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 544:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Calculamos el valor del rz-time en cada trama wake-up de la secuencia dado que debe ir reduci
 545:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // al extemo remoto el tiempo restante hasta el envío de la trama de datos.
 546:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 547:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // El tiempo lastCapturedTime se ve incrementado tras el envio de cada trama wake-up por lo que 
 548:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // valor más proximo al macCSLMaxPeriod.
 549:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 550:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.remainingRzTime = macCSLMaxPeriod - ieee154e_vars.lastCapturedTime;
 1182              		.loc 1 550 0
 1183 083e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1184 0842 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1185 0846 5B6A     		ldr	r3, [r3, #36]
 1186 0848 9BB2     		uxth	r3, r3
 1187 084a C3F5CC53 		rsb	r3, r3, #6528
 1188 084e 03F11A03 		add	r3, r3, #26
 1189 0852 9AB2     		uxth	r2, r3
 1190 0854 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1191 0858 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1192 085c A3F84820 		strh	r2, [r3, #72]	@ movhi
 551:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 552:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (MaxWakeUpTxTime < ieee154e_vars.remainingRzTime) { // Si da tiempo a enviar una nueva trama 
 1193              		.loc 1 552 0
 1194 0860 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1195 0864 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1196 0868 B3F84820 		ldrh	r2, [r3, #72]
 1197 086c 40F24113 		movw	r3, #321
 1198 0870 9A42     		cmp	r2, r3
 1199 0872 40F2CB80 		bls	.L91
 553:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 554:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // change state
 555:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   changeState(S_CSLTXWAKEUPPREPARE);
 1200              		.loc 1 555 0
 1201 0876 4FF01B00 		mov	r0, #27
 1202 087a FFF7FEFF 		bl	changeState
 556:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 557:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   //
 558:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // Construimos el paquete Wake-Up con su valor RZTime asociado en caso de no existir ya.
 559:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   //
 560:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 561:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   if (ieee154e_vars.wakeupToSend == NULL) { // first time
 1203              		.loc 1 561 0
 1204 087e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1205 0882 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1206 0886 DB6B     		ldr	r3, [r3, #60]
 1207 0888 002B     		cmp	r3, #0
 1208 088a 7FD1     		bne	.L92
 562:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 563:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // obtenemos un buffer en el cual poder guardar los datos recibidos.
 564:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   ieee154e_vars.wakeupToSend = openqueue_getFreePacketBuffer(COMPONENT_IEEE802154E);
 1209              		.loc 1 564 0
 1210 088c 4FF00900 		mov	r0, #9
 1211 0890 FFF7FEFF 		bl	openqueue_getFreePacketBuffer
 1212 0894 0246     		mov	r2, r0
 1213 0896 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1214 089a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1215 089e DA63     		str	r2, [r3, #60]
 565:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   if (ieee154e_vars.wakeupToSend == NULL) {
 1216              		.loc 1 565 0
 1217 08a0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1218 08a4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1219 08a8 DB6B     		ldr	r3, [r3, #60]
 1220 08aa 002B     		cmp	r3, #0
 1221 08ac 0CD1     		bne	.L93
 566:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			  // registro del error & fin de operaciones.
 567:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			  openserial_printError(COMPONENT_IEEE802154E,ERR_NO_FREE_PACKET_BUFFER, (errorparameter_t)0, (e
 1222              		.loc 1 567 0
 1223 08ae 4FF00900 		mov	r0, #9
 1224 08b2 4FF02C01 		mov	r1, #44
 1225 08b6 4FF00002 		mov	r2, #0
 1226 08ba 4FF00003 		mov	r3, #0
 1227 08be FFF7FEFF 		bl	openserial_printError
 568:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			  endOps();
 1228              		.loc 1 568 0
 1229 08c2 FFF7FEFF 		bl	endOps
 1230 08c6 AEE0     		b	.L90
 1231              	.L93:
 569:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			  return;
 570:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   }
 571:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 572:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // Declaración de propiedad sobre el paquete.
 573:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   ieee154e_vars.wakeupToSend->creator = COMPONENT_IEEE802154E;
 1232              		.loc 1 573 0
 1233 08c8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1234 08cc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1235 08d0 DB6B     		ldr	r3, [r3, #60]
 1236 08d2 4FF00902 		mov	r2, #9
 1237 08d6 1A70     		strb	r2, [r3, #0]
 574:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   ieee154e_vars.wakeupToSend->owner   = COMPONENT_IEEE802154E;
 1238              		.loc 1 574 0
 1239 08d8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1240 08dc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1241 08e0 DB6B     		ldr	r3, [r3, #60]
 1242 08e2 4FF00902 		mov	r2, #9
 1243 08e6 5A70     		strb	r2, [r3, #1]
 575:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 576:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // El tipo de trama es Multipurpose.
 577:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   ieee154e_vars.wakeupToSend->l2_frameType = IEEE154_TYPE_MULTIPURPOSE;
 1244              		.loc 1 577 0
 1245 08e8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1246 08ec C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1247 08f0 DB6B     		ldr	r3, [r3, #60]
 1248 08f2 4FF00502 		mov	r2, #5
 1249 08f6 83F84920 		strb	r2, [r3, #73]
 578:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 579:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // El dsn del paquete lo obtenemos a partir del actual DSN incrementado en cada paquete de la 
 580:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   ieee154e_vars.wakeupToSend->l2_dsn = ieee154e_vars.cslDSN++;
 1250              		.loc 1 580 0
 1251 08fa 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1252 08fe C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1253 0902 DA6B     		ldr	r2, [r3, #60]
 1254 0904 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1255 0908 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1256 090c 93F84430 		ldrb	r3, [r3, #68]	@ zero_extendqisi2
 1257 0910 1946     		mov	r1, r3
 1258 0912 82F84A10 		strb	r1, [r2, #74]
 1259 0916 03F10103 		add	r3, r3, #1
 1260 091a DAB2     		uxtb	r2, r3
 1261 091c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1262 0920 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1263 0924 83F84420 		strb	r2, [r3, #68]
 581:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 582:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // El destinatario es el mismo que el destinatario del mensaje de datos indicado en el schedul
 583:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   schedule_getNeighbor(&neighbor);
 1264              		.loc 1 583 0
 1265 0928 07F10403 		add	r3, r7, #4
 1266 092c 1846     		mov	r0, r3
 1267 092e FFF7FEFF 		bl	schedule_getNeighbor
 584:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 585:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // Verificamos que se trata de una dirección corta (short address). En caso contrario generam
 586:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   if(neighbor.type != ADDR_16B) {
 1268              		.loc 1 586 0
 1269 0932 3B79     		ldrb	r3, [r7, #4]	@ zero_extendqisi2
 1270 0934 012B     		cmp	r3, #1
 1271 0936 08D0     		beq	.L95
 587:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			   // CSL: This is an invalid address because address in wake-up frame must be short address.
 588:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			   // We do not finish operations but we will use later short address getting it from long addre
 589:openstack/02a-MAClow/IEEE802154Ecsl.c **** 			   openserial_printInfo(COMPONENT_IEEE802154,ERR_IEEE154_UNSUPPORTED, (errorparameter_t)1, (erro
 1272              		.loc 1 589 0
 1273 0938 3B79     		ldrb	r3, [r7, #4]	@ zero_extendqisi2
 1274 093a 4FF00800 		mov	r0, #8
 1275 093e 4FF01901 		mov	r1, #25
 1276 0942 4FF00102 		mov	r2, #1
 1277 0946 FFF7FEFF 		bl	openserial_printInfo
 1278              	.L95:
 590:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   }
 591:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 592:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // create frame header.
 593:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   ieee802154_createWakeUpFrame(ieee154e_vars.wakeupToSend,
 1279              		.loc 1 593 0
 1280 094a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1281 094e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1282 0952 D86B     		ldr	r0, [r3, #60]
 594:openstack/02a-MAClow/IEEE802154Ecsl.c **** 										ieee154e_vars.wakeupToSend->l2_dsn,
 1283              		.loc 1 594 0
 1284 0954 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1285 0958 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1286 095c DB6B     		ldr	r3, [r3, #60]
 593:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   ieee802154_createWakeUpFrame(ieee154e_vars.wakeupToSend,
 1287              		.loc 1 593 0
 1288 095e 93F84A10 		ldrb	r1, [r3, #74]	@ zero_extendqisi2
 1289 0962 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1290 0966 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1291 096a B3F84830 		ldrh	r3, [r3, #72]
 1292 096e 07F10402 		add	r2, r7, #4
 1293 0972 FFF7FEFF 		bl	ieee802154_createWakeUpFrame
 595:openstack/02a-MAClow/IEEE802154Ecsl.c **** 										&neighbor,
 596:openstack/02a-MAClow/IEEE802154Ecsl.c **** 										ieee154e_vars.remainingRzTime);
 597:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 598:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // space for 2-byte CRC
 599:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   packetfunctions_reserveFooterSize(ieee154e_vars.wakeupToSend,2);
 1294              		.loc 1 599 0
 1295 0976 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1296 097a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1297 097e DB6B     		ldr	r3, [r3, #60]
 1298 0980 1846     		mov	r0, r3
 1299 0982 4FF00201 		mov	r1, #2
 1300 0986 FFF7FEFF 		bl	packetfunctions_reserveFooterSize
 1301 098a 0EE0     		b	.L96
 1302              	.L92:
 600:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 601:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   else {
 602:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // update rztime in header.
 603:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // Se posiciona 8 posiciones antes dado que estamos escribiendo el paquete de atras hacia dela
 604:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // - 1 byte FCF
 605:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // - 1 byte SEQ
 606:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // - 2 bytes PANID
 607:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // - 2 bytes DEST ADDR
 608:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // - 2 bytes RZTIME IE HEADER
 609:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   // - 2 bytes RZTIME (el cual se sobrescribirá con el nuevo valor).
 610:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		   *((uint16_t*)(ieee154e_vars.wakeupToSend->payload+8)) = ieee154e_vars.remainingRzTime;
 1303              		.loc 1 610 0
 1304 098c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1305 0990 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1306 0994 DB6B     		ldr	r3, [r3, #60]
 1307 0996 5B68     		ldr	r3, [r3, #4]
 1308 0998 03F10802 		add	r2, r3, #8
 1309 099c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1310 09a0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1311 09a4 B3F84830 		ldrh	r3, [r3, #72]
 1312 09a8 1380     		strh	r3, [r2, #0]	@ movhi
 1313              	.L96:
 611:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
 612:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 613:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // load the packet in the radio's Tx buffer
 614:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   radio_loadPacket(ieee154e_vars.wakeupToSend->payload, ieee154e_vars.wakeupToSend->length);
 1314              		.loc 1 614 0
 1315 09aa 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1316 09ae C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1317 09b2 DB6B     		ldr	r3, [r3, #60]
 1318 09b4 5A68     		ldr	r2, [r3, #4]
 1319 09b6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1320 09ba C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1321 09be DB6B     		ldr	r3, [r3, #60]
 1322 09c0 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 1323 09c2 1046     		mov	r0, r2
 1324 09c4 1946     		mov	r1, r3
 1325 09c6 FFF7FEFF 		bl	radio_loadPacket
 615:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 616:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // enable the radio in Tx mode. This does not send the packet.
 617:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   radio_txEnable();
 1326              		.loc 1 617 0
 1327 09ca FFF7FEFF 		bl	radio_txEnable
 618:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   ieee154e_vars.radioOnInit=radio_getTimerValue();
 1328              		.loc 1 618 0
 1329 09ce FFF7FEFF 		bl	radio_getTimerValue
 1330 09d2 0246     		mov	r2, r0
 1331 09d4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1332 09d8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1333 09dc 1A63     		str	r2, [r3, #48]
 619:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   ieee154e_vars.radioOnThisSlot=TRUE;
 1334              		.loc 1 619 0
 1335 09de 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1336 09e2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1337 09e6 4FF00102 		mov	r2, #1
 1338 09ea 83F83820 		strb	r2, [r3, #56]
 620:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 621:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // arm tt2
 622:openstack/02a-MAClow/IEEE802154Ecsl.c ****        radiotimer_schedule(DURATION_tt2);
 1339              		.loc 1 622 0
 1340 09ee 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1341 09f2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1342 09f6 5B6A     		ldr	r3, [r3, #36]
 1343 09f8 03F17C03 		add	r3, r3, #124
 1344 09fc 1846     		mov	r0, r3
 1345 09fe FFF7FEFF 		bl	radiotimer_schedule
 623:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 624:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // change state
 625:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   changeState(S_CSLTXWAKEUPREADY);
 1346              		.loc 1 625 0
 1347 0a02 4FF01C00 		mov	r0, #28
 1348 0a06 FFF7FEFF 		bl	changeState
 1349 0a0a 0CE0     		b	.L90
 1350              	.L91:
 626:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 627:openstack/02a-MAClow/IEEE802154Ecsl.c ****    else {
 628:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // Si no da tiempo a enviar una nueva trama, simplemente esperamos un tiempo igual a remainingR
 629:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // el tiempo que queda pendiente hasta el envío de la trama de datos y actualizamos directamen
 630:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // pasar a la transmisión de los datos, a través del estado CSLTXDATAPREOFFSET.
 631:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 632:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // change state
 633:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   changeState(S_CSLTXDATAPREOFFSET);
 1351              		.loc 1 633 0
 1352 0a0c 4FF01F00 		mov	r0, #31
 1353 0a10 FFF7FEFF 		bl	changeState
 634:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 635:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // arm remaining rendezvous time.
 636:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   radiotimer_schedule(ieee154e_vars.remainingRzTime);
 1354              		.loc 1 636 0
 1355 0a14 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1356 0a18 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1357 0a1c B3F84830 		ldrh	r3, [r3, #72]
 1358 0a20 1846     		mov	r0, r3
 1359 0a22 FFF7FEFF 		bl	radiotimer_schedule
 1360              	.L90:
 637:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 638:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1361              		.loc 1 638 0
 1362 0a26 07F11807 		add	r7, r7, #24
 1363 0a2a BD46     		mov	sp, r7
 1364 0a2c 80BD     		pop	{r7, pc}
 1365              		.cfi_endproc
 1366              	.LFE8:
 1368 0a2e 00BF     		.align	2
 1369              		.global	activity_csl_wakeup_tie1
 1370              		.thumb
 1371              		.thumb_func
 1373              	activity_csl_wakeup_tie1:
 1374              	.LFB9:
 639:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 640:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 641:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [wake-up tie1].
 642:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 643:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #tt2 expiring, i.e. timer fires while state = S_CSLTXWAKEUPPREPARE. This is 
 644:openstack/02a-MAClow/IEEE802154Ecsl.c ****   did not have enough time to execute. Chances are to set maxTxDataPrepare too small. The implement
 645:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 646:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_tie1() {
 1375              		.loc 1 646 0
 1376              		.cfi_startproc
 1377              		@ args = 0, pretend = 0, frame = 0
 1378              		@ frame_needed = 1, uses_anonymous_args = 0
 1379 0a30 80B5     		push	{r7, lr}
 1380              	.LCFI23:
 1381              		.cfi_def_cfa_offset 8
 1382              		.cfi_offset 7, -8
 1383              		.cfi_offset 14, -4
 1384 0a32 00AF     		add	r7, sp, #0
 1385              	.LCFI24:
 1386              		.cfi_def_cfa_register 7
 647:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
 648:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXDATAPREPARE_OVERFLOW,
 649:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_vars.slo
 1387              		.loc 1 649 0
 1388 0a34 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1389 0a38 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1390 0a3c 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 648:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXDATAPREPARE_OVERFLOW,
 1391              		.loc 1 648 0
 1392 0a3e 1A46     		mov	r2, r3
 1393 0a40 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1394 0a44 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1395 0a48 DB88     		ldrh	r3, [r3, #6]
 1396 0a4a 4FF00900 		mov	r0, #9
 1397 0a4e 4FF02201 		mov	r1, #34
 1398 0a52 FFF7FEFF 		bl	openserial_printError
 650:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 651:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
 652:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 1399              		.loc 1 652 0
 1400 0a56 FFF7FEFF 		bl	endOps
 653:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1401              		.loc 1 653 0
 1402 0a5a 80BD     		pop	{r7, pc}
 1403              		.cfi_endproc
 1404              	.LFE9:
 1406              		.align	2
 1407              		.global	activity_csl_wakeup_ti3
 1408              		.thumb
 1409              		.thumb_func
 1411              	activity_csl_wakeup_ti3:
 1412              	.LFB10:
 654:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 655:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 656:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [wake-up ti3].
 657:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 658:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 659:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The radio is configured and this interrupt gives it the "go" signal to start listening.
 660:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 661:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 662:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ti3() {
 1413              		.loc 1 662 0
 1414              		.cfi_startproc
 1415              		@ args = 0, pretend = 0, frame = 0
 1416              		@ frame_needed = 1, uses_anonymous_args = 0
 1417 0a5c 80B5     		push	{r7, lr}
 1418              	.LCFI25:
 1419              		.cfi_def_cfa_offset 8
 1420              		.cfi_offset 7, -8
 1421              		.cfi_offset 14, -4
 1422 0a5e 00AF     		add	r7, sp, #0
 1423              	.LCFI26:
 1424              		.cfi_def_cfa_register 7
 663:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 664:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXWAKEUPDELAY);
 1425              		.loc 1 664 0
 1426 0a60 4FF01D00 		mov	r0, #29
 1427 0a64 FFF7FEFF 		bl	changeState
 665:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 666:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt3
 667:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt3);
 1428              		.loc 1 667 0
 1429 0a68 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1430 0a6c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1431 0a70 5B6A     		ldr	r3, [r3, #36]
 1432 0a72 03F19D03 		add	r3, r3, #157
 1433 0a76 1846     		mov	r0, r3
 1434 0a78 FFF7FEFF 		bl	radiotimer_schedule
 668:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 669:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // give the 'go' to transmit
 670:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_txNow();
 1435              		.loc 1 670 0
 1436 0a7c FFF7FEFF 		bl	radio_txNow
 671:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1437              		.loc 1 671 0
 1438 0a80 80BD     		pop	{r7, pc}
 1439              		.cfi_endproc
 1440              	.LFE10:
 1442 0a82 00BF     		.align	2
 1443              		.global	activity_csl_wakeup_tie2
 1444              		.thumb
 1445              		.thumb_func
 1447              	activity_csl_wakeup_tie2:
 1448              	.LFB11:
 672:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 673:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 674:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [wakeup tie2].
 675:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 676:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #tt3 expiring, i.e. timer fires while state = S_CSLTXWAKEUPDELAY. If no pack
 677:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 678:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_tie2() {
 1449              		.loc 1 678 0
 1450              		.cfi_startproc
 1451              		@ args = 0, pretend = 0, frame = 0
 1452              		@ frame_needed = 1, uses_anonymous_args = 0
 1453 0a84 80B5     		push	{r7, lr}
 1454              	.LCFI27:
 1455              		.cfi_def_cfa_offset 8
 1456              		.cfi_offset 7, -8
 1457              		.cfi_offset 14, -4
 1458 0a86 00AF     		add	r7, sp, #0
 1459              	.LCFI28:
 1460              		.cfi_def_cfa_register 7
 679:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
 680:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIO_OVERFLOWS,
 681:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_vars.slo
 1461              		.loc 1 681 0
 1462 0a88 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1463 0a8c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1464 0a90 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 680:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIO_OVERFLOWS,
 1465              		.loc 1 680 0
 1466 0a92 1A46     		mov	r2, r3
 1467 0a94 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1468 0a98 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1469 0a9c DB88     		ldrh	r3, [r3, #6]
 1470 0a9e 4FF00900 		mov	r0, #9
 1471 0aa2 4FF02701 		mov	r1, #39
 1472 0aa6 FFF7FEFF 		bl	openserial_printError
 682:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
 683:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 1473              		.loc 1 683 0
 1474 0aaa FFF7FEFF 		bl	endOps
 684:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1475              		.loc 1 684 0
 1476 0aae 80BD     		pop	{r7, pc}
 1477              		.cfi_endproc
 1478              	.LFE11:
 1480              		.align	2
 1481              		.global	activity_csl_wakeup_ti4
 1482              		.thumb
 1483              		.thumb_func
 1485              	activity_csl_wakeup_ti4:
 1486              	.LFB12:
 685:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 686:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 687:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [wake-up ti4].
 688:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 689:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_startOfFrame" function when a start of frame ev
 690:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to capture the time, cancel #tt3 and arm #tt4 (max time to send all the pack
 691:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 692:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ti4(PORT_RADIOTIMER_WIDTH capturedTime) {
 1487              		.loc 1 692 0
 1488              		.cfi_startproc
 1489              		@ args = 0, pretend = 0, frame = 8
 1490              		@ frame_needed = 1, uses_anonymous_args = 0
 1491 0ab0 80B5     		push	{r7, lr}
 1492              	.LCFI29:
 1493              		.cfi_def_cfa_offset 8
 1494              		.cfi_offset 7, -8
 1495              		.cfi_offset 14, -4
 1496 0ab2 82B0     		sub	sp, sp, #8
 1497              	.LCFI30:
 1498              		.cfi_def_cfa_offset 16
 1499 0ab4 00AF     		add	r7, sp, #0
 1500              	.LCFI31:
 1501              		.cfi_def_cfa_register 7
 1502 0ab6 7860     		str	r0, [r7, #4]
 693:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 694:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel tt3
 695:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 1503              		.loc 1 695 0
 1504 0ab8 FFF7FEFF 		bl	radiotimer_cancel
 696:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 697:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
 698:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.lastCapturedTime = capturedTime;
 1505              		.loc 1 698 0
 1506 0abc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1507 0ac0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1508 0ac4 7A68     		ldr	r2, [r7, #4]
 1509 0ac6 5A62     		str	r2, [r3, #36]
 699:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 700:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 701:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXWAKEUP);
 1510              		.loc 1 701 0
 1511 0ac8 4FF01E00 		mov	r0, #30
 1512 0acc FFF7FEFF 		bl	changeState
 702:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 703:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt4
 704:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt4);
 1513              		.loc 1 704 0
 1514 0ad0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1515 0ad4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1516 0ad8 5B6A     		ldr	r3, [r3, #36]
 1517 0ada 03F1A403 		add	r3, r3, #164
 1518 0ade 1846     		mov	r0, r3
 1519 0ae0 FFF7FEFF 		bl	radiotimer_schedule
 705:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1520              		.loc 1 705 0
 1521 0ae4 07F10807 		add	r7, r7, #8
 1522 0ae8 BD46     		mov	sp, r7
 1523 0aea 80BD     		pop	{r7, pc}
 1524              		.cfi_endproc
 1525              	.LFE12:
 1527              		.align	2
 1528              		.global	activity_csl_wakeup_tie3
 1529              		.thumb
 1530              		.thumb_func
 1532              	activity_csl_wakeup_tie3:
 1533              	.LFB13:
 706:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 707:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 708:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [wake-up tie3].
 709:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 710:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #tt4 expiring, i.e. timer fires while state = S_CSLTXWAKEUP. This is an erro
 711:openstack/02a-MAClow/IEEE802154Ecsl.c ****   took too long to transmit the data packet. The implemented behaviour is to log the error and fini
 712:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 713:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_tie3() {
 1534              		.loc 1 713 0
 1535              		.cfi_startproc
 1536              		@ args = 0, pretend = 0, frame = 0
 1537              		@ frame_needed = 1, uses_anonymous_args = 0
 1538 0aec 80B5     		push	{r7, lr}
 1539              	.LCFI32:
 1540              		.cfi_def_cfa_offset 8
 1541              		.cfi_offset 7, -8
 1542              		.cfi_offset 14, -4
 1543 0aee 00AF     		add	r7, sp, #0
 1544              	.LCFI33:
 1545              		.cfi_def_cfa_register 7
 714:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
 715:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
 716:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_vars.slo
 1546              		.loc 1 716 0
 1547 0af0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1548 0af4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1549 0af8 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 715:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
 1550              		.loc 1 715 0
 1551 0afa 1A46     		mov	r2, r3
 1552 0afc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1553 0b00 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1554 0b04 DB88     		ldrh	r3, [r3, #6]
 1555 0b06 4FF00900 		mov	r0, #9
 1556 0b0a 4FF02601 		mov	r1, #38
 1557 0b0e FFF7FEFF 		bl	openserial_printError
 717:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
 718:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 1558              		.loc 1 718 0
 1559 0b12 FFF7FEFF 		bl	endOps
 719:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1560              		.loc 1 719 0
 1561 0b16 80BD     		pop	{r7, pc}
 1562              		.cfi_endproc
 1563              	.LFE13:
 1565              		.align	2
 1566              		.global	activity_csl_wakeup_ti5
 1567              		.thumb
 1568              		.thumb_func
 1570              	activity_csl_wakeup_ti5:
 1571              	.LFB14:
 720:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 721:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 722:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 723:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [wake-up ri5].
 724:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 725:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_endOfFrame" function when a end of frame event 
 726:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change state, cancel #rt4, and start sending data frame and wait for ACK.
 727:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 728:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ti5(PORT_RADIOTIMER_WIDTH capturedTime) {
 1572              		.loc 1 728 0
 1573              		.cfi_startproc
 1574              		@ args = 0, pretend = 0, frame = 8
 1575              		@ frame_needed = 1, uses_anonymous_args = 0
 1576 0b18 80B5     		push	{r7, lr}
 1577              	.LCFI34:
 1578              		.cfi_def_cfa_offset 8
 1579              		.cfi_offset 7, -8
 1580              		.cfi_offset 14, -4
 1581 0b1a 82B0     		sub	sp, sp, #8
 1582              	.LCFI35:
 1583              		.cfi_def_cfa_offset 16
 1584 0b1c 00AF     		add	r7, sp, #0
 1585              	.LCFI36:
 1586              		.cfi_def_cfa_register 7
 1587 0b1e 7860     		str	r0, [r7, #4]
 729:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 730:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// record the captured time
 731:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	ieee154e_vars.lastCapturedTime = capturedTime;
 1588              		.loc 1 731 0
 1589 0b20 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1590 0b24 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1591 0b28 7A68     		ldr	r2, [r7, #4]
 1592 0b2a 5A62     		str	r2, [r3, #36]
 732:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 733:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// Mientras el tiempo capturado en el envío de la ultima trama wake-up de la trama wake-up sequen
 734:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// sea inferior al tiempo de la duración del rztime inicial, debemos seguir enviando tramas wake-
 735:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// En caso contrario, enviamos la trama de datos.
 736:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 737:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//if((macCSLMaxPeriod - ieee154e_vars.lastCapturedTime) < ieee154e_vars.remainingRzTime) {
 738:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//	changeState(S_CSLTXWAKEUPOFFSET);
 739:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//}
 740:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//else {
 741:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //   changeState(S_CSLTXDATAOFFSET);
 742:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //}
 743:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 744:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	changeState(S_CSLTXWAKEUPOFFSET);
 1593              		.loc 1 744 0
 1594 0b2c 4FF01A00 		mov	r0, #26
 1595 0b30 FFF7FEFF 		bl	changeState
 745:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 746:openstack/02a-MAClow/IEEE802154Ecsl.c ****     // arm tt1 (enviemos de nuevo una trama de wake-up o de datos, el tiempo será tt1).
 747:openstack/02a-MAClow/IEEE802154Ecsl.c ****     radiotimer_schedule(DURATION_tt1);
 1596              		.loc 1 747 0
 1597 0b34 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1598 0b38 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1599 0b3c 5B6A     		ldr	r3, [r3, #36]
 1600 0b3e 03F13A03 		add	r3, r3, #58
 1601 0b42 1846     		mov	r0, r3
 1602 0b44 FFF7FEFF 		bl	radiotimer_schedule
 748:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1603              		.loc 1 748 0
 1604 0b48 07F10807 		add	r7, r7, #8
 1605 0b4c BD46     		mov	sp, r7
 1606 0b4e 80BD     		pop	{r7, pc}
 1607              		.cfi_endproc
 1608              	.LFE14:
 1610              		.align	2
 1611              		.global	activity_csl_data_ti1
 1612              		.thumb
 1613              		.thumb_func
 1615              	activity_csl_data_ti1:
 1616              	.LFB15:
 749:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 750:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 751:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti1].
 752:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 753:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires after 
 754:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to prepare the data to be sent.
 755:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 756:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 757:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti1() {
 1617              		.loc 1 757 0
 1618              		.cfi_startproc
 1619              		@ args = 0, pretend = 0, frame = 0
 1620              		@ frame_needed = 1, uses_anonymous_args = 0
 1621 0b50 80B5     		push	{r7, lr}
 1622              	.LCFI37:
 1623              		.cfi_def_cfa_offset 8
 1624              		.cfi_offset 7, -8
 1625              		.cfi_offset 14, -4
 1626 0b52 00AF     		add	r7, sp, #0
 1627              	.LCFI38:
 1628              		.cfi_def_cfa_register 7
 758:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 759:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// change state
 760:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	changeState(S_CSLTXDATAOFFSET);
 1629              		.loc 1 760 0
 1630 0b54 4FF02000 		mov	r0, #32
 1631 0b58 FFF7FEFF 		bl	changeState
 761:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 762:openstack/02a-MAClow/IEEE802154Ecsl.c ****     // arm tt1 (enviemos de nuevo una trama de wake-up o de datos, el tiempo será tt1).
 763:openstack/02a-MAClow/IEEE802154Ecsl.c ****     radiotimer_schedule(DURATION_tt1);
 1632              		.loc 1 763 0
 1633 0b5c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1634 0b60 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1635 0b64 5B6A     		ldr	r3, [r3, #36]
 1636 0b66 03F13A03 		add	r3, r3, #58
 1637 0b6a 1846     		mov	r0, r3
 1638 0b6c FFF7FEFF 		bl	radiotimer_schedule
 764:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1639              		.loc 1 764 0
 1640 0b70 80BD     		pop	{r7, pc}
 1641              		.cfi_endproc
 1642              	.LFE15:
 1644 0b72 00BF     		.align	2
 1645              		.global	activity_csl_data_ti2
 1646              		.thumb
 1647              		.thumb_func
 1649              	activity_csl_data_ti2:
 1650              	.LFB16:
 765:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 766:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 767:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 768:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 769:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti2].
 770:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 771:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 772:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to prepare the radio for sending packets.
 773:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 774:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti2() {
 1651              		.loc 1 774 0
 1652              		.cfi_startproc
 1653              		@ args = 0, pretend = 0, frame = 0
 1654              		@ frame_needed = 1, uses_anonymous_args = 0
 1655 0b74 80B5     		push	{r7, lr}
 1656              	.LCFI39:
 1657              		.cfi_def_cfa_offset 8
 1658              		.cfi_offset 7, -8
 1659              		.cfi_offset 14, -4
 1660 0b76 00AF     		add	r7, sp, #0
 1661              	.LCFI40:
 1662              		.cfi_def_cfa_register 7
 775:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 776:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXDATAPREPARE);
 1663              		.loc 1 776 0
 1664 0b78 4FF02100 		mov	r0, #33
 1665 0b7c FFF7FEFF 		bl	changeState
 777:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 778:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // load the packet in the radio's Tx buffer
 779:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_loadPacket(ieee154e_vars.dataToSend->payload,
 1666              		.loc 1 779 0
 1667 0b80 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1668 0b84 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1669 0b88 5B69     		ldr	r3, [r3, #20]
 1670 0b8a 5A68     		ldr	r2, [r3, #4]
 780:openstack/02a-MAClow/IEEE802154Ecsl.c ****                     ieee154e_vars.dataToSend->length);
 1671              		.loc 1 780 0
 1672 0b8c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1673 0b90 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1674 0b94 5B69     		ldr	r3, [r3, #20]
 779:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_loadPacket(ieee154e_vars.dataToSend->payload,
 1675              		.loc 1 779 0
 1676 0b96 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 1677 0b98 1046     		mov	r0, r2
 1678 0b9a 1946     		mov	r1, r3
 1679 0b9c FFF7FEFF 		bl	radio_loadPacket
 781:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 782:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // enable the radio in Tx mode. This does not send the packet.
 783:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_txEnable();
 1680              		.loc 1 783 0
 1681 0ba0 FFF7FEFF 		bl	radio_txEnable
 784:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnInit=radio_getTimerValue();
 1682              		.loc 1 784 0
 1683 0ba4 FFF7FEFF 		bl	radio_getTimerValue
 1684 0ba8 0246     		mov	r2, r0
 1685 0baa 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1686 0bae C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1687 0bb2 1A63     		str	r2, [r3, #48]
 785:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnThisSlot=TRUE;
 1688              		.loc 1 785 0
 1689 0bb4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1690 0bb8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1691 0bbc 4FF00102 		mov	r2, #1
 1692 0bc0 83F83820 		strb	r2, [r3, #56]
 786:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 787:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt2
 788:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt2);
 1693              		.loc 1 788 0
 1694 0bc4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1695 0bc8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1696 0bcc 5B6A     		ldr	r3, [r3, #36]
 1697 0bce 03F17C03 		add	r3, r3, #124
 1698 0bd2 1846     		mov	r0, r3
 1699 0bd4 FFF7FEFF 		bl	radiotimer_schedule
 789:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 790:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 791:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXDATAREADY);
 1700              		.loc 1 791 0
 1701 0bd8 4FF02200 		mov	r0, #34
 1702 0bdc FFF7FEFF 		bl	changeState
 792:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 793:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1703              		.loc 1 793 0
 1704 0be0 80BD     		pop	{r7, pc}
 1705              		.cfi_endproc
 1706              	.LFE16:
 1708 0be2 00BF     		.align	2
 1709              		.global	activity_csl_data_tie1
 1710              		.thumb
 1711              		.thumb_func
 1713              	activity_csl_data_tie1:
 1714              	.LFB17:
 794:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 795:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 796:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data tie1].
 797:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 798:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #tt2 expiring, i.e. timer fires while state = S_CSLTXDATAPREPARE. This is re
 799:openstack/02a-MAClow/IEEE802154Ecsl.c ****   did not have enough time to execute. Chances are to set maxTxDataPrepare too small. The implement
 800:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 801:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_tie1() {
 1715              		.loc 1 801 0
 1716              		.cfi_startproc
 1717              		@ args = 0, pretend = 0, frame = 0
 1718              		@ frame_needed = 1, uses_anonymous_args = 0
 1719 0be4 80B5     		push	{r7, lr}
 1720              	.LCFI41:
 1721              		.cfi_def_cfa_offset 8
 1722              		.cfi_offset 7, -8
 1723              		.cfi_offset 14, -4
 1724 0be6 00AF     		add	r7, sp, #0
 1725              	.LCFI42:
 1726              		.cfi_def_cfa_register 7
 802:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
 803:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXDATAPREPARE_OVERFLOW,
 804:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_vars.slo
 1727              		.loc 1 804 0
 1728 0be8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1729 0bec C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1730 0bf0 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 803:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXDATAPREPARE_OVERFLOW,
 1731              		.loc 1 803 0
 1732 0bf2 1A46     		mov	r2, r3
 1733 0bf4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1734 0bf8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1735 0bfc DB88     		ldrh	r3, [r3, #6]
 1736 0bfe 4FF00900 		mov	r0, #9
 1737 0c02 4FF02201 		mov	r1, #34
 1738 0c06 FFF7FEFF 		bl	openserial_printError
 805:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
 806:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 1739              		.loc 1 806 0
 1740 0c0a FFF7FEFF 		bl	endOps
 807:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1741              		.loc 1 807 0
 1742 0c0e 80BD     		pop	{r7, pc}
 1743              		.cfi_endproc
 1744              	.LFE17:
 1746              		.align	2
 1747              		.global	activity_csl_data_ti3
 1748              		.thumb
 1749              		.thumb_func
 1751              	activity_csl_data_ti3:
 1752              	.LFB18:
 808:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 809:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 810:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti3].
 811:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 812:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 813:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The radio is configured and this interrupt gives it the "go" signal to start listening.
 814:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 815:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti3() {
 1753              		.loc 1 815 0
 1754              		.cfi_startproc
 1755              		@ args = 0, pretend = 0, frame = 0
 1756              		@ frame_needed = 1, uses_anonymous_args = 0
 1757 0c10 80B5     		push	{r7, lr}
 1758              	.LCFI43:
 1759              		.cfi_def_cfa_offset 8
 1760              		.cfi_offset 7, -8
 1761              		.cfi_offset 14, -4
 1762 0c12 00AF     		add	r7, sp, #0
 1763              	.LCFI44:
 1764              		.cfi_def_cfa_register 7
 816:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 817:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXDATADELAY);
 1765              		.loc 1 817 0
 1766 0c14 4FF02300 		mov	r0, #35
 1767 0c18 FFF7FEFF 		bl	changeState
 818:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 819:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt3
 820:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt3);
 1768              		.loc 1 820 0
 1769 0c1c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1770 0c20 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1771 0c24 5B6A     		ldr	r3, [r3, #36]
 1772 0c26 03F19D03 		add	r3, r3, #157
 1773 0c2a 1846     		mov	r0, r3
 1774 0c2c FFF7FEFF 		bl	radiotimer_schedule
 821:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 822:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // give the 'go' to transmit
 823:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_txNow();
 1775              		.loc 1 823 0
 1776 0c30 FFF7FEFF 		bl	radio_txNow
 824:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1777              		.loc 1 824 0
 1778 0c34 80BD     		pop	{r7, pc}
 1779              		.cfi_endproc
 1780              	.LFE18:
 1782 0c36 00BF     		.align	2
 1783              		.global	activity_csl_data_tie2
 1784              		.thumb
 1785              		.thumb_func
 1787              	activity_csl_data_tie2:
 1788              	.LFB19:
 825:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 826:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 827:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 828:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX Sampling error [data tie2].
 829:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 830:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #tt3 expiring, i.e. timer fires while state = S_CSLTXDATADELAY. If no packet
 831:openstack/02a-MAClow/IEEE802154Ecsl.c ****   none will be sent and it is safe to switch off the radio. This timer is set such that the radio w
 832:openstack/02a-MAClow/IEEE802154Ecsl.c ****   duration (#TsLongGT).
 833:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 834:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_tie2() {
 1789              		.loc 1 834 0
 1790              		.cfi_startproc
 1791              		@ args = 0, pretend = 0, frame = 0
 1792              		@ frame_needed = 1, uses_anonymous_args = 0
 1793 0c38 80B5     		push	{r7, lr}
 1794              	.LCFI45:
 1795              		.cfi_def_cfa_offset 8
 1796              		.cfi_offset 7, -8
 1797              		.cfi_offset 14, -4
 1798 0c3a 00AF     		add	r7, sp, #0
 1799              	.LCFI46:
 1800              		.cfi_def_cfa_register 7
 835:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
 836:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIO_OVERFLOWS,
 837:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_vars.slo
 1801              		.loc 1 837 0
 1802 0c3c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1803 0c40 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1804 0c44 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 836:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIO_OVERFLOWS,
 1805              		.loc 1 836 0
 1806 0c46 1A46     		mov	r2, r3
 1807 0c48 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1808 0c4c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1809 0c50 DB88     		ldrh	r3, [r3, #6]
 1810 0c52 4FF00900 		mov	r0, #9
 1811 0c56 4FF02701 		mov	r1, #39
 1812 0c5a FFF7FEFF 		bl	openserial_printError
 838:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 839:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
 840:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 1813              		.loc 1 840 0
 1814 0c5e FFF7FEFF 		bl	endOps
 841:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1815              		.loc 1 841 0
 1816 0c62 80BD     		pop	{r7, pc}
 1817              		.cfi_endproc
 1818              	.LFE19:
 1820              		.align	2
 1821              		.global	activity_csl_data_ti4
 1822              		.thumb
 1823              		.thumb_func
 1825              	activity_csl_data_ti4:
 1826              	.LFB20:
 842:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 843:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 844:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 845:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti4].
 846:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 847:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_startOfFrame" function when a start of frame ev
 848:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change state, cancel #tt3 and arm #tt4 (max time to sent all the packet).
 849:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 850:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti4(PORT_RADIOTIMER_WIDTH capturedTime) {
 1827              		.loc 1 850 0
 1828              		.cfi_startproc
 1829              		@ args = 0, pretend = 0, frame = 8
 1830              		@ frame_needed = 1, uses_anonymous_args = 0
 1831 0c64 80B5     		push	{r7, lr}
 1832              	.LCFI47:
 1833              		.cfi_def_cfa_offset 8
 1834              		.cfi_offset 7, -8
 1835              		.cfi_offset 14, -4
 1836 0c66 82B0     		sub	sp, sp, #8
 1837              	.LCFI48:
 1838              		.cfi_def_cfa_offset 16
 1839 0c68 00AF     		add	r7, sp, #0
 1840              	.LCFI49:
 1841              		.cfi_def_cfa_register 7
 1842 0c6a 7860     		str	r0, [r7, #4]
 851:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 852:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXDATA);
 1843              		.loc 1 852 0
 1844 0c6c 4FF02400 		mov	r0, #36
 1845 0c70 FFF7FEFF 		bl	changeState
 853:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 854:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel tt3
 855:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 1846              		.loc 1 855 0
 1847 0c74 FFF7FEFF 		bl	radiotimer_cancel
 856:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 857:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
 858:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.lastCapturedTime = capturedTime;
 1848              		.loc 1 858 0
 1849 0c78 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1850 0c7c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1851 0c80 7A68     		ldr	r2, [r7, #4]
 1852 0c82 5A62     		str	r2, [r3, #36]
 859:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 860:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt4
 861:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt4);
 1853              		.loc 1 861 0
 1854 0c84 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1855 0c88 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1856 0c8c 5B6A     		ldr	r3, [r3, #36]
 1857 0c8e 03F1A403 		add	r3, r3, #164
 1858 0c92 1846     		mov	r0, r3
 1859 0c94 FFF7FEFF 		bl	radiotimer_schedule
 862:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1860              		.loc 1 862 0
 1861 0c98 07F10807 		add	r7, r7, #8
 1862 0c9c BD46     		mov	sp, r7
 1863 0c9e 80BD     		pop	{r7, pc}
 1864              		.cfi_endproc
 1865              	.LFE20:
 1867              		.align	2
 1868              		.global	activity_csl_data_tie3
 1869              		.thumb
 1870              		.thumb_func
 1872              	activity_csl_data_tie3:
 1873              	.LFB21:
 863:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 864:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 865:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data tie3].
 866:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 867:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #tt4 expiring, i.e. timer fires while state = S_CSLTXDATA. This is an error 
 868:openstack/02a-MAClow/IEEE802154Ecsl.c ****   to transmit the data packet. The implemented behaviour is to log the error and finish.
 869:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 870:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_tie3() {
 1874              		.loc 1 870 0
 1875              		.cfi_startproc
 1876              		@ args = 0, pretend = 0, frame = 0
 1877              		@ frame_needed = 1, uses_anonymous_args = 0
 1878 0ca0 80B5     		push	{r7, lr}
 1879              	.LCFI50:
 1880              		.cfi_def_cfa_offset 8
 1881              		.cfi_offset 7, -8
 1882              		.cfi_offset 14, -4
 1883 0ca2 00AF     		add	r7, sp, #0
 1884              	.LCFI51:
 1885              		.cfi_def_cfa_register 7
 871:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
 872:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
 873:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_vars.slo
 1886              		.loc 1 873 0
 1887 0ca4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1888 0ca8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1889 0cac 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 872:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
 1890              		.loc 1 872 0
 1891 0cae 1A46     		mov	r2, r3
 1892 0cb0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1893 0cb4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1894 0cb8 DB88     		ldrh	r3, [r3, #6]
 1895 0cba 4FF00900 		mov	r0, #9
 1896 0cbe 4FF02601 		mov	r1, #38
 1897 0cc2 FFF7FEFF 		bl	openserial_printError
 874:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
 875:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 1898              		.loc 1 875 0
 1899 0cc6 FFF7FEFF 		bl	endOps
 876:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 1900              		.loc 1 876 0
 1901 0cca 80BD     		pop	{r7, pc}
 1902              		.cfi_endproc
 1903              	.LFE21:
 1905              		.align	2
 1906              		.global	activity_csl_data_ti5
 1907              		.thumb
 1908              		.thumb_func
 1910              	activity_csl_data_ti5:
 1911              	.LFB22:
 877:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 878:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 879:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ri5].
 880:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 881:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_endOfFrame" function when a end of frame event 
 882:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change state, cancel #tt4, and notify upper layer and schedule about succ
 883:openstack/02a-MAClow/IEEE802154Ecsl.c ****   start process for receive ACK frame (arm #tt5).
 884:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 885:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti5(PORT_RADIOTIMER_WIDTH capturedTime) {
 1912              		.loc 1 885 0
 1913              		.cfi_startproc
 1914              		@ args = 0, pretend = 0, frame = 16
 1915              		@ frame_needed = 1, uses_anonymous_args = 0
 1916 0ccc 90B5     		push	{r4, r7, lr}
 1917              	.LCFI52:
 1918              		.cfi_def_cfa_offset 12
 1919              		.cfi_offset 4, -12
 1920              		.cfi_offset 7, -8
 1921              		.cfi_offset 14, -4
 1922 0cce 85B0     		sub	sp, sp, #20
 1923              	.LCFI53:
 1924              		.cfi_def_cfa_offset 32
 1925 0cd0 00AF     		add	r7, sp, #0
 1926              	.LCFI54:
 1927              		.cfi_def_cfa_register 7
 1928 0cd2 7860     		str	r0, [r7, #4]
 886:openstack/02a-MAClow/IEEE802154Ecsl.c ****    bool listenForAck;
 887:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 888:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 889:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXACKOFFSET);
 1929              		.loc 1 889 0
 1930 0cd4 4FF02500 		mov	r0, #37
 1931 0cd8 FFF7FEFF 		bl	changeState
 890:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 891:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel tt4
 892:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 1932              		.loc 1 892 0
 1933 0cdc FFF7FEFF 		bl	radiotimer_cancel
 893:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 894:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // turn off the radio
 895:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rfOff();
 1934              		.loc 1 895 0
 1935 0ce0 FFF7FEFF 		bl	radio_rfOff
 896:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnTics+=(radio_getTimerValue()-ieee154e_vars.radioOnInit);
 1936              		.loc 1 896 0
 1937 0ce4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1938 0ce8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1939 0cec 5C6B     		ldr	r4, [r3, #52]
 1940 0cee FFF7FEFF 		bl	radio_getTimerValue
 1941 0cf2 0246     		mov	r2, r0
 1942 0cf4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1943 0cf8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1944 0cfc 1B6B     		ldr	r3, [r3, #48]
 1945 0cfe D31A     		subs	r3, r2, r3
 1946 0d00 E218     		adds	r2, r4, r3
 1947 0d02 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1948 0d06 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1949 0d0a 5A63     		str	r2, [r3, #52]
 897:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 898:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
 899:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //ieee154e_vars.lastCapturedTime = capturedTime;
 900:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 901:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // decides whether to listen for an ACK
 902:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (packetfunctions_isBroadcastMulticast(&ieee154e_vars.dataToSend->l2_nextORpreviousHop)==TRUE)
 1950              		.loc 1 902 0
 1951 0d0c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1952 0d10 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1953 0d14 5B69     		ldr	r3, [r3, #20]
 1954 0d16 03F13803 		add	r3, r3, #56
 1955 0d1a 1846     		mov	r0, r3
 1956 0d1c FFF7FEFF 		bl	packetfunctions_isBroadcastMulticast
 1957 0d20 0346     		mov	r3, r0
 1958 0d22 002B     		cmp	r3, #0
 1959 0d24 03D0     		beq	.L112
 903:openstack/02a-MAClow/IEEE802154Ecsl.c ****       listenForAck = FALSE;
 1960              		.loc 1 903 0
 1961 0d26 4FF00003 		mov	r3, #0
 1962 0d2a FB73     		strb	r3, [r7, #15]
 1963 0d2c 02E0     		b	.L113
 1964              	.L112:
 904:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
 905:openstack/02a-MAClow/IEEE802154Ecsl.c ****       listenForAck = TRUE;
 1965              		.loc 1 905 0
 1966 0d2e 4FF00103 		mov	r3, #1
 1967 0d32 FB73     		strb	r3, [r7, #15]
 1968              	.L113:
 906:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 907:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 908:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // CSL: TEST CODE
 909:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // toggle orange led to indicate TX.
 910:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if((ieee154e_vars.dataToSend->l2_frameType == IEEE154_TYPE_DATA) &&
 1969              		.loc 1 910 0
 1970 0d34 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1971 0d38 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1972 0d3c 5B69     		ldr	r3, [r3, #20]
 1973 0d3e 93F84930 		ldrb	r3, [r3, #73]	@ zero_extendqisi2
 1974 0d42 012B     		cmp	r3, #1
 1975 0d44 15D1     		bne	.L114
 911:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  (ieee154e_vars.dataToSend->owner == COMPONENT_SIXTOP_TO_IEEE802154E) &&
 1976              		.loc 1 911 0 discriminator 1
 1977 0d46 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1978 0d4a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1979 0d4e 5B69     		ldr	r3, [r3, #20]
 1980 0d50 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 910:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if((ieee154e_vars.dataToSend->l2_frameType == IEEE154_TYPE_DATA) &&
 1981              		.loc 1 910 0 discriminator 1
 1982 0d52 0A2B     		cmp	r3, #10
 1983 0d54 0DD1     		bne	.L114
 912:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  (ieee154e_vars.dataToSend->cslFlag == 123)) {
 1984              		.loc 1 912 0
 1985 0d56 40F20003 		movw	r3, #:lower16:ieee154e_vars
 1986 0d5a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 1987 0d5e 5B69     		ldr	r3, [r3, #20]
 1988 0d60 93F8ED30 		ldrb	r3, [r3, #237]	@ zero_extendqisi2
 911:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  (ieee154e_vars.dataToSend->owner == COMPONENT_SIXTOP_TO_IEEE802154E) &&
 1989              		.loc 1 911 0
 1990 0d64 7B2B     		cmp	r3, #123
 1991 0d66 04D1     		bne	.L114
 913:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	 leds_sync_blink();
 1992              		.loc 1 913 0
 1993 0d68 FFF7FEFF 		bl	leds_sync_blink
 914:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	 listenForAck = FALSE;
 1994              		.loc 1 914 0
 1995 0d6c 4FF00003 		mov	r3, #0
 1996 0d70 FB73     		strb	r3, [r7, #15]
 1997              	.L114:
 915:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 916:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // END TEST CODE
 917:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 918:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 919:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (listenForAck==TRUE) {
 1998              		.loc 1 919 0
 1999 0d72 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 2000 0d74 002B     		cmp	r3, #0
 2001 0d76 0AD0     		beq	.L115
 920:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // arm tt5
 921:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radiotimer_schedule(DURATION_tt5);
 2002              		.loc 1 921 0
 2003 0d78 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2004 0d7c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2005 0d80 5B6A     		ldr	r3, [r3, #36]
 2006 0d82 03F17D03 		add	r3, r3, #125
 2007 0d86 1846     		mov	r0, r3
 2008 0d88 FFF7FEFF 		bl	radiotimer_schedule
 2009 0d8c 09E0     		b	.L111
 2010              	.L115:
 922:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
 923:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // indicate succesful Tx to schedule to keep statistics
 924:openstack/02a-MAClow/IEEE802154Ecsl.c ****       schedule_indicateTx(&ieee154e_vars.asn,TRUE);
 2011              		.loc 1 924 0
 2012 0d8e 40F20000 		movw	r0, #:lower16:ieee154e_vars
 2013 0d92 C0F20000 		movt	r0, #:upper16:ieee154e_vars
 2014 0d96 4FF00101 		mov	r1, #1
 2015 0d9a FFF7FEFF 		bl	schedule_indicateTx
 925:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 926:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // CSL TEST CODE (comment notification)
 927:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // indicate to upper later the packet was sent successfully
 928:openstack/02a-MAClow/IEEE802154Ecsl.c ****       //notif_sendDone(ieee154e_vars.dataToSend,E_SUCCESS);
 929:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 930:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset local variable
 931:openstack/02a-MAClow/IEEE802154Ecsl.c ****       //ieee154e_vars.dataToSend = NULL;
 932:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // END TEST CODE
 933:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 934:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // abort
 935:openstack/02a-MAClow/IEEE802154Ecsl.c ****       endOps();
 2016              		.loc 1 935 0
 2017 0d9e FFF7FEFF 		bl	endOps
 2018              	.L111:
 936:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
 937:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2019              		.loc 1 937 0
 2020 0da2 07F11407 		add	r7, r7, #20
 2021 0da6 BD46     		mov	sp, r7
 2022 0da8 90BD     		pop	{r4, r7, pc}
 2023              		.cfi_endproc
 2024              	.LFE22:
 2026 0daa 00BF     		.align	2
 2027              		.global	activity_csl_data_ti6
 2028              		.thumb
 2029              		.thumb_func
 2031              	activity_csl_data_ti6:
 2032              	.LFB23:
 938:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 939:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 940:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti6].
 941:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 942:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 943:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The functionality is to prepare the radio for ACK reception.
 944:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 945:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti6() {
 2033              		.loc 1 945 0
 2034              		.cfi_startproc
 2035              		@ args = 0, pretend = 0, frame = 0
 2036              		@ frame_needed = 1, uses_anonymous_args = 0
 2037 0dac 80B5     		push	{r7, lr}
 2038              	.LCFI55:
 2039              		.cfi_def_cfa_offset 8
 2040              		.cfi_offset 7, -8
 2041              		.cfi_offset 14, -4
 2042 0dae 00AF     		add	r7, sp, #0
 2043              	.LCFI56:
 2044              		.cfi_def_cfa_register 7
 946:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 947:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXACKPREPARE);
 2045              		.loc 1 947 0
 2046 0db0 4FF02600 		mov	r0, #38
 2047 0db4 FFF7FEFF 		bl	changeState
 948:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 949:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // enable the radio in Rx mode. The radio is not actively listening yet.
 950:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rxEnable();
 2048              		.loc 1 950 0
 2049 0db8 FFF7FEFF 		bl	radio_rxEnable
 951:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 952:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //caputre init of radio for duty cycle calculation
 953:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnInit=radio_getTimerValue();
 2050              		.loc 1 953 0
 2051 0dbc FFF7FEFF 		bl	radio_getTimerValue
 2052 0dc0 0246     		mov	r2, r0
 2053 0dc2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2054 0dc6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2055 0dca 1A63     		str	r2, [r3, #48]
 954:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnThisSlot=TRUE;
 2056              		.loc 1 954 0
 2057 0dcc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2058 0dd0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2059 0dd4 4FF00102 		mov	r2, #1
 2060 0dd8 83F83820 		strb	r2, [r3, #56]
 955:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 956:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt6
 957:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt6);
 2061              		.loc 1 957 0
 2062 0ddc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2063 0de0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2064 0de4 5B6A     		ldr	r3, [r3, #36]
 2065 0de6 03F18703 		add	r3, r3, #135
 2066 0dea 1846     		mov	r0, r3
 2067 0dec FFF7FEFF 		bl	radiotimer_schedule
 958:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 959:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 960:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXACKREADY);
 2068              		.loc 1 960 0
 2069 0df0 4FF02700 		mov	r0, #39
 2070 0df4 FFF7FEFF 		bl	changeState
 961:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2071              		.loc 1 961 0
 2072 0df8 80BD     		pop	{r7, pc}
 2073              		.cfi_endproc
 2074              	.LFE23:
 2076 0dfa 00BF     		.align	2
 2077              		.global	activity_csl_data_tie4
 2078              		.thumb
 2079              		.thumb_func
 2081              	activity_csl_data_tie4:
 2082              	.LFB24:
 962:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 963:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 964:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data tie4].
 965:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 966:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 967:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The functionality is to prepare the radio for ACK sending.
 968:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 969:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_tie4() {
 2083              		.loc 1 969 0
 2084              		.cfi_startproc
 2085              		@ args = 0, pretend = 0, frame = 0
 2086              		@ frame_needed = 1, uses_anonymous_args = 0
 2087 0dfc 80B5     		push	{r7, lr}
 2088              	.LCFI57:
 2089              		.cfi_def_cfa_offset 8
 2090              		.cfi_offset 7, -8
 2091              		.cfi_offset 14, -4
 2092 0dfe 00AF     		add	r7, sp, #0
 2093              	.LCFI58:
 2094              		.cfi_def_cfa_register 7
 970:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
 971:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXACKPREPARE_OVERFLOWS,
 972:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state, (errorparameter_t)ieee154e_vars.slo
 2095              		.loc 1 972 0
 2096 0e00 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2097 0e04 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2098 0e08 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 971:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXACKPREPARE_OVERFLOWS,
 2099              		.loc 1 971 0
 2100 0e0a 1A46     		mov	r2, r3
 2101 0e0c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2102 0e10 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2103 0e14 DB88     		ldrh	r3, [r3, #6]
 2104 0e16 4FF00900 		mov	r0, #9
 2105 0e1a 4FF02301 		mov	r1, #35
 2106 0e1e FFF7FEFF 		bl	openserial_printError
 973:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
 974:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 2107              		.loc 1 974 0
 2108 0e22 FFF7FEFF 		bl	endOps
 975:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2109              		.loc 1 975 0
 2110 0e26 80BD     		pop	{r7, pc}
 2111              		.cfi_endproc
 2112              	.LFE24:
 2114              		.align	2
 2115              		.global	activity_csl_data_ti7
 2116              		.thumb
 2117              		.thumb_func
 2119              	activity_csl_data_ti7:
 2120              	.LFB25:
 976:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 977:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 978:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti7].
 979:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 980:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 981:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The radio is configured and this interrupt gives it the "go" signal to start listening.
 982:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
 983:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti7() {
 2121              		.loc 1 983 0
 2122              		.cfi_startproc
 2123              		@ args = 0, pretend = 0, frame = 0
 2124              		@ frame_needed = 1, uses_anonymous_args = 0
 2125 0e28 80B5     		push	{r7, lr}
 2126              	.LCFI59:
 2127              		.cfi_def_cfa_offset 8
 2128              		.cfi_offset 7, -8
 2129              		.cfi_offset 14, -4
 2130 0e2a 00AF     		add	r7, sp, #0
 2131              	.LCFI60:
 2132              		.cfi_def_cfa_register 7
 984:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
 985:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXACKLISTEN);
 2133              		.loc 1 985 0
 2134 0e2c 4FF02800 		mov	r0, #40
 2135 0e30 FFF7FEFF 		bl	changeState
 986:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 987:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // start listening
 988:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rxNow();
 2136              		.loc 1 988 0
 2137 0e34 FFF7FEFF 		bl	radio_rxNow
 989:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 990:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt7
 991:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt7);
 2138              		.loc 1 991 0
 2139 0e38 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2140 0e3c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2141 0e40 5B6A     		ldr	r3, [r3, #36]
 2142 0e42 03F1A703 		add	r3, r3, #167
 2143 0e46 1846     		mov	r0, r3
 2144 0e48 FFF7FEFF 		bl	radiotimer_schedule
 992:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2145              		.loc 1 992 0
 2146 0e4c 80BD     		pop	{r7, pc}
 2147              		.cfi_endproc
 2148              	.LFE25:
 2150 0e4e 00BF     		.align	2
 2151              		.global	activity_csl_data_tie5
 2152              		.thumb
 2153              		.thumb_func
 2155              	activity_csl_data_tie5:
 2156              	.LFB26:
 993:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 994:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
 995:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data tie5].
 996:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
 997:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
 998:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to notify upper level, updating the number of remaining retries of the packe
 999:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1000:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_tie5() {
 2157              		.loc 1 1000 0
 2158              		.cfi_startproc
 2159              		@ args = 0, pretend = 0, frame = 0
 2160              		@ frame_needed = 1, uses_anonymous_args = 0
 2161 0e50 80B5     		push	{r7, lr}
 2162              	.LCFI61:
 2163              		.cfi_def_cfa_offset 8
 2164              		.cfi_offset 7, -8
 2165              		.cfi_offset 14, -4
 2166 0e52 00AF     		add	r7, sp, #0
 2167              	.LCFI62:
 2168              		.cfi_def_cfa_register 7
1001:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // indicate transmit failed to schedule to keep stats
1002:openstack/02a-MAClow/IEEE802154Ecsl.c ****    schedule_indicateTx(&ieee154e_vars.asn,FALSE);
 2169              		.loc 1 1002 0
 2170 0e54 40F20000 		movw	r0, #:lower16:ieee154e_vars
 2171 0e58 C0F20000 		movt	r0, #:upper16:ieee154e_vars
 2172 0e5c 4FF00001 		mov	r1, #0
 2173 0e60 FFF7FEFF 		bl	schedule_indicateTx
1003:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1004:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // decrement transmits left counter
1005:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.dataToSend->l2_retriesLeft--;
 2174              		.loc 1 1005 0
 2175 0e64 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2176 0e68 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2177 0e6c 5B69     		ldr	r3, [r3, #20]
 2178 0e6e 93F84B20 		ldrb	r2, [r3, #75]	@ zero_extendqisi2
 2179 0e72 02F1FF32 		add	r2, r2, #-1
 2180 0e76 D2B2     		uxtb	r2, r2
 2181 0e78 83F84B20 		strb	r2, [r3, #75]
1006:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1007:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.dataToSend->l2_retriesLeft==0) {
 2182              		.loc 1 1007 0
 2183 0e7c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2184 0e80 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2185 0e84 5B69     		ldr	r3, [r3, #20]
 2186 0e86 93F84B30 		ldrb	r3, [r3, #75]	@ zero_extendqisi2
 2187 0e8a 002B     		cmp	r3, #0
 2188 0e8c 07D0     		beq	.L121
1008:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // indicate tx fail if no more retries left
1009:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // CSL testing commented
1010:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  // notif_sendDone(ieee154e_vars.dataToSend,E_FAIL);
1011:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
1012:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // return packet to the virtual COMPONENT_SIXTOP_TO_IEEE802154E component
1013:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataToSend->owner = COMPONENT_SIXTOP_TO_IEEE802154E;
 2189              		.loc 1 1013 0
 2190 0e8e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2191 0e92 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2192 0e96 5B69     		ldr	r3, [r3, #20]
 2193 0e98 4FF00A02 		mov	r2, #10
 2194 0e9c 5A70     		strb	r2, [r3, #1]
 2195              	.L121:
1014:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
1015:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1016:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // reset local variable
1017:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.dataToSend = NULL;
 2196              		.loc 1 1017 0
 2197 0e9e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2198 0ea2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2199 0ea6 4FF00002 		mov	r2, #0
 2200 0eaa 5A61     		str	r2, [r3, #20]
1018:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1019:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1020:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 2201              		.loc 1 1020 0
 2202 0eac FFF7FEFF 		bl	endOps
1021:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2203              		.loc 1 1021 0
 2204 0eb0 80BD     		pop	{r7, pc}
 2205              		.cfi_endproc
 2206              	.LFE26:
 2208 0eb2 00BF     		.align	2
 2209              		.global	activity_csl_data_ti8
 2210              		.thumb
 2211              		.thumb_func
 2213              	activity_csl_data_ti8:
 2214              	.LFB27:
1022:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1023:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1024:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti8].
1025:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1026:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_startOfFrame" function when a start of frame ev
1027:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change the state, cancel #tt7 and arm #tt8 (max time to receive the ack p
1028:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1029:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti8(PORT_RADIOTIMER_WIDTH capturedTime) {
 2215              		.loc 1 1029 0
 2216              		.cfi_startproc
 2217              		@ args = 0, pretend = 0, frame = 8
 2218              		@ frame_needed = 1, uses_anonymous_args = 0
 2219 0eb4 80B5     		push	{r7, lr}
 2220              	.LCFI63:
 2221              		.cfi_def_cfa_offset 8
 2222              		.cfi_offset 7, -8
 2223              		.cfi_offset 14, -4
 2224 0eb6 82B0     		sub	sp, sp, #8
 2225              	.LCFI64:
 2226              		.cfi_def_cfa_offset 16
 2227 0eb8 00AF     		add	r7, sp, #0
 2228              	.LCFI65:
 2229              		.cfi_def_cfa_register 7
 2230 0eba 7860     		str	r0, [r7, #4]
1030:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1031:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXACK);
 2231              		.loc 1 1031 0
 2232 0ebc 4FF02900 		mov	r0, #41
 2233 0ec0 FFF7FEFF 		bl	changeState
1032:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1033:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel tt7
1034:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 2234              		.loc 1 1034 0
 2235 0ec4 FFF7FEFF 		bl	radiotimer_cancel
1035:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1036:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
1037:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //ieee154e_vars.lastCapturedTime = capturedTime;
1038:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1039:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm tt8
1040:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_tt8);
 2236              		.loc 1 1040 0
 2237 0ec8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2238 0ecc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2239 0ed0 5B6A     		ldr	r3, [r3, #36]
 2240 0ed2 03F16203 		add	r3, r3, #98
 2241 0ed6 1846     		mov	r0, r3
 2242 0ed8 FFF7FEFF 		bl	radiotimer_schedule
1041:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2243              		.loc 1 1041 0
 2244 0edc 07F10807 		add	r7, r7, #8
 2245 0ee0 BD46     		mov	sp, r7
 2246 0ee2 80BD     		pop	{r7, pc}
 2247              		.cfi_endproc
 2248              	.LFE27:
 2250              		.align	2
 2251              		.global	activity_csl_data_tie6
 2252              		.thumb
 2253              		.thumb_func
 2255              	activity_csl_data_tie6:
 2256              	.LFB28:
1042:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1043:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1044:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data tie6].
1045:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1046:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1047:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to finish and clean registers.
1048:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1049:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_tie6() {
 2257              		.loc 1 1049 0
 2258              		.cfi_startproc
 2259              		@ args = 0, pretend = 0, frame = 0
 2260              		@ frame_needed = 1, uses_anonymous_args = 0
 2261 0ee4 80B5     		push	{r7, lr}
 2262              	.LCFI66:
 2263              		.cfi_def_cfa_offset 8
 2264              		.cfi_offset 7, -8
 2265              		.cfi_offset 14, -4
 2266 0ee6 00AF     		add	r7, sp, #0
 2267              	.LCFI67:
 2268              		.cfi_def_cfa_register 7
1050:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1051:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 2269              		.loc 1 1051 0
 2270 0ee8 FFF7FEFF 		bl	endOps
1052:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2271              		.loc 1 1052 0
 2272 0eec 80BD     		pop	{r7, pc}
 2273              		.cfi_endproc
 2274              	.LFE28:
 2276 0eee 00BF     		.align	2
 2277              		.global	activity_csl_data_ti9
 2278              		.thumb
 2279              		.thumb_func
 2281              	activity_csl_data_ti9:
 2282              	.LFB29:
1053:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1054:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1055:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1056:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL TX stage [data ti9].
1057:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1058:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_endOfFrame" function when a end of frame event 
1059:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change the state, cancel #tt8, analyze ack packet and notify upper layer.
1060:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1061:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ti9(PORT_RADIOTIMER_WIDTH capturedTime) {
 2283              		.loc 1 1061 0
 2284              		.cfi_startproc
 2285              		@ args = 0, pretend = 0, frame = 80
 2286              		@ frame_needed = 1, uses_anonymous_args = 0
 2287 0ef0 B0B5     		push	{r4, r5, r7, lr}
 2288              	.LCFI68:
 2289              		.cfi_def_cfa_offset 16
 2290              		.cfi_offset 4, -16
 2291              		.cfi_offset 5, -12
 2292              		.cfi_offset 7, -8
 2293              		.cfi_offset 14, -4
 2294 0ef2 96B0     		sub	sp, sp, #88
 2295              	.LCFI69:
 2296              		.cfi_def_cfa_offset 104
 2297 0ef4 02AF     		add	r7, sp, #8
 2298              	.LCFI70:
 2299              		.cfi_def_cfa 7, 96
 2300 0ef6 7860     		str	r0, [r7, #4]
1062:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802154_header_iht     ieee802514_header;
1063:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint16_t                  lenIE;
1064:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1065:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1066:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXPROC);
 2301              		.loc 1 1066 0
 2302 0ef8 4FF02A00 		mov	r0, #42
 2303 0efc FFF7FEFF 		bl	changeState
1067:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1068:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel tt8
1069:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 2304              		.loc 1 1069 0
 2305 0f00 FFF7FEFF 		bl	radiotimer_cancel
1070:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1071:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // turn off the radio
1072:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rfOff();
 2306              		.loc 1 1072 0
 2307 0f04 FFF7FEFF 		bl	radio_rfOff
1073:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //compute tics radio on.
1074:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnTics+=(radio_getTimerValue()-ieee154e_vars.radioOnInit);
 2308              		.loc 1 1074 0
 2309 0f08 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2310 0f0c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2311 0f10 5C6B     		ldr	r4, [r3, #52]
 2312 0f12 FFF7FEFF 		bl	radio_getTimerValue
 2313 0f16 0246     		mov	r2, r0
 2314 0f18 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2315 0f1c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2316 0f20 1B6B     		ldr	r3, [r3, #48]
 2317 0f22 D31A     		subs	r3, r2, r3
 2318 0f24 E218     		adds	r2, r4, r3
 2319 0f26 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2320 0f2a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2321 0f2e 5A63     		str	r2, [r3, #52]
1075:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1076:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
1077:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //ieee154e_vars.lastCapturedTime = capturedTime;
1078:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1079:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // get a buffer to put the (received) ACK in
1080:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackReceived = openqueue_getFreePacketBuffer(COMPONENT_IEEE802154E);
 2322              		.loc 1 1080 0
 2323 0f30 4FF00900 		mov	r0, #9
 2324 0f34 FFF7FEFF 		bl	openqueue_getFreePacketBuffer
 2325 0f38 0246     		mov	r2, r0
 2326 0f3a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2327 0f3e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2328 0f42 1A62     		str	r2, [r3, #32]
1081:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.ackReceived==NULL) {
 2329              		.loc 1 1081 0
 2330 0f44 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2331 0f48 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2332 0f4c 1B6A     		ldr	r3, [r3, #32]
 2333 0f4e 002B     		cmp	r3, #0
 2334 0f50 0CD1     		bne	.L125
1082:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // log the error
1083:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openserial_printError(COMPONENT_IEEE802154E,ERR_NO_FREE_PACKET_BUFFER,
 2335              		.loc 1 1083 0
 2336 0f52 4FF00900 		mov	r0, #9
 2337 0f56 4FF02C01 		mov	r1, #44
 2338 0f5a 4FF00002 		mov	r2, #0
 2339 0f5e 4FF00003 		mov	r3, #0
 2340 0f62 FFF7FEFF 		bl	openserial_printError
1084:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)0,
1085:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)0);
1086:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // abort
1087:openstack/02a-MAClow/IEEE802154Ecsl.c ****       endOps();
 2341              		.loc 1 1087 0
 2342 0f66 FFF7FEFF 		bl	endOps
 2343 0f6a 15E1     		b	.L124
 2344              	.L125:
1088:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return;
1089:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
1090:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1091:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // declare ownership over that packet
1092:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackReceived->creator = COMPONENT_IEEE802154E;
 2345              		.loc 1 1092 0
 2346 0f6c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2347 0f70 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2348 0f74 1B6A     		ldr	r3, [r3, #32]
 2349 0f76 4FF00902 		mov	r2, #9
 2350 0f7a 1A70     		strb	r2, [r3, #0]
1093:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackReceived->owner   = COMPONENT_IEEE802154E;
 2351              		.loc 1 1093 0
 2352 0f7c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2353 0f80 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2354 0f84 1B6A     		ldr	r3, [r3, #32]
 2355 0f86 4FF00902 		mov	r2, #9
 2356 0f8a 5A70     		strb	r2, [r3, #1]
1094:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1095:openstack/02a-MAClow/IEEE802154Ecsl.c ****    /*
1096:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The do-while loop that follows is a little parsing trick.
1097:openstack/02a-MAClow/IEEE802154Ecsl.c ****    Because it contains a while(0) condition, it gets executed only once.
1098:openstack/02a-MAClow/IEEE802154Ecsl.c ****    Below the do-while loop is some code to cleans up the ack variable.
1099:openstack/02a-MAClow/IEEE802154Ecsl.c ****    Anywhere in the do-while loop, a break statement can be called to jump to
1100:openstack/02a-MAClow/IEEE802154Ecsl.c ****    the clean up code early. If the loop ends without a break, the received
1101:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packet was correct. If it got aborted early (through a break), the packet
1102:openstack/02a-MAClow/IEEE802154Ecsl.c ****    was faulty.
1103:openstack/02a-MAClow/IEEE802154Ecsl.c ****    */
1104:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1105:openstack/02a-MAClow/IEEE802154Ecsl.c ****    do { // this "loop" is only executed once
1106:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1107:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // retrieve the received ack frame from the radio's Rx buffer
1108:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.ackReceived->payload = &(ieee154e_vars.ackReceived->packet[FIRST_FRAME_BYTE]);
 2357              		.loc 1 1108 0
 2358 0f8c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2359 0f90 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2360 0f94 1A6A     		ldr	r2, [r3, #32]
 2361 0f96 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2362 0f9a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2363 0f9e 1B6A     		ldr	r3, [r3, #32]
 2364 0fa0 03F16C03 		add	r3, r3, #108
 2365 0fa4 5360     		str	r3, [r2, #4]
1109:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.ackReceived->payload,
 2366              		.loc 1 1109 0
 2367 0fa6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2368 0faa C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2369 0fae 1B6A     		ldr	r3, [r3, #32]
 2370 0fb0 5968     		ldr	r1, [r3, #4]
1110:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.ackReceived->length,
 2371              		.loc 1 1110 0
 2372 0fb2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2373 0fb6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2374 0fba 1B6A     		ldr	r3, [r3, #32]
1109:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.ackReceived->payload,
 2375              		.loc 1 1109 0
 2376 0fbc 03F10802 		add	r2, r3, #8
1111:openstack/02a-MAClow/IEEE802154Ecsl.c ****                              sizeof(ieee154e_vars.ackReceived->packet),
1112:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.ackReceived->l1_rssi,
 2377              		.loc 1 1112 0
 2378 0fc0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2379 0fc4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2380 0fc8 1B6A     		ldr	r3, [r3, #32]
1109:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.ackReceived->payload,
 2381              		.loc 1 1109 0
 2382 0fca 03F16804 		add	r4, r3, #104
1113:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.ackReceived->l1_lqi,
 2383              		.loc 1 1113 0
 2384 0fce 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2385 0fd2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2386 0fd6 1B6A     		ldr	r3, [r3, #32]
1109:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.ackReceived->payload,
 2387              		.loc 1 1109 0
 2388 0fd8 03F16900 		add	r0, r3, #105
1114:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.ackReceived->l1_crc);
 2389              		.loc 1 1114 0
 2390 0fdc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2391 0fe0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2392 0fe4 1B6A     		ldr	r3, [r3, #32]
1109:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.ackReceived->payload,
 2393              		.loc 1 1109 0
 2394 0fe6 03F16A03 		add	r3, r3, #106
 2395 0fea 0090     		str	r0, [sp, #0]
 2396 0fec 0193     		str	r3, [sp, #4]
 2397 0fee 0846     		mov	r0, r1
 2398 0ff0 1146     		mov	r1, r2
 2399 0ff2 4FF08202 		mov	r2, #130
 2400 0ff6 2346     		mov	r3, r4
 2401 0ff8 FFF7FEFF 		bl	radio_getReceivedFrame
1115:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1116:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // break if wrong length
1117:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.ackReceived->length<LENGTH_CRC || ieee154e_vars.ackReceived->length>LENGTH_
 2402              		.loc 1 1117 0
 2403 0ffc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2404 1000 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2405 1004 1B6A     		ldr	r3, [r3, #32]
 2406 1006 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 2407 1008 012B     		cmp	r3, #1
 2408 100a 07D9     		bls	.L127
 2409              		.loc 1 1117 0 is_stmt 0 discriminator 1
 2410 100c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2411 1010 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2412 1014 1B6A     		ldr	r3, [r3, #32]
 2413 1016 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 2414 1018 802B     		cmp	r3, #128
 2415 101a 0ED9     		bls	.L128
 2416              	.L127:
1118:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // break from the do-while loop and execute the clean-up code below
1119:openstack/02a-MAClow/IEEE802154Ecsl.c ****         openserial_printError(COMPONENT_IEEE802154E,ERR_INVALIDPACKETFROMRADIO,
1120:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)1,
1121:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             ieee154e_vars.ackReceived->length);
 2417              		.loc 1 1121 0 is_stmt 1
 2418 101c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2419 1020 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2420 1024 1B6A     		ldr	r3, [r3, #32]
 2421 1026 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
1119:openstack/02a-MAClow/IEEE802154Ecsl.c ****         openserial_printError(COMPONENT_IEEE802154E,ERR_INVALIDPACKETFROMRADIO,
 2422              		.loc 1 1119 0
 2423 1028 4FF00900 		mov	r0, #9
 2424 102c 4FF03701 		mov	r1, #55
 2425 1030 4FF00102 		mov	r2, #1
 2426 1034 FFF7FEFF 		bl	openserial_printError
1122:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1123:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 2427              		.loc 1 1123 0
 2428 1038 9DE0     		b	.L129
 2429              	.L128:
1124:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1125:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1126:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // toss CRC (2 last bytes)
1127:openstack/02a-MAClow/IEEE802154Ecsl.c ****       packetfunctions_tossFooter(   ieee154e_vars.ackReceived, LENGTH_CRC);
 2430              		.loc 1 1127 0
 2431 103a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2432 103e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2433 1042 1B6A     		ldr	r3, [r3, #32]
 2434 1044 1846     		mov	r0, r3
 2435 1046 4FF00201 		mov	r1, #2
 2436 104a FFF7FEFF 		bl	packetfunctions_tossFooter
1128:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1129:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // break if invalid CRC
1130:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.ackReceived->l1_crc==FALSE) {
 2437              		.loc 1 1130 0
 2438 104e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2439 1052 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2440 1056 1B6A     		ldr	r3, [r3, #32]
 2441 1058 93F86A30 		ldrb	r3, [r3, #106]	@ zero_extendqisi2
 2442 105c 83F00103 		eor	r3, r3, #1
 2443 1060 DBB2     		uxtb	r3, r3
 2444 1062 002B     		cmp	r3, #0
 2445 1064 7ED1     		bne	.L135
 2446              	.L130:
1131:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // break from the do-while loop and execute the clean-up code below
1132:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
1133:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1134:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1135:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // parse the IEEE802.15.4 header (RX ACK)
1136:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee802154_retrieveHeader(ieee154e_vars.ackReceived,&ieee802514_header);
 2447              		.loc 1 1136 0
 2448 1066 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2449 106a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2450 106e 1A6A     		ldr	r2, [r3, #32]
 2451 1070 07F11003 		add	r3, r7, #16
 2452 1074 1046     		mov	r0, r2
 2453 1076 1946     		mov	r1, r3
 2454 1078 FFF7FEFF 		bl	ieee802154_retrieveHeader
1137:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1138:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // break if invalid IEEE802.15.4 header
1139:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee802514_header.valid==FALSE) {
 2455              		.loc 1 1139 0
 2456 107c 3B7C     		ldrb	r3, [r7, #16]	@ zero_extendqisi2
 2457 107e 83F00103 		eor	r3, r3, #1
 2458 1082 DBB2     		uxtb	r3, r3
 2459 1084 002B     		cmp	r3, #0
 2460 1086 6FD1     		bne	.L136
 2461              	.L131:
1140:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // break from the do-while loop and execute the clean-up code below
1141:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
1142:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1143:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1144:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // store header details in packet buffer
1145:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.ackReceived->l2_frameType  = ieee802514_header.frameType;
 2462              		.loc 1 1145 0
 2463 1088 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2464 108c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2465 1090 1B6A     		ldr	r3, [r3, #32]
 2466 1092 BA7C     		ldrb	r2, [r7, #18]	@ zero_extendqisi2
 2467 1094 83F84920 		strb	r2, [r3, #73]
1146:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.ackReceived->l2_dsn        = ieee802514_header.dsn;
 2468              		.loc 1 1146 0
 2469 1098 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2470 109c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2471 10a0 1B6A     		ldr	r3, [r3, #32]
 2472 10a2 7A7E     		ldrb	r2, [r7, #25]	@ zero_extendqisi2
 2473 10a4 83F84A20 		strb	r2, [r3, #74]
1147:openstack/02a-MAClow/IEEE802154Ecsl.c ****       memcpy(&(ieee154e_vars.ackReceived->l2_nextORpreviousHop),&(ieee802514_header.src),sizeof(ope
 2474              		.loc 1 1147 0
 2475 10a8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2476 10ac C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2477 10b0 1B6A     		ldr	r3, [r3, #32]
 2478 10b2 03F13803 		add	r3, r3, #56
 2479 10b6 1D46     		mov	r5, r3
 2480 10b8 07F13C04 		add	r4, r7, #60
 2481 10bc 0FCC     		ldmia	r4!, {r0, r1, r2, r3}
 2482 10be 2860     		str	r0, [r5, #0]	@ unaligned
 2483 10c0 6960     		str	r1, [r5, #4]	@ unaligned
 2484 10c2 AA60     		str	r2, [r5, #8]	@ unaligned
 2485 10c4 EB60     		str	r3, [r5, #12]	@ unaligned
 2486 10c6 2378     		ldrb	r3, [r4, #0]
 2487 10c8 2B74     		strb	r3, [r5, #16]
1148:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1149:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // toss the IEEE802.15.4 header
1150:openstack/02a-MAClow/IEEE802154Ecsl.c ****       packetfunctions_tossHeader(ieee154e_vars.ackReceived,ieee802514_header.headerLength);
 2488              		.loc 1 1150 0
 2489 10ca 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2490 10ce C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2491 10d2 1A6A     		ldr	r2, [r3, #32]
 2492 10d4 7B7C     		ldrb	r3, [r7, #17]	@ zero_extendqisi2
 2493 10d6 1046     		mov	r0, r2
 2494 10d8 1946     		mov	r1, r3
 2495 10da FFF7FEFF 		bl	packetfunctions_tossHeader
1151:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1152:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // break if invalid ACK
1153:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (isValidAck(&ieee802514_header,ieee154e_vars.dataToSend)==FALSE) {
 2496              		.loc 1 1153 0
 2497 10de 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2498 10e2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2499 10e6 5B69     		ldr	r3, [r3, #20]
 2500 10e8 07F11002 		add	r2, r7, #16
 2501 10ec 1046     		mov	r0, r2
 2502 10ee 1946     		mov	r1, r3
 2503 10f0 FFF7FEFF 		bl	isValidAck
 2504 10f4 0346     		mov	r3, r0
 2505 10f6 83F00103 		eor	r3, r3, #1
 2506 10fa DBB2     		uxtb	r3, r3
 2507 10fc 002B     		cmp	r3, #0
 2508 10fe 35D1     		bne	.L137
 2509              	.L132:
1154:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // break from the do-while loop and execute the clean-up code below
1155:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
1156:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1157:openstack/02a-MAClow/IEEE802154Ecsl.c ****       //hanlde IEs --xv poipoi
1158:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee802514_header.ieListPresent==FALSE){
 2510              		.loc 1 1158 0
 2511 1100 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 2512 1102 83F00103 		eor	r3, r3, #1
 2513 1106 DBB2     		uxtb	r3, r3
 2514 1108 002B     		cmp	r3, #0
 2515 110a 31D1     		bne	.L138
 2516              	.L133:
1159:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break; //ack should contain IEs.
1160:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1161:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1162:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_processIEs(ieee154e_vars.ackReceived,&lenIE)==FALSE){
 2517              		.loc 1 1162 0
 2518 110c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2519 1110 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2520 1114 1A6A     		ldr	r2, [r3, #32]
 2521 1116 07F10E03 		add	r3, r7, #14
 2522 111a 1046     		mov	r0, r2
 2523 111c 1946     		mov	r1, r3
 2524 111e FFF7FEFF 		bl	ieee154e_processIEs
 2525 1122 0346     		mov	r3, r0
 2526 1124 83F00103 		eor	r3, r3, #1
 2527 1128 DBB2     		uxtb	r3, r3
 2528 112a 002B     		cmp	r3, #0
 2529 112c 22D1     		bne	.L139
 2530              	.L134:
1163:openstack/02a-MAClow/IEEE802154Ecsl.c ****         // invalid IEs in ACK
1164:openstack/02a-MAClow/IEEE802154Ecsl.c ****         break;
1165:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1166:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1167:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // toss the IEs
1168:openstack/02a-MAClow/IEEE802154Ecsl.c ****       packetfunctions_tossHeader(ieee154e_vars.ackReceived,lenIE);
 2531              		.loc 1 1168 0
 2532 112e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2533 1132 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2534 1136 1A6A     		ldr	r2, [r3, #32]
 2535 1138 FB89     		ldrh	r3, [r7, #14]
 2536 113a DBB2     		uxtb	r3, r3
 2537 113c 1046     		mov	r0, r2
 2538 113e 1946     		mov	r1, r3
 2539 1140 FFF7FEFF 		bl	packetfunctions_tossHeader
1169:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1170:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // inform schedule of successful transmission
1171:openstack/02a-MAClow/IEEE802154Ecsl.c ****       schedule_indicateTx(&ieee154e_vars.asn,TRUE);
 2540              		.loc 1 1171 0
 2541 1144 40F20000 		movw	r0, #:lower16:ieee154e_vars
 2542 1148 C0F20000 		movt	r0, #:upper16:ieee154e_vars
 2543 114c 4FF00101 		mov	r1, #1
 2544 1150 FFF7FEFF 		bl	schedule_indicateTx
1172:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1173:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // inform upper layer
1174:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // CSL testing commented
1175:openstack/02a-MAClow/IEEE802154Ecsl.c ****       //notif_sendDone(ieee154e_vars.dataToSend,E_SUCCESS);
1176:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataToSend = NULL;
 2545              		.loc 1 1176 0
 2546 1154 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2547 1158 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2548 115c 4FF00002 		mov	r2, #0
 2549 1160 5A61     		str	r2, [r3, #20]
 2550 1162 08E0     		b	.L129
 2551              	.L135:
1132:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 2552              		.loc 1 1132 0
 2553 1164 00BF     		nop
 2554 1166 06E0     		b	.L129
 2555              	.L136:
1141:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 2556              		.loc 1 1141 0
 2557 1168 00BF     		nop
 2558 116a 04E0     		b	.L129
 2559              	.L137:
1155:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 2560              		.loc 1 1155 0
 2561 116c 00BF     		nop
 2562 116e 02E0     		b	.L129
 2563              	.L138:
1159:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break; //ack should contain IEs.
 2564              		.loc 1 1159 0
 2565 1170 00BF     		nop
 2566 1172 00E0     		b	.L129
 2567              	.L139:
1164:openstack/02a-MAClow/IEEE802154Ecsl.c ****         break;
 2568              		.loc 1 1164 0
 2569 1174 00BF     		nop
 2570              	.L129:
1177:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1178:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // in any case, execute the clean-up code below (processing of ACK done)
1179:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } while (0);
1180:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1181:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // free the received ack so corresponding RAM memory can be recycled
1182:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openqueue_freePacketBuffer(ieee154e_vars.ackReceived);
 2571              		.loc 1 1182 0
 2572 1176 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2573 117a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2574 117e 1B6A     		ldr	r3, [r3, #32]
 2575 1180 1846     		mov	r0, r3
 2576 1182 FFF7FEFF 		bl	openqueue_freePacketBuffer
1183:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1184:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clear local variable
1185:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackReceived = NULL;
 2577              		.loc 1 1185 0
 2578 1186 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2579 118a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2580 118e 4FF00002 		mov	r2, #0
 2581 1192 1A62     		str	r2, [r3, #32]
1186:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1187:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // official end of Tx
1188:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 2582              		.loc 1 1188 0
 2583 1194 FFF7FEFF 		bl	endOps
 2584              	.L124:
1189:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2585              		.loc 1 1189 0
 2586 1198 07F15007 		add	r7, r7, #80
 2587 119c BD46     		mov	sp, r7
 2588 119e B0BD     		pop	{r4, r5, r7, pc}
 2589              		.cfi_endproc
 2590              	.LFE29:
 2592              		.align	2
 2593              		.global	activity_csl_wakeup_ri1
 2594              		.thumb
 2595              		.thumb_func
 2597              	activity_csl_wakeup_ri1:
 2598              	.LFB30:
1190:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1191:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
1192:openstack/02a-MAClow/IEEE802154Ecsl.c **** //========================== CSL RX MODE ===============================
1193:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
1194:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1195:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1196:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1197:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [wake-up ri1].
1198:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1199:openstack/02a-MAClow/IEEE802154Ecsl.c ****  This method is invoked in ISR-mode from "isr_ieee154ecsl_newChannelSample" function when a new CSL
1200:openstack/02a-MAClow/IEEE802154Ecsl.c ****  
1201:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \note The FSM state should be S_SLEEP (initial state), raising an error in otherwise.
1202:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1203:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ri1() { // Activity for stage [ri1] on CSL RX Sampling.
 2599              		.loc 1 1203 0
 2600              		.cfi_startproc
 2601              		@ args = 0, pretend = 0, frame = 0
 2602              		@ frame_needed = 1, uses_anonymous_args = 0
 2603 11a0 80B5     		push	{r7, lr}
 2604              	.LCFI71:
 2605              		.cfi_def_cfa_offset 8
 2606              		.cfi_offset 7, -8
 2607              		.cfi_offset 14, -4
 2608 11a2 00AF     		add	r7, sp, #0
 2609              	.LCFI72:
 2610              		.cfi_def_cfa_register 7
1204:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1205:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // if the previous sample took too long or the state is incorrect, we will not be in the right 
1206:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // we register an error indicating the number of CSL sample where the problem have been detecte
1207:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   if (ieee154e_vars.state!=S_SLEEP) {
 2611              		.loc 1 1207 0
 2612 11a4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2613 11a8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2614 11ac 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 2615 11ae 002B     		cmp	r3, #0
 2616 11b0 14D0     		beq	.L141
1208:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  // log the error
1209:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_START_CSL_SAMPLING,
1210:openstack/02a-MAClow/IEEE802154Ecsl.c **** 								(errorparameter_t)ieee154e_vars.state,
 2617              		.loc 1 1210 0
 2618 11b2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2619 11b6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2620 11ba 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1209:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_START_CSL_SAMPLING,
 2621              		.loc 1 1209 0
 2622 11bc 1A46     		mov	r2, r3
1211:openstack/02a-MAClow/IEEE802154Ecsl.c **** 								(errorparameter_t)ieee154e_dbg.num_cslSamples);
 2623              		.loc 1 1211 0
 2624 11be 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 2625 11c2 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 2626 11c6 1B69     		ldr	r3, [r3, #16]
1209:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  openserial_printError(COMPONENT_IEEE802154E,ERR_WRONG_STATE_IN_START_CSL_SAMPLING,
 2627              		.loc 1 1209 0
 2628 11c8 9BB2     		uxth	r3, r3
 2629 11ca 4FF00900 		mov	r0, #9
 2630 11ce 4FF03A01 		mov	r1, #58
 2631 11d2 FFF7FEFF 		bl	openserial_printError
1212:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1213:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  // Abort in case of error. The signature of the function has been changed (instead of endSlot()
1214:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  // functionality. However, this function is equal for CSL and not-CSL.
1215:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  endOps();
 2632              		.loc 1 1215 0
 2633 11d6 FFF7FEFF 		bl	endOps
1216:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		  return;
 2634              		.loc 1 1216 0
 2635 11da 17E0     		b	.L140
 2636              	.L141:
1217:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   }
1218:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1219:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // stop using serial
1220:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   openserial_stop();
 2637              		.loc 1 1220 0
 2638 11dc FFF7FEFF 		bl	openserial_stop
1221:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1222:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // change state --> Next State will be S_CSLRXWAKEUPOFFSET in order to prepare for CSL Rx wake-
1223:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   changeState(S_CSLRXWAKEUPOFFSET);
 2639              		.loc 1 1223 0
 2640 11e0 4FF02B00 		mov	r0, #43
 2641 11e4 FFF7FEFF 		bl	changeState
1224:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1225:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // update CSL Mode to RX in order to avoid problems in FSM.
1226:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   ieee154e_vars.cslMode = CSL_RX_MODE;
 2642              		.loc 1 1226 0
 2643 11e8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2644 11ec C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2645 11f0 4FF00102 		mov	r2, #1
 2646 11f4 83F84520 		strb	r2, [r3, #69]
1227:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1228:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   // arm rt1
1229:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   radiotimer_schedule(DURATION_rt1);
 2647              		.loc 1 1229 0
 2648 11f8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2649 11fc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2650 1200 5B6A     		ldr	r3, [r3, #36]
 2651 1202 03F13703 		add	r3, r3, #55
 2652 1206 1846     		mov	r0, r3
 2653 1208 FFF7FEFF 		bl	radiotimer_schedule
 2654              	.L140:
1230:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2655              		.loc 1 1230 0
 2656 120c 80BD     		pop	{r7, pc}
 2657              		.cfi_endproc
 2658              	.LFE30:
 2660 120e 00BF     		.align	2
 2661              		.global	activity_csl_wakeup_ri2
 2662              		.thumb
 2663              		.thumb_func
 2665              	activity_csl_wakeup_ri2:
 2666              	.LFB31:
1231:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1232:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1233:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1234:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [wake-up ri2].
1235:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1236:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1237:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to prepare the radio for receiving packets.
1238:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1239:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ri2() { // Activity for stage [ri2] on CSL RX Sampling.
 2667              		.loc 1 1239 0
 2668              		.cfi_startproc
 2669              		@ args = 0, pretend = 0, frame = 0
 2670              		@ frame_needed = 1, uses_anonymous_args = 0
 2671 1210 80B5     		push	{r7, lr}
 2672              	.LCFI73:
 2673              		.cfi_def_cfa_offset 8
 2674              		.cfi_offset 7, -8
 2675              		.cfi_offset 14, -4
 2676 1212 00AF     		add	r7, sp, #0
 2677              	.LCFI74:
 2678              		.cfi_def_cfa_register 7
1240:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1241:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXWAKEUPPREPARE);
 2679              		.loc 1 1241 0
 2680 1214 4FF02C00 		mov	r0, #44
 2681 1218 FFF7FEFF 		bl	changeState
1242:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1243:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // We use always the same frequency so it is not necessary to change it on radio.
1244:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Enable the radio in Rx mode. The radio does not actively listen yet.
1245:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rxEnable();
 2682              		.loc 1 1245 0
 2683 121c FFF7FEFF 		bl	radio_rxEnable
1246:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnInit=radio_getTimerValue();
 2684              		.loc 1 1246 0
 2685 1220 FFF7FEFF 		bl	radio_getTimerValue
 2686 1224 0246     		mov	r2, r0
 2687 1226 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2688 122a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2689 122e 1A63     		str	r2, [r3, #48]
1247:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnThisSlot=TRUE;
 2690              		.loc 1 1247 0
 2691 1230 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2692 1234 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2693 1238 4FF00102 		mov	r2, #1
 2694 123c 83F83820 		strb	r2, [r3, #56]
1248:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1249:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt2
1250:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt2);
 2695              		.loc 1 1250 0
 2696 1240 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2697 1244 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2698 1248 5B6A     		ldr	r3, [r3, #36]
 2699 124a 03F15803 		add	r3, r3, #88
 2700 124e 1846     		mov	r0, r3
 2701 1250 FFF7FEFF 		bl	radiotimer_schedule
1251:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1252:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Change state.
1253:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // If this action is not performed before rt2 has expired, we need to manage the error in activi
1254:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // prepare has exceeded the maximum allowed time (duration_rt2).
1255:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXWAKEUPREADY);
 2702              		.loc 1 1255 0
 2703 1254 4FF02D00 		mov	r0, #45
 2704 1258 FFF7FEFF 		bl	changeState
1256:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2705              		.loc 1 1256 0
 2706 125c 80BD     		pop	{r7, pc}
 2707              		.cfi_endproc
 2708              	.LFE31:
 2710 125e 00BF     		.align	2
 2711              		.global	activity_csl_wakeup_rie1
 2712              		.thumb
 2713              		.thumb_func
 2715              	activity_csl_wakeup_rie1:
 2716              	.LFB32:
1257:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1258:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1259:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1260:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling error [wake-up rie1].
1261:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1262:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #rt2 expiring, i.e. timer fires while state = S_CSLRXWAKEUPPREPARE. This is 
1263:openstack/02a-MAClow/IEEE802154Ecsl.c ****   did not have enough time to execute. Chances are to set maxRxDataPrepare too small. The implement
1264:openstack/02a-MAClow/IEEE802154Ecsl.c ****   next CSL sample.
1265:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1266:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_rie1() {  // Activity for error event [rie1] on CSL RX Samplin
 2717              		.loc 1 1266 0
 2718              		.cfi_startproc
 2719              		@ args = 0, pretend = 0, frame = 0
 2720              		@ frame_needed = 1, uses_anonymous_args = 0
 2721 1260 80B5     		push	{r7, lr}
 2722              	.LCFI75:
 2723              		.cfi_def_cfa_offset 8
 2724              		.cfi_offset 7, -8
 2725              		.cfi_offset 14, -4
 2726 1262 00AF     		add	r7, sp, #0
 2727              	.LCFI76:
 2728              		.cfi_def_cfa_register 7
1267:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
1268:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXWAKEUPPREPARE_OVERFLOWS,
1269:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state,
 2729              		.loc 1 1269 0
 2730 1264 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2731 1268 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2732 126c 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1268:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXWAKEUPPREPARE_OVERFLOWS,
 2733              		.loc 1 1268 0
 2734 126e 1A46     		mov	r2, r3
1270:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_dbg.num_cslSamples);
 2735              		.loc 1 1270 0
 2736 1270 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 2737 1274 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 2738 1278 1B69     		ldr	r3, [r3, #16]
1268:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXWAKEUPPREPARE_OVERFLOWS,
 2739              		.loc 1 1268 0
 2740 127a 9BB2     		uxth	r3, r3
 2741 127c 4FF00900 		mov	r0, #9
 2742 1280 4FF03C01 		mov	r1, #60
 2743 1284 FFF7FEFF 		bl	openserial_printError
1271:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1272:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 2744              		.loc 1 1272 0
 2745 1288 FFF7FEFF 		bl	endOps
1273:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2746              		.loc 1 1273 0
 2747 128c 80BD     		pop	{r7, pc}
 2748              		.cfi_endproc
 2749              	.LFE32:
 2751 128e 00BF     		.align	2
 2752              		.global	activity_csl_wakeup_ri3
 2753              		.thumb
 2754              		.thumb_func
 2756              	activity_csl_wakeup_ri3:
 2757              	.LFB33:
1274:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1275:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1276:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1277:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [wake-up ri3].
1278:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1279:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1280:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The radio is configured and this interrupt gives it the "go" signal to start listening.
1281:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1282:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ri3() { // Activity for stage [ri3] on CSL RX Sampling.
 2758              		.loc 1 1282 0
 2759              		.cfi_startproc
 2760              		@ args = 0, pretend = 0, frame = 0
 2761              		@ frame_needed = 1, uses_anonymous_args = 0
 2762 1290 80B5     		push	{r7, lr}
 2763              	.LCFI77:
 2764              		.cfi_def_cfa_offset 8
 2765              		.cfi_offset 7, -8
 2766              		.cfi_offset 14, -4
 2767 1292 00AF     		add	r7, sp, #0
 2768              	.LCFI78:
 2769              		.cfi_def_cfa_register 7
1283:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1284:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXWAKEUPLISTEN);
 2770              		.loc 1 1284 0
 2771 1294 4FF02E00 		mov	r0, #46
 2772 1298 FFF7FEFF 		bl	changeState
1285:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1286:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // give the 'go' to receive
1287:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rxNow();
 2773              		.loc 1 1287 0
 2774 129c FFF7FEFF 		bl	radio_rxNow
1288:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1289:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt3
1290:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt3);
 2775              		.loc 1 1290 0
 2776 12a0 40F24110 		movw	r0, #321
 2777 12a4 FFF7FEFF 		bl	radiotimer_schedule
1291:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2778              		.loc 1 1291 0
 2779 12a8 80BD     		pop	{r7, pc}
 2780              		.cfi_endproc
 2781              	.LFE33:
 2783 12aa 00BF     		.align	2
 2784              		.global	activity_csl_wakeup_rie2
 2785              		.thumb
 2786              		.thumb_func
 2788              	activity_csl_wakeup_rie2:
 2789              	.LFB34:
1292:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1293:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1294:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1295:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling error [wake-up rie2].
1296:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1297:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #rt3 expiring, i.e. timer fires while state = S_CSLRXWAKEUPLISTEN. If no pac
1298:openstack/02a-MAClow/IEEE802154Ecsl.c ****   none will be received ever and it is safe to switch of the radio. This timer is set such that the
1299:openstack/02a-MAClow/IEEE802154Ecsl.c ****   duration (#TsLongGT).
1300:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1301:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_rie2() { // Activity for error event [rie2] on CSL RX Sampling
 2790              		.loc 1 1301 0
 2791              		.cfi_startproc
 2792              		@ args = 0, pretend = 0, frame = 0
 2793              		@ frame_needed = 1, uses_anonymous_args = 0
 2794 12ac 80B5     		push	{r7, lr}
 2795              	.LCFI79:
 2796              		.cfi_def_cfa_offset 8
 2797              		.cfi_offset 7, -8
 2798              		.cfi_offset 14, -4
 2799 12ae 00AF     		add	r7, sp, #0
 2800              	.LCFI80:
 2801              		.cfi_def_cfa_register 7
1302:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state --> Next State will be S_CSLRXWAKEUPOFFSET in order to prepare for CSL Rx wake-u
1303:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXWAKEUPOFFSET);
 2802              		.loc 1 1303 0
 2803 12b0 4FF02B00 		mov	r0, #43
 2804 12b4 FFF7FEFF 		bl	changeState
1304:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1305:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt1
1306:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt1);
 2805              		.loc 1 1306 0
 2806 12b8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2807 12bc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2808 12c0 5B6A     		ldr	r3, [r3, #36]
 2809 12c2 03F13703 		add	r3, r3, #55
 2810 12c6 1846     		mov	r0, r3
 2811 12c8 FFF7FEFF 		bl	radiotimer_schedule
1307:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1308:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1309:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 2812              		.loc 1 1309 0
 2813 12cc FFF7FEFF 		bl	endOps
1310:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2814              		.loc 1 1310 0
 2815 12d0 80BD     		pop	{r7, pc}
 2816              		.cfi_endproc
 2817              	.LFE34:
 2819 12d2 00BF     		.align	2
 2820              		.global	activity_csl_wakeup_ri4
 2821              		.thumb
 2822              		.thumb_func
 2824              	activity_csl_wakeup_ri4:
 2825              	.LFB35:
1311:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1312:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1313:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1314:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [wake-up ri4].
1315:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1316:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_startOfFrame" function when a start of frame ev
1317:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to capture the time, cancel #rt3 and arm #rt4 (max time to receive all the p
1318:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1319:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ri4(PORT_RADIOTIMER_WIDTH capturedTime) {  // Activity for sta
 2826              		.loc 1 1319 0
 2827              		.cfi_startproc
 2828              		@ args = 0, pretend = 0, frame = 8
 2829              		@ frame_needed = 1, uses_anonymous_args = 0
 2830 12d4 80B5     		push	{r7, lr}
 2831              	.LCFI81:
 2832              		.cfi_def_cfa_offset 8
 2833              		.cfi_offset 7, -8
 2834              		.cfi_offset 14, -4
 2835 12d6 82B0     		sub	sp, sp, #8
 2836              	.LCFI82:
 2837              		.cfi_def_cfa_offset 16
 2838 12d8 00AF     		add	r7, sp, #0
 2839              	.LCFI83:
 2840              		.cfi_def_cfa_register 7
 2841 12da 7860     		str	r0, [r7, #4]
1320:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1321:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1322:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXWAKEUP);
 2842              		.loc 1 1322 0
 2843 12dc 4FF02F00 		mov	r0, #47
 2844 12e0 FFF7FEFF 		bl	changeState
1323:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1324:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel rt3
1325:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 2845              		.loc 1 1325 0
 2846 12e4 FFF7FEFF 		bl	radiotimer_cancel
1326:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1327:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
1328:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.lastCapturedTime = capturedTime;
 2847              		.loc 1 1328 0
 2848 12e8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2849 12ec C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2850 12f0 7A68     		ldr	r2, [r7, #4]
 2851 12f2 5A62     		str	r2, [r3, #36]
1329:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1330:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time to sync
1331:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.syncCapturedTime = capturedTime;
 2852              		.loc 1 1331 0
 2853 12f4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2854 12f8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2855 12fc 7A68     		ldr	r2, [r7, #4]
 2856 12fe 9A62     		str	r2, [r3, #40]
1332:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1333:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt4);
 2857              		.loc 1 1333 0
 2858 1300 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2859 1304 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2860 1308 5B6A     		ldr	r3, [r3, #36]
 2861 130a 03F1A403 		add	r3, r3, #164
 2862 130e 1846     		mov	r0, r3
 2863 1310 FFF7FEFF 		bl	radiotimer_schedule
1334:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2864              		.loc 1 1334 0
 2865 1314 07F10807 		add	r7, r7, #8
 2866 1318 BD46     		mov	sp, r7
 2867 131a 80BD     		pop	{r7, pc}
 2868              		.cfi_endproc
 2869              	.LFE35:
 2871              		.align	2
 2872              		.global	activity_csl_wakeup_rie3
 2873              		.thumb
 2874              		.thumb_func
 2876              	activity_csl_wakeup_rie3:
 2877              	.LFB36:
1335:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1336:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1337:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1338:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling error [wake-up rie3].
1339:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1340:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #rt4 expiring, i.e. timer fires while state = S_CSLRXWAKEUP. This is an erro
1341:openstack/02a-MAClow/IEEE802154Ecsl.c ****   transmit the data packet. The implemented behaviour is to log the error and move on the next CSL 
1342:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1343:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_rie3() {
 2878              		.loc 1 1343 0
 2879              		.cfi_startproc
 2880              		@ args = 0, pretend = 0, frame = 0
 2881              		@ frame_needed = 1, uses_anonymous_args = 0
 2882 131c 80B5     		push	{r7, lr}
 2883              	.LCFI84:
 2884              		.cfi_def_cfa_offset 8
 2885              		.cfi_offset 7, -8
 2886              		.cfi_offset 14, -4
 2887 131e 00AF     		add	r7, sp, #0
 2888              	.LCFI85:
 2889              		.cfi_def_cfa_register 7
1344:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1345:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
1346:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDWAKEUPDURATION_OVERFLOWS,
1347:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state,
 2890              		.loc 1 1347 0
 2891 1320 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2892 1324 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2893 1328 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1346:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDWAKEUPDURATION_OVERFLOWS,
 2894              		.loc 1 1346 0
 2895 132a 1A46     		mov	r2, r3
1348:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_dbg.num_cslSamples);
 2896              		.loc 1 1348 0
 2897 132c 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 2898 1330 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 2899 1334 1B69     		ldr	r3, [r3, #16]
1346:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDWAKEUPDURATION_OVERFLOWS,
 2900              		.loc 1 1346 0
 2901 1336 9BB2     		uxth	r3, r3
 2902 1338 4FF00900 		mov	r0, #9
 2903 133c 4FF03D01 		mov	r1, #61
 2904 1340 FFF7FEFF 		bl	openserial_printError
1349:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1350:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 2905              		.loc 1 1350 0
 2906 1344 FFF7FEFF 		bl	endOps
1351:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 2907              		.loc 1 1351 0
 2908 1348 80BD     		pop	{r7, pc}
 2909              		.cfi_endproc
 2910              	.LFE36:
 2912 134a 00BF     		.align	2
 2913              		.global	activity_csl_wakeup_ri5
 2914              		.thumb
 2915              		.thumb_func
 2917              	activity_csl_wakeup_ri5:
 2918              	.LFB37:
1352:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1353:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1354:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1355:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [wake-up ri5].
1356:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1357:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_endOfFrame" function when a end of frame event 
1358:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change state, cancel #rt4, validate wake-up frame and destination, and ar
1359:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1360:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_ri5(PORT_RADIOTIMER_WIDTH capturedTime) {
 2919              		.loc 1 1360 0
 2920              		.cfi_startproc
 2921              		@ args = 0, pretend = 0, frame = 120
 2922              		@ frame_needed = 1, uses_anonymous_args = 0
 2923 134c 90B5     		push	{r4, r7, lr}
 2924              	.LCFI86:
 2925              		.cfi_def_cfa_offset 12
 2926              		.cfi_offset 4, -12
 2927              		.cfi_offset 7, -8
 2928              		.cfi_offset 14, -4
 2929 134e A1B0     		sub	sp, sp, #132
 2930              	.LCFI87:
 2931              		.cfi_def_cfa_offset 144
 2932 1350 02AF     		add	r7, sp, #8
 2933              	.LCFI88:
 2934              		.cfi_def_cfa 7, 136
 2935 1352 7860     		str	r0, [r7, #4]
1361:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1362:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	ieee802154_header_iht ieee802514_header;
1363:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	open_addr_t myID, myID16b;
1364:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	uint16_t rztime = 0;
 2936              		.loc 1 1364 0
 2937 1354 4FF00003 		mov	r3, #0
 2938 1358 FB81     		strh	r3, [r7, #14]	@ movhi
1365:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1366:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// CSL TEST CODE
1367:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// Only for Testing due to we are hard-coding destination (neighbor) address on schedule, sent pac
1368:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1369:openstack/02a-MAClow/IEEE802154Ecsl.c ****     myID.addr_64b[0]=0x00;
 2939              		.loc 1 1369 0
 2940 135a 4FF00003 		mov	r3, #0
 2941 135e 87F82530 		strb	r3, [r7, #37]
1370:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.addr_64b[1]=0x11;
 2942              		.loc 1 1370 0
 2943 1362 4FF01103 		mov	r3, #17
 2944 1366 87F82630 		strb	r3, [r7, #38]
1371:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.addr_64b[2]=0x22;
 2945              		.loc 1 1371 0
 2946 136a 4FF02203 		mov	r3, #34
 2947 136e 87F82730 		strb	r3, [r7, #39]
1372:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.addr_64b[3]=0x33;
 2948              		.loc 1 1372 0
 2949 1372 4FF03303 		mov	r3, #51
 2950 1376 87F82830 		strb	r3, [r7, #40]
1373:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.addr_64b[4]=0x44;
 2951              		.loc 1 1373 0
 2952 137a 4FF04403 		mov	r3, #68
 2953 137e 87F82930 		strb	r3, [r7, #41]
1374:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.addr_64b[5]=0x55;
 2954              		.loc 1 1374 0
 2955 1382 4FF05503 		mov	r3, #85
 2956 1386 87F82A30 		strb	r3, [r7, #42]
1375:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.addr_64b[6]=0x66;
 2957              		.loc 1 1375 0
 2958 138a 4FF06603 		mov	r3, #102
 2959 138e 87F82B30 		strb	r3, [r7, #43]
1376:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.addr_64b[7]=0x77;
 2960              		.loc 1 1376 0
 2961 1392 4FF07703 		mov	r3, #119
 2962 1396 87F82C30 		strb	r3, [r7, #44]
1377:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1378:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	myID.type=ADDR_64B;
 2963              		.loc 1 1378 0
 2964 139a 4FF00203 		mov	r3, #2
 2965 139e 87F82430 		strb	r3, [r7, #36]
1379:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1380:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// END CSL TEST
1381:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1382:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// En este punto ya hemos recibido la trama por lo que hay que hacer las siguientes validaciones:
1383:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   1.- Cambiar el estado a S_CSLRXWAKEUPVALIDATE y cancelar el temporizador rt4.
1384:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   2.- Apagar la radio.
1385:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   3.- Analizar el mensaje recibido y parsear su cabecera.
1386:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   4.- Verificar que se trata de una trama de tipo wake-up.
1387:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   5.- Comprobar que el destinatario soy yo mismo.
1388:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//
1389:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// En caso afirmativo, utilizamos el Rendezvous time recibido para saber cuánto tiempo hay que do
1390:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// En caso negativo, desactivamos la radio e iniciamos de nuevo el proceso de channel sampling.
1391:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1392:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // actualizamos el estado.
1393:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXWAKEUPVALIDATE);
 2966              		.loc 1 1393 0
 2967 13a2 4FF03000 		mov	r0, #48
 2968 13a6 FFF7FEFF 		bl	changeState
1394:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1395:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancelamos el timer #rt4
1396:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 2969              		.loc 1 1396 0
 2970 13aa FFF7FEFF 		bl	radiotimer_cancel
1397:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1398:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // apagamos la radio
1399:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rfOff();
 2971              		.loc 1 1399 0
 2972 13ae FFF7FEFF 		bl	radio_rfOff
1400:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1401:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // obtenemos un buffer en el cual poder guardar los datos recibidos.
1402:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.wakeupReceived = openqueue_getFreePacketBuffer(COMPONENT_IEEE802154E);
 2973              		.loc 1 1402 0
 2974 13b2 4FF00900 		mov	r0, #9
 2975 13b6 FFF7FEFF 		bl	openqueue_getFreePacketBuffer
 2976 13ba 0246     		mov	r2, r0
 2977 13bc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2978 13c0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2979 13c4 1A64     		str	r2, [r3, #64]
1403:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.wakeupReceived==NULL) {
 2980              		.loc 1 1403 0
 2981 13c6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2982 13ca C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2983 13ce 1B6C     		ldr	r3, [r3, #64]
 2984 13d0 002B     		cmp	r3, #0
 2985 13d2 0CD1     		bne	.L150
1404:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // registro del error & fin de operaciones.
1405:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openserial_printError(COMPONENT_IEEE802154E,ERR_NO_FREE_PACKET_BUFFER, (errorparameter_t)0, (
 2986              		.loc 1 1405 0
 2987 13d4 4FF00900 		mov	r0, #9
 2988 13d8 4FF02C01 		mov	r1, #44
 2989 13dc 4FF00002 		mov	r2, #0
 2990 13e0 4FF00003 		mov	r3, #0
 2991 13e4 FFF7FEFF 		bl	openserial_printError
1406:openstack/02a-MAClow/IEEE802154Ecsl.c ****       endOps();
 2992              		.loc 1 1406 0
 2993 13e8 FFF7FEFF 		bl	endOps
 2994 13ec 40E1     		b	.L149
 2995              	.L150:
1407:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return;
1408:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
1409:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1410:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Declaración de propiedad sobre el paquete.
1411:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.wakeupReceived->creator = COMPONENT_IEEE802154E;
 2996              		.loc 1 1411 0
 2997 13ee 40F20003 		movw	r3, #:lower16:ieee154e_vars
 2998 13f2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 2999 13f6 1B6C     		ldr	r3, [r3, #64]
 3000 13f8 4FF00902 		mov	r2, #9
 3001 13fc 1A70     		strb	r2, [r3, #0]
1412:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.wakeupReceived->owner   = COMPONENT_IEEE802154E;
 3002              		.loc 1 1412 0
 3003 13fe 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3004 1402 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3005 1406 1B6C     		ldr	r3, [r3, #64]
 3006 1408 4FF00902 		mov	r2, #9
 3007 140c 5A70     		strb	r2, [r3, #1]
1413:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1414:openstack/02a-MAClow/IEEE802154Ecsl.c ****    /*
1415:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The do-while loop that follows is a little parsing trick.
1416:openstack/02a-MAClow/IEEE802154Ecsl.c ****    Because it contains a while(0) condition, it gets executed only once.
1417:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The behavior is:
1418:openstack/02a-MAClow/IEEE802154Ecsl.c ****    - if a break occurs inside the do{} body, the error code below the loop gets executed. This indi
1419:openstack/02a-MAClow/IEEE802154Ecsl.c ****    - if a return occurs inside the do{} body, the error code below the loop does not get executed. 
1420:openstack/02a-MAClow/IEEE802154Ecsl.c ****    */
1421:openstack/02a-MAClow/IEEE802154Ecsl.c ****    do { // Este "loop" es ejecutado sólo en una ocasión.
1422:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1423:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Obtenemos la trama con los datos recibidos desde el buffer de recepción de la radio.
1424:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.wakeupReceived->payload = &(ieee154e_vars.wakeupReceived->packet[FIRST_FRAME_BY
 3008              		.loc 1 1424 0
 3009 140e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3010 1412 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3011 1416 1A6C     		ldr	r2, [r3, #64]
 3012 1418 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3013 141c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3014 1420 1B6C     		ldr	r3, [r3, #64]
 3015 1422 03F16C03 		add	r3, r3, #108
 3016 1426 5360     		str	r3, [r2, #4]
1425:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(      ieee154e_vars.wakeupReceived->payload,
 3017              		.loc 1 1425 0
 3018 1428 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3019 142c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3020 1430 1B6C     		ldr	r3, [r3, #64]
 3021 1432 5968     		ldr	r1, [r3, #4]
1426:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.wakeupReceived->length,
 3022              		.loc 1 1426 0
 3023 1434 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3024 1438 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3025 143c 1B6C     		ldr	r3, [r3, #64]
1425:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(      ieee154e_vars.wakeupReceived->payload,
 3026              		.loc 1 1425 0
 3027 143e 03F10802 		add	r2, r3, #8
1427:openstack/02a-MAClow/IEEE802154Ecsl.c ****                              sizeof(ieee154e_vars.wakeupReceived->packet),
1428:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.wakeupReceived->l1_rssi,
 3028              		.loc 1 1428 0
 3029 1442 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3030 1446 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3031 144a 1B6C     		ldr	r3, [r3, #64]
1425:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(      ieee154e_vars.wakeupReceived->payload,
 3032              		.loc 1 1425 0
 3033 144c 03F16804 		add	r4, r3, #104
1429:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.wakeupReceived->l1_lqi,
 3034              		.loc 1 1429 0
 3035 1450 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3036 1454 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3037 1458 1B6C     		ldr	r3, [r3, #64]
1425:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(      ieee154e_vars.wakeupReceived->payload,
 3038              		.loc 1 1425 0
 3039 145a 03F16900 		add	r0, r3, #105
1430:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.wakeupReceived->l1_crc);
 3040              		.loc 1 1430 0
 3041 145e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3042 1462 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3043 1466 1B6C     		ldr	r3, [r3, #64]
1425:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(      ieee154e_vars.wakeupReceived->payload,
 3044              		.loc 1 1425 0
 3045 1468 03F16A03 		add	r3, r3, #106
 3046 146c 0090     		str	r0, [sp, #0]
 3047 146e 0193     		str	r3, [sp, #4]
 3048 1470 0846     		mov	r0, r1
 3049 1472 1146     		mov	r1, r2
 3050 1474 4FF08202 		mov	r2, #130
 3051 1478 2346     		mov	r3, r4
 3052 147a FFF7FEFF 		bl	radio_getReceivedFrame
1431:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1432:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Finalizamos si la longitud no es correcta.
1433:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.wakeupReceived->length<LENGTH_CRC || ieee154e_vars.wakeupReceived->length>L
 3053              		.loc 1 1433 0
 3054 147e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3055 1482 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3056 1486 1B6C     		ldr	r3, [r3, #64]
 3057 1488 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 3058 148a 012B     		cmp	r3, #1
 3059 148c 07D9     		bls	.L152
 3060              		.loc 1 1433 0 is_stmt 0 discriminator 1
 3061 148e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3062 1492 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3063 1496 1B6C     		ldr	r3, [r3, #64]
 3064 1498 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 3065 149a 802B     		cmp	r3, #128
 3066 149c 0ED9     		bls	.L153
 3067              	.L152:
1434:openstack/02a-MAClow/IEEE802154Ecsl.c ****         openserial_printError(COMPONENT_IEEE802154E,ERR_INVALIDPACKETFROMRADIO, (errorparameter_t)2
 3068              		.loc 1 1434 0 is_stmt 1
 3069 149e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3070 14a2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3071 14a6 1B6C     		ldr	r3, [r3, #64]
 3072 14a8 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 3073 14aa 4FF00900 		mov	r0, #9
 3074 14ae 4FF03701 		mov	r1, #55
 3075 14b2 4FF00202 		mov	r2, #2
 3076 14b6 FFF7FEFF 		bl	openserial_printError
1435:openstack/02a-MAClow/IEEE802154Ecsl.c ****         break;
 3077              		.loc 1 1435 0
 3078 14ba C8E0     		b	.L154
 3079              	.L153:
1436:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1437:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1438:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // toss CRC (2 últimos bytes)
1439:openstack/02a-MAClow/IEEE802154Ecsl.c ****       packetfunctions_tossFooter(ieee154e_vars.wakeupReceived, LENGTH_CRC);
 3080              		.loc 1 1439 0
 3081 14bc 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3082 14c0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3083 14c4 1B6C     		ldr	r3, [r3, #64]
 3084 14c6 1846     		mov	r0, r3
 3085 14c8 4FF00201 		mov	r1, #2
 3086 14cc FFF7FEFF 		bl	packetfunctions_tossFooter
1440:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1441:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // si CRC no es válido, finalizamos el proceso.
1442:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.wakeupReceived->l1_crc==FALSE) { break; }
 3087              		.loc 1 1442 0
 3088 14d0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3089 14d4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3090 14d8 1B6C     		ldr	r3, [r3, #64]
 3091 14da 93F86A30 		ldrb	r3, [r3, #106]	@ zero_extendqisi2
 3092 14de 83F00103 		eor	r3, r3, #1
 3093 14e2 DBB2     		uxtb	r3, r3
 3094 14e4 002B     		cmp	r3, #0
 3095 14e6 40F0AD80 		bne	.L162
 3096              	.L155:
1443:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1444:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // parseamos la trama IEEE802.15.4 WAKE-UP y su cabecera.
1445:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee802154_retrieveWakeUpFrame(ieee154e_vars.wakeupReceived,&ieee802514_header,&rztime);
 3097              		.loc 1 1445 0
 3098 14ea 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3099 14ee C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3100 14f2 196C     		ldr	r1, [r3, #64]
 3101 14f4 07F13802 		add	r2, r7, #56
 3102 14f8 07F10E03 		add	r3, r7, #14
 3103 14fc 0846     		mov	r0, r1
 3104 14fe 1146     		mov	r1, r2
 3105 1500 1A46     		mov	r2, r3
 3106 1502 FFF7FEFF 		bl	ieee802154_retrieveWakeUpFrame
1446:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1447:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // En el caso de que no sea una cabecera IEEE802.15.4 válida, finalizamos el proceso.
1448:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee802514_header.valid==FALSE) { break; }
 3107              		.loc 1 1448 0
 3108 1506 97F83830 		ldrb	r3, [r7, #56]	@ zero_extendqisi2
 3109 150a 83F00103 		eor	r3, r3, #1
 3110 150e DBB2     		uxtb	r3, r3
 3111 1510 002B     		cmp	r3, #0
 3112 1512 40F09980 		bne	.L163
 3113              	.L156:
1449:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1450:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Verificamos que se trata de una trama WAKE-UP, perteneciente a la misma PAN ID, y dirigida
1451:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if(ieee802514_header.frameType==IEEE154_TYPE_MULTIPURPOSE) {
 3114              		.loc 1 1451 0
 3115 1516 97F83A30 		ldrb	r3, [r7, #58]	@ zero_extendqisi2
 3116 151a 052B     		cmp	r3, #5
 3117 151c 40F09680 		bne	.L164
1452:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	  // Comentado y sustituido para CSL TESTING ya que está hard-codeada la direccion.
1453:openstack/02a-MAClow/IEEE802154Ecsl.c ****      	  //if(packetfunctions_sameAddress(&ieee802514_header.dest,idmanager_getMyID(ADDR_16B)) &&
1454:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	  // CSL TEST
1455:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	  packetfunctions_mac64bToMac16b(&myID,&myID16b);
 3118              		.loc 1 1455 0
 3119 1520 07F12402 		add	r2, r7, #36
 3120 1524 07F11003 		add	r3, r7, #16
 3121 1528 1046     		mov	r0, r2
 3122 152a 1946     		mov	r1, r3
 3123 152c FFF7FEFF 		bl	packetfunctions_mac64bToMac16b
1456:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	  if(packetfunctions_sameAddress(&ieee802514_header.dest, &myID16b) &&
 3124              		.loc 1 1456 0
 3125 1530 07F13803 		add	r3, r7, #56
 3126 1534 03F11B02 		add	r2, r3, #27
 3127 1538 07F11003 		add	r3, r7, #16
 3128 153c 1046     		mov	r0, r2
 3129 153e 1946     		mov	r1, r3
 3130 1540 FFF7FEFF 		bl	packetfunctions_sameAddress
 3131 1544 0346     		mov	r3, r0
 3132 1546 002B     		cmp	r3, #0
 3133 1548 43D0     		beq	.L158
1457:openstack/02a-MAClow/IEEE802154Ecsl.c ****    		  // END CSL TEST
1458:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     packetfunctions_sameAddress(&ieee802514_header.panid,idmanager_getMyID(ADDR_PANID))) {
 3134              		.loc 1 1458 0 discriminator 1
 3135 154a 4FF00400 		mov	r0, #4
 3136 154e FFF7FEFF 		bl	idmanager_getMyID
 3137 1552 0346     		mov	r3, r0
 3138 1554 07F13802 		add	r2, r7, #56
 3139 1558 02F10A02 		add	r2, r2, #10
 3140 155c 1046     		mov	r0, r2
 3141 155e 1946     		mov	r1, r3
 3142 1560 FFF7FEFF 		bl	packetfunctions_sameAddress
 3143 1564 0346     		mov	r3, r0
1456:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	  if(packetfunctions_sameAddress(&ieee802514_header.dest, &myID16b) &&
 3144              		.loc 1 1456 0 discriminator 1
 3145 1566 002B     		cmp	r3, #0
 3146 1568 33D0     		beq	.L158
1459:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1460:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	   // En este caso, debemos dormir el tiempo indicado por RZ Time, estableciendo el estado a S
1461:openstack/02a-MAClow/IEEE802154Ecsl.c ****  	       changeState(S_CSLRXDATAOFFSET);
 3147              		.loc 1 1461 0
 3148 156a 4FF03100 		mov	r0, #49
 3149 156e FFF7FEFF 		bl	changeState
1462:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1463:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	   // registro del tiempo de captura
1464:openstack/02a-MAClow/IEEE802154Ecsl.c ****            ieee154e_vars.lastCapturedTime = capturedTime;
 3150              		.loc 1 1464 0
 3151 1572 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3152 1576 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3153 157a 7A68     		ldr	r2, [r7, #4]
 3154 157c 5A62     		str	r2, [r3, #36]
1465:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1466:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	   // Tratamos el caso en el cual rztime_ie.time sea cero, es decir, sea la ultima trama wake-
1467:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	   if (rztime == 0) {
 3155              		.loc 1 1467 0
 3156 157e FB89     		ldrh	r3, [r7, #14]
 3157 1580 002B     		cmp	r3, #0
 3158 1582 0AD1     		bne	.L159
1468:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     // Establecemos el timer rt1 (consideramos el mismo tiempo de offset para la recepción d
1469:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     radiotimer_schedule(DURATION_rt1);
 3159              		.loc 1 1469 0
 3160 1584 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3161 1588 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3162 158c 5B6A     		ldr	r3, [r3, #36]
 3163 158e 03F13703 		add	r3, r3, #55
 3164 1592 1846     		mov	r0, r3
 3165 1594 FFF7FEFF 		bl	radiotimer_schedule
 3166 1598 0BE0     		b	.L160
 3167              	.L159:
1470:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	   } else {
1471:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     // Establecemos el timer al valor rt1 pero desplazado el tiempo indicado por rendezvous-t
1472:openstack/02a-MAClow/IEEE802154Ecsl.c ****         	 radiotimer_schedule(DURATION_rt1 + rztime);
 3168              		.loc 1 1472 0
 3169 159a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3170 159e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3171 15a2 5A6A     		ldr	r2, [r3, #36]
 3172 15a4 FB89     		ldrh	r3, [r7, #14]
 3173 15a6 D318     		adds	r3, r2, r3
 3174 15a8 03F13703 		add	r3, r3, #55
 3175 15ac 1846     		mov	r0, r3
 3176 15ae FFF7FEFF 		bl	radiotimer_schedule
 3177              	.L160:
1473:openstack/02a-MAClow/IEEE802154Ecsl.c ****            }
1474:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1475:openstack/02a-MAClow/IEEE802154Ecsl.c ****            // Descartamos el paquete una vez recibido y tratado.
1476:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1477:openstack/02a-MAClow/IEEE802154Ecsl.c ****            openqueue_freePacketBuffer(ieee154e_vars.wakeupReceived);
 3178              		.loc 1 1477 0
 3179 15b2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3180 15b6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3181 15ba 1B6C     		ldr	r3, [r3, #64]
 3182 15bc 1846     		mov	r0, r3
 3183 15be FFF7FEFF 		bl	openqueue_freePacketBuffer
1478:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1479:openstack/02a-MAClow/IEEE802154Ecsl.c ****            // clear local variable
1480:openstack/02a-MAClow/IEEE802154Ecsl.c ****            ieee154e_vars.wakeupReceived = NULL;
 3184              		.loc 1 1480 0
 3185 15c2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3186 15c6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3187 15ca 4FF00002 		mov	r2, #0
 3188 15ce 1A64     		str	r2, [r3, #64]
 3189 15d0 4EE0     		b	.L149
 3190              	.L158:
1481:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1482:openstack/02a-MAClow/IEEE802154Ecsl.c ****            // retornamos para no ejecutar el codigo inferior y finalizar el proceso.
1483:openstack/02a-MAClow/IEEE802154Ecsl.c ****            return;
1484:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 }
1485:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 // En el caso que sea una trama dentro de mi PANID pero no dirigida a mi, entonces dormimos u
1486:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 //   - RZ time + Maximum length payload frame + secure ack frame (consideraremos un tiempo ig
1487:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 // dado que TsSlotDuration es el tiempo utilizado en OpenWSN-TSCH para enviar y recibir una t
1488:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 // en cualquier caso revisar estos timings mediante medidas y mecanismos más precisos (oscil
1489:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1490:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 else if( ! packetfunctions_sameAddress(&ieee802514_header.dest,idmanager_getMyID(ADDR_16B)) &
 3191              		.loc 1 1490 0
 3192 15d2 4FF00100 		mov	r0, #1
 3193 15d6 FFF7FEFF 		bl	idmanager_getMyID
 3194 15da 0346     		mov	r3, r0
 3195 15dc 07F13802 		add	r2, r7, #56
 3196 15e0 02F11B02 		add	r2, r2, #27
 3197 15e4 1046     		mov	r0, r2
 3198 15e6 1946     		mov	r1, r3
 3199 15e8 FFF7FEFF 		bl	packetfunctions_sameAddress
 3200 15ec 0346     		mov	r3, r0
 3201 15ee 83F00103 		eor	r3, r3, #1
 3202 15f2 DBB2     		uxtb	r3, r3
 3203 15f4 002B     		cmp	r3, #0
 3204 15f6 2AD0     		beq	.L154
1491:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	   		    packetfunctions_sameAddress(&ieee802514_header.panid,idmanager_getMyID(ADDR_PANID))) 
 3205              		.loc 1 1491 0 discriminator 1
 3206 15f8 4FF00400 		mov	r0, #4
 3207 15fc FFF7FEFF 		bl	idmanager_getMyID
 3208 1600 0346     		mov	r3, r0
 3209 1602 07F13802 		add	r2, r7, #56
 3210 1606 02F10A02 		add	r2, r2, #10
 3211 160a 1046     		mov	r0, r2
 3212 160c 1946     		mov	r1, r3
 3213 160e FFF7FEFF 		bl	packetfunctions_sameAddress
 3214 1612 0346     		mov	r3, r0
1490:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 else if( ! packetfunctions_sameAddress(&ieee802514_header.dest,idmanager_getMyID(ADDR_16B)) &
 3215              		.loc 1 1490 0 discriminator 1
 3216 1614 002B     		cmp	r3, #0
 3217 1616 1AD0     		beq	.L154
1492:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1493:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     // La limpieza del paquete y los datos recibidos será realizada en el metodo activity_cs
1494:openstack/02a-MAClow/IEEE802154Ecsl.c ****     		 radiotimer_schedule(rztime + TsSlotDuration);
 3218              		.loc 1 1494 0
 3219 1618 FB89     		ldrh	r3, [r7, #14]
 3220 161a 03F5F673 		add	r3, r3, #492
 3221 161e 1846     		mov	r0, r3
 3222 1620 FFF7FEFF 		bl	radiotimer_schedule
1495:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1496:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     // Descartamos el paquete una vez recibido y tratado.
1497:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1498:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     openqueue_freePacketBuffer(ieee154e_vars.wakeupReceived);
 3223              		.loc 1 1498 0
 3224 1624 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3225 1628 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3226 162c 1B6C     		ldr	r3, [r3, #64]
 3227 162e 1846     		mov	r0, r3
 3228 1630 FFF7FEFF 		bl	openqueue_freePacketBuffer
1499:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1500:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     // clear local variable
1501:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     ieee154e_vars.wakeupReceived = NULL;
 3229              		.loc 1 1501 0
 3230 1634 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3231 1638 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3232 163c 4FF00002 		mov	r2, #0
 3233 1640 1A64     		str	r2, [r3, #64]
 3234 1642 15E0     		b	.L149
 3235              	.L162:
1442:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.wakeupReceived->l1_crc==FALSE) { break; }
 3236              		.loc 1 1442 0
 3237 1644 00BF     		nop
 3238 1646 02E0     		b	.L154
 3239              	.L163:
1448:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee802514_header.valid==FALSE) { break; }
 3240              		.loc 1 1448 0
 3241 1648 00BF     		nop
 3242 164a 00E0     		b	.L154
 3243              	.L164:
1502:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1503:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	     return;
1504:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 }
1505:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1506:openstack/02a-MAClow/IEEE802154Ecsl.c ****       else {
1507:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	  break; // cualquier otro tipo de trama recibida en este punto de la FSM es descartada.
 3244              		.loc 1 1507 0
 3245 164c 00BF     		nop
 3246              	.L154:
1508:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1509:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1510:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } while(0);
1511:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1512:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // En cualquier otro caso, descartamos el paquete e iniciamos de nuevo el proceso de channel sam
1513:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1514:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openqueue_freePacketBuffer(ieee154e_vars.wakeupReceived);
 3247              		.loc 1 1514 0
 3248 164e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3249 1652 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3250 1656 1B6C     		ldr	r3, [r3, #64]
 3251 1658 1846     		mov	r0, r3
 3252 165a FFF7FEFF 		bl	openqueue_freePacketBuffer
1515:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1516:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clear local variable
1517:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.wakeupReceived = NULL;
 3253              		.loc 1 1517 0
 3254 165e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3255 1662 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3256 1666 4FF00002 		mov	r2, #0
 3257 166a 1A64     		str	r2, [r3, #64]
1518:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1519:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1520:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 3258              		.loc 1 1520 0
 3259 166c FFF7FEFF 		bl	endOps
 3260              	.L149:
1521:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3261              		.loc 1 1521 0
 3262 1670 07F17C07 		add	r7, r7, #124
 3263 1674 BD46     		mov	sp, r7
 3264 1676 90BD     		pop	{r4, r7, pc}
 3265              		.cfi_endproc
 3266              	.LFE37:
 3268              		.align	2
 3269              		.global	activity_csl_wakeup_rie4
 3270              		.thumb
 3271              		.thumb_func
 3273              	activity_csl_wakeup_rie4:
 3274              	.LFB38:
1522:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1523:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1524:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1525:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling error [wake-up rie4].
1526:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1527:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by rztime+TsSlotDuration expiring, i.e. timer fires while state = S_CSLRXWAKEUP
1528:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The behaviour is to free mem used and restart CSL sampling.
1529:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1530:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_wakeup_rie4() {
 3275              		.loc 1 1530 0
 3276              		.cfi_startproc
 3277              		@ args = 0, pretend = 0, frame = 0
 3278              		@ frame_needed = 1, uses_anonymous_args = 0
 3279 1678 80B5     		push	{r7, lr}
 3280              	.LCFI89:
 3281              		.cfi_def_cfa_offset 8
 3282              		.cfi_offset 7, -8
 3283              		.cfi_offset 14, -4
 3284 167a 00AF     		add	r7, sp, #0
 3285              	.LCFI90:
 3286              		.cfi_def_cfa_register 7
1531:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1532:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 3287              		.loc 1 1532 0
 3288 167c FFF7FEFF 		bl	endOps
1533:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3289              		.loc 1 1533 0
 3290 1680 80BD     		pop	{r7, pc}
 3291              		.cfi_endproc
 3292              	.LFE38:
 3294 1682 00BF     		.align	2
 3295              		.global	activity_csl_data_ri2
 3296              		.thumb
 3297              		.thumb_func
 3299              	activity_csl_data_ri2:
 3300              	.LFB39:
1534:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1535:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1536:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1537:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri2].
1538:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1539:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1540:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to prepare the radio for receiving packets.
1541:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1542:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1543:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri2() {
 3301              		.loc 1 1543 0
 3302              		.cfi_startproc
 3303              		@ args = 0, pretend = 0, frame = 0
 3304              		@ frame_needed = 1, uses_anonymous_args = 0
 3305 1684 80B5     		push	{r7, lr}
 3306              	.LCFI91:
 3307              		.cfi_def_cfa_offset 8
 3308              		.cfi_offset 7, -8
 3309              		.cfi_offset 14, -4
 3310 1686 00AF     		add	r7, sp, #0
 3311              	.LCFI92:
 3312              		.cfi_def_cfa_register 7
1544:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1545:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXDATAPREPARE);
 3313              		.loc 1 1545 0
 3314 1688 4FF03200 		mov	r0, #50
 3315 168c FFF7FEFF 		bl	changeState
1546:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1547:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // We use always the same frequency so it is not necessary to change it on radio.
1548:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Enable the radio in Rx mode. The radio does not actively listen yet.
1549:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rxEnable();
 3316              		.loc 1 1549 0
 3317 1690 FFF7FEFF 		bl	radio_rxEnable
1550:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnInit=radio_getTimerValue();
 3318              		.loc 1 1550 0
 3319 1694 FFF7FEFF 		bl	radio_getTimerValue
 3320 1698 0246     		mov	r2, r0
 3321 169a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3322 169e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3323 16a2 1A63     		str	r2, [r3, #48]
1551:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnThisSlot=TRUE;
 3324              		.loc 1 1551 0
 3325 16a4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3326 16a8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3327 16ac 4FF00102 		mov	r2, #1
 3328 16b0 83F83820 		strb	r2, [r3, #56]
1552:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1553:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt2
1554:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt2);
 3329              		.loc 1 1554 0
 3330 16b4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3331 16b8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3332 16bc 5B6A     		ldr	r3, [r3, #36]
 3333 16be 03F15803 		add	r3, r3, #88
 3334 16c2 1846     		mov	r0, r3
 3335 16c4 FFF7FEFF 		bl	radiotimer_schedule
1555:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1556:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1557:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // If this action is not performed before rt2 has expired, we need to manage the error in activi
1558:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // prepare has exceeded the maximum allowed time (duration_rt2).
1559:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXDATAREADY);
 3336              		.loc 1 1559 0
 3337 16c8 4FF03300 		mov	r0, #51
 3338 16cc FFF7FEFF 		bl	changeState
1560:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3339              		.loc 1 1560 0
 3340 16d0 80BD     		pop	{r7, pc}
 3341              		.cfi_endproc
 3342              	.LFE39:
 3344 16d2 00BF     		.align	2
 3345              		.global	activity_csl_data_rie1
 3346              		.thumb
 3347              		.thumb_func
 3349              	activity_csl_data_rie1:
 3350              	.LFB40:
1561:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1562:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1563:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1564:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling error [data_rie1].
1565:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1566:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #rt2 expiring, i.e. timer fires while state = S_CSLRXDATAPREPARE. This is re
1567:openstack/02a-MAClow/IEEE802154Ecsl.c ****   did not have enough time to execute. Chances are to set maxRxDataPrepare too small. The implement
1568:openstack/02a-MAClow/IEEE802154Ecsl.c ****   next CSL sample.
1569:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1570:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_rie1() {  // Activity for error event [rie1] on CSL RX Sampling.
 3351              		.loc 1 1570 0
 3352              		.cfi_startproc
 3353              		@ args = 0, pretend = 0, frame = 0
 3354              		@ frame_needed = 1, uses_anonymous_args = 0
 3355 16d4 80B5     		push	{r7, lr}
 3356              	.LCFI93:
 3357              		.cfi_def_cfa_offset 8
 3358              		.cfi_offset 7, -8
 3359              		.cfi_offset 14, -4
 3360 16d6 00AF     		add	r7, sp, #0
 3361              	.LCFI94:
 3362              		.cfi_def_cfa_register 7
1571:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
1572:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXDATAPREPARE_OVERFLOWS,
1573:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state,
 3363              		.loc 1 1573 0
 3364 16d8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3365 16dc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3366 16e0 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1572:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXDATAPREPARE_OVERFLOWS,
 3367              		.loc 1 1572 0
 3368 16e2 1A46     		mov	r2, r3
1574:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_dbg.num_cslSamples);
 3369              		.loc 1 1574 0
 3370 16e4 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 3371 16e8 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 3372 16ec 1B69     		ldr	r3, [r3, #16]
1572:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXDATAPREPARE_OVERFLOWS,
 3373              		.loc 1 1572 0
 3374 16ee 9BB2     		uxth	r3, r3
 3375 16f0 4FF00900 		mov	r0, #9
 3376 16f4 4FF02401 		mov	r1, #36
 3377 16f8 FFF7FEFF 		bl	openserial_printError
1575:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1576:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 3378              		.loc 1 1576 0
 3379 16fc FFF7FEFF 		bl	endOps
1577:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3380              		.loc 1 1577 0
 3381 1700 80BD     		pop	{r7, pc}
 3382              		.cfi_endproc
 3383              	.LFE40:
 3385 1702 00BF     		.align	2
 3386              		.global	activity_csl_data_ri3
 3387              		.thumb
 3388              		.thumb_func
 3390              	activity_csl_data_ri3:
 3391              	.LFB41:
1578:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1579:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1580:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1581:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri3].
1582:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1583:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1584:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The radio is configured and this interrupt gives it the "go" signal to start listening.
1585:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1586:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri3() { // Activity for stage [data ri3] on CSL RX Sampling.
 3392              		.loc 1 1586 0
 3393              		.cfi_startproc
 3394              		@ args = 0, pretend = 0, frame = 0
 3395              		@ frame_needed = 1, uses_anonymous_args = 0
 3396 1704 80B5     		push	{r7, lr}
 3397              	.LCFI95:
 3398              		.cfi_def_cfa_offset 8
 3399              		.cfi_offset 7, -8
 3400              		.cfi_offset 14, -4
 3401 1706 00AF     		add	r7, sp, #0
 3402              	.LCFI96:
 3403              		.cfi_def_cfa_register 7
1587:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1588:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXDATALISTEN);
 3404              		.loc 1 1588 0
 3405 1708 4FF03400 		mov	r0, #52
 3406 170c FFF7FEFF 		bl	changeState
1589:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1590:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // give the 'go' to receive
1591:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rxNow();
 3407              		.loc 1 1591 0
 3408 1710 FFF7FEFF 		bl	radio_rxNow
1592:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1593:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt3
1594:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt3);
 3409              		.loc 1 1594 0
 3410 1714 40F24110 		movw	r0, #321
 3411 1718 FFF7FEFF 		bl	radiotimer_schedule
1595:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3412              		.loc 1 1595 0
 3413 171c 80BD     		pop	{r7, pc}
 3414              		.cfi_endproc
 3415              	.LFE41:
 3417 171e 00BF     		.align	2
 3418              		.global	activity_csl_data_rie2
 3419              		.thumb
 3420              		.thumb_func
 3422              	activity_csl_data_rie2:
 3423              	.LFB42:
1596:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1597:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1598:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1599:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling error [data rie2].
1600:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1601:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #rt3 expiring, i.e. timer fires while state = S_CSLRXDATALISTEN. If no packe
1602:openstack/02a-MAClow/IEEE802154Ecsl.c ****   none will be received ever and it is safe to switch of the radio. This timer is set such that the
1603:openstack/02a-MAClow/IEEE802154Ecsl.c ****   duration (#TsLongGT).
1604:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1605:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_rie2() { // Activity for error event [data rie2] on CSL RX Sampl
 3424              		.loc 1 1605 0
 3425              		.cfi_startproc
 3426              		@ args = 0, pretend = 0, frame = 0
 3427              		@ frame_needed = 1, uses_anonymous_args = 0
 3428 1720 80B5     		push	{r7, lr}
 3429              	.LCFI97:
 3430              		.cfi_def_cfa_offset 8
 3431              		.cfi_offset 7, -8
 3432              		.cfi_offset 14, -4
 3433 1722 00AF     		add	r7, sp, #0
 3434              	.LCFI98:
 3435              		.cfi_def_cfa_register 7
1606:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1607:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 3436              		.loc 1 1607 0
 3437 1724 FFF7FEFF 		bl	endOps
1608:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3438              		.loc 1 1608 0
 3439 1728 80BD     		pop	{r7, pc}
 3440              		.cfi_endproc
 3441              	.LFE42:
 3443 172a 00BF     		.align	2
 3444              		.global	activity_csl_data_ri4
 3445              		.thumb
 3446              		.thumb_func
 3448              	activity_csl_data_ri4:
 3449              	.LFB43:
1609:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1610:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1611:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri4].
1612:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1613:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_startOfFrame" function when a start of frame ev
1614:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to capture the time, cancel #rt3 and arm #rt4 (max time to receive all the p
1615:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1616:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri4(PORT_RADIOTIMER_WIDTH capturedTime) {  // Activity for stage
 3450              		.loc 1 1616 0
 3451              		.cfi_startproc
 3452              		@ args = 0, pretend = 0, frame = 8
 3453              		@ frame_needed = 1, uses_anonymous_args = 0
 3454 172c 80B5     		push	{r7, lr}
 3455              	.LCFI99:
 3456              		.cfi_def_cfa_offset 8
 3457              		.cfi_offset 7, -8
 3458              		.cfi_offset 14, -4
 3459 172e 82B0     		sub	sp, sp, #8
 3460              	.LCFI100:
 3461              		.cfi_def_cfa_offset 16
 3462 1730 00AF     		add	r7, sp, #0
 3463              	.LCFI101:
 3464              		.cfi_def_cfa_register 7
 3465 1732 7860     		str	r0, [r7, #4]
1617:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1618:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1619:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXDATA);
 3466              		.loc 1 1619 0
 3467 1734 4FF03500 		mov	r0, #53
 3468 1738 FFF7FEFF 		bl	changeState
1620:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1621:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel rt3
1622:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 3469              		.loc 1 1622 0
 3470 173c FFF7FEFF 		bl	radiotimer_cancel
1623:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1624:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
1625:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.lastCapturedTime = capturedTime;
 3471              		.loc 1 1625 0
 3472 1740 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3473 1744 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3474 1748 7A68     		ldr	r2, [r7, #4]
 3475 174a 5A62     		str	r2, [r3, #36]
1626:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1627:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time to sync
1628:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.syncCapturedTime = capturedTime;
 3476              		.loc 1 1628 0
 3477 174c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3478 1750 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3479 1754 7A68     		ldr	r2, [r7, #4]
 3480 1756 9A62     		str	r2, [r3, #40]
1629:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1630:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt4);
 3481              		.loc 1 1630 0
 3482 1758 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3483 175c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3484 1760 5B6A     		ldr	r3, [r3, #36]
 3485 1762 03F1A403 		add	r3, r3, #164
 3486 1766 1846     		mov	r0, r3
 3487 1768 FFF7FEFF 		bl	radiotimer_schedule
1631:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3488              		.loc 1 1631 0
 3489 176c 07F10807 		add	r7, r7, #8
 3490 1770 BD46     		mov	sp, r7
 3491 1772 80BD     		pop	{r7, pc}
 3492              		.cfi_endproc
 3493              	.LFE43:
 3495              		.align	2
 3496              		.global	activity_csl_data_rie3
 3497              		.thumb
 3498              		.thumb_func
 3500              	activity_csl_data_rie3:
 3501              	.LFB44:
1632:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1633:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1634:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1635:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling error [data rie3].
1636:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1637:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This is triggered by #rt4 expiring, i.e. timer fires while state = S_CSLRXDATA. This is an error 
1638:openstack/02a-MAClow/IEEE802154Ecsl.c ****   transmit the data packet. The implemented behaviour is to log the error and move on the next CSL 
1639:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1640:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_rie3() {
 3502              		.loc 1 1640 0
 3503              		.cfi_startproc
 3504              		@ args = 0, pretend = 0, frame = 0
 3505              		@ frame_needed = 1, uses_anonymous_args = 0
 3506 1774 80B5     		push	{r7, lr}
 3507              	.LCFI102:
 3508              		.cfi_def_cfa_offset 8
 3509              		.cfi_offset 7, -8
 3510              		.cfi_offset 14, -4
 3511 1776 00AF     		add	r7, sp, #0
 3512              	.LCFI103:
 3513              		.cfi_def_cfa_register 7
1641:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1642:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
1643:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
1644:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state,
 3514              		.loc 1 1644 0
 3515 1778 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3516 177c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3517 1780 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1643:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
 3518              		.loc 1 1643 0
 3519 1782 1A46     		mov	r2, r3
1645:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_dbg.num_cslSamples);
 3520              		.loc 1 1645 0
 3521 1784 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 3522 1788 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 3523 178c 1B69     		ldr	r3, [r3, #16]
1643:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
 3524              		.loc 1 1643 0
 3525 178e 9BB2     		uxth	r3, r3
 3526 1790 4FF00900 		mov	r0, #9
 3527 1794 4FF02601 		mov	r1, #38
 3528 1798 FFF7FEFF 		bl	openserial_printError
1646:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1647:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1648:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 3529              		.loc 1 1648 0
 3530 179c FFF7FEFF 		bl	endOps
1649:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3531              		.loc 1 1649 0
 3532 17a0 80BD     		pop	{r7, pc}
 3533              		.cfi_endproc
 3534              	.LFE44:
 3536 17a2 00BF     		.align	2
 3537              		.global	activity_csl_data_ri5
 3538              		.thumb
 3539              		.thumb_func
 3541              	activity_csl_data_ri5:
 3542              	.LFB45:
1650:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1651:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1652:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri5].
1653:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1654:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_endOfFrame" function when a end of frame event 
1655:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change state, cancel #rt4, validate data frame, and transmit ACK.
1656:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1657:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri5(PORT_RADIOTIMER_WIDTH capturedTime) {
 3543              		.loc 1 1657 0
 3544              		.cfi_startproc
 3545              		@ args = 0, pretend = 0, frame = 80
 3546              		@ frame_needed = 1, uses_anonymous_args = 0
 3547 17a4 B0B5     		push	{r4, r5, r7, lr}
 3548              	.LCFI104:
 3549              		.cfi_def_cfa_offset 16
 3550              		.cfi_offset 4, -16
 3551              		.cfi_offset 5, -12
 3552              		.cfi_offset 7, -8
 3553              		.cfi_offset 14, -4
 3554 17a6 96B0     		sub	sp, sp, #88
 3555              	.LCFI105:
 3556              		.cfi_def_cfa_offset 104
 3557 17a8 02AF     		add	r7, sp, #8
 3558              	.LCFI106:
 3559              		.cfi_def_cfa 7, 96
 3560 17aa 7860     		str	r0, [r7, #4]
1658:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802154_header_iht ieee802514_header;
1659:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint16_t lenIE=0;
 3561              		.loc 1 1659 0
 3562 17ac 4FF00003 		mov	r3, #0
 3563 17b0 FB81     		strh	r3, [r7, #14]	@ movhi
1660:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1661:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1662:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXACKOFFSET);
 3564              		.loc 1 1662 0
 3565 17b2 4FF03600 		mov	r0, #54
 3566 17b6 FFF7FEFF 		bl	changeState
1663:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1664:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel rt4
1665:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 3567              		.loc 1 1665 0
 3568 17ba FFF7FEFF 		bl	radiotimer_cancel
1666:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1667:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // turn off the radio
1668:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rfOff();
 3569              		.loc 1 1668 0
 3570 17be FFF7FEFF 		bl	radio_rfOff
1669:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnTics+=radio_getTimerValue()-ieee154e_vars.radioOnInit;
 3571              		.loc 1 1669 0
 3572 17c2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3573 17c6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3574 17ca 5C6B     		ldr	r4, [r3, #52]
 3575 17cc FFF7FEFF 		bl	radio_getTimerValue
 3576 17d0 0246     		mov	r2, r0
 3577 17d2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3578 17d6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3579 17da 1B6B     		ldr	r3, [r3, #48]
 3580 17dc D31A     		subs	r3, r2, r3
 3581 17de E218     		adds	r2, r4, r3
 3582 17e0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3583 17e4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3584 17e8 5A63     		str	r2, [r3, #52]
1670:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // get a buffer to put the (received) data in
1671:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.dataReceived = openqueue_getFreePacketBuffer(COMPONENT_IEEE802154E);
 3585              		.loc 1 1671 0
 3586 17ea 4FF00900 		mov	r0, #9
 3587 17ee FFF7FEFF 		bl	openqueue_getFreePacketBuffer
 3588 17f2 0246     		mov	r2, r0
 3589 17f4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3590 17f8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3591 17fc 9A61     		str	r2, [r3, #24]
1672:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.dataReceived==NULL) {
 3592              		.loc 1 1672 0
 3593 17fe 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3594 1802 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3595 1806 9B69     		ldr	r3, [r3, #24]
 3596 1808 002B     		cmp	r3, #0
 3597 180a 0CD1     		bne	.L173
1673:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // log the error
1674:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openserial_printError(COMPONENT_IEEE802154E,ERR_NO_FREE_PACKET_BUFFER,
 3598              		.loc 1 1674 0
 3599 180c 4FF00900 		mov	r0, #9
 3600 1810 4FF02C01 		mov	r1, #44
 3601 1814 4FF00002 		mov	r2, #0
 3602 1818 4FF00003 		mov	r3, #0
 3603 181c FFF7FEFF 		bl	openserial_printError
1675:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)0,
1676:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)0);
1677:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // abort
1678:openstack/02a-MAClow/IEEE802154Ecsl.c ****       endOps();
 3604              		.loc 1 1678 0
 3605 1820 FFF7FEFF 		bl	endOps
 3606 1824 3FE1     		b	.L172
 3607              	.L173:
1679:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return;
1680:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
1681:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1682:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // declare ownership over that packet
1683:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.dataReceived->creator = COMPONENT_IEEE802154E;
 3608              		.loc 1 1683 0
 3609 1826 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3610 182a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3611 182e 9B69     		ldr	r3, [r3, #24]
 3612 1830 4FF00902 		mov	r2, #9
 3613 1834 1A70     		strb	r2, [r3, #0]
1684:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.dataReceived->owner   = COMPONENT_IEEE802154E;
 3614              		.loc 1 1684 0
 3615 1836 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3616 183a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3617 183e 9B69     		ldr	r3, [r3, #24]
 3618 1840 4FF00902 		mov	r2, #9
 3619 1844 5A70     		strb	r2, [r3, #1]
1685:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1686:openstack/02a-MAClow/IEEE802154Ecsl.c ****    /*
1687:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The do-while loop that follows is a little parsing trick.
1688:openstack/02a-MAClow/IEEE802154Ecsl.c ****    Because it contains a while(0) condition, it gets executed only once.
1689:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The behavior is:
1690:openstack/02a-MAClow/IEEE802154Ecsl.c ****    - if a break occurs inside the do{} body, the error code below the loop
1691:openstack/02a-MAClow/IEEE802154Ecsl.c ****      gets executed. This indicates something is wrong with the packet being
1692:openstack/02a-MAClow/IEEE802154Ecsl.c ****      parsed.
1693:openstack/02a-MAClow/IEEE802154Ecsl.c ****    - if a return occurs inside the do{} body, the error code below the loop
1694:openstack/02a-MAClow/IEEE802154Ecsl.c ****      does not get executed. This indicates the received packet is correct.
1695:openstack/02a-MAClow/IEEE802154Ecsl.c ****    */
1696:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1697:openstack/02a-MAClow/IEEE802154Ecsl.c ****    do { // this "loop" is only executed once
1698:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1699:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // retrieve the received data frame from the radio's Rx buffer
1700:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataReceived->payload = &(ieee154e_vars.dataReceived->packet[FIRST_FRAME_BYTE])
 3620              		.loc 1 1700 0
 3621 1846 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3622 184a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3623 184e 9A69     		ldr	r2, [r3, #24]
 3624 1850 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3625 1854 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3626 1858 9B69     		ldr	r3, [r3, #24]
 3627 185a 03F16C03 		add	r3, r3, #108
 3628 185e 5360     		str	r3, [r2, #4]
1701:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.dataReceived->payload,
 3629              		.loc 1 1701 0
 3630 1860 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3631 1864 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3632 1868 9B69     		ldr	r3, [r3, #24]
 3633 186a 5968     		ldr	r1, [r3, #4]
1702:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.dataReceived->length,
 3634              		.loc 1 1702 0
 3635 186c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3636 1870 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3637 1874 9B69     		ldr	r3, [r3, #24]
1701:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.dataReceived->payload,
 3638              		.loc 1 1701 0
 3639 1876 03F10802 		add	r2, r3, #8
1703:openstack/02a-MAClow/IEEE802154Ecsl.c ****                              sizeof(ieee154e_vars.dataReceived->packet),
1704:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.dataReceived->l1_rssi,
 3640              		.loc 1 1704 0
 3641 187a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3642 187e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3643 1882 9B69     		ldr	r3, [r3, #24]
1701:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.dataReceived->payload,
 3644              		.loc 1 1701 0
 3645 1884 03F16804 		add	r4, r3, #104
1705:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.dataReceived->l1_lqi,
 3646              		.loc 1 1705 0
 3647 1888 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3648 188c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3649 1890 9B69     		ldr	r3, [r3, #24]
1701:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.dataReceived->payload,
 3650              		.loc 1 1701 0
 3651 1892 03F16900 		add	r0, r3, #105
1706:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                    &ieee154e_vars.dataReceived->l1_crc);
 3652              		.loc 1 1706 0
 3653 1896 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3654 189a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3655 189e 9B69     		ldr	r3, [r3, #24]
1701:openstack/02a-MAClow/IEEE802154Ecsl.c ****       radio_getReceivedFrame(       ieee154e_vars.dataReceived->payload,
 3656              		.loc 1 1701 0
 3657 18a0 03F16A03 		add	r3, r3, #106
 3658 18a4 0090     		str	r0, [sp, #0]
 3659 18a6 0193     		str	r3, [sp, #4]
 3660 18a8 0846     		mov	r0, r1
 3661 18aa 1146     		mov	r1, r2
 3662 18ac 4FF08202 		mov	r2, #130
 3663 18b0 2346     		mov	r3, r4
 3664 18b2 FFF7FEFF 		bl	radio_getReceivedFrame
1707:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1708:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // break if wrong length
1709:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.dataReceived->length<LENGTH_CRC || ieee154e_vars.dataReceived->length>LENGT
 3665              		.loc 1 1709 0
 3666 18b6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3667 18ba C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3668 18be 9B69     		ldr	r3, [r3, #24]
 3669 18c0 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 3670 18c2 012B     		cmp	r3, #1
 3671 18c4 07D9     		bls	.L175
 3672              		.loc 1 1709 0 is_stmt 0 discriminator 1
 3673 18c6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3674 18ca C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3675 18ce 9B69     		ldr	r3, [r3, #24]
 3676 18d0 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 3677 18d2 802B     		cmp	r3, #128
 3678 18d4 0ED9     		bls	.L176
 3679              	.L175:
1710:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // jump to the error code below this do-while loop
1711:openstack/02a-MAClow/IEEE802154Ecsl.c ****         openserial_printError(COMPONENT_IEEE802154E,ERR_INVALIDPACKETFROMRADIO,
1712:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)2,
1713:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             ieee154e_vars.dataReceived->length);
 3680              		.loc 1 1713 0 is_stmt 1
 3681 18d6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3682 18da C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3683 18de 9B69     		ldr	r3, [r3, #24]
 3684 18e0 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
1711:openstack/02a-MAClow/IEEE802154Ecsl.c ****         openserial_printError(COMPONENT_IEEE802154E,ERR_INVALIDPACKETFROMRADIO,
 3685              		.loc 1 1711 0
 3686 18e2 4FF00900 		mov	r0, #9
 3687 18e6 4FF03701 		mov	r1, #55
 3688 18ea 4FF00202 		mov	r2, #2
 3689 18ee FFF7FEFF 		bl	openserial_printError
1714:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 3690              		.loc 1 1714 0
 3691 18f2 C7E0     		b	.L177
 3692              	.L176:
1715:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1716:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1717:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // toss CRC (2 last bytes)
1718:openstack/02a-MAClow/IEEE802154Ecsl.c ****       packetfunctions_tossFooter(   ieee154e_vars.dataReceived, LENGTH_CRC);
 3693              		.loc 1 1718 0
 3694 18f4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3695 18f8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3696 18fc 9B69     		ldr	r3, [r3, #24]
 3697 18fe 1846     		mov	r0, r3
 3698 1900 4FF00201 		mov	r1, #2
 3699 1904 FFF7FEFF 		bl	packetfunctions_tossFooter
1719:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1720:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // if CRC doesn't check, stop
1721:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.dataReceived->l1_crc==FALSE) {
 3700              		.loc 1 1721 0
 3701 1908 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3702 190c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3703 1910 9B69     		ldr	r3, [r3, #24]
 3704 1912 93F86A30 		ldrb	r3, [r3, #106]	@ zero_extendqisi2
 3705 1916 83F00103 		eor	r3, r3, #1
 3706 191a DBB2     		uxtb	r3, r3
 3707 191c 002B     		cmp	r3, #0
 3708 191e 40F0AC80 		bne	.L185
 3709              	.L178:
1722:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // jump to the error code below this do-while loop
1723:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
1724:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1725:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1726:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // parse the IEEE802.15.4 header (RX DATA)
1727:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee802154_retrieveHeader(ieee154e_vars.dataReceived,&ieee802514_header);
 3710              		.loc 1 1727 0
 3711 1922 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3712 1926 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3713 192a 9A69     		ldr	r2, [r3, #24]
 3714 192c 07F11003 		add	r3, r7, #16
 3715 1930 1046     		mov	r0, r2
 3716 1932 1946     		mov	r1, r3
 3717 1934 FFF7FEFF 		bl	ieee802154_retrieveHeader
1728:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1729:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // break if invalid IEEE802.15.4 header
1730:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee802514_header.valid==FALSE) {
 3718              		.loc 1 1730 0
 3719 1938 3B7C     		ldrb	r3, [r7, #16]	@ zero_extendqisi2
 3720 193a 83F00103 		eor	r3, r3, #1
 3721 193e DBB2     		uxtb	r3, r3
 3722 1940 002B     		cmp	r3, #0
 3723 1942 40F09C80 		bne	.L186
 3724              	.L179:
1731:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // break from the do-while loop and execute the clean-up code below
1732:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
1733:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1734:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1735:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // store header details in packet buffer
1736:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataReceived->l2_frameType      = ieee802514_header.frameType;
 3725              		.loc 1 1736 0
 3726 1946 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3727 194a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3728 194e 9B69     		ldr	r3, [r3, #24]
 3729 1950 BA7C     		ldrb	r2, [r7, #18]	@ zero_extendqisi2
 3730 1952 83F84920 		strb	r2, [r3, #73]
1737:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataReceived->l2_dsn            = ieee802514_header.dsn;
 3731              		.loc 1 1737 0
 3732 1956 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3733 195a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3734 195e 9B69     		ldr	r3, [r3, #24]
 3735 1960 7A7E     		ldrb	r2, [r7, #25]	@ zero_extendqisi2
 3736 1962 83F84A20 		strb	r2, [r3, #74]
1738:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataReceived->l2_IEListPresent  = ieee802514_header.ieListPresent;
 3737              		.loc 1 1738 0
 3738 1966 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3739 196a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3740 196e 9B69     		ldr	r3, [r3, #24]
 3741 1970 FA7D     		ldrb	r2, [r7, #23]	@ zero_extendqisi2
 3742 1972 83F86520 		strb	r2, [r3, #101]
1739:openstack/02a-MAClow/IEEE802154Ecsl.c ****       memcpy(&(ieee154e_vars.dataReceived->l2_nextORpreviousHop),&(ieee802514_header.src),sizeof(op
 3743              		.loc 1 1739 0
 3744 1976 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3745 197a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3746 197e 9B69     		ldr	r3, [r3, #24]
 3747 1980 03F13803 		add	r3, r3, #56
 3748 1984 1D46     		mov	r5, r3
 3749 1986 07F13C04 		add	r4, r7, #60
 3750 198a 0FCC     		ldmia	r4!, {r0, r1, r2, r3}
 3751 198c 2860     		str	r0, [r5, #0]	@ unaligned
 3752 198e 6960     		str	r1, [r5, #4]	@ unaligned
 3753 1990 AA60     		str	r2, [r5, #8]	@ unaligned
 3754 1992 EB60     		str	r3, [r5, #12]	@ unaligned
 3755 1994 2378     		ldrb	r3, [r4, #0]
 3756 1996 2B74     		strb	r3, [r5, #16]
1740:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1741:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // toss the IEEE802.15.4 header
1742:openstack/02a-MAClow/IEEE802154Ecsl.c ****       packetfunctions_tossHeader(ieee154e_vars.dataReceived,ieee802514_header.headerLength);
 3757              		.loc 1 1742 0
 3758 1998 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3759 199c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3760 19a0 9A69     		ldr	r2, [r3, #24]
 3761 19a2 7B7C     		ldrb	r3, [r7, #17]	@ zero_extendqisi2
 3762 19a4 1046     		mov	r0, r2
 3763 19a6 1946     		mov	r1, r3
 3764 19a8 FFF7FEFF 		bl	packetfunctions_tossHeader
1743:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1744:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // handle IEs xv poipoi
1745:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset join priority
1746:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // retrieve IE in sixtop
1747:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if ((ieee802514_header.valid==TRUE &&
 3765              		.loc 1 1747 0
 3766 19ac 3B7C     		ldrb	r3, [r7, #16]	@ zero_extendqisi2
1748:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header.ieListPresent==TRUE &&
1749:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header.frameType==IEEE154_TYPE_BEACON && // if it is not a beacon and have ie,
1750:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header.panid,idmanager_getMyID(ADDR_PANID)) &&
 3767              		.loc 1 1750 0
 3768 19ae 002B     		cmp	r3, #0
 3769 19b0 22D0     		beq	.L181
1748:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header.ieListPresent==TRUE &&
 3770              		.loc 1 1748 0
 3771 19b2 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
1747:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if ((ieee802514_header.valid==TRUE &&
 3772              		.loc 1 1747 0
 3773 19b4 002B     		cmp	r3, #0
 3774 19b6 1FD0     		beq	.L181
1749:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header.frameType==IEEE154_TYPE_BEACON && // if it is not a beacon and have ie,
 3775              		.loc 1 1749 0
 3776 19b8 BB7C     		ldrb	r3, [r7, #18]	@ zero_extendqisi2
1748:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header.ieListPresent==TRUE &&
 3777              		.loc 1 1748 0
 3778 19ba 002B     		cmp	r3, #0
 3779 19bc 1CD1     		bne	.L181
 3780              		.loc 1 1750 0
 3781 19be 4FF00400 		mov	r0, #4
 3782 19c2 FFF7FEFF 		bl	idmanager_getMyID
 3783 19c6 0346     		mov	r3, r0
 3784 19c8 07F11002 		add	r2, r7, #16
 3785 19cc 02F10A02 		add	r2, r2, #10
 3786 19d0 1046     		mov	r0, r2
 3787 19d2 1946     		mov	r1, r3
 3788 19d4 FFF7FEFF 		bl	packetfunctions_sameAddress
 3789 19d8 0346     		mov	r3, r0
1749:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header.frameType==IEEE154_TYPE_BEACON && // if it is not a beacon and have ie,
 3790              		.loc 1 1749 0
 3791 19da 002B     		cmp	r3, #0
 3792 19dc 0CD0     		beq	.L181
1751:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee154e_processIEs(ieee154e_vars.dataReceived,&lenIE))==FALSE) {
 3793              		.loc 1 1751 0
 3794 19de 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3795 19e2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3796 19e6 9A69     		ldr	r2, [r3, #24]
 3797 19e8 07F10E03 		add	r3, r7, #14
 3798 19ec 1046     		mov	r0, r2
 3799 19ee 1946     		mov	r1, r3
 3800 19f0 FFF7FEFF 		bl	ieee154e_processIEs
 3801 19f4 0346     		mov	r3, r0
1750:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header.panid,idmanager_getMyID(ADDR_PANID)) &&
 3802              		.loc 1 1750 0
 3803 19f6 002B     		cmp	r3, #0
 3804              	.L181:
1752:openstack/02a-MAClow/IEEE802154Ecsl.c ****           //log  that the packet is not carrying IEs
1753:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1754:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1755:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // toss the IEs including Synch
1756:openstack/02a-MAClow/IEEE802154Ecsl.c ****       packetfunctions_tossHeader(ieee154e_vars.dataReceived,lenIE);
 3805              		.loc 1 1756 0
 3806 19f8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3807 19fc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3808 1a00 9A69     		ldr	r2, [r3, #24]
 3809 1a02 FB89     		ldrh	r3, [r7, #14]
 3810 1a04 DBB2     		uxtb	r3, r3
 3811 1a06 1046     		mov	r0, r2
 3812 1a08 1946     		mov	r1, r3
 3813 1a0a FFF7FEFF 		bl	packetfunctions_tossHeader
1757:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1758:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // record the captured time
1759:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.lastCapturedTime = capturedTime;
 3814              		.loc 1 1759 0
 3815 1a0e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3816 1a12 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3817 1a16 7A68     		ldr	r2, [r7, #4]
 3818 1a18 5A62     		str	r2, [r3, #36]
1760:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1761:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // if I just received an invalid frame, stop
1762:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (isValidRxFrame(&ieee802514_header)==FALSE) {
 3819              		.loc 1 1762 0
 3820 1a1a 07F11003 		add	r3, r7, #16
 3821 1a1e 1846     		mov	r0, r3
 3822 1a20 FFF7FEFF 		bl	isValidRxFrame
 3823 1a24 0346     		mov	r3, r0
 3824 1a26 83F00103 		eor	r3, r3, #1
 3825 1a2a DBB2     		uxtb	r3, r3
 3826 1a2c 002B     		cmp	r3, #0
 3827 1a2e 28D1     		bne	.L187
 3828              	.L182:
1763:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // jump to the error code below this do-while loop
1764:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
1765:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1766:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1767:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // CSL TEST - Force to not send ack packet
1768:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee802514_header.ackRequested = 0;
 3829              		.loc 1 1768 0
 3830 1a30 4FF00003 		mov	r3, #0
 3831 1a34 7B75     		strb	r3, [r7, #21]
1769:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // END CSL TEST
1770:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1771:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // check if ack requested
1772:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee802514_header.ackRequested==1) {
 3832              		.loc 1 1772 0
 3833 1a36 7B7D     		ldrb	r3, [r7, #21]	@ zero_extendqisi2
 3834 1a38 002B     		cmp	r3, #0
 3835 1a3a 0AD0     		beq	.L183
1773:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // arm rt5
1774:openstack/02a-MAClow/IEEE802154Ecsl.c ****          radiotimer_schedule(DURATION_rt5);
 3836              		.loc 1 1774 0
 3837 1a3c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3838 1a40 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3839 1a44 5B6A     		ldr	r3, [r3, #36]
 3840 1a46 03F17A03 		add	r3, r3, #122
 3841 1a4a 1846     		mov	r0, r3
 3842 1a4c FFF7FEFF 		bl	radiotimer_schedule
 3843 1a50 29E0     		b	.L172
 3844              	.L183:
1775:openstack/02a-MAClow/IEEE802154Ecsl.c ****       } else {
1776:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // synchronize to the received packet if I'm not a DAGroot and this is my preferred parent
1777:openstack/02a-MAClow/IEEE802154Ecsl.c ****          //if (idmanager_getIsDAGroot()==FALSE && neighbors_isPreferredParent(&(ieee154e_vars.dataR
1778:openstack/02a-MAClow/IEEE802154Ecsl.c ****          //   synchronizePacket(ieee154e_vars.syncCapturedTime);
1779:openstack/02a-MAClow/IEEE802154Ecsl.c ****          //}
1780:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // indicate reception to upper layer (no ACK asked)
1781:openstack/02a-MAClow/IEEE802154Ecsl.c ****          notif_receive(ieee154e_vars.dataReceived, 1);
 3845              		.loc 1 1781 0
 3846 1a52 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3847 1a56 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3848 1a5a 9B69     		ldr	r3, [r3, #24]
 3849 1a5c 1846     		mov	r0, r3
 3850 1a5e 4FF00101 		mov	r1, #1
 3851 1a62 FFF7FEFF 		bl	notif_receive
1782:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // reset local variable
1783:openstack/02a-MAClow/IEEE802154Ecsl.c ****          ieee154e_vars.dataReceived = NULL;
 3852              		.loc 1 1783 0
 3853 1a66 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3854 1a6a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3855 1a6e 4FF00002 		mov	r2, #0
 3856 1a72 9A61     		str	r2, [r3, #24]
1784:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // abort
1785:openstack/02a-MAClow/IEEE802154Ecsl.c ****          endOps();
 3857              		.loc 1 1785 0
 3858 1a74 FFF7FEFF 		bl	endOps
 3859 1a78 15E0     		b	.L172
 3860              	.L185:
1723:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 3861              		.loc 1 1723 0
 3862 1a7a 00BF     		nop
 3863 1a7c 02E0     		b	.L177
 3864              	.L186:
1732:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 3865              		.loc 1 1732 0
 3866 1a7e 00BF     		nop
 3867 1a80 00E0     		b	.L177
 3868              	.L187:
1764:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 3869              		.loc 1 1764 0
 3870 1a82 00BF     		nop
 3871              	.L177:
1786:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
1787:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1788:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // everything went well, return here not to execute the error code below
1789:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return;
1790:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1791:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } while(0);
1792:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1793:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // free the (invalid) received data so RAM memory can be recycled
1794:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openqueue_freePacketBuffer(ieee154e_vars.dataReceived);
 3872              		.loc 1 1794 0
 3873 1a84 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3874 1a88 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3875 1a8c 9B69     		ldr	r3, [r3, #24]
 3876 1a8e 1846     		mov	r0, r3
 3877 1a90 FFF7FEFF 		bl	openqueue_freePacketBuffer
1795:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1796:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clear local variable
1797:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.dataReceived = NULL;
 3878              		.loc 1 1797 0
 3879 1a94 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3880 1a98 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3881 1a9c 4FF00002 		mov	r2, #0
 3882 1aa0 9A61     		str	r2, [r3, #24]
1798:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1799:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1800:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 3883              		.loc 1 1800 0
 3884 1aa2 FFF7FEFF 		bl	endOps
 3885              	.L172:
1801:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 3886              		.loc 1 1801 0
 3887 1aa6 07F15007 		add	r7, r7, #80
 3888 1aaa BD46     		mov	sp, r7
 3889 1aac B0BD     		pop	{r4, r5, r7, pc}
 3890              		.cfi_endproc
 3891              	.LFE45:
 3893 1aae 00BF     		.align	2
 3894              		.global	activity_csl_data_ri6
 3895              		.thumb
 3896              		.thumb_func
 3898              	activity_csl_data_ri6:
 3899              	.LFB46:
1802:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1803:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1804:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri6].
1805:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1806:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1807:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The functionality is to prepare the radio for ACK sending.
1808:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1809:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri6() {
 3900              		.loc 1 1809 0
 3901              		.cfi_startproc
 3902              		@ args = 0, pretend = 0, frame = 8
 3903              		@ frame_needed = 1, uses_anonymous_args = 0
 3904 1ab0 90B5     		push	{r4, r7, lr}
 3905              	.LCFI107:
 3906              		.cfi_def_cfa_offset 12
 3907              		.cfi_offset 4, -12
 3908              		.cfi_offset 7, -8
 3909              		.cfi_offset 14, -4
 3910 1ab2 87B0     		sub	sp, sp, #28
 3911              	.LCFI108:
 3912              		.cfi_def_cfa_offset 40
 3913 1ab4 04AF     		add	r7, sp, #16
 3914              	.LCFI109:
 3915              		.cfi_def_cfa 7, 24
1810:openstack/02a-MAClow/IEEE802154Ecsl.c ****    PORT_SIGNED_INT_WIDTH timeCorrection;
1811:openstack/02a-MAClow/IEEE802154Ecsl.c ****    header_IE_ht header_desc;
1812:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1813:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1814:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXACKPREPARE);
 3916              		.loc 1 1814 0
 3917 1ab6 4FF03700 		mov	r0, #55
 3918 1aba FFF7FEFF 		bl	changeState
1815:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1816:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // get a buffer to put the ack to send in
1817:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend = openqueue_getFreePacketBuffer(COMPONENT_IEEE802154E);
 3919              		.loc 1 1817 0
 3920 1abe 4FF00900 		mov	r0, #9
 3921 1ac2 FFF7FEFF 		bl	openqueue_getFreePacketBuffer
 3922 1ac6 0246     		mov	r2, r0
 3923 1ac8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3924 1acc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3925 1ad0 DA61     		str	r2, [r3, #28]
1818:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.ackToSend==NULL) {
 3926              		.loc 1 1818 0
 3927 1ad2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3928 1ad6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3929 1ada DB69     		ldr	r3, [r3, #28]
 3930 1adc 002B     		cmp	r3, #0
 3931 1ade 1DD1     		bne	.L189
1819:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // log the error
1820:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openserial_printError(COMPONENT_IEEE802154E,ERR_NO_FREE_PACKET_BUFFER, (errorparameter_t)0, (
 3932              		.loc 1 1820 0
 3933 1ae0 4FF00900 		mov	r0, #9
 3934 1ae4 4FF02C01 		mov	r1, #44
 3935 1ae8 4FF00002 		mov	r2, #0
 3936 1aec 4FF00003 		mov	r3, #0
 3937 1af0 FFF7FEFF 		bl	openserial_printError
1821:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // indicate we received a packet anyway (we don't want to loose any)
1822:openstack/02a-MAClow/IEEE802154Ecsl.c ****       notif_receive(ieee154e_vars.dataReceived,0);
 3938              		.loc 1 1822 0
 3939 1af4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3940 1af8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3941 1afc 9B69     		ldr	r3, [r3, #24]
 3942 1afe 1846     		mov	r0, r3
 3943 1b00 4FF00001 		mov	r1, #0
 3944 1b04 FFF7FEFF 		bl	notif_receive
1823:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // free local variable
1824:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataReceived = NULL;
 3945              		.loc 1 1824 0
 3946 1b08 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3947 1b0c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3948 1b10 4FF00002 		mov	r2, #0
 3949 1b14 9A61     		str	r2, [r3, #24]
1825:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // abort
1826:openstack/02a-MAClow/IEEE802154Ecsl.c ****       endOps();
 3950              		.loc 1 1826 0
 3951 1b16 FFF7FEFF 		bl	endOps
 3952 1b1a D3E0     		b	.L188
 3953              	.L189:
1827:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return;
1828:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
1829:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1830:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // declare ownership over that packet
1831:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend->creator = COMPONENT_IEEE802154E;
 3954              		.loc 1 1831 0
 3955 1b1c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3956 1b20 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3957 1b24 DB69     		ldr	r3, [r3, #28]
 3958 1b26 4FF00902 		mov	r2, #9
 3959 1b2a 1A70     		strb	r2, [r3, #0]
1832:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend->owner   = COMPONENT_IEEE802154E;
 3960              		.loc 1 1832 0
 3961 1b2c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3962 1b30 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3963 1b34 DB69     		ldr	r3, [r3, #28]
 3964 1b36 4FF00902 		mov	r2, #9
 3965 1b3a 5A70     		strb	r2, [r3, #1]
1833:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1834:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // calculate the time timeCorrection (this is the time when the packet arrive w.r.t the time it 
1835:openstack/02a-MAClow/IEEE802154Ecsl.c ****    timeCorrection = (PORT_SIGNED_INT_WIDTH)((PORT_SIGNED_INT_WIDTH)ieee154e_vars.syncCapturedTime-(
 3966              		.loc 1 1835 0
 3967 1b3c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3968 1b40 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3969 1b44 9B6A     		ldr	r3, [r3, #40]
 3970 1b46 A3F18303 		sub	r3, r3, #131
 3971 1b4a 7B60     		str	r3, [r7, #4]
1836:openstack/02a-MAClow/IEEE802154Ecsl.c ****     
1837:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // add the payload to the ACK (i.e. the timeCorrection)
1838:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packetfunctions_reserveHeaderSize(ieee154e_vars.ackToSend,sizeof(timecorrection_IE_ht));
 3972              		.loc 1 1838 0
 3973 1b4c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3974 1b50 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3975 1b54 DB69     		ldr	r3, [r3, #28]
 3976 1b56 1846     		mov	r0, r3
 3977 1b58 4FF00201 		mov	r1, #2
 3978 1b5c FFF7FEFF 		bl	packetfunctions_reserveHeaderSize
1839:openstack/02a-MAClow/IEEE802154Ecsl.c ****    timeCorrection  = -timeCorrection;
 3979              		.loc 1 1839 0
 3980 1b60 7B68     		ldr	r3, [r7, #4]
 3981 1b62 C3F10003 		rsb	r3, r3, #0
 3982 1b66 7B60     		str	r3, [r7, #4]
1840:openstack/02a-MAClow/IEEE802154Ecsl.c ****    timeCorrection *= US_PER_TICK;
 3983              		.loc 1 1840 0
 3984 1b68 7A68     		ldr	r2, [r7, #4]
 3985 1b6a 1346     		mov	r3, r2
 3986 1b6c 4FEA0313 		lsl	r3, r3, #4
 3987 1b70 9B1A     		subs	r3, r3, r2
 3988 1b72 4FEA4303 		lsl	r3, r3, #1
 3989 1b76 7B60     		str	r3, [r7, #4]
1841:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend->payload[0] = (uint8_t)((((uint16_t)timeCorrection)   ) & 0xff);
 3990              		.loc 1 1841 0
 3991 1b78 40F20003 		movw	r3, #:lower16:ieee154e_vars
 3992 1b7c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 3993 1b80 DB69     		ldr	r3, [r3, #28]
 3994 1b82 5B68     		ldr	r3, [r3, #4]
 3995 1b84 7A68     		ldr	r2, [r7, #4]
 3996 1b86 D2B2     		uxtb	r2, r2
 3997 1b88 1A70     		strb	r2, [r3, #0]
1842:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend->payload[1] = (uint8_t)((((uint16_t)timeCorrection)>>8) & 0xff);
 3998              		.loc 1 1842 0
 3999 1b8a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4000 1b8e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4001 1b92 DB69     		ldr	r3, [r3, #28]
 4002 1b94 5B68     		ldr	r3, [r3, #4]
 4003 1b96 03F10103 		add	r3, r3, #1
 4004 1b9a 7A68     		ldr	r2, [r7, #4]
 4005 1b9c 92B2     		uxth	r2, r2
 4006 1b9e 4FEA1222 		lsr	r2, r2, #8
 4007 1ba2 92B2     		uxth	r2, r2
 4008 1ba4 D2B2     		uxtb	r2, r2
 4009 1ba6 1A70     		strb	r2, [r3, #0]
1843:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1844:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // add header IE header -- xv poipoi -- pkt is filled in reverse order..
1845:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packetfunctions_reserveHeaderSize(ieee154e_vars.ackToSend,sizeof(header_IE_ht));
 4010              		.loc 1 1845 0
 4011 1ba8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4012 1bac C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4013 1bb0 DB69     		ldr	r3, [r3, #28]
 4014 1bb2 1846     		mov	r0, r3
 4015 1bb4 4FF00201 		mov	r1, #2
 4016 1bb8 FFF7FEFF 		bl	packetfunctions_reserveHeaderSize
1846:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //create the header for ack IE
1847:openstack/02a-MAClow/IEEE802154Ecsl.c ****    header_desc.length_elementid_type=(sizeof(timecorrection_IE_ht)<< IEEE802154E_DESC_LEN_HEADER_IE
 4017              		.loc 1 1847 0
 4018 1bbc 40F23C43 		movw	r3, #1084
 4019 1bc0 3B80     		strh	r3, [r7, #0]	@ movhi
1848:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                      (IEEE802154E_ACK_NACK_TIMECORRECTION_ELEMENTID << IEEE802154E_
1849:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                      IEEE802154E_DESC_TYPE_SHORT; 
1850:openstack/02a-MAClow/IEEE802154Ecsl.c ****    memcpy(ieee154e_vars.ackToSend->payload,&header_desc,sizeof(header_IE_ht));
 4020              		.loc 1 1850 0
 4021 1bc2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4022 1bc6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4023 1bca DB69     		ldr	r3, [r3, #28]
 4024 1bcc 5B68     		ldr	r3, [r3, #4]
 4025 1bce 3A46     		mov	r2, r7
 4026 1bd0 1288     		ldrh	r2, [r2, #0]	@ unaligned
 4027 1bd2 1A80     		strh	r2, [r3, #0]	@ unaligned
1851:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1852:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // prepend the IEEE802.15.4 header to the ACK
1853:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend->l2_frameType = IEEE154_TYPE_ACK;
 4028              		.loc 1 1853 0
 4029 1bd4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4030 1bd8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4031 1bdc DB69     		ldr	r3, [r3, #28]
 4032 1bde 4FF00202 		mov	r2, #2
 4033 1be2 83F84920 		strb	r2, [r3, #73]
1854:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend->l2_dsn       = ieee154e_vars.dataReceived->l2_dsn;
 4034              		.loc 1 1854 0
 4035 1be6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4036 1bea C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4037 1bee DA69     		ldr	r2, [r3, #28]
 4038 1bf0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4039 1bf4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4040 1bf8 9B69     		ldr	r3, [r3, #24]
 4041 1bfa 93F84A30 		ldrb	r3, [r3, #74]	@ zero_extendqisi2
 4042 1bfe 82F84A30 		strb	r3, [r2, #74]
1855:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802154_prependHeader(ieee154e_vars.ackToSend,
 4043              		.loc 1 1855 0
 4044 1c02 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4045 1c06 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4046 1c0a D969     		ldr	r1, [r3, #28]
1856:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             ieee154e_vars.ackToSend->l2_frameType,
 4047              		.loc 1 1856 0
 4048 1c0c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4049 1c10 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4050 1c14 DB69     		ldr	r3, [r3, #28]
1855:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802154_prependHeader(ieee154e_vars.ackToSend,
 4051              		.loc 1 1855 0
 4052 1c16 93F84920 		ldrb	r2, [r3, #73]	@ zero_extendqisi2
1857:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             IEEE154_IELIST_YES,//ie in ack
1858:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             IEEE154_FRAMEVERSION,//enhanced ack
1859:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             IEEE154_SEC_NO_SECURITY,
1860:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             ieee154e_vars.dataReceived->l2_dsn,
 4053              		.loc 1 1860 0
 4054 1c1a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4055 1c1e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4056 1c22 9B69     		ldr	r3, [r3, #24]
1855:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802154_prependHeader(ieee154e_vars.ackToSend,
 4057              		.loc 1 1855 0
 4058 1c24 93F84A00 		ldrb	r0, [r3, #74]	@ zero_extendqisi2
1861:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             &(ieee154e_vars.dataReceived->l2_nextORpreviousHop)
 4059              		.loc 1 1861 0
 4060 1c28 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4061 1c2c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4062 1c30 9B69     		ldr	r3, [r3, #24]
1855:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802154_prependHeader(ieee154e_vars.ackToSend,
 4063              		.loc 1 1855 0
 4064 1c32 03F13803 		add	r3, r3, #56
 4065 1c36 4FF00004 		mov	r4, #0
 4066 1c3a 0094     		str	r4, [sp, #0]
 4067 1c3c 0190     		str	r0, [sp, #4]
 4068 1c3e 0293     		str	r3, [sp, #8]
 4069 1c40 0846     		mov	r0, r1
 4070 1c42 1146     		mov	r1, r2
 4071 1c44 4FF00102 		mov	r2, #1
 4072 1c48 4FF00203 		mov	r3, #2
 4073 1c4c FFF7FEFF 		bl	ieee802154_prependHeader
1862:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             );
1863:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1864:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // space for 2-byte CRC
1865:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packetfunctions_reserveFooterSize(ieee154e_vars.ackToSend,2);
 4074              		.loc 1 1865 0
 4075 1c50 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4076 1c54 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4077 1c58 DB69     		ldr	r3, [r3, #28]
 4078 1c5a 1846     		mov	r0, r3
 4079 1c5c 4FF00201 		mov	r1, #2
 4080 1c60 FFF7FEFF 		bl	packetfunctions_reserveFooterSize
1866:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1867:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // load the packet in the radio's Tx buffer
1868:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_loadPacket(ieee154e_vars.ackToSend->payload,
 4081              		.loc 1 1868 0
 4082 1c64 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4083 1c68 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4084 1c6c DB69     		ldr	r3, [r3, #28]
 4085 1c6e 5A68     		ldr	r2, [r3, #4]
1869:openstack/02a-MAClow/IEEE802154Ecsl.c ****                     ieee154e_vars.ackToSend->length);
 4086              		.loc 1 1869 0
 4087 1c70 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4088 1c74 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4089 1c78 DB69     		ldr	r3, [r3, #28]
1868:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_loadPacket(ieee154e_vars.ackToSend->payload,
 4090              		.loc 1 1868 0
 4091 1c7a 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4092 1c7c 1046     		mov	r0, r2
 4093 1c7e 1946     		mov	r1, r3
 4094 1c80 FFF7FEFF 		bl	radio_loadPacket
1870:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1871:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // enable the radio in Tx mode. This does not send that packet.
1872:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_txEnable();
 4095              		.loc 1 1872 0
 4096 1c84 FFF7FEFF 		bl	radio_txEnable
1873:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnInit=radio_getTimerValue();
 4097              		.loc 1 1873 0
 4098 1c88 FFF7FEFF 		bl	radio_getTimerValue
 4099 1c8c 0246     		mov	r2, r0
 4100 1c8e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4101 1c92 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4102 1c96 1A63     		str	r2, [r3, #48]
1874:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnThisSlot=TRUE;
 4103              		.loc 1 1874 0
 4104 1c98 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4105 1c9c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4106 1ca0 4FF00102 		mov	r2, #1
 4107 1ca4 83F83820 		strb	r2, [r3, #56]
1875:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt6
1876:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt6);
 4108              		.loc 1 1876 0
 4109 1ca8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4110 1cac C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4111 1cb0 5B6A     		ldr	r3, [r3, #36]
 4112 1cb2 03F19003 		add	r3, r3, #144
 4113 1cb6 1846     		mov	r0, r3
 4114 1cb8 FFF7FEFF 		bl	radiotimer_schedule
1877:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1878:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1879:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXACKREADY);
 4115              		.loc 1 1879 0
 4116 1cbc 4FF03800 		mov	r0, #56
 4117 1cc0 FFF7FEFF 		bl	changeState
 4118              	.L188:
1880:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4119              		.loc 1 1880 0
 4120 1cc4 07F10C07 		add	r7, r7, #12
 4121 1cc8 BD46     		mov	sp, r7
 4122 1cca 90BD     		pop	{r4, r7, pc}
 4123              		.cfi_endproc
 4124              	.LFE46:
 4126              		.align	2
 4127              		.global	activity_csl_data_rie4
 4128              		.thumb
 4129              		.thumb_func
 4131              	activity_csl_data_rie4:
 4132              	.LFB47:
1881:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1882:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1883:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data rie4].
1884:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1885:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1886:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The functionality is to prepare the radio for ACK sending.
1887:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1888:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_rie4() {
 4133              		.loc 1 1888 0
 4134              		.cfi_startproc
 4135              		@ args = 0, pretend = 0, frame = 0
 4136              		@ frame_needed = 1, uses_anonymous_args = 0
 4137 1ccc 80B5     		push	{r7, lr}
 4138              	.LCFI110:
 4139              		.cfi_def_cfa_offset 8
 4140              		.cfi_offset 7, -8
 4141              		.cfi_offset 14, -4
 4142 1cce 00AF     		add	r7, sp, #0
 4143              	.LCFI111:
 4144              		.cfi_def_cfa_register 7
1889:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
1890:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXACKPREPARE_OVERFLOWS,
1891:openstack/02a-MAClow/IEEE802154Ecsl.c **** 		                 (errorparameter_t)ieee154e_vars.state,
 4145              		.loc 1 1891 0
 4146 1cd0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4147 1cd4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4148 1cd8 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1890:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXACKPREPARE_OVERFLOWS,
 4149              		.loc 1 1890 0
 4150 1cda 1A46     		mov	r2, r3
1892:openstack/02a-MAClow/IEEE802154Ecsl.c **** 						 (errorparameter_t)ieee154e_dbg.num_cslSamples);
 4151              		.loc 1 1892 0
 4152 1cdc 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 4153 1ce0 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 4154 1ce4 1B69     		ldr	r3, [r3, #16]
1890:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXACKPREPARE_OVERFLOWS,
 4155              		.loc 1 1890 0
 4156 1ce6 9BB2     		uxth	r3, r3
 4157 1ce8 4FF00900 		mov	r0, #9
 4158 1cec 4FF02501 		mov	r1, #37
 4159 1cf0 FFF7FEFF 		bl	openserial_printError
1893:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1894:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1895:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 4160              		.loc 1 1895 0
 4161 1cf4 FFF7FEFF 		bl	endOps
1896:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4162              		.loc 1 1896 0
 4163 1cf8 80BD     		pop	{r7, pc}
 4164              		.cfi_endproc
 4165              	.LFE47:
 4167 1cfa 00BF     		.align	2
 4168              		.global	activity_csl_data_ri7
 4169              		.thumb
 4170              		.thumb_func
 4172              	activity_csl_data_ri7:
 4173              	.LFB48:
1897:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1898:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1899:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri7].
1900:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1901:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1902:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The radio is configured and this interrupt gives it the "go" signal to start listening.
1903:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1904:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri7() {
 4174              		.loc 1 1904 0
 4175              		.cfi_startproc
 4176              		@ args = 0, pretend = 0, frame = 0
 4177              		@ frame_needed = 1, uses_anonymous_args = 0
 4178 1cfc 80B5     		push	{r7, lr}
 4179              	.LCFI112:
 4180              		.cfi_def_cfa_offset 8
 4181              		.cfi_offset 7, -8
 4182              		.cfi_offset 14, -4
 4183 1cfe 00AF     		add	r7, sp, #0
 4184              	.LCFI113:
 4185              		.cfi_def_cfa_register 7
1905:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1906:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXACKDELAY);
 4186              		.loc 1 1906 0
 4187 1d00 4FF03900 		mov	r0, #57
 4188 1d04 FFF7FEFF 		bl	changeState
1907:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1908:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt7
1909:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt7);
 4189              		.loc 1 1909 0
 4190 1d08 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4191 1d0c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4192 1d10 5B6A     		ldr	r3, [r3, #36]
 4193 1d12 03F1B103 		add	r3, r3, #177
 4194 1d16 1846     		mov	r0, r3
 4195 1d18 FFF7FEFF 		bl	radiotimer_schedule
1910:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1911:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // give the 'go' to transmit
1912:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_txNow(); 
 4196              		.loc 1 1912 0
 4197 1d1c FFF7FEFF 		bl	radio_txNow
1913:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4198              		.loc 1 1913 0
 4199 1d20 80BD     		pop	{r7, pc}
 4200              		.cfi_endproc
 4201              	.LFE48:
 4203 1d22 00BF     		.align	2
 4204              		.global	activity_csl_data_rie5
 4205              		.thumb
 4206              		.thumb_func
 4208              	activity_csl_data_rie5:
 4209              	.LFB49:
1914:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1915:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1916:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data rie5].
1917:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1918:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1919:openstack/02a-MAClow/IEEE802154Ecsl.c ****    The functionality is to prepare the radio for ACK sending.
1920:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1921:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_rie5() {
 4210              		.loc 1 1921 0
 4211              		.cfi_startproc
 4212              		@ args = 0, pretend = 0, frame = 0
 4213              		@ frame_needed = 1, uses_anonymous_args = 0
 4214 1d24 80B5     		push	{r7, lr}
 4215              	.LCFI114:
 4216              		.cfi_def_cfa_offset 8
 4217              		.cfi_offset 7, -8
 4218              		.cfi_offset 14, -4
 4219 1d26 00AF     		add	r7, sp, #0
 4220              	.LCFI115:
 4221              		.cfi_def_cfa_register 7
1922:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
1923:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIOTX_OVERFLOWS,
1924:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state,
 4222              		.loc 1 1924 0
 4223 1d28 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4224 1d2c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4225 1d30 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1923:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIOTX_OVERFLOWS,
 4226              		.loc 1 1923 0
 4227 1d32 1A46     		mov	r2, r3
1925:openstack/02a-MAClow/IEEE802154Ecsl.c **** 						 (errorparameter_t)ieee154e_dbg.num_cslSamples);
 4228              		.loc 1 1925 0
 4229 1d34 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 4230 1d38 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 4231 1d3c 1B69     		ldr	r3, [r3, #16]
1923:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIOTX_OVERFLOWS,
 4232              		.loc 1 1923 0
 4233 1d3e 9BB2     		uxth	r3, r3
 4234 1d40 4FF00900 		mov	r0, #9
 4235 1d44 4FF02801 		mov	r1, #40
 4236 1d48 FFF7FEFF 		bl	openserial_printError
1926:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1927:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 4237              		.loc 1 1927 0
 4238 1d4c FFF7FEFF 		bl	endOps
1928:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4239              		.loc 1 1928 0
 4240 1d50 80BD     		pop	{r7, pc}
 4241              		.cfi_endproc
 4242              	.LFE49:
 4244 1d52 00BF     		.align	2
 4245              		.global	activity_csl_data_ri8
 4246              		.thumb
 4247              		.thumb_func
 4249              	activity_csl_data_ri8:
 4250              	.LFB50:
1929:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1930:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1931:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri8].
1932:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1933:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_startOfFrame" function when a start of frame ev
1934:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change the state to set transmission, cancel #rt7 and arm #rt8 (max time 
1935:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1936:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri8(PORT_RADIOTIMER_WIDTH capturedTime) {
 4251              		.loc 1 1936 0
 4252              		.cfi_startproc
 4253              		@ args = 0, pretend = 0, frame = 8
 4254              		@ frame_needed = 1, uses_anonymous_args = 0
 4255 1d54 80B5     		push	{r7, lr}
 4256              	.LCFI116:
 4257              		.cfi_def_cfa_offset 8
 4258              		.cfi_offset 7, -8
 4259              		.cfi_offset 14, -4
 4260 1d56 82B0     		sub	sp, sp, #8
 4261              	.LCFI117:
 4262              		.cfi_def_cfa_offset 16
 4263 1d58 00AF     		add	r7, sp, #0
 4264              	.LCFI118:
 4265              		.cfi_def_cfa_register 7
 4266 1d5a 7860     		str	r0, [r7, #4]
1937:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1938:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLTXACK);
 4267              		.loc 1 1938 0
 4268 1d5c 4FF03A00 		mov	r0, #58
 4269 1d60 FFF7FEFF 		bl	changeState
1939:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1940:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel rt7
1941:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 4270              		.loc 1 1941 0
 4271 1d64 FFF7FEFF 		bl	radiotimer_cancel
1942:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1943:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
1944:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.lastCapturedTime = capturedTime;
 4272              		.loc 1 1944 0
 4273 1d68 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4274 1d6c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4275 1d70 7A68     		ldr	r2, [r7, #4]
 4276 1d72 5A62     		str	r2, [r3, #36]
1945:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1946:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // arm rt8
1947:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_schedule(DURATION_rt8);
 4277              		.loc 1 1947 0
 4278 1d74 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4279 1d78 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4280 1d7c 5B6A     		ldr	r3, [r3, #36]
 4281 1d7e 03F16203 		add	r3, r3, #98
 4282 1d82 1846     		mov	r0, r3
 4283 1d84 FFF7FEFF 		bl	radiotimer_schedule
1948:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4284              		.loc 1 1948 0
 4285 1d88 07F10807 		add	r7, r7, #8
 4286 1d8c BD46     		mov	sp, r7
 4287 1d8e 80BD     		pop	{r7, pc}
 4288              		.cfi_endproc
 4289              	.LFE50:
 4291              		.align	2
 4292              		.global	activity_csl_data_rie6
 4293              		.thumb
 4294              		.thumb_func
 4296              	activity_csl_data_rie6:
 4297              	.LFB51:
1949:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1950:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1951:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data rie6].
1952:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1953:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "isr_ieee154ecsl_timer" function when FSM timer fires (expir
1954:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to register an error when timer for sent ACK has expired.
1955:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1956:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_rie6() {
 4298              		.loc 1 1956 0
 4299              		.cfi_startproc
 4300              		@ args = 0, pretend = 0, frame = 0
 4301              		@ frame_needed = 1, uses_anonymous_args = 0
 4302 1d90 80B5     		push	{r7, lr}
 4303              	.LCFI119:
 4304              		.cfi_def_cfa_offset 8
 4305              		.cfi_offset 7, -8
 4306              		.cfi_offset 14, -4
 4307 1d92 00AF     		add	r7, sp, #0
 4308              	.LCFI120:
 4309              		.cfi_def_cfa_register 7
1957:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log the error
1958:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDACKDURATION_OVERFLOWS,
1959:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_vars.state,
 4310              		.loc 1 1959 0
 4311 1d94 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4312 1d98 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4313 1d9c 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
1958:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDACKDURATION_OVERFLOWS,
 4314              		.loc 1 1958 0
 4315 1d9e 1A46     		mov	r2, r3
1960:openstack/02a-MAClow/IEEE802154Ecsl.c ****                          (errorparameter_t)ieee154e_dbg.num_cslSamples);
 4316              		.loc 1 1960 0
 4317 1da0 40F20003 		movw	r3, #:lower16:ieee154e_dbg
 4318 1da4 C0F20003 		movt	r3, #:upper16:ieee154e_dbg
 4319 1da8 1B69     		ldr	r3, [r3, #16]
1958:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printError(COMPONENT_IEEE802154E,ERR_WDACKDURATION_OVERFLOWS,
 4320              		.loc 1 1958 0
 4321 1daa 9BB2     		uxth	r3, r3
 4322 1dac 4FF00900 		mov	r0, #9
 4323 1db0 4FF02901 		mov	r1, #41
 4324 1db4 FFF7FEFF 		bl	openserial_printError
1961:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abort
1962:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 4325              		.loc 1 1962 0
 4326 1db8 FFF7FEFF 		bl	endOps
1963:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4327              		.loc 1 1963 0
 4328 1dbc 80BD     		pop	{r7, pc}
 4329              		.cfi_endproc
 4330              	.LFE51:
 4332 1dbe 00BF     		.align	2
 4333              		.global	activity_csl_data_ri9
 4334              		.thumb
 4335              		.thumb_func
 4337              	activity_csl_data_ri9:
 4338              	.LFB52:
1964:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1965:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
1966:openstack/02a-MAClow/IEEE802154Ecsl.c ****  \brief Activity for CSL RX Sampling stage [data ri9].
1967:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
1968:openstack/02a-MAClow/IEEE802154Ecsl.c ****   This method is invoked from ISR-mode "ieee154ecsl_endOfFrame" function when a end of frame event 
1969:openstack/02a-MAClow/IEEE802154Ecsl.c ****   The functionality is to change the state, cancel #rt8, free ack packet and notify upper layer.
1970:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
1971:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void activity_csl_data_ri9(PORT_RADIOTIMER_WIDTH capturedTime) {
 4339              		.loc 1 1971 0
 4340              		.cfi_startproc
 4341              		@ args = 0, pretend = 0, frame = 8
 4342              		@ frame_needed = 1, uses_anonymous_args = 0
 4343 1dc0 80B5     		push	{r7, lr}
 4344              	.LCFI121:
 4345              		.cfi_def_cfa_offset 8
 4346              		.cfi_offset 7, -8
 4347              		.cfi_offset 14, -4
 4348 1dc2 82B0     		sub	sp, sp, #8
 4349              	.LCFI122:
 4350              		.cfi_def_cfa_offset 16
 4351 1dc4 00AF     		add	r7, sp, #0
 4352              	.LCFI123:
 4353              		.cfi_def_cfa_register 7
 4354 1dc6 7860     		str	r0, [r7, #4]
1972:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
1973:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_CSLRXPROC);
 4355              		.loc 1 1973 0
 4356 1dc8 4FF03B00 		mov	r0, #59
 4357 1dcc FFF7FEFF 		bl	changeState
1974:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1975:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // cancel rt8
1976:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 4358              		.loc 1 1976 0
 4359 1dd0 FFF7FEFF 		bl	radiotimer_cancel
1977:openstack/02a-MAClow/IEEE802154Ecsl.c ****   
1978:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the captured time
1979:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.lastCapturedTime = capturedTime;
 4360              		.loc 1 1979 0
 4361 1dd4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4362 1dd8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4363 1ddc 7A68     		ldr	r2, [r7, #4]
 4364 1dde 5A62     		str	r2, [r3, #36]
1980:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1981:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // free the ack we just sent so corresponding RAM memory can be recycled
1982:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openqueue_freePacketBuffer(ieee154e_vars.ackToSend);
 4365              		.loc 1 1982 0
 4366 1de0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4367 1de4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4368 1de8 DB69     		ldr	r3, [r3, #28]
 4369 1dea 1846     		mov	r0, r3
 4370 1dec FFF7FEFF 		bl	openqueue_freePacketBuffer
1983:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1984:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clear local variable
1985:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.ackToSend = NULL;
 4371              		.loc 1 1985 0
 4372 1df0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4373 1df4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4374 1df8 4FF00002 		mov	r2, #0
 4375 1dfc DA61     		str	r2, [r3, #28]
1986:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1987:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // synchronize to the received packet
1988:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //if (idmanager_getIsDAGroot()==FALSE && neighbors_isPreferredParent(&(ieee154e_vars.dataReceive
1989:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   synchronizePacket(ieee154e_vars.syncCapturedTime);
1990:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //}
1991:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1992:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // inform upper layer of reception (after ACK sent)
1993:openstack/02a-MAClow/IEEE802154Ecsl.c ****    notif_receive(ieee154e_vars.dataReceived,1);
 4376              		.loc 1 1993 0
 4377 1dfe 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4378 1e02 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4379 1e06 9B69     		ldr	r3, [r3, #24]
 4380 1e08 1846     		mov	r0, r3
 4381 1e0a 4FF00101 		mov	r1, #1
 4382 1e0e FFF7FEFF 		bl	notif_receive
1994:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1995:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clear local variable
1996:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.dataReceived = NULL;
 4383              		.loc 1 1996 0
 4384 1e12 40F20003 		movw	r3, #:lower16:ieee154e_vars
 4385 1e16 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 4386 1e1a 4FF00002 		mov	r2, #0
 4387 1e1e 9A61     		str	r2, [r3, #24]
1997:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
1998:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // official end of Rx slot
1999:openstack/02a-MAClow/IEEE802154Ecsl.c ****    endOps();
 4388              		.loc 1 1999 0
 4389 1e20 FFF7FEFF 		bl	endOps
2000:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4390              		.loc 1 2000 0
 4391 1e24 07F10807 		add	r7, r7, #8
 4392 1e28 BD46     		mov	sp, r7
 4393 1e2a 80BD     		pop	{r7, pc}
 4394              		.cfi_endproc
 4395              	.LFE52:
 4397              		.align	2
 4398              		.global	ieee802154_createWakeUpFrame
 4399              		.thumb
 4400              		.thumb_func
 4402              	ieee802154_createWakeUpFrame:
 4403              	.LFB53:
2001:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2002:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2003:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2004:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================= WAKE-UP FRAMES ===============================
2005:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2006:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2007:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2008:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Prepend the IEEE802.15.4 MAC Wake-Up header to a (to be transmitted) packet.
2009:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2010:openstack/02a-MAClow/IEEE802154Ecsl.c **** Note that we are writing the field from the end of the header to the beginning.
2011:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2012:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in,out] msg              The message to append the header to.
2013:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in]     sequenceNumber   Sequence number of this frame.
2014:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in]     nextHop          Address of the next hop
2015:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in]     rztime           Rendezvoud time
2016:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2017:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2018:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CSL]: Prepend  a wake-up header to a packet.
2019:openstack/02a-MAClow/IEEE802154Ecsl.c **** void ieee802154_createWakeUpFrame(OpenQueueEntry_t*		msg,
2020:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                   uint8_t           	sequenceNumber,
2021:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                   open_addr_t*        	nextHop,
2022:openstack/02a-MAClow/IEEE802154Ecsl.c **** 							      uint16_t				rz_time) {
 4404              		.loc 1 2022 0
 4405              		.cfi_startproc
 4406              		@ args = 0, pretend = 0, frame = 40
 4407              		@ frame_needed = 1, uses_anonymous_args = 0
 4408 1e2c 80B5     		push	{r7, lr}
 4409              	.LCFI124:
 4410              		.cfi_def_cfa_offset 8
 4411              		.cfi_offset 7, -8
 4412              		.cfi_offset 14, -4
 4413 1e2e 8AB0     		sub	sp, sp, #40
 4414              	.LCFI125:
 4415              		.cfi_def_cfa_offset 48
 4416 1e30 00AF     		add	r7, sp, #0
 4417              	.LCFI126:
 4418              		.cfi_def_cfa_register 7
 4419 1e32 F860     		str	r0, [r7, #12]
 4420 1e34 7A60     		str	r2, [r7, #4]
 4421 1e36 0A46     		mov	r2, r1
 4422 1e38 FA72     		strb	r2, [r7, #11]
 4423 1e3a 3B81     		strh	r3, [r7, #8]	@ movhi
2023:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2024:openstack/02a-MAClow/IEEE802154Ecsl.c ****     open_addr_t	nextHop16b;
2025:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2026:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// La estructura de una trama Wake-Up es la siguiente:
2027:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//
2028:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   - FRAME CONTROL: 1 byte
2029:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   - SEQ NUMBER (macDSN): 1 byte
2030:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   - PAN ID: 2 bytes
2031:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   - DEST ADDR: 2 bytes
2032:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   - RZ TIME IE: 2 bytes (header) + 2 bytes (body)
2033:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   - IE LIST TERMINATOR: 2 bytes
2034:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//
2035:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//  | FRAME   |  SEQ   | PAN | DEST | RZ TIME  | IE LIST    |
2036:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//  | CONTROL | NUMBER |  ID | ADDR |  HDR IE  | TERMINATOR |
2037:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//
2038:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2039:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// Empezamos a escribir el payload de la trama wake-up empezando del final hacia adelante.
2040:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2041:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// IE LIST TERMINATOR, formado por 2 bytes con la siguiente estructura (0x3F80 o 0x3F00)
2042:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  - b0-b6 (Length) = 0
2043:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  - b7-b14 (Element ID) = 0x7e o 0x7f
2044:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  - b15 (Type) = 0
2045:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //
2046:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  b15 | b14 | b13 | b12 | b11 | b10 | b9 | b8 | b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 |
2047:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //   0  |  0  |  1  |  1  |  1  |  1  | 1  | 1  |  0 |  0 |  0 |  0 |  0 |  0 |  0 |  0 |
2048:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	packetfunctions_reserveHeaderSize(msg,sizeof(uint16_t));
 4424              		.loc 1 2048 0
 4425 1e3c F868     		ldr	r0, [r7, #12]
 4426 1e3e 4FF00201 		mov	r1, #2
 4427 1e42 FFF7FEFF 		bl	packetfunctions_reserveHeaderSize
2049:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	*((uint16_t*)(msg->payload)) = 0x3F00;  // Element ID = 0x7e
 4428              		.loc 1 2049 0
 4429 1e46 FB68     		ldr	r3, [r7, #12]
 4430 1e48 5B68     		ldr	r3, [r3, #4]
 4431 1e4a 4FF47C52 		mov	r2, #16128
 4432 1e4e 1A80     		strh	r2, [r3, #0]	@ movhi
2050:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2051:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// RZ TIME IE, formado por 4 bytes con la siguiente estructura (0x0E82). La cabecera es igual a:
2052:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  - b0-b6 (Length) = 2
2053:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  - b7-b14 (Element ID) = 0x1D
2054:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  - b15 (Type) = 0
2055:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  - b16-b31 (IE Content) = time (2 bytes)
2056:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //
2057:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //  b15 | b14 | b13 | b12 | b11 | b10 | b9 | b8 | b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 |
2058:openstack/02a-MAClow/IEEE802154Ecsl.c ****     //   0  |  0  |  0  |  0  |  1  |  1  |  1 |  0 |  1 |  0 |  0 |  0 |  0 |  0 |  1 |  0 |
2059:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2060:openstack/02a-MAClow/IEEE802154Ecsl.c ****  	// rz time ie body (time)
2061:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	packetfunctions_reserveHeaderSize(msg,sizeof(uint16_t));
 4433              		.loc 1 2061 0
 4434 1e50 F868     		ldr	r0, [r7, #12]
 4435 1e52 4FF00201 		mov	r1, #2
 4436 1e56 FFF7FEFF 		bl	packetfunctions_reserveHeaderSize
2062:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	*((uint16_t*)(msg->payload)) = rz_time;
 4437              		.loc 1 2062 0
 4438 1e5a FB68     		ldr	r3, [r7, #12]
 4439 1e5c 5B68     		ldr	r3, [r3, #4]
 4440 1e5e 3A89     		ldrh	r2, [r7, #8]	@ movhi
 4441 1e60 1A80     		strh	r2, [r3, #0]	@ movhi
2063:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2064:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// rz time ie header
2065:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	packetfunctions_reserveHeaderSize(msg,sizeof(uint16_t));
 4442              		.loc 1 2065 0
 4443 1e62 F868     		ldr	r0, [r7, #12]
 4444 1e64 4FF00201 		mov	r1, #2
 4445 1e68 FFF7FEFF 		bl	packetfunctions_reserveHeaderSize
2066:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	*((uint16_t*)(msg->payload)) = 0x0E82;
 4446              		.loc 1 2066 0
 4447 1e6c FB68     		ldr	r3, [r7, #12]
 4448 1e6e 5B68     		ldr	r3, [r3, #4]
 4449 1e70 40F68262 		movw	r2, #3714
 4450 1e74 1A80     		strh	r2, [r3, #0]	@ movhi
2067:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2068:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// DEST ADDR
2069:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	if (nextHop->type == ADDR_16B) {
 4451              		.loc 1 2069 0
 4452 1e76 7B68     		ldr	r3, [r7, #4]
 4453 1e78 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 4454 1e7a 012B     		cmp	r3, #1
 4455 1e7c 06D1     		bne	.L198
2070:openstack/02a-MAClow/IEEE802154Ecsl.c ****   	   packetfunctions_writeAddress(msg,nextHop,OW_LITTLE_ENDIAN);
 4456              		.loc 1 2070 0
 4457 1e7e F868     		ldr	r0, [r7, #12]
 4458 1e80 7968     		ldr	r1, [r7, #4]
 4459 1e82 4FF00102 		mov	r2, #1
 4460 1e86 FFF7FEFF 		bl	packetfunctions_writeAddress
 4461 1e8a 11E0     		b	.L199
 4462              	.L198:
2071:openstack/02a-MAClow/IEEE802154Ecsl.c ****     } else if (nextHop->type == ADDR_64B) {
 4463              		.loc 1 2071 0
 4464 1e8c 7B68     		ldr	r3, [r7, #4]
 4465 1e8e 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 4466 1e90 022B     		cmp	r3, #2
 4467 1e92 0DD1     		bne	.L199
2072:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   packetfunctions_mac64bToMac16b(nextHop, &nextHop16b);
 4468              		.loc 1 2072 0
 4469 1e94 07F11403 		add	r3, r7, #20
 4470 1e98 7868     		ldr	r0, [r7, #4]
 4471 1e9a 1946     		mov	r1, r3
 4472 1e9c FFF7FEFF 		bl	packetfunctions_mac64bToMac16b
2073:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	   packetfunctions_writeAddress(msg,&nextHop16b,OW_LITTLE_ENDIAN);
 4473              		.loc 1 2073 0
 4474 1ea0 07F11403 		add	r3, r7, #20
 4475 1ea4 F868     		ldr	r0, [r7, #12]
 4476 1ea6 1946     		mov	r1, r3
 4477 1ea8 4FF00102 		mov	r2, #1
 4478 1eac FFF7FEFF 		bl	packetfunctions_writeAddress
 4479              	.L199:
2074:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	}
2075:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2076:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// PAN ID
2077:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	packetfunctions_writeAddress(msg,idmanager_getMyID(ADDR_PANID),OW_LITTLE_ENDIAN);
 4480              		.loc 1 2077 0
 4481 1eb0 4FF00400 		mov	r0, #4
 4482 1eb4 FFF7FEFF 		bl	idmanager_getMyID
 4483 1eb8 0346     		mov	r3, r0
 4484 1eba F868     		ldr	r0, [r7, #12]
 4485 1ebc 1946     		mov	r1, r3
 4486 1ebe 4FF00102 		mov	r2, #1
 4487 1ec2 FFF7FEFF 		bl	packetfunctions_writeAddress
2078:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2079:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// SEQ NUMBER
2080:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	packetfunctions_reserveHeaderSize(msg,sizeof(uint8_t));
 4488              		.loc 1 2080 0
 4489 1ec6 F868     		ldr	r0, [r7, #12]
 4490 1ec8 4FF00101 		mov	r1, #1
 4491 1ecc FFF7FEFF 		bl	packetfunctions_reserveHeaderSize
2081:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	*((uint8_t*)(msg->payload)) = sequenceNumber;
 4492              		.loc 1 2081 0
 4493 1ed0 FB68     		ldr	r3, [r7, #12]
 4494 1ed2 5B68     		ldr	r3, [r3, #4]
 4495 1ed4 FA7A     		ldrb	r2, [r7, #11]
 4496 1ed6 1A70     		strb	r2, [r3, #0]
2082:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2083:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// La estructura del FCF en la trama de wake-up es 0x55 = 01010101b:
2084:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// b0-b2 -- Frame Type (debe ser 101 para trama wake-up)
2085:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// b3 ----- Long Frame Control (debe ser 0 para indicar que se trata de un FCF de 1 byte como es e
2086:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// b4-b5 -- Dest Addr Mode (en este caso, short address por lo que tiene que valer 10).
2087:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// b6-b7 -- Src Addr Mode (en este caso, short address por lo que tiene que valer 10).
2088:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2089:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//  b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 |
2090:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	//   0 |  1 |  0 |  1 |  0 |  1 |  0 |  1 |
2091:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2092:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	// FCF
2093:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	packetfunctions_reserveHeaderSize(msg,sizeof(uint8_t));
 4497              		.loc 1 2093 0
 4498 1ed8 F868     		ldr	r0, [r7, #12]
 4499 1eda 4FF00101 		mov	r1, #1
 4500 1ede FFF7FEFF 		bl	packetfunctions_reserveHeaderSize
2094:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	*((uint8_t*)(msg->payload)) = 0x55;
 4501              		.loc 1 2094 0
 4502 1ee2 FB68     		ldr	r3, [r7, #12]
 4503 1ee4 5B68     		ldr	r3, [r3, #4]
 4504 1ee6 4FF05502 		mov	r2, #85
 4505 1eea 1A70     		strb	r2, [r3, #0]
2095:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2096:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4506              		.loc 1 2096 0
 4507 1eec 07F12807 		add	r7, r7, #40
 4508 1ef0 BD46     		mov	sp, r7
 4509 1ef2 80BD     		pop	{r7, pc}
 4510              		.cfi_endproc
 4511              	.LFE53:
 4513              		.align	2
 4514              		.global	ieee802154_retrieveWakeUpFrame
 4515              		.thumb
 4516              		.thumb_func
 4518              	ieee802154_retrieveWakeUpFrame:
 4519              	.LFB54:
2097:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2098:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2099:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Retrieve the IEEE802.15.4 MAC Wake-Up Frame header from a (just received) packet.
2100:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2101:openstack/02a-MAClow/IEEE802154Ecsl.c **** Note We are writing the fields from the beginning of the header to the end.
2102:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2103:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in,out] msg            The message just received.
2104:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[out] ieee802514_header The internal header to write the data to.
2105:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[out] rztime  		  Rendezvous time to wait for data packet.
2106:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2107:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2108:openstack/02a-MAClow/IEEE802154Ecsl.c **** // [CSL]: Retrieve a wake-up header from the received packet.
2109:openstack/02a-MAClow/IEEE802154Ecsl.c **** void ieee802154_retrieveWakeUpFrame(OpenQueueEntry_t*      msg,
2110:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                     ieee802154_header_iht* ieee802514_header,
2111:openstack/02a-MAClow/IEEE802154Ecsl.c **** 									uint16_t* rztime) {
 4520              		.loc 1 2111 0
 4521              		.cfi_startproc
 4522              		@ args = 0, pretend = 0, frame = 24
 4523              		@ frame_needed = 1, uses_anonymous_args = 0
 4524 1ef4 80B5     		push	{r7, lr}
 4525              	.LCFI127:
 4526              		.cfi_def_cfa_offset 8
 4527              		.cfi_offset 7, -8
 4528              		.cfi_offset 14, -4
 4529 1ef6 86B0     		sub	sp, sp, #24
 4530              	.LCFI128:
 4531              		.cfi_def_cfa_offset 32
 4532 1ef8 00AF     		add	r7, sp, #0
 4533              	.LCFI129:
 4534              		.cfi_def_cfa_register 7
 4535 1efa F860     		str	r0, [r7, #12]
 4536 1efc B960     		str	r1, [r7, #8]
 4537 1efe 7A60     		str	r2, [r7, #4]
2112:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t temp_8b, temp_8b1, temp_8b2;
2113:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t src_addr_mode, dst_addr_mode;
2114:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint16_t temp_16b;
2115:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2116:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2117:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // La estructura de una trama Wake-Up es la siguiente:
2118:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2119:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - FRAME CONTROL: 1 byte
2120:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - SEQ NUMBER (macDSN): 1 byte
2121:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - PAN ID: 2 bytes
2122:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - DEST ADDR: 2 bytes
2123:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - RZ TIME IE: 2 bytes
2124:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - IE LIST TERMINATOR: 2 bytes
2125:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2126:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  | FRAME   |  SEQ   | PAN | DEST | RZ TIME  | IE LIST    |
2127:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  | CONTROL | NUMBER |  ID | ADDR |  HDR IE  | TERMINATOR |
2128:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2129:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2130:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Por defecto, se asume que la cabecera no es válida en el caso de
2131:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // abandonar la función al ser el paquete más corto que la cabecera.
2132:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->valid=FALSE;
 4538              		.loc 1 2132 0
 4539 1f00 BB68     		ldr	r3, [r7, #8]
 4540 1f02 4FF00002 		mov	r2, #0
 4541 1f06 1A70     		strb	r2, [r3, #0]
2133:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength = 0;
 4542              		.loc 1 2133 0
 4543 1f08 BB68     		ldr	r3, [r7, #8]
 4544 1f0a 4FF00002 		mov	r2, #0
 4545 1f0e 5A70     		strb	r2, [r3, #1]
2134:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2135:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Validamos la existencia de datos que leer.
2136:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; }
 4546              		.loc 1 2136 0
 4547 1f10 BB68     		ldr	r3, [r7, #8]
 4548 1f12 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 4549 1f14 FB68     		ldr	r3, [r7, #12]
 4550 1f16 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4551 1f18 9A42     		cmp	r2, r3
 4552 1f1a 00F25F81 		bhi	.L223
 4553              	.L201:
2137:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2138:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Frame Control Field (1 byte)
2139:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_8b = *((uint8_t*)(msg->payload)+ieee802514_header->headerLength);
 4554              		.loc 1 2139 0
 4555 1f1e FB68     		ldr	r3, [r7, #12]
 4556 1f20 5A68     		ldr	r2, [r3, #4]
 4557 1f22 BB68     		ldr	r3, [r7, #8]
 4558 1f24 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4559 1f26 D318     		adds	r3, r2, r3
 4560 1f28 1B78     		ldrb	r3, [r3, #0]
 4561 1f2a FB75     		strb	r3, [r7, #23]
2140:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2141:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // La estructura del FCF en la trama de wake-up es 0x55 = 01010101b:
2142:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // b0-b2 -- Frame Type (debe ser 101 para trama wake-up)
2143:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // b3 ----- Long Frame Control (debe ser 0 para indicar que se trata de un FCF de 1 byte como es
2144:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // b4-b5 -- Dest Addr Mode (en este caso, short address por lo que tiene que valer 10).
2145:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // b6-b7 -- Src Addr Mode (en este caso, short address por lo que tiene que valer 10).
2146:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2147:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 |
2148:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   0 |  1 |  0 |  1 |  0 |  1 |  0 |  1 |
2149:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2150:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->frameType = (temp_8b >> IEEE154_FCF_FRAME_TYPE) & 0x07;//3b
 4562              		.loc 1 2150 0
 4563 1f2c FB7D     		ldrb	r3, [r7, #23]
 4564 1f2e 03F00703 		and	r3, r3, #7
 4565 1f32 DAB2     		uxtb	r2, r3
 4566 1f34 BB68     		ldr	r3, [r7, #8]
 4567 1f36 9A70     		strb	r2, [r3, #2]
2151:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2152:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Comprobamos que efectivamente se trata de una trama de tipo MULTIPURPOSE.
2153:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->frameType != IEEE154_TYPE_MULTIPURPOSE) {return; }
 4568              		.loc 1 2153 0
 4569 1f38 BB68     		ldr	r3, [r7, #8]
 4570 1f3a 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 4571 1f3c 052B     		cmp	r3, #5
 4572 1f3e 40F04F81 		bne	.L224
 4573              	.L203:
2154:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2155:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Verificamos que efectivamente el campo Long Frame Control tiene valor cero para indicar que e
2156:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_8b >> 3) & 0x01) { return; }
 4574              		.loc 1 2156 0
 4575 1f42 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 4576 1f44 4FEAD303 		lsr	r3, r3, #3
 4577 1f48 DBB2     		uxtb	r3, r3
 4578 1f4a 03F00103 		and	r3, r3, #1
 4579 1f4e 002B     		cmp	r3, #0
 4580 1f50 40F04881 		bne	.L225
 4581              	.L204:
2157:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2158:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Recuperamos los Destination y Source Address Mode
2159:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2160:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Destination Address Mode
2161:openstack/02a-MAClow/IEEE802154Ecsl.c ****    dst_addr_mode = (temp_8b >> 4) & 0x03;
 4582              		.loc 1 2161 0
 4583 1f54 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 4584 1f56 4FEA1313 		lsr	r3, r3, #4
 4585 1f5a DBB2     		uxtb	r3, r3
 4586 1f5c 03F00303 		and	r3, r3, #3
 4587 1f60 BB75     		strb	r3, [r7, #22]
2162:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if(dst_addr_mode == 1) { // 01 en binario en bits b5-b4
 4588              		.loc 1 2162 0
 4589 1f62 BB7D     		ldrb	r3, [r7, #22]	@ zero_extendqisi2
 4590 1f64 012B     		cmp	r3, #1
 4591 1f66 0BD1     		bne	.L205
2163:openstack/02a-MAClow/IEEE802154Ecsl.c ****      // Debería ser siempre este caso en las tramas wake-up por lo que se trata como error cualqui
2164:openstack/02a-MAClow/IEEE802154Ecsl.c ****      ieee802514_header->dest.type = ADDR_16B;
 4592              		.loc 1 2164 0
 4593 1f68 BB68     		ldr	r3, [r7, #8]
 4594 1f6a 4FF00102 		mov	r2, #1
 4595 1f6e DA76     		strb	r2, [r3, #27]
2165:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2166:openstack/02a-MAClow/IEEE802154Ecsl.c ****    else {
2167:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	 openserial_printError(COMPONENT_IEEE802154,ERR_IEEE154_UNSUPPORTED, (errorparameter_t)1, (errorpa
2168:openstack/02a-MAClow/IEEE802154Ecsl.c ****      return; // this is an invalid packet, return
2169:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2170:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2171:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Source Address Mode
2172:openstack/02a-MAClow/IEEE802154Ecsl.c ****    src_addr_mode = (temp_8b >> 6) & 0x03;
 4596              		.loc 1 2172 0
 4597 1f70 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 4598 1f72 4FEA9313 		lsr	r3, r3, #6
 4599 1f76 7B75     		strb	r3, [r7, #21]
2173:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if(src_addr_mode == 1) { // 01 en binario en bits b7-b6
 4600              		.loc 1 2173 0
 4601 1f78 7B7D     		ldrb	r3, [r7, #21]	@ zero_extendqisi2
 4602 1f7a 012B     		cmp	r3, #1
 4603 1f7c 0BD0     		beq	.L206
 4604 1f7e 1EE0     		b	.L221
 4605              	.L205:
2167:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	 openserial_printError(COMPONENT_IEEE802154,ERR_IEEE154_UNSUPPORTED, (errorparameter_t)1, (errorpa
 4606              		.loc 1 2167 0
 4607 1f80 BB7D     		ldrb	r3, [r7, #22]	@ zero_extendqisi2
 4608 1f82 9BB2     		uxth	r3, r3
 4609 1f84 4FF00800 		mov	r0, #8
 4610 1f88 4FF01901 		mov	r1, #25
 4611 1f8c 4FF00102 		mov	r2, #1
 4612 1f90 FFF7FEFF 		bl	openserial_printError
2168:openstack/02a-MAClow/IEEE802154Ecsl.c ****      return; // this is an invalid packet, return
 4613              		.loc 1 2168 0
 4614 1f94 3FE1     		b	.L200
 4615              	.L206:
2174:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Debería ser siempre este caso en las tramas wake-up por lo que se trata como error cualqu
2175:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee802514_header->src.type = ADDR_16B;
 4616              		.loc 1 2175 0
 4617 1f96 BB68     		ldr	r3, [r7, #8]
 4618 1f98 4FF00102 		mov	r2, #1
 4619 1f9c 83F82C20 		strb	r2, [r3, #44]
2176:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2177:openstack/02a-MAClow/IEEE802154Ecsl.c ****    else {
2178:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printError(COMPONENT_IEEE802154,ERR_IEEE154_UNSUPPORTED, (errorparameter_t)2, (errorp
2179:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return; // this is an invalid packet, return
2180:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2181:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2182:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2183:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // En este punto ya hemos analizado el contenido del primer byte de la cabecera correspondiente 
2184:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2185:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2186:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // A partir de este punto, la estructura del paquete es la siguiente:
2187:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - SEQ NUMBER (macDSN): 1 byte
2188:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - PAN ID: 2 bytes
2189:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - DEST ADDR: 2 bytes
2190:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - RZ TIME IE: 2 bytes
2191:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   - IE LIST TERMINATOR: 2 bytes
2192:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2193:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2194:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Avanzamos 1 byte en el procesamiento de la cabecera.
2195:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 1;
 4620              		.loc 1 2195 0
 4621 1fa0 BB68     		ldr	r3, [r7, #8]
 4622 1fa2 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4623 1fa4 03F10103 		add	r3, r3, #1
 4624 1fa8 DAB2     		uxtb	r2, r3
 4625 1faa BB68     		ldr	r3, [r7, #8]
 4626 1fac 5A70     		strb	r2, [r3, #1]
2196:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2197:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Posicionamos dentro del paquete para leer el resto de elementos.
2198:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2199:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // 1.- SequenceNumber
2200:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4627              		.loc 1 2200 0
 4628 1fae BB68     		ldr	r3, [r7, #8]
 4629 1fb0 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 4630 1fb2 FB68     		ldr	r3, [r7, #12]
 4631 1fb4 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4632 1fb6 9A42     		cmp	r2, r3
 4633 1fb8 00F21681 		bhi	.L226
 4634 1fbc 0AE0     		b	.L222
 4635              	.L221:
2178:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	  openserial_printError(COMPONENT_IEEE802154,ERR_IEEE154_UNSUPPORTED, (errorparameter_t)2, (errorp
 4636              		.loc 1 2178 0
 4637 1fbe 7B7D     		ldrb	r3, [r7, #21]	@ zero_extendqisi2
 4638 1fc0 9BB2     		uxth	r3, r3
 4639 1fc2 4FF00800 		mov	r0, #8
 4640 1fc6 4FF01901 		mov	r1, #25
 4641 1fca 4FF00202 		mov	r2, #2
 4642 1fce FFF7FEFF 		bl	openserial_printError
2179:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return; // this is an invalid packet, return
 4643              		.loc 1 2179 0
 4644 1fd2 20E1     		b	.L200
 4645              	.L222:
2201:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->dsn  = *((uint8_t*)(msg->payload)+ieee802514_header->headerLength);
 4646              		.loc 1 2201 0
 4647 1fd4 FB68     		ldr	r3, [r7, #12]
 4648 1fd6 5A68     		ldr	r2, [r3, #4]
 4649 1fd8 BB68     		ldr	r3, [r7, #8]
 4650 1fda 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4651 1fdc D318     		adds	r3, r2, r3
 4652 1fde 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 4653 1fe0 BB68     		ldr	r3, [r7, #8]
 4654 1fe2 5A72     		strb	r2, [r3, #9]
2202:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 1;
 4655              		.loc 1 2202 0
 4656 1fe4 BB68     		ldr	r3, [r7, #8]
 4657 1fe6 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4658 1fe8 03F10103 		add	r3, r3, #1
 4659 1fec DAB2     		uxtb	r2, r3
 4660 1fee BB68     		ldr	r3, [r7, #8]
 4661 1ff0 5A70     		strb	r2, [r3, #1]
2203:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2204:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // 2.- panID
2205:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4662              		.loc 1 2205 0
 4663 1ff2 BB68     		ldr	r3, [r7, #8]
 4664 1ff4 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 4665 1ff6 FB68     		ldr	r3, [r7, #12]
 4666 1ff8 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4667 1ffa 9A42     		cmp	r2, r3
 4668 1ffc 00F2F680 		bhi	.L227
 4669              	.L210:
2206:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packetfunctions_readAddress(((uint8_t*)(msg->payload)+ieee802514_header->headerLength), ADDR_PAN
 4670              		.loc 1 2206 0
 4671 2000 FB68     		ldr	r3, [r7, #12]
 4672 2002 5A68     		ldr	r2, [r3, #4]
 4673 2004 BB68     		ldr	r3, [r7, #8]
 4674 2006 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4675 2008 D218     		adds	r2, r2, r3
 4676 200a BB68     		ldr	r3, [r7, #8]
 4677 200c 03F10A03 		add	r3, r3, #10
 4678 2010 1046     		mov	r0, r2
 4679 2012 4FF00401 		mov	r1, #4
 4680 2016 1A46     		mov	r2, r3
 4681 2018 4FF00103 		mov	r3, #1
 4682 201c FFF7FEFF 		bl	packetfunctions_readAddress
2207:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 2;
 4683              		.loc 1 2207 0
 4684 2020 BB68     		ldr	r3, [r7, #8]
 4685 2022 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4686 2024 03F10203 		add	r3, r3, #2
 4687 2028 DAB2     		uxtb	r2, r3
 4688 202a BB68     		ldr	r3, [r7, #8]
 4689 202c 5A70     		strb	r2, [r3, #1]
2208:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2209:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // 3.- Dest Addr
2210:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4690              		.loc 1 2210 0
 4691 202e BB68     		ldr	r3, [r7, #8]
 4692 2030 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 4693 2032 FB68     		ldr	r3, [r7, #12]
 4694 2034 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4695 2036 9A42     		cmp	r2, r3
 4696 2038 00F2DA80 		bhi	.L228
 4697              	.L211:
2211:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2212:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // En este punto ya sabemos que el tipo de dirección tiene que ser ADDR_16B dado que cualquier 
2213:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // en la lectura del frame control field por lo que leemos los 2 bytes de la dirección del dest
2214:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packetfunctions_readAddress(((uint8_t*)(msg->payload)+ieee802514_header->headerLength), ADDR_16B
 4698              		.loc 1 2214 0
 4699 203c FB68     		ldr	r3, [r7, #12]
 4700 203e 5A68     		ldr	r2, [r3, #4]
 4701 2040 BB68     		ldr	r3, [r7, #8]
 4702 2042 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4703 2044 D218     		adds	r2, r2, r3
 4704 2046 BB68     		ldr	r3, [r7, #8]
 4705 2048 03F11B03 		add	r3, r3, #27
 4706 204c 1046     		mov	r0, r2
 4707 204e 4FF00101 		mov	r1, #1
 4708 2052 1A46     		mov	r2, r3
 4709 2054 4FF00103 		mov	r3, #1
 4710 2058 FFF7FEFF 		bl	packetfunctions_readAddress
2215:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 2;
 4711              		.loc 1 2215 0
 4712 205c BB68     		ldr	r3, [r7, #8]
 4713 205e 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4714 2060 03F10203 		add	r3, r3, #2
 4715 2064 DAB2     		uxtb	r2, r3
 4716 2066 BB68     		ldr	r3, [r7, #8]
 4717 2068 5A70     		strb	r2, [r3, #1]
2216:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2217:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // 4.- RZ Time Header IE, formado por 4 bytes con la siguiente estructura (0x0E82)
2218:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  - b0-b6 (Length) = 2
2219:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  - b7-b14 (Element ID) = 0x1D
2220:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  - b15 (Type) = 0
2221:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  - b16-b31 (IE Content) = time (2 bytes)
2222:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2223:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  b15 | b14 | b13 | b12 | b11 | b10 | b9 | b8 | b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 |
2224:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   0  |  0  |  0  |  0  |  1  |  1  |  1 |  0 |  1 |  0 |  0 |  0 |  0 |  0 |  1 |  0 |
2225:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2226:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) {  return; } // no more to read!
 4718              		.loc 1 2226 0
 4719 206a BB68     		ldr	r3, [r7, #8]
 4720 206c 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 4721 206e FB68     		ldr	r3, [r7, #12]
 4722 2070 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4723 2072 9A42     		cmp	r2, r3
 4724 2074 00F2BE80 		bhi	.L229
 4725              	.L212:
2227:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2228:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Verificamos longitud a valor 2 y el elementID a valor 0x1D. Lo hacemos leyendo los primeros 2
2229:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_8b1 = *((uint8_t*)(msg->payload)+ieee802514_header->headerLength);
 4726              		.loc 1 2229 0
 4727 2078 FB68     		ldr	r3, [r7, #12]
 4728 207a 5A68     		ldr	r2, [r3, #4]
 4729 207c BB68     		ldr	r3, [r7, #8]
 4730 207e 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4731 2080 D318     		adds	r3, r2, r3
 4732 2082 1B78     		ldrb	r3, [r3, #0]
 4733 2084 3B75     		strb	r3, [r7, #20]
2230:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 1;
 4734              		.loc 1 2230 0
 4735 2086 BB68     		ldr	r3, [r7, #8]
 4736 2088 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4737 208a 03F10103 		add	r3, r3, #1
 4738 208e DAB2     		uxtb	r2, r3
 4739 2090 BB68     		ldr	r3, [r7, #8]
 4740 2092 5A70     		strb	r2, [r3, #1]
2231:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2232:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_8b2 = *((uint8_t*)(msg->payload)+ieee802514_header->headerLength);
 4741              		.loc 1 2232 0
 4742 2094 FB68     		ldr	r3, [r7, #12]
 4743 2096 5A68     		ldr	r2, [r3, #4]
 4744 2098 BB68     		ldr	r3, [r7, #8]
 4745 209a 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4746 209c D318     		adds	r3, r2, r3
 4747 209e 1B78     		ldrb	r3, [r3, #0]
 4748 20a0 FB74     		strb	r3, [r7, #19]
2233:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 1;
 4749              		.loc 1 2233 0
 4750 20a2 BB68     		ldr	r3, [r7, #8]
 4751 20a4 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4752 20a6 03F10103 		add	r3, r3, #1
 4753 20aa DAB2     		uxtb	r2, r3
 4754 20ac BB68     		ldr	r3, [r7, #8]
 4755 20ae 5A70     		strb	r2, [r3, #1]
2234:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2235:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_16b = (temp_8b2 << 8) | temp_8b1;
 4756              		.loc 1 2235 0
 4757 20b0 FB7C     		ldrb	r3, [r7, #19]	@ zero_extendqisi2
 4758 20b2 4FEA0323 		lsl	r3, r3, #8
 4759 20b6 9AB2     		uxth	r2, r3
 4760 20b8 3B7D     		ldrb	r3, [r7, #20]	@ zero_extendqisi2
 4761 20ba 9BB2     		uxth	r3, r3
 4762 20bc 1343     		orrs	r3, r3, r2
 4763 20be 9BB2     		uxth	r3, r3
 4764 20c0 3B82     		strh	r3, [r7, #16]	@ movhi
2236:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2237:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Comprobación de longitud a valor 2.
2238:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b & 0x007f) != 2) { return; }
 4765              		.loc 1 2238 0
 4766 20c2 3B8A     		ldrh	r3, [r7, #16]
 4767 20c4 03F07F03 		and	r3, r3, #127
 4768 20c8 022B     		cmp	r3, #2
 4769 20ca 40F09580 		bne	.L230
 4770              	.L213:
2239:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2240:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Comprobación de element ID = 0x1D.
2241:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b >> 7) != 0x001d) { return; }
 4771              		.loc 1 2241 0
 4772 20ce 3B8A     		ldrh	r3, [r7, #16]
 4773 20d0 4FEAD313 		lsr	r3, r3, #7
 4774 20d4 9BB2     		uxth	r3, r3
 4775 20d6 1D2B     		cmp	r3, #29
 4776 20d8 40F09080 		bne	.L231
 4777              	.L214:
2242:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2243:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Comprobación del type = 0.
2244:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b >> 15) & 0x0001) { return; }
 4778              		.loc 1 2244 0
 4779 20dc 3B8A     		ldrh	r3, [r7, #16]
 4780 20de 4FEAD333 		lsr	r3, r3, #15
 4781 20e2 9BB2     		uxth	r3, r3
 4782 20e4 03F00103 		and	r3, r3, #1
 4783 20e8 002B     		cmp	r3, #0
 4784 20ea 40F08980 		bne	.L232
 4785              	.L215:
2245:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2246:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Obtención del IE Content (rztime).
2247:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4786              		.loc 1 2247 0
 4787 20ee BB68     		ldr	r3, [r7, #8]
 4788 20f0 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 4789 20f2 FB68     		ldr	r3, [r7, #12]
 4790 20f4 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4791 20f6 9A42     		cmp	r2, r3
 4792 20f8 00F28480 		bhi	.L233
 4793              	.L216:
2248:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2249:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_8b1 = *((uint8_t*)(msg->payload)+ieee802514_header->headerLength);
 4794              		.loc 1 2249 0
 4795 20fc FB68     		ldr	r3, [r7, #12]
 4796 20fe 5A68     		ldr	r2, [r3, #4]
 4797 2100 BB68     		ldr	r3, [r7, #8]
 4798 2102 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4799 2104 D318     		adds	r3, r2, r3
 4800 2106 1B78     		ldrb	r3, [r3, #0]
 4801 2108 3B75     		strb	r3, [r7, #20]
2250:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 1;
 4802              		.loc 1 2250 0
 4803 210a BB68     		ldr	r3, [r7, #8]
 4804 210c 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4805 210e 03F10103 		add	r3, r3, #1
 4806 2112 DAB2     		uxtb	r2, r3
 4807 2114 BB68     		ldr	r3, [r7, #8]
 4808 2116 5A70     		strb	r2, [r3, #1]
2251:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2252:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_8b2 = *((uint8_t*)(msg->payload)+ieee802514_header->headerLength);
 4809              		.loc 1 2252 0
 4810 2118 FB68     		ldr	r3, [r7, #12]
 4811 211a 5A68     		ldr	r2, [r3, #4]
 4812 211c BB68     		ldr	r3, [r7, #8]
 4813 211e 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4814 2120 D318     		adds	r3, r2, r3
 4815 2122 1B78     		ldrb	r3, [r3, #0]
 4816 2124 FB74     		strb	r3, [r7, #19]
2253:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 1;
 4817              		.loc 1 2253 0
 4818 2126 BB68     		ldr	r3, [r7, #8]
 4819 2128 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4820 212a 03F10103 		add	r3, r3, #1
 4821 212e DAB2     		uxtb	r2, r3
 4822 2130 BB68     		ldr	r3, [r7, #8]
 4823 2132 5A70     		strb	r2, [r3, #1]
2254:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2255:openstack/02a-MAClow/IEEE802154Ecsl.c ****    (*rztime) = (temp_8b2 << 8) | temp_8b1;
 4824              		.loc 1 2255 0
 4825 2134 FB7C     		ldrb	r3, [r7, #19]	@ zero_extendqisi2
 4826 2136 4FEA0323 		lsl	r3, r3, #8
 4827 213a 9AB2     		uxth	r2, r3
 4828 213c 3B7D     		ldrb	r3, [r7, #20]	@ zero_extendqisi2
 4829 213e 9BB2     		uxth	r3, r3
 4830 2140 1343     		orrs	r3, r3, r2
 4831 2142 9BB2     		uxth	r3, r3
 4832 2144 9AB2     		uxth	r2, r3
 4833 2146 7B68     		ldr	r3, [r7, #4]
 4834 2148 1A80     		strh	r2, [r3, #0]	@ movhi
2256:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2257:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // 5.- IE List Terminator, formado por 2 bytes con la siguiente estructura (0x3F80 o 0x3F00)
2258:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  - b0-b6 (Length) = 0
2259:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  - b7-b14 (Element ID) = 0x7e o 0x7f
2260:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  - b15 (Type) = 0
2261:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //
2262:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //  b15 | b14 | b13 | b12 | b11 | b10 | b9 | b8 | b7 | b6 | b5 | b4 | b3 | b2 | b1 | b0 |
2263:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //   0  |  0  |  1  |  1  |  1  |  1  | 1  | 1  |  0 |  0 |  0 |  0 |  0 |  0 |  0 |  0 |
2264:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2265:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4835              		.loc 1 2265 0
 4836 214a BB68     		ldr	r3, [r7, #8]
 4837 214c 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 4838 214e FB68     		ldr	r3, [r7, #12]
 4839 2150 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 4840 2152 9A42     		cmp	r2, r3
 4841 2154 58D8     		bhi	.L234
 4842              	.L217:
2266:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2267:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Verificamos longitud a valor 0 y el elementID a valor 0x7E o 0x7F. Lo hacemos leyendo los 2 b
2268:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_8b1 = *((uint8_t*)(msg->payload)+ieee802514_header->headerLength);
 4843              		.loc 1 2268 0
 4844 2156 FB68     		ldr	r3, [r7, #12]
 4845 2158 5A68     		ldr	r2, [r3, #4]
 4846 215a BB68     		ldr	r3, [r7, #8]
 4847 215c 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4848 215e D318     		adds	r3, r2, r3
 4849 2160 1B78     		ldrb	r3, [r3, #0]
 4850 2162 3B75     		strb	r3, [r7, #20]
2269:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 1;
 4851              		.loc 1 2269 0
 4852 2164 BB68     		ldr	r3, [r7, #8]
 4853 2166 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4854 2168 03F10103 		add	r3, r3, #1
 4855 216c DAB2     		uxtb	r2, r3
 4856 216e BB68     		ldr	r3, [r7, #8]
 4857 2170 5A70     		strb	r2, [r3, #1]
2270:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2271:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_8b2 = *((uint8_t*)(msg->payload)+ieee802514_header->headerLength);
 4858              		.loc 1 2271 0
 4859 2172 FB68     		ldr	r3, [r7, #12]
 4860 2174 5A68     		ldr	r2, [r3, #4]
 4861 2176 BB68     		ldr	r3, [r7, #8]
 4862 2178 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4863 217a D318     		adds	r3, r2, r3
 4864 217c 1B78     		ldrb	r3, [r3, #0]
 4865 217e FB74     		strb	r3, [r7, #19]
2272:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->headerLength += 1;
 4866              		.loc 1 2272 0
 4867 2180 BB68     		ldr	r3, [r7, #8]
 4868 2182 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 4869 2184 03F10103 		add	r3, r3, #1
 4870 2188 DAB2     		uxtb	r2, r3
 4871 218a BB68     		ldr	r3, [r7, #8]
 4872 218c 5A70     		strb	r2, [r3, #1]
2273:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2274:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_16b = (temp_8b2 << 8) | temp_8b1;
 4873              		.loc 1 2274 0
 4874 218e FB7C     		ldrb	r3, [r7, #19]	@ zero_extendqisi2
 4875 2190 4FEA0323 		lsl	r3, r3, #8
 4876 2194 9AB2     		uxth	r2, r3
 4877 2196 3B7D     		ldrb	r3, [r7, #20]	@ zero_extendqisi2
 4878 2198 9BB2     		uxth	r3, r3
 4879 219a 1343     		orrs	r3, r3, r2
 4880 219c 9BB2     		uxth	r3, r3
 4881 219e 3B82     		strh	r3, [r7, #16]	@ movhi
2275:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2276:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Comprobación de longitud a valor 0.
2277:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (temp_16b & 0x007f) { return; }
 4882              		.loc 1 2277 0
 4883 21a0 3B8A     		ldrh	r3, [r7, #16]
 4884 21a2 03F07F03 		and	r3, r3, #127
 4885 21a6 002B     		cmp	r3, #0
 4886 21a8 30D1     		bne	.L235
 4887              	.L218:
2278:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2279:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Comprobación de element ID = 0x7E o 0x7F.
2280:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (((temp_16b >> 7) != 0x7e) && ((temp_16b >> 7) != 0x7f)) { return; }
 4888              		.loc 1 2280 0
 4889 21aa 3B8A     		ldrh	r3, [r7, #16]
 4890 21ac 4FEAD313 		lsr	r3, r3, #7
 4891 21b0 9BB2     		uxth	r3, r3
 4892 21b2 7E2B     		cmp	r3, #126
 4893 21b4 05D0     		beq	.L219
 4894              		.loc 1 2280 0 is_stmt 0 discriminator 1
 4895 21b6 3B8A     		ldrh	r3, [r7, #16]
 4896 21b8 4FEAD313 		lsr	r3, r3, #7
 4897 21bc 9BB2     		uxth	r3, r3
 4898 21be 7F2B     		cmp	r3, #127
 4899 21c0 26D1     		bne	.L236
 4900              	.L219:
2281:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2282:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Comprobación del type = 0.
2283:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b >> 15) & 0x0001) { return; }
 4901              		.loc 1 2283 0 is_stmt 1
 4902 21c2 3B8A     		ldrh	r3, [r7, #16]
 4903 21c4 4FEAD333 		lsr	r3, r3, #15
 4904 21c8 9BB2     		uxth	r3, r3
 4905 21ca 03F00103 		and	r3, r3, #1
 4906 21ce 002B     		cmp	r3, #0
 4907 21d0 20D1     		bne	.L237
 4908              	.L220:
2284:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2285:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Por ultimo y en el caso de haber llegado aquí, consideramos la cabecera como válida.
2286:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee802514_header->valid=TRUE;
 4909              		.loc 1 2286 0
 4910 21d2 BB68     		ldr	r3, [r7, #8]
 4911 21d4 4FF00102 		mov	r2, #1
 4912 21d8 1A70     		strb	r2, [r3, #0]
 4913 21da 1CE0     		b	.L200
 4914              	.L223:
2136:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; }
 4915              		.loc 1 2136 0
 4916 21dc 00BF     		nop
 4917 21de 1AE0     		b	.L200
 4918              	.L224:
2153:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->frameType != IEEE154_TYPE_MULTIPURPOSE) {return; }
 4919              		.loc 1 2153 0
 4920 21e0 00BF     		nop
 4921 21e2 18E0     		b	.L200
 4922              	.L225:
2156:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_8b >> 3) & 0x01) { return; }
 4923              		.loc 1 2156 0
 4924 21e4 00BF     		nop
 4925 21e6 16E0     		b	.L200
 4926              	.L226:
2200:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4927              		.loc 1 2200 0
 4928 21e8 00BF     		nop
 4929 21ea 14E0     		b	.L200
 4930              	.L227:
2205:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4931              		.loc 1 2205 0
 4932 21ec 00BF     		nop
 4933 21ee 12E0     		b	.L200
 4934              	.L228:
2210:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4935              		.loc 1 2210 0
 4936 21f0 00BF     		nop
 4937 21f2 10E0     		b	.L200
 4938              	.L229:
2226:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) {  return; } // no more to read!
 4939              		.loc 1 2226 0
 4940 21f4 00BF     		nop
 4941 21f6 0EE0     		b	.L200
 4942              	.L230:
2238:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b & 0x007f) != 2) { return; }
 4943              		.loc 1 2238 0
 4944 21f8 00BF     		nop
 4945 21fa 0CE0     		b	.L200
 4946              	.L231:
2241:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b >> 7) != 0x001d) { return; }
 4947              		.loc 1 2241 0
 4948 21fc 00BF     		nop
 4949 21fe 0AE0     		b	.L200
 4950              	.L232:
2244:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b >> 15) & 0x0001) { return; }
 4951              		.loc 1 2244 0
 4952 2200 00BF     		nop
 4953 2202 08E0     		b	.L200
 4954              	.L233:
2247:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4955              		.loc 1 2247 0
 4956 2204 00BF     		nop
 4957 2206 06E0     		b	.L200
 4958              	.L234:
2265:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee802514_header->headerLength > msg->length) { return; } // no more to read!
 4959              		.loc 1 2265 0
 4960 2208 00BF     		nop
 4961 220a 04E0     		b	.L200
 4962              	.L235:
2277:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (temp_16b & 0x007f) { return; }
 4963              		.loc 1 2277 0
 4964 220c 00BF     		nop
 4965 220e 02E0     		b	.L200
 4966              	.L236:
2280:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (((temp_16b >> 7) != 0x7e) && ((temp_16b >> 7) != 0x7f)) { return; }
 4967              		.loc 1 2280 0
 4968 2210 00BF     		nop
 4969 2212 00E0     		b	.L200
 4970              	.L237:
2283:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b >> 15) & 0x0001) { return; }
 4971              		.loc 1 2283 0
 4972 2214 00BF     		nop
 4973              	.L200:
2287:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 4974              		.loc 1 2287 0
 4975 2216 07F11807 		add	r7, r7, #24
 4976 221a BD46     		mov	sp, r7
 4977 221c 80BD     		pop	{r7, pc}
 4978              		.cfi_endproc
 4979              	.LFE54:
 4981 221e 00BF     		.align	2
 4982              		.global	isValidRxFrame
 4983              		.thumb
 4984              		.thumb_func
 4986              	isValidRxFrame:
 4987              	.LFB55:
2288:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2289:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2290:openstack/02a-MAClow/IEEE802154Ecsl.c **** //====================  FRAME VALIDITY CHECK ===========================
2291:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2292:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2293:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2294:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Decides whether the packet I just received is valid received frame.
2295:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2296:openstack/02a-MAClow/IEEE802154Ecsl.c **** A valid Rx frame satisfies the following constraints:
2297:openstack/02a-MAClow/IEEE802154Ecsl.c **** - its IEEE802.15.4 header is well formatted
2298:openstack/02a-MAClow/IEEE802154Ecsl.c **** - it's a DATA of BEACON frame (i.e. not ACK and not COMMAND)
2299:openstack/02a-MAClow/IEEE802154Ecsl.c **** - it's sent on the same PANid as mine
2300:openstack/02a-MAClow/IEEE802154Ecsl.c **** - it's for me (unicast or broadcast)
2301:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2302:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in] ieee802514_header IEEE802.15.4 header of the packet I just received
2303:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2304:openstack/02a-MAClow/IEEE802154Ecsl.c **** \returns TRUE if packet is valid received frame, FALSE otherwise
2305:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2306:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE bool isValidRxFrame(ieee802154_header_iht* ieee802514_header) {
 4988              		.loc 1 2306 0
 4989              		.cfi_startproc
 4990              		@ args = 0, pretend = 0, frame = 8
 4991              		@ frame_needed = 1, uses_anonymous_args = 0
 4992 2220 90B5     		push	{r4, r7, lr}
 4993              	.LCFI130:
 4994              		.cfi_def_cfa_offset 12
 4995              		.cfi_offset 4, -12
 4996              		.cfi_offset 7, -8
 4997              		.cfi_offset 14, -4
 4998 2222 83B0     		sub	sp, sp, #12
 4999              	.LCFI131:
 5000              		.cfi_def_cfa_offset 24
 5001 2224 00AF     		add	r7, sp, #0
 5002              	.LCFI132:
 5003              		.cfi_def_cfa_register 7
 5004 2226 7860     		str	r0, [r7, #4]
2307:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee802514_header->valid==TRUE                                                           
 5005              		.loc 1 2307 0
 5006 2228 7B68     		ldr	r3, [r7, #4]
 5007 222a 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
2308:openstack/02a-MAClow/IEEE802154Ecsl.c ****           (
2309:openstack/02a-MAClow/IEEE802154Ecsl.c ****              ieee802514_header->frameType==IEEE154_TYPE_DATA                   ||
2310:openstack/02a-MAClow/IEEE802154Ecsl.c ****              ieee802514_header->frameType==IEEE154_TYPE_BEACON
2311:openstack/02a-MAClow/IEEE802154Ecsl.c ****           )                                                                                        
2312:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
 5008              		.loc 1 2312 0
 5009 222c 002B     		cmp	r3, #0
 5010 222e 2BD0     		beq	.L239
2309:openstack/02a-MAClow/IEEE802154Ecsl.c ****              ieee802514_header->frameType==IEEE154_TYPE_DATA                   ||
 5011              		.loc 1 2309 0
 5012 2230 7B68     		ldr	r3, [r7, #4]
 5013 2232 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
2307:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee802514_header->valid==TRUE                                                           
 5014              		.loc 1 2307 0
 5015 2234 012B     		cmp	r3, #1
 5016 2236 03D0     		beq	.L240
2310:openstack/02a-MAClow/IEEE802154Ecsl.c ****              ieee802514_header->frameType==IEEE154_TYPE_BEACON
 5017              		.loc 1 2310 0
 5018 2238 7B68     		ldr	r3, [r7, #4]
 5019 223a 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
2309:openstack/02a-MAClow/IEEE802154Ecsl.c ****              ieee802514_header->frameType==IEEE154_TYPE_DATA                   ||
 5020              		.loc 1 2309 0
 5021 223c 002B     		cmp	r3, #0
 5022 223e 23D1     		bne	.L239
 5023              	.L240:
 5024              		.loc 1 2312 0
 5025 2240 7B68     		ldr	r3, [r7, #4]
 5026 2242 03F10A04 		add	r4, r3, #10
 5027 2246 4FF00400 		mov	r0, #4
 5028 224a FFF7FEFF 		bl	idmanager_getMyID
 5029 224e 0346     		mov	r3, r0
 5030 2250 2046     		mov	r0, r4
 5031 2252 1946     		mov	r1, r3
 5032 2254 FFF7FEFF 		bl	packetfunctions_sameAddress
 5033 2258 0346     		mov	r3, r0
2311:openstack/02a-MAClow/IEEE802154Ecsl.c ****           )                                                                                        
 5034              		.loc 1 2311 0
 5035 225a 002B     		cmp	r3, #0
 5036 225c 14D0     		beq	.L239
2313:openstack/02a-MAClow/IEEE802154Ecsl.c ****           (
2314:openstack/02a-MAClow/IEEE802154Ecsl.c ****              idmanager_isMyAddress(&ieee802514_header->dest)                   ||
 5037              		.loc 1 2314 0
 5038 225e 7B68     		ldr	r3, [r7, #4]
 5039 2260 03F11B03 		add	r3, r3, #27
 5040 2264 1846     		mov	r0, r3
 5041 2266 FFF7FEFF 		bl	idmanager_isMyAddress
 5042 226a 0346     		mov	r3, r0
2312:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
 5043              		.loc 1 2312 0
 5044 226c 002B     		cmp	r3, #0
 5045 226e 08D1     		bne	.L241
2315:openstack/02a-MAClow/IEEE802154Ecsl.c ****              packetfunctions_isBroadcastMulticast(&ieee802514_header->dest)
 5046              		.loc 1 2315 0
 5047 2270 7B68     		ldr	r3, [r7, #4]
 5048 2272 03F11B03 		add	r3, r3, #27
 5049 2276 1846     		mov	r0, r3
 5050 2278 FFF7FEFF 		bl	packetfunctions_isBroadcastMulticast
 5051 227c 0346     		mov	r3, r0
2314:openstack/02a-MAClow/IEEE802154Ecsl.c ****              idmanager_isMyAddress(&ieee802514_header->dest)                   ||
 5052              		.loc 1 2314 0
 5053 227e 002B     		cmp	r3, #0
 5054 2280 02D0     		beq	.L239
 5055              	.L241:
2312:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
 5056              		.loc 1 2312 0 discriminator 2
 5057 2282 4FF00103 		mov	r3, #1
 5058 2286 01E0     		b	.L242
 5059              	.L239:
2312:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
 5060              		.loc 1 2312 0 is_stmt 0 discriminator 1
 5061 2288 4FF00003 		mov	r3, #0
 5062              	.L242:
2307:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee802514_header->valid==TRUE                                                           
 5063              		.loc 1 2307 0 is_stmt 1
 5064 228c 03F00103 		and	r3, r3, #1
 5065 2290 DBB2     		uxtb	r3, r3
2316:openstack/02a-MAClow/IEEE802154Ecsl.c ****           );
2317:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5066              		.loc 1 2317 0
 5067 2292 1846     		mov	r0, r3
 5068 2294 07F10C07 		add	r7, r7, #12
 5069 2298 BD46     		mov	sp, r7
 5070 229a 90BD     		pop	{r4, r7, pc}
 5071              		.cfi_endproc
 5072              	.LFE55:
 5074              		.align	2
 5075              		.global	isValidAck
 5076              		.thumb
 5077              		.thumb_func
 5079              	isValidAck:
 5080              	.LFB56:
2318:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2319:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2320:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Decides whether the packet I just received is a valid ACK.
2321:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2322:openstack/02a-MAClow/IEEE802154Ecsl.c **** A packet is a valid ACK if it satisfies the following conditions:
2323:openstack/02a-MAClow/IEEE802154Ecsl.c **** - the IEEE802.15.4 header is valid
2324:openstack/02a-MAClow/IEEE802154Ecsl.c **** - the frame type is 'ACK'
2325:openstack/02a-MAClow/IEEE802154Ecsl.c **** - the sequence number in the ACK matches the sequence number of the packet sent
2326:openstack/02a-MAClow/IEEE802154Ecsl.c **** - the ACK contains my PANid
2327:openstack/02a-MAClow/IEEE802154Ecsl.c **** - the packet is unicast to me
2328:openstack/02a-MAClow/IEEE802154Ecsl.c **** - the packet comes from the neighbor I sent the data to
2329:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2330:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in] ieee802514_header IEEE802.15.4 header of the packet I just received
2331:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in] packetSent points to the packet I just sent
2332:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2333:openstack/02a-MAClow/IEEE802154Ecsl.c **** \returns TRUE if packet is a valid ACK, FALSE otherwise.
2334:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2335:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE bool isValidAck(ieee802154_header_iht* ieee802514_header, OpenQueueEntry_t* packetSent)
 5081              		.loc 1 2335 0
 5082              		.cfi_startproc
 5083              		@ args = 0, pretend = 0, frame = 8
 5084              		@ frame_needed = 1, uses_anonymous_args = 0
 5085 229c 90B5     		push	{r4, r7, lr}
 5086              	.LCFI133:
 5087              		.cfi_def_cfa_offset 12
 5088              		.cfi_offset 4, -12
 5089              		.cfi_offset 7, -8
 5090              		.cfi_offset 14, -4
 5091 229e 83B0     		sub	sp, sp, #12
 5092              	.LCFI134:
 5093              		.cfi_def_cfa_offset 24
 5094 22a0 00AF     		add	r7, sp, #0
 5095              	.LCFI135:
 5096              		.cfi_def_cfa_register 7
 5097 22a2 7860     		str	r0, [r7, #4]
 5098 22a4 3960     		str	r1, [r7, #0]
2336:openstack/02a-MAClow/IEEE802154Ecsl.c ****    /*
2337:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee802514_header->valid==TRUE                                                           
2338:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header->frameType==IEEE154_TYPE_ACK                                           
2339:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header->dsn==packetSent->l2_dsn                                               
2340:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
2341:openstack/02a-MAClow/IEEE802154Ecsl.c ****           idmanager_isMyAddress(&ieee802514_header->dest)                                          
2342:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->src,&packetSent->l2_nextORpreviousHop);
2343:openstack/02a-MAClow/IEEE802154Ecsl.c ****    */
2344:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // poipoi don't check for seq num
2345:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee802514_header->valid==TRUE                                                           
 5099              		.loc 1 2345 0
 5100 22a6 7B68     		ldr	r3, [r7, #4]
 5101 22a8 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
2346:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header->frameType==IEEE154_TYPE_ACK                                           
2347:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
2348:openstack/02a-MAClow/IEEE802154Ecsl.c ****           idmanager_isMyAddress(&ieee802514_header->dest)                                          
 5102              		.loc 1 2348 0
 5103 22aa 002B     		cmp	r3, #0
 5104 22ac 2BD0     		beq	.L245
2346:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header->frameType==IEEE154_TYPE_ACK                                           
 5105              		.loc 1 2346 0
 5106 22ae 7B68     		ldr	r3, [r7, #4]
 5107 22b0 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
2345:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee802514_header->valid==TRUE                                                           
 5108              		.loc 1 2345 0
 5109 22b2 022B     		cmp	r3, #2
 5110 22b4 27D1     		bne	.L245
2347:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
 5111              		.loc 1 2347 0
 5112 22b6 7B68     		ldr	r3, [r7, #4]
 5113 22b8 03F10A04 		add	r4, r3, #10
 5114 22bc 4FF00400 		mov	r0, #4
 5115 22c0 FFF7FEFF 		bl	idmanager_getMyID
 5116 22c4 0346     		mov	r3, r0
 5117 22c6 2046     		mov	r0, r4
 5118 22c8 1946     		mov	r1, r3
 5119 22ca FFF7FEFF 		bl	packetfunctions_sameAddress
 5120 22ce 0346     		mov	r3, r0
2346:openstack/02a-MAClow/IEEE802154Ecsl.c ****           ieee802514_header->frameType==IEEE154_TYPE_ACK                                           
 5121              		.loc 1 2346 0
 5122 22d0 002B     		cmp	r3, #0
 5123 22d2 18D0     		beq	.L245
 5124              		.loc 1 2348 0
 5125 22d4 7B68     		ldr	r3, [r7, #4]
 5126 22d6 03F11B03 		add	r3, r3, #27
 5127 22da 1846     		mov	r0, r3
 5128 22dc FFF7FEFF 		bl	idmanager_isMyAddress
 5129 22e0 0346     		mov	r3, r0
2347:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))     
 5130              		.loc 1 2347 0
 5131 22e2 002B     		cmp	r3, #0
 5132 22e4 0FD0     		beq	.L245
2349:openstack/02a-MAClow/IEEE802154Ecsl.c ****           packetfunctions_sameAddress(&ieee802514_header->src,&packetSent->l2_nextORpreviousHop);
 5133              		.loc 1 2349 0
 5134 22e6 7B68     		ldr	r3, [r7, #4]
 5135 22e8 03F12C02 		add	r2, r3, #44
 5136 22ec 3B68     		ldr	r3, [r7, #0]
 5137 22ee 03F13803 		add	r3, r3, #56
 5138 22f2 1046     		mov	r0, r2
 5139 22f4 1946     		mov	r1, r3
 5140 22f6 FFF7FEFF 		bl	packetfunctions_sameAddress
 5141 22fa 0346     		mov	r3, r0
2348:openstack/02a-MAClow/IEEE802154Ecsl.c ****           idmanager_isMyAddress(&ieee802514_header->dest)                                          
 5142              		.loc 1 2348 0
 5143 22fc 002B     		cmp	r3, #0
 5144 22fe 02D0     		beq	.L245
2348:openstack/02a-MAClow/IEEE802154Ecsl.c ****           idmanager_isMyAddress(&ieee802514_header->dest)                                          
 5145              		.loc 1 2348 0 is_stmt 0 discriminator 2
 5146 2300 4FF00103 		mov	r3, #1
 5147 2304 01E0     		b	.L246
 5148              	.L245:
2348:openstack/02a-MAClow/IEEE802154Ecsl.c ****           idmanager_isMyAddress(&ieee802514_header->dest)                                          
 5149              		.loc 1 2348 0 discriminator 1
 5150 2306 4FF00003 		mov	r3, #0
 5151              	.L246:
2345:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee802514_header->valid==TRUE                                                           
 5152              		.loc 1 2345 0 is_stmt 1
 5153 230a 03F00103 		and	r3, r3, #1
 5154 230e DBB2     		uxtb	r3, r3
2350:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5155              		.loc 1 2350 0
 5156 2310 1846     		mov	r0, r3
 5157 2312 07F10C07 		add	r7, r7, #12
 5158 2316 BD46     		mov	sp, r7
 5159 2318 90BD     		pop	{r4, r7, pc}
 5160              		.cfi_endproc
 5161              	.LFE56:
 5163 231a 00BF     		.align	2
 5164              		.global	incrementAsnOffset
 5165              		.thumb
 5166              		.thumb_func
 5168              	incrementAsnOffset:
 5169              	.LFB57:
2351:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2352:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2353:openstack/02a-MAClow/IEEE802154Ecsl.c **** //========================  ASN HANDLING ===============================
2354:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2355:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2356:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void incrementAsnOffset() {
 5170              		.loc 1 2356 0
 5171              		.cfi_startproc
 5172              		@ args = 0, pretend = 0, frame = 0
 5173              		@ frame_needed = 1, uses_anonymous_args = 0
 5174 231c 98B5     		push	{r3, r4, r7, lr}
 5175              	.LCFI136:
 5176              		.cfi_def_cfa_offset 16
 5177              		.cfi_offset 3, -16
 5178              		.cfi_offset 4, -12
 5179              		.cfi_offset 7, -8
 5180              		.cfi_offset 14, -4
 5181 231e 00AF     		add	r7, sp, #0
 5182              	.LCFI137:
 5183              		.cfi_def_cfa_register 7
2357:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // increment the asn
2358:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asn.bytes0and1++;
 5184              		.loc 1 2358 0
 5185 2320 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5186 2324 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5187 2328 B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 5188 232c 9BB2     		uxth	r3, r3
 5189 232e 03F10103 		add	r3, r3, #1
 5190 2332 9AB2     		uxth	r2, r3
 5191 2334 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5192 2338 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5193 233c A3F80320 		strh	r2, [r3, #3]	@ unaligned
2359:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.asn.bytes0and1==0) {
 5194              		.loc 1 2359 0
 5195 2340 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5196 2344 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5197 2348 B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 5198 234c 9BB2     		uxth	r3, r3
 5199 234e 002B     		cmp	r3, #0
 5200 2350 25D1     		bne	.L249
2360:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.asn.bytes2and3++;
 5201              		.loc 1 2360 0
 5202 2352 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5203 2356 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5204 235a B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 5205 235e 9BB2     		uxth	r3, r3
 5206 2360 03F10103 		add	r3, r3, #1
 5207 2364 9AB2     		uxth	r2, r3
 5208 2366 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5209 236a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5210 236e A3F80120 		strh	r2, [r3, #1]	@ unaligned
2361:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.asn.bytes2and3==0) {
 5211              		.loc 1 2361 0
 5212 2372 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5213 2376 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5214 237a B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 5215 237e 9BB2     		uxth	r3, r3
 5216 2380 002B     		cmp	r3, #0
 5217 2382 0CD1     		bne	.L249
2362:openstack/02a-MAClow/IEEE802154Ecsl.c ****          ieee154e_vars.asn.byte4++;
 5218              		.loc 1 2362 0
 5219 2384 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5220 2388 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5221 238c 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 5222 238e 03F10103 		add	r3, r3, #1
 5223 2392 DAB2     		uxtb	r2, r3
 5224 2394 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5225 2398 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5226 239c 1A70     		strb	r2, [r3, #0]
 5227              	.L249:
2363:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
2364:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2365:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // increment the offsets: Comment slot offset update.
2366:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.slotOffset  = (ieee154e_vars.slotOffset+1)%schedule_getFrameLength();
 5228              		.loc 1 2366 0
 5229 239e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5230 23a2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5231 23a6 DB88     		ldrh	r3, [r3, #6]
 5232 23a8 03F10104 		add	r4, r3, #1
 5233 23ac FFF7FEFF 		bl	schedule_getFrameLength
 5234 23b0 0346     		mov	r3, r0
 5235 23b2 94FBF3F2 		sdiv	r2, r4, r3
 5236 23b6 03FB02F3 		mul	r3, r3, r2
 5237 23ba E31A     		subs	r3, r4, r3
 5238 23bc 9AB2     		uxth	r2, r3
 5239 23be 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5240 23c2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5241 23c6 DA80     		strh	r2, [r3, #6]	@ movhi
2367:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asnOffset   = (ieee154e_vars.asnOffset+1)%16;
 5242              		.loc 1 2367 0
 5243 23c8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5244 23cc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5245 23d0 93F82D30 		ldrb	r3, [r3, #45]	@ zero_extendqisi2
 5246 23d4 03F10102 		add	r2, r3, #1
 5247 23d8 4FF00F03 		mov	r3, #15
 5248 23dc C8F20003 		movt	r3, 32768
 5249 23e0 1340     		ands	r3, r3, r2
 5250 23e2 002B     		cmp	r3, #0
 5251 23e4 05DA     		bge	.L250
 5252 23e6 03F1FF33 		add	r3, r3, #-1
 5253 23ea 63F00F03 		orn	r3, r3, #15
 5254 23ee 03F10103 		add	r3, r3, #1
 5255              	.L250:
 5256 23f2 DAB2     		uxtb	r2, r3
 5257 23f4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5258 23f8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5259 23fc 83F82D20 		strb	r2, [r3, #45]
2368:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5260              		.loc 1 2368 0
 5261 2400 98BD     		pop	{r3, r4, r7, pc}
 5262              		.cfi_endproc
 5263              	.LFE57:
 5265 2402 00BF     		.align	2
 5266              		.global	ieee154e_getAsn
 5267              		.thumb
 5268              		.thumb_func
 5270              	ieee154e_getAsn:
 5271              	.LFB58:
2369:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2370:openstack/02a-MAClow/IEEE802154Ecsl.c **** //from upper layer that want to send the ASN to compute timing or latency
2371:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void ieee154e_getAsn(uint8_t* array) {
 5272              		.loc 1 2371 0
 5273              		.cfi_startproc
 5274              		@ args = 0, pretend = 0, frame = 8
 5275              		@ frame_needed = 1, uses_anonymous_args = 0
 5276              		@ link register save eliminated.
 5277 2404 80B4     		push	{r7}
 5278              	.LCFI138:
 5279              		.cfi_def_cfa_offset 4
 5280              		.cfi_offset 7, -4
 5281 2406 83B0     		sub	sp, sp, #12
 5282              	.LCFI139:
 5283              		.cfi_def_cfa_offset 16
 5284 2408 00AF     		add	r7, sp, #0
 5285              	.LCFI140:
 5286              		.cfi_def_cfa_register 7
 5287 240a 7860     		str	r0, [r7, #4]
2372:openstack/02a-MAClow/IEEE802154Ecsl.c ****    array[0]         = (ieee154e_vars.asn.bytes0and1     & 0xff);
 5288              		.loc 1 2372 0
 5289 240c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5290 2410 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5291 2414 B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 5292 2418 9BB2     		uxth	r3, r3
 5293 241a DAB2     		uxtb	r2, r3
 5294 241c 7B68     		ldr	r3, [r7, #4]
 5295 241e 1A70     		strb	r2, [r3, #0]
2373:openstack/02a-MAClow/IEEE802154Ecsl.c ****    array[1]         = (ieee154e_vars.asn.bytes0and1/256 & 0xff);
 5296              		.loc 1 2373 0
 5297 2420 7B68     		ldr	r3, [r7, #4]
 5298 2422 03F10102 		add	r2, r3, #1
 5299 2426 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5300 242a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5301 242e B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 5302 2432 9BB2     		uxth	r3, r3
 5303 2434 4FEA1323 		lsr	r3, r3, #8
 5304 2438 9BB2     		uxth	r3, r3
 5305 243a DBB2     		uxtb	r3, r3
 5306 243c 1370     		strb	r3, [r2, #0]
2374:openstack/02a-MAClow/IEEE802154Ecsl.c ****    array[2]         = (ieee154e_vars.asn.bytes2and3     & 0xff);
 5307              		.loc 1 2374 0
 5308 243e 7B68     		ldr	r3, [r7, #4]
 5309 2440 03F10202 		add	r2, r3, #2
 5310 2444 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5311 2448 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5312 244c B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 5313 2450 9BB2     		uxth	r3, r3
 5314 2452 DBB2     		uxtb	r3, r3
 5315 2454 1370     		strb	r3, [r2, #0]
2375:openstack/02a-MAClow/IEEE802154Ecsl.c ****    array[3]         = (ieee154e_vars.asn.bytes2and3/256 & 0xff);
 5316              		.loc 1 2375 0
 5317 2456 7B68     		ldr	r3, [r7, #4]
 5318 2458 03F10302 		add	r2, r3, #3
 5319 245c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5320 2460 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5321 2464 B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 5322 2468 9BB2     		uxth	r3, r3
 5323 246a 4FEA1323 		lsr	r3, r3, #8
 5324 246e 9BB2     		uxth	r3, r3
 5325 2470 DBB2     		uxtb	r3, r3
 5326 2472 1370     		strb	r3, [r2, #0]
2376:openstack/02a-MAClow/IEEE802154Ecsl.c ****    array[4]         =  ieee154e_vars.asn.byte4;
 5327              		.loc 1 2376 0
 5328 2474 7B68     		ldr	r3, [r7, #4]
 5329 2476 03F10402 		add	r2, r3, #4
 5330 247a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5331 247e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5332 2482 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 5333 2484 1370     		strb	r3, [r2, #0]
2377:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5334              		.loc 1 2377 0
 5335 2486 07F10C07 		add	r7, r7, #12
 5336 248a BD46     		mov	sp, r7
 5337 248c 80BC     		pop	{r7}
 5338 248e 7047     		bx	lr
 5339              		.cfi_endproc
 5340              	.LFE58:
 5342              		.align	2
 5343              		.global	synchronizeAck
 5344              		.thumb
 5345              		.thumb_func
 5347              	synchronizeAck:
 5348              	.LFB59:
2378:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2379:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2380:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================  SYNCHRONIZATION ==============================
2381:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2382:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2383:openstack/02a-MAClow/IEEE802154Ecsl.c **** void synchronizeAck(PORT_SIGNED_INT_WIDTH timeCorrection) {
 5349              		.loc 1 2383 0
 5350              		.cfi_startproc
 5351              		@ args = 0, pretend = 0, frame = 16
 5352              		@ frame_needed = 1, uses_anonymous_args = 0
 5353 2490 90B5     		push	{r4, r7, lr}
 5354              	.LCFI141:
 5355              		.cfi_def_cfa_offset 12
 5356              		.cfi_offset 4, -12
 5357              		.cfi_offset 7, -8
 5358              		.cfi_offset 14, -4
 5359 2492 87B0     		sub	sp, sp, #28
 5360              	.LCFI142:
 5361              		.cfi_def_cfa_offset 40
 5362 2494 02AF     		add	r7, sp, #8
 5363              	.LCFI143:
 5364              		.cfi_def_cfa 7, 32
 5365 2496 7860     		str	r0, [r7, #4]
2384:openstack/02a-MAClow/IEEE802154Ecsl.c ****    PORT_RADIOTIMER_WIDTH newPeriod;
2385:openstack/02a-MAClow/IEEE802154Ecsl.c ****    PORT_RADIOTIMER_WIDTH currentPeriod;
2386:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
2387:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // calculate new period
2388:openstack/02a-MAClow/IEEE802154Ecsl.c ****    currentPeriod                  =  radio_getTimerPeriod();
 5366              		.loc 1 2388 0
 5367 2498 FFF7FEFF 		bl	radio_getTimerPeriod
 5368 249c F860     		str	r0, [r7, #12]
2389:openstack/02a-MAClow/IEEE802154Ecsl.c ****    newPeriod                      =  (PORT_RADIOTIMER_WIDTH)((PORT_SIGNED_INT_WIDTH)currentPeriod-t
 5369              		.loc 1 2389 0
 5370 249e FA68     		ldr	r2, [r7, #12]
 5371 24a0 7B68     		ldr	r3, [r7, #4]
 5372 24a2 D31A     		subs	r3, r2, r3
 5373 24a4 BB60     		str	r3, [r7, #8]
2390:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2391:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // resynchronize by applying the new period
2392:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_setTimerPeriod(newPeriod);
 5374              		.loc 1 2392 0
 5375 24a6 B868     		ldr	r0, [r7, #8]
 5376 24a8 FFF7FEFF 		bl	radio_setTimerPeriod
2393:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
2394:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // reset the de-synchronization timeout
2395:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.deSyncTimeout    = DESYNCTIMEOUT;
 5377              		.loc 1 2395 0
 5378 24ac 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5379 24b0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5380 24b4 40F61D12 		movw	r2, #2333
 5381 24b8 DA60     		str	r2, [r3, #12]
2396:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
2397:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // indicate time correction to adaptive sync module
2398:openstack/02a-MAClow/IEEE802154Ecsl.c ****    adaptive_sync_indicateTimeCorrection((-timeCorrection),ieee154e_vars.ackReceived->l2_nextORprevi
 5382              		.loc 1 2398 0
 5383 24ba 7B68     		ldr	r3, [r7, #4]
 5384 24bc 9BB2     		uxth	r3, r3
 5385 24be C3F10003 		rsb	r3, r3, #0
 5386 24c2 9BB2     		uxth	r3, r3
 5387 24c4 99B2     		uxth	r1, r3
 5388 24c6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5389 24ca C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5390 24ce 1A6A     		ldr	r2, [r3, #32]
 5391 24d0 0CB2     		sxth	r4, r1
 5392 24d2 6B46     		mov	r3, sp
 5393 24d4 02F14401 		add	r1, r2, #68
 5394 24d8 03C9     		ldmia	r1, {r0, r1}
 5395 24da 1860     		str	r0, [r3, #0]
 5396 24dc 03F10403 		add	r3, r3, #4
 5397 24e0 1970     		strb	r1, [r3, #0]
 5398 24e2 02F13803 		add	r3, r2, #56
 5399 24e6 0ECB     		ldmia	r3, {r1, r2, r3}
 5400 24e8 2046     		mov	r0, r4
 5401 24ea FFF7FEFF 		bl	adaptive_sync_indicateTimeCorrection
2399:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
2400:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // log a large timeCorrection
2401:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (
2402:openstack/02a-MAClow/IEEE802154Ecsl.c ****          ieee154e_vars.isSync==TRUE &&
 5402              		.loc 1 2402 0
 5403 24ee 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5404 24f2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5405 24f6 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
2401:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (
 5406              		.loc 1 2401 0
 5407 24f8 002B     		cmp	r3, #0
 5408 24fa 11D0     		beq	.L253
 5409              		.loc 1 2402 0
 5410 24fc 7B68     		ldr	r3, [r7, #4]
 5411 24fe 13F1050F 		cmn	r3, #5
 5412 2502 02DB     		blt	.L254
2403:openstack/02a-MAClow/IEEE802154Ecsl.c ****          (
2404:openstack/02a-MAClow/IEEE802154Ecsl.c ****             timeCorrection<-LIMITLARGETIMECORRECTION ||
 5413              		.loc 1 2404 0
 5414 2504 7B68     		ldr	r3, [r7, #4]
 5415 2506 052B     		cmp	r3, #5
 5416 2508 0ADD     		ble	.L253
 5417              	.L254:
2405:openstack/02a-MAClow/IEEE802154Ecsl.c ****             timeCorrection> LIMITLARGETIMECORRECTION
2406:openstack/02a-MAClow/IEEE802154Ecsl.c ****          )
2407:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ) {
2408:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openserial_printError(COMPONENT_IEEE802154E,ERR_LARGE_TIMECORRECTION,
 5418              		.loc 1 2408 0
 5419 250a 7B68     		ldr	r3, [r7, #4]
 5420 250c 9BB2     		uxth	r3, r3
 5421 250e 4FF00900 		mov	r0, #9
 5422 2512 4FF01C01 		mov	r1, #28
 5423 2516 1A46     		mov	r2, r3
 5424 2518 4FF00103 		mov	r3, #1
 5425 251c FFF7FEFF 		bl	openserial_printError
 5426              	.L253:
2409:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)timeCorrection,
2410:openstack/02a-MAClow/IEEE802154Ecsl.c ****                             (errorparameter_t)1);
2411:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2412:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // update the stats
2413:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.numSyncAck++;
 5427              		.loc 1 2413 0
 5428 2520 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5429 2524 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5430 2528 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 5431 252a 03F10103 		add	r3, r3, #1
 5432 252e DAB2     		uxtb	r2, r3
 5433 2530 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5434 2534 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5435 2538 5A70     		strb	r2, [r3, #1]
2414:openstack/02a-MAClow/IEEE802154Ecsl.c ****    updateStats(timeCorrection);
 5436              		.loc 1 2414 0
 5437 253a 7868     		ldr	r0, [r7, #4]
 5438 253c FFF7FEFF 		bl	updateStats
2415:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
2416:openstack/02a-MAClow/IEEE802154Ecsl.c **** #ifdef OPENSIM
2417:openstack/02a-MAClow/IEEE802154Ecsl.c ****    debugpins_syncAck_set();
2418:openstack/02a-MAClow/IEEE802154Ecsl.c ****    debugpins_syncAck_clr();
2419:openstack/02a-MAClow/IEEE802154Ecsl.c **** #endif
2420:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5439              		.loc 1 2420 0
 5440 2540 07F11407 		add	r7, r7, #20
 5441 2544 BD46     		mov	sp, r7
 5442 2546 90BD     		pop	{r4, r7, pc}
 5443              		.cfi_endproc
 5444              	.LFE59:
 5446              		.align	2
 5447              		.global	changeIsSync
 5448              		.thumb
 5449              		.thumb_func
 5451              	changeIsSync:
 5452              	.LFB60:
2421:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2422:openstack/02a-MAClow/IEEE802154Ecsl.c **** void changeIsSync(bool newIsSync) {
 5453              		.loc 1 2422 0
 5454              		.cfi_startproc
 5455              		@ args = 0, pretend = 0, frame = 8
 5456              		@ frame_needed = 1, uses_anonymous_args = 0
 5457 2548 80B5     		push	{r7, lr}
 5458              	.LCFI144:
 5459              		.cfi_def_cfa_offset 8
 5460              		.cfi_offset 7, -8
 5461              		.cfi_offset 14, -4
 5462 254a 82B0     		sub	sp, sp, #8
 5463              	.LCFI145:
 5464              		.cfi_def_cfa_offset 16
 5465 254c 00AF     		add	r7, sp, #0
 5466              	.LCFI146:
 5467              		.cfi_def_cfa_register 7
 5468 254e 0346     		mov	r3, r0
 5469 2550 FB71     		strb	r3, [r7, #7]
2423:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.isSync = newIsSync;
 5470              		.loc 1 2423 0
 5471 2552 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5472 2556 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5473 255a FA79     		ldrb	r2, [r7, #7]
 5474 255c 1A74     		strb	r2, [r3, #16]
2424:openstack/02a-MAClow/IEEE802154Ecsl.c ****    
2425:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.isSync==TRUE) {
 5475              		.loc 1 2425 0
 5476 255e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5477 2562 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5478 2566 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
 5479 2568 002B     		cmp	r3, #0
 5480 256a 04D0     		beq	.L256
2426:openstack/02a-MAClow/IEEE802154Ecsl.c ****       leds_sync_on();
 5481              		.loc 1 2426 0
 5482 256c FFF7FEFF 		bl	leds_sync_on
2427:openstack/02a-MAClow/IEEE802154Ecsl.c ****       resetStats();
 5483              		.loc 1 2427 0
 5484 2570 FFF7FEFF 		bl	resetStats
 5485 2574 03E0     		b	.L255
 5486              	.L256:
2428:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
2429:openstack/02a-MAClow/IEEE802154Ecsl.c ****       leds_sync_off();
 5487              		.loc 1 2429 0
 5488 2576 FFF7FEFF 		bl	leds_sync_off
2430:openstack/02a-MAClow/IEEE802154Ecsl.c ****       schedule_resetBackoff();
 5489              		.loc 1 2430 0
 5490 257a FFF7FEFF 		bl	schedule_resetBackoff
 5491              	.L255:
2431:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2432:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5492              		.loc 1 2432 0
 5493 257e 07F10807 		add	r7, r7, #8
 5494 2582 BD46     		mov	sp, r7
 5495 2584 80BD     		pop	{r7, pc}
 5496              		.cfi_endproc
 5497              	.LFE60:
 5499 2586 00BF     		.align	2
 5500              		.global	notif_sendDone
 5501              		.thumb
 5502              		.thumb_func
 5504              	notif_sendDone:
 5505              	.LFB61:
2433:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2434:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2435:openstack/02a-MAClow/IEEE802154Ecsl.c **** //=====================  NOTIFY UPPER LAYER  ===========================
2436:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2437:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2438:openstack/02a-MAClow/IEEE802154Ecsl.c **** void notif_sendDone(OpenQueueEntry_t* packetSent, owerror_t error) {
 5506              		.loc 1 2438 0
 5507              		.cfi_startproc
 5508              		@ args = 0, pretend = 0, frame = 8
 5509              		@ frame_needed = 1, uses_anonymous_args = 0
 5510 2588 80B5     		push	{r7, lr}
 5511              	.LCFI147:
 5512              		.cfi_def_cfa_offset 8
 5513              		.cfi_offset 7, -8
 5514              		.cfi_offset 14, -4
 5515 258a 82B0     		sub	sp, sp, #8
 5516              	.LCFI148:
 5517              		.cfi_def_cfa_offset 16
 5518 258c 00AF     		add	r7, sp, #0
 5519              	.LCFI149:
 5520              		.cfi_def_cfa_register 7
 5521 258e 7860     		str	r0, [r7, #4]
 5522 2590 0B46     		mov	r3, r1
 5523 2592 FB70     		strb	r3, [r7, #3]
2439:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the outcome of the trasmission attempt
2440:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packetSent->l2_sendDoneError   = error;
 5524              		.loc 1 2440 0
 5525 2594 7B68     		ldr	r3, [r7, #4]
 5526 2596 FA78     		ldrb	r2, [r7, #3]
 5527 2598 83F83720 		strb	r2, [r3, #55]
2441:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the current ASN
2442:openstack/02a-MAClow/IEEE802154Ecsl.c ****    memcpy(&packetSent->l2_asn,&ieee154e_vars.asn,sizeof(asn_t));
 5528              		.loc 1 2442 0
 5529 259c 7B68     		ldr	r3, [r7, #4]
 5530 259e 03F14D02 		add	r2, r3, #77
 5531 25a2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5532 25a6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5533 25aa 1868     		ldr	r0, [r3, #0]	@ unaligned
 5534 25ac 1060     		str	r0, [r2, #0]	@ unaligned
 5535 25ae 1B79     		ldrb	r3, [r3, #4]
 5536 25b0 1371     		strb	r3, [r2, #4]
2443:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // associate this packet with the virtual component
2444:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // COMPONENT_IEEE802154E_TO_RES so RES can knows it's for it
2445:openstack/02a-MAClow/IEEE802154Ecsl.c ****    packetSent->owner              = COMPONENT_IEEE802154E_TO_SIXTOP;
 5537              		.loc 1 2445 0
 5538 25b2 7B68     		ldr	r3, [r7, #4]
 5539 25b4 4FF00B02 		mov	r2, #11
 5540 25b8 5A70     		strb	r2, [r3, #1]
2446:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // post RES's sendDone task
2447:openstack/02a-MAClow/IEEE802154Ecsl.c ****    scheduler_push_task(task_sixtopNotifSendDone,TASKPRIO_SIXTOP_NOTIF_TXDONE);
 5541              		.loc 1 2447 0
 5542 25ba 40F20000 		movw	r0, #:lower16:task_sixtopNotifSendDone
 5543 25be C0F20000 		movt	r0, #:upper16:task_sixtopNotifSendDone
 5544 25c2 4FF00201 		mov	r1, #2
 5545 25c6 FFF7FEFF 		bl	scheduler_push_task
2448:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // wake up the scheduler
2449:openstack/02a-MAClow/IEEE802154Ecsl.c ****    SCHEDULER_WAKEUP();
2450:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5546              		.loc 1 2450 0
 5547 25ca 07F10807 		add	r7, r7, #8
 5548 25ce BD46     		mov	sp, r7
 5549 25d0 80BD     		pop	{r7, pc}
 5550              		.cfi_endproc
 5551              	.LFE61:
 5553 25d2 00BF     		.align	2
 5554              		.global	notif_receive
 5555              		.thumb
 5556              		.thumb_func
 5558              	notif_receive:
 5559              	.LFB62:
2451:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2452:openstack/02a-MAClow/IEEE802154Ecsl.c **** // Modified notif_receive signature to add action for CSL testing purposes.
2453:openstack/02a-MAClow/IEEE802154Ecsl.c **** // Packet is removed on endOps in order to not fill all the slots on queue due
2454:openstack/02a-MAClow/IEEE802154Ecsl.c **** // to no sixtop action is defined for receive and process incoming packets.
2455:openstack/02a-MAClow/IEEE802154Ecsl.c **** // Then, we comment this actions here and add remove packet on endOps method.
2456:openstack/02a-MAClow/IEEE802154Ecsl.c **** void notif_receive(OpenQueueEntry_t* packetReceived, uint8_t action) {
 5560              		.loc 1 2456 0
 5561              		.cfi_startproc
 5562              		@ args = 0, pretend = 0, frame = 8
 5563              		@ frame_needed = 1, uses_anonymous_args = 0
 5564 25d4 80B5     		push	{r7, lr}
 5565              	.LCFI150:
 5566              		.cfi_def_cfa_offset 8
 5567              		.cfi_offset 7, -8
 5568              		.cfi_offset 14, -4
 5569 25d6 82B0     		sub	sp, sp, #8
 5570              	.LCFI151:
 5571              		.cfi_def_cfa_offset 16
 5572 25d8 00AF     		add	r7, sp, #0
 5573              	.LCFI152:
 5574              		.cfi_def_cfa_register 7
 5575 25da 7860     		str	r0, [r7, #4]
 5576 25dc 0B46     		mov	r3, r1
 5577 25de FB70     		strb	r3, [r7, #3]
2457:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // record the current ASN
2458:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //memcpy(&packetReceived->l2_asn, &ieee154e_vars.asn, sizeof(asn_t));
2459:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2460:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // indicate reception to the schedule, to keep statistics
2461:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //schedule_indicateRx(&packetReceived->l2_asn);
2462:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2463:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // associate this packet with the virtual component
2464:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // COMPONENT_IEEE802154E_TO_SIXTOP so sixtop can knows it's for it
2465:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //packetReceived->owner          = COMPONENT_IEEE802154E_TO_SIXTOP;
2466:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2467:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // post RES's Receive task
2468:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //scheduler_push_task(task_sixtopNotifReceive,TASKPRIO_SIXTOP_NOTIF_RX);
2469:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2470:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // CSL TEST CODE
2471:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // Error ACK. naranja toggle
2472:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (action == 1)
 5578              		.loc 1 2472 0
 5579 25e0 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 5580 25e2 012B     		cmp	r3, #1
 5581 25e4 02D1     		bne	.L260
2473:openstack/02a-MAClow/IEEE802154Ecsl.c **** 	leds_sync_blink();
 5582              		.loc 1 2473 0
 5583 25e6 FFF7FEFF 		bl	leds_sync_blink
 5584 25ea 01E0     		b	.L259
 5585              	.L260:
2474:openstack/02a-MAClow/IEEE802154Ecsl.c ****    else
2475:openstack/02a-MAClow/IEEE802154Ecsl.c ****     leds_error_toggle();
 5586              		.loc 1 2475 0
 5587 25ec FFF7FEFF 		bl	leds_error_toggle
 5588              	.L259:
2476:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2477:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // wake up the scheduler
2478:openstack/02a-MAClow/IEEE802154Ecsl.c ****    SCHEDULER_WAKEUP();
2479:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5589              		.loc 1 2479 0
 5590 25f0 07F10807 		add	r7, r7, #8
 5591 25f4 BD46     		mov	sp, r7
 5592 25f6 80BD     		pop	{r7, pc}
 5593              		.cfi_endproc
 5594              	.LFE62:
 5596              		.align	2
 5597              		.global	resetStats
 5598              		.thumb
 5599              		.thumb_func
 5601              	resetStats:
 5602              	.LFB63:
2480:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2481:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2482:openstack/02a-MAClow/IEEE802154Ecsl.c **** //============================== STATS =================================
2483:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2484:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2485:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void resetStats() {
 5603              		.loc 1 2485 0
 5604              		.cfi_startproc
 5605              		@ args = 0, pretend = 0, frame = 0
 5606              		@ frame_needed = 1, uses_anonymous_args = 0
 5607              		@ link register save eliminated.
 5608 25f8 80B4     		push	{r7}
 5609              	.LCFI153:
 5610              		.cfi_def_cfa_offset 4
 5611              		.cfi_offset 7, -4
 5612 25fa 00AF     		add	r7, sp, #0
 5613              	.LCFI154:
 5614              		.cfi_def_cfa_register 7
2486:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.numSyncPkt      =    0;
 5615              		.loc 1 2486 0
 5616 25fc 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5617 2600 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5618 2604 4FF00002 		mov	r2, #0
 5619 2608 1A70     		strb	r2, [r3, #0]
2487:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.numSyncAck      =    0;
 5620              		.loc 1 2487 0
 5621 260a 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5622 260e C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5623 2612 4FF00002 		mov	r2, #0
 5624 2616 5A70     		strb	r2, [r3, #1]
2488:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.minCorrection   =  127;
 5625              		.loc 1 2488 0
 5626 2618 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5627 261c C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5628 2620 4FF07F02 		mov	r2, #127
 5629 2624 5A80     		strh	r2, [r3, #2]	@ movhi
2489:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.maxCorrection   = -127;
 5630              		.loc 1 2489 0
 5631 2626 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5632 262a C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5633 262e 4FF68172 		movw	r2, #65409
 5634 2632 9A80     		strh	r2, [r3, #4]	@ movhi
2490:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.numTicsOn       =    0;
 5635              		.loc 1 2490 0
 5636 2634 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5637 2638 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5638 263c 4FF00002 		mov	r2, #0
 5639 2640 DA71     		strb	r2, [r3, #7]
 5640 2642 9A68     		ldr	r2, [r3, #8]
 5641 2644 02F07F42 		and	r2, r2, #-16777216
 5642 2648 9A60     		str	r2, [r3, #8]
2491:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_stats.numTicsTotal    =    0;
 5643              		.loc 1 2491 0
 5644 264a 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5645 264e C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5646 2652 4FF00002 		mov	r2, #0
 5647 2656 DA72     		strb	r2, [r3, #11]
 5648 2658 DA68     		ldr	r2, [r3, #12]
 5649 265a 02F07F42 		and	r2, r2, #-16777216
 5650 265e DA60     		str	r2, [r3, #12]
2492:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // do not reset the number of de-synchronizations
2493:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5651              		.loc 1 2493 0
 5652 2660 BD46     		mov	sp, r7
 5653 2662 80BC     		pop	{r7}
 5654 2664 7047     		bx	lr
 5655              		.cfi_endproc
 5656              	.LFE63:
 5658 2666 00BF     		.align	2
 5659              		.global	updateStats
 5660              		.thumb
 5661              		.thumb_func
 5663              	updateStats:
 5664              	.LFB64:
2494:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2495:openstack/02a-MAClow/IEEE802154Ecsl.c **** void updateStats(PORT_SIGNED_INT_WIDTH timeCorrection) {
 5665              		.loc 1 2495 0
 5666              		.cfi_startproc
 5667              		@ args = 0, pretend = 0, frame = 8
 5668              		@ frame_needed = 1, uses_anonymous_args = 0
 5669              		@ link register save eliminated.
 5670 2668 80B4     		push	{r7}
 5671              	.LCFI155:
 5672              		.cfi_def_cfa_offset 4
 5673              		.cfi_offset 7, -4
 5674 266a 83B0     		sub	sp, sp, #12
 5675              	.LCFI156:
 5676              		.cfi_def_cfa_offset 16
 5677 266c 00AF     		add	r7, sp, #0
 5678              	.LCFI157:
 5679              		.cfi_def_cfa_register 7
 5680 266e 7860     		str	r0, [r7, #4]
2496:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // update minCorrection
2497:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (timeCorrection<ieee154e_stats.minCorrection) {
 5681              		.loc 1 2497 0
 5682 2670 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5683 2674 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5684 2678 5B88     		ldrh	r3, [r3, #2]
 5685 267a 1AB2     		sxth	r2, r3
 5686 267c 7B68     		ldr	r3, [r7, #4]
 5687 267e 9A42     		cmp	r2, r3
 5688 2680 06DD     		ble	.L264
2498:openstack/02a-MAClow/IEEE802154Ecsl.c ****      ieee154e_stats.minCorrection = timeCorrection;
 5689              		.loc 1 2498 0
 5690 2682 7B68     		ldr	r3, [r7, #4]
 5691 2684 9AB2     		uxth	r2, r3
 5692 2686 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5693 268a C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5694 268e 5A80     		strh	r2, [r3, #2]	@ movhi
 5695              	.L264:
2499:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2500:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // update maxConnection
2501:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if(timeCorrection>ieee154e_stats.maxCorrection) {
 5696              		.loc 1 2501 0
 5697 2690 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5698 2694 C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5699 2698 9B88     		ldrh	r3, [r3, #4]
 5700 269a 1AB2     		sxth	r2, r3
 5701 269c 7B68     		ldr	r3, [r7, #4]
 5702 269e 9A42     		cmp	r2, r3
 5703 26a0 06DA     		bge	.L263
2502:openstack/02a-MAClow/IEEE802154Ecsl.c ****      ieee154e_stats.maxCorrection = timeCorrection;
 5704              		.loc 1 2502 0
 5705 26a2 7B68     		ldr	r3, [r7, #4]
 5706 26a4 9AB2     		uxth	r2, r3
 5707 26a6 40F20003 		movw	r3, #:lower16:ieee154e_stats
 5708 26aa C0F20003 		movt	r3, #:upper16:ieee154e_stats
 5709 26ae 9A80     		strh	r2, [r3, #4]	@ movhi
 5710              	.L263:
2503:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2504:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5711              		.loc 1 2504 0
 5712 26b0 07F10C07 		add	r7, r7, #12
 5713 26b4 BD46     		mov	sp, r7
 5714 26b6 80BC     		pop	{r7}
 5715 26b8 7047     		bx	lr
 5716              		.cfi_endproc
 5717              	.LFE64:
 5719 26ba 00BF     		.align	2
 5720              		.global	changeState
 5721              		.thumb
 5722              		.thumb_func
 5724              	changeState:
 5725              	.LFB65:
2505:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2506:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2507:openstack/02a-MAClow/IEEE802154Ecsl.c **** //============================== MISC ==================================
2508:openstack/02a-MAClow/IEEE802154Ecsl.c **** //======================================================================
2509:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2510:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2511:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Changes the state of the IEEE802.15.4e FSM.
2512:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2513:openstack/02a-MAClow/IEEE802154Ecsl.c **** Besides simply updating the state global variable,
2514:openstack/02a-MAClow/IEEE802154Ecsl.c **** this function toggles the FSM debug pin.
2515:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2516:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in] newstate The state the IEEE802.15.4e FSM is now in.
2517:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2518:openstack/02a-MAClow/IEEE802154Ecsl.c **** void changeState(ieee154e_state_t newstate) {
 5726              		.loc 1 2518 0
 5727              		.cfi_startproc
 5728              		@ args = 0, pretend = 0, frame = 8
 5729              		@ frame_needed = 1, uses_anonymous_args = 0
 5730 26bc 80B5     		push	{r7, lr}
 5731              	.LCFI158:
 5732              		.cfi_def_cfa_offset 8
 5733              		.cfi_offset 7, -8
 5734              		.cfi_offset 14, -4
 5735 26be 82B0     		sub	sp, sp, #8
 5736              	.LCFI159:
 5737              		.cfi_def_cfa_offset 16
 5738 26c0 00AF     		add	r7, sp, #0
 5739              	.LCFI160:
 5740              		.cfi_def_cfa_register 7
 5741 26c2 0346     		mov	r3, r0
 5742 26c4 FB71     		strb	r3, [r7, #7]
2519:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // update the state
2520:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.state = newstate;
 5743              		.loc 1 2520 0
 5744 26c6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5745 26ca C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5746 26ce FA79     		ldrb	r2, [r7, #7]
 5747 26d0 5A74     		strb	r2, [r3, #17]
2521:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // wiggle the FSM debug pin
2522:openstack/02a-MAClow/IEEE802154Ecsl.c ****    switch (ieee154e_vars.state) {
 5748              		.loc 1 2522 0
 5749 26d2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5750 26d6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5751 26da 5B7C     		ldrb	r3, [r3, #17]	@ zero_extendqisi2
 5752 26dc 3B2B     		cmp	r3, #59
 5753 26de 00F28480 		bhi	.L266
 5754 26e2 01A2     		adr	r2, .L271
 5755 26e4 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 5756              		.align	2
 5757              	.L271:
 5758 26e8 DF270000 		.word	.L268+1
 5759 26ec EB270000 		.word	.L266+1
 5760 26f0 EB270000 		.word	.L266+1
 5761 26f4 EB270000 		.word	.L266+1
 5762 26f8 EB270000 		.word	.L266+1
 5763 26fc EB270000 		.word	.L266+1
 5764 2700 EB270000 		.word	.L266+1
 5765 2704 EB270000 		.word	.L266+1
 5766 2708 EB270000 		.word	.L266+1
 5767 270c EB270000 		.word	.L266+1
 5768 2710 EB270000 		.word	.L266+1
 5769 2714 EB270000 		.word	.L266+1
 5770 2718 EB270000 		.word	.L266+1
 5771 271c EB270000 		.word	.L266+1
 5772 2720 EB270000 		.word	.L266+1
 5773 2724 EB270000 		.word	.L266+1
 5774 2728 EB270000 		.word	.L266+1
 5775 272c EB270000 		.word	.L266+1
 5776 2730 EB270000 		.word	.L266+1
 5777 2734 EB270000 		.word	.L266+1
 5778 2738 EB270000 		.word	.L266+1
 5779 273c EB270000 		.word	.L266+1
 5780 2740 EB270000 		.word	.L266+1
 5781 2744 EB270000 		.word	.L266+1
 5782 2748 EB270000 		.word	.L266+1
 5783 274c EB270000 		.word	.L266+1
 5784 2750 D9270000 		.word	.L269+1
 5785 2754 E5270000 		.word	.L270+1
 5786 2758 E5270000 		.word	.L270+1
 5787 275c E5270000 		.word	.L270+1
 5788 2760 E5270000 		.word	.L270+1
 5789 2764 D9270000 		.word	.L269+1
 5790 2768 D9270000 		.word	.L269+1
 5791 276c E5270000 		.word	.L270+1
 5792 2770 E5270000 		.word	.L270+1
 5793 2774 E5270000 		.word	.L270+1
 5794 2778 E5270000 		.word	.L270+1
 5795 277c E5270000 		.word	.L270+1
 5796 2780 E5270000 		.word	.L270+1
 5797 2784 E5270000 		.word	.L270+1
 5798 2788 E5270000 		.word	.L270+1
 5799 278c E5270000 		.word	.L270+1
 5800 2790 E5270000 		.word	.L270+1
 5801 2794 DF270000 		.word	.L268+1
 5802 2798 E5270000 		.word	.L270+1
 5803 279c E5270000 		.word	.L270+1
 5804 27a0 E5270000 		.word	.L270+1
 5805 27a4 E5270000 		.word	.L270+1
 5806 27a8 E5270000 		.word	.L270+1
 5807 27ac DF270000 		.word	.L268+1
 5808 27b0 E5270000 		.word	.L270+1
 5809 27b4 E5270000 		.word	.L270+1
 5810 27b8 E5270000 		.word	.L270+1
 5811 27bc E5270000 		.word	.L270+1
 5812 27c0 E5270000 		.word	.L270+1
 5813 27c4 E5270000 		.word	.L270+1
 5814 27c8 E5270000 		.word	.L270+1
 5815 27cc E5270000 		.word	.L270+1
 5816 27d0 E5270000 		.word	.L270+1
 5817 27d4 E5270000 		.word	.L270+1
 5818              	.L269:
2523:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXWAKEUPOFFSET:
2524:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXDATAPREOFFSET:
2525:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXDATAOFFSET:
2526:openstack/02a-MAClow/IEEE802154Ecsl.c ****          debugpins_fsm_set();
 5819              		.loc 1 2526 0
 5820 27d8 FFF7FEFF 		bl	debugpins_fsm_set
2527:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 5821              		.loc 1 2527 0
 5822 27dc 05E0     		b	.L266
 5823              	.L268:
2528:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_SLEEP:
2529:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXDATAOFFSET:
2530:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXWAKEUPOFFSET:
2531:openstack/02a-MAClow/IEEE802154Ecsl.c ****          debugpins_fsm_clr();
 5824              		.loc 1 2531 0
 5825 27de FFF7FEFF 		bl	debugpins_fsm_clr
2532:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 5826              		.loc 1 2532 0
 5827 27e2 02E0     		b	.L266
 5828              	.L270:
2533:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2534:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // ------- TX STATES -------
2535:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2536:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Estados usados para la transmisión de tramas WAKE-UP previas a la trama de datos (Wake-Up
2537:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXWAKEUPPREPARE:
2538:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXWAKEUPREADY:
2539:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXWAKEUPDELAY:
2540:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXWAKEUP:
2541:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2542:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Estados usados para la transmisión del paquete de datos y la recepción del ACK.
2543:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXDATAPREPARE:
2544:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXDATAREADY:
2545:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXDATADELAY:
2546:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXDATA:
2547:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2548:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXACKOFFSET:
2549:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXACKPREPARE:
2550:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXACKREADY:
2551:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXACKLISTEN:
2552:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXACK:
2553:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXPROC:
2554:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2555:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // ------- RX STATES -------
2556:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2557:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Estados usados para la recepción y tratamiento de la trama de WAKE-UP.
2558:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXWAKEUPPREPARE:
2559:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXWAKEUPREADY:
2560:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXWAKEUPLISTEN:
2561:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXWAKEUP:
2562:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXWAKEUPVALIDATE:
2563:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2564:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // Estados usados para la recepción del paquete de datos y la transmisión del ACK.
2565:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXDATAPREPARE:
2566:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXDATAREADY:
2567:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXDATALISTEN:
2568:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXDATA:
2569:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2570:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXACKOFFSET:
2571:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXACKPREPARE:
2572:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXACKREADY:
2573:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXACKDELAY:
2574:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLTXACK:
2575:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case S_CSLRXPROC:
2576:openstack/02a-MAClow/IEEE802154Ecsl.c ****          debugpins_fsm_toggle();
 5829              		.loc 1 2576 0
 5830 27e4 FFF7FEFF 		bl	debugpins_fsm_toggle
2577:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 5831              		.loc 1 2577 0
 5832 27e8 00BF     		nop
 5833              	.L266:
2578:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2579:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5834              		.loc 1 2579 0
 5835 27ea 07F10807 		add	r7, r7, #8
 5836 27ee BD46     		mov	sp, r7
 5837 27f0 80BD     		pop	{r7, pc}
 5838              		.cfi_endproc
 5839              	.LFE65:
 5841 27f2 00BF     		.align	2
 5842              		.global	debugPrint_asn
 5843              		.thumb
 5844              		.thumb_func
 5846              	debugPrint_asn:
 5847              	.LFB66:
2580:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2581:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2582:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Trigger this module to print status information, over serial.
2583:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2584:openstack/02a-MAClow/IEEE802154Ecsl.c **** debugPrint_* functions are used by the openserial module to continuously print
2585:openstack/02a-MAClow/IEEE802154Ecsl.c **** status information about several modules in the OpenWSN stack.
2586:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2587:openstack/02a-MAClow/IEEE802154Ecsl.c **** \returns TRUE if this function printed something, FALSE otherwise.
2588:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2589:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool debugPrint_asn() {
 5848              		.loc 1 2589 0
 5849              		.cfi_startproc
 5850              		@ args = 0, pretend = 0, frame = 8
 5851              		@ frame_needed = 1, uses_anonymous_args = 0
 5852 27f4 80B5     		push	{r7, lr}
 5853              	.LCFI161:
 5854              		.cfi_def_cfa_offset 8
 5855              		.cfi_offset 7, -8
 5856              		.cfi_offset 14, -4
 5857 27f6 82B0     		sub	sp, sp, #8
 5858              	.LCFI162:
 5859              		.cfi_def_cfa_offset 16
 5860 27f8 00AF     		add	r7, sp, #0
 5861              	.LCFI163:
 5862              		.cfi_def_cfa_register 7
2590:openstack/02a-MAClow/IEEE802154Ecsl.c ****    asn_t output;
2591:openstack/02a-MAClow/IEEE802154Ecsl.c ****    output.byte4         =  ieee154e_vars.asn.byte4;
 5863              		.loc 1 2591 0
 5864 27fa 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5865 27fe C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5866 2802 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 5867 2804 3B70     		strb	r3, [r7, #0]
2592:openstack/02a-MAClow/IEEE802154Ecsl.c ****    output.bytes2and3    =  ieee154e_vars.asn.bytes2and3;
 5868              		.loc 1 2592 0
 5869 2806 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5870 280a C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5871 280e B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 5872 2812 9BB2     		uxth	r3, r3
 5873 2814 A7F80130 		strh	r3, [r7, #1]	@ unaligned
2593:openstack/02a-MAClow/IEEE802154Ecsl.c ****    output.bytes0and1    =  ieee154e_vars.asn.bytes0and1;
 5874              		.loc 1 2593 0
 5875 2818 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5876 281c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5877 2820 B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 5878 2824 9BB2     		uxth	r3, r3
 5879 2826 A7F80330 		strh	r3, [r7, #3]	@ unaligned
2594:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printStatus(STATUS_ASN,(uint8_t*)&output,sizeof(output));
 5880              		.loc 1 2594 0
 5881 282a 3B46     		mov	r3, r7
 5882 282c 4FF00400 		mov	r0, #4
 5883 2830 1946     		mov	r1, r3
 5884 2832 4FF00502 		mov	r2, #5
 5885 2836 FFF7FEFF 		bl	openserial_printStatus
2595:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return TRUE;
 5886              		.loc 1 2595 0
 5887 283a 4FF00103 		mov	r3, #1
2596:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5888              		.loc 1 2596 0
 5889 283e 1846     		mov	r0, r3
 5890 2840 07F10807 		add	r7, r7, #8
 5891 2844 BD46     		mov	sp, r7
 5892 2846 80BD     		pop	{r7, pc}
 5893              		.cfi_endproc
 5894              	.LFE66:
 5896              		.align	2
 5897              		.global	debugPrint_isSync
 5898              		.thumb
 5899              		.thumb_func
 5901              	debugPrint_isSync:
 5902              	.LFB67:
2597:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2598:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2599:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Trigger this module to print status information, over serial.
2600:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2601:openstack/02a-MAClow/IEEE802154Ecsl.c **** debugPrint_* functions are used by the openserial module to continuously print
2602:openstack/02a-MAClow/IEEE802154Ecsl.c **** status information about several modules in the OpenWSN stack.
2603:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2604:openstack/02a-MAClow/IEEE802154Ecsl.c **** \returns TRUE if this function printed something, FALSE otherwise.
2605:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2606:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool debugPrint_isSync() {
 5903              		.loc 1 2606 0
 5904              		.cfi_startproc
 5905              		@ args = 0, pretend = 0, frame = 8
 5906              		@ frame_needed = 1, uses_anonymous_args = 0
 5907 2848 80B5     		push	{r7, lr}
 5908              	.LCFI164:
 5909              		.cfi_def_cfa_offset 8
 5910              		.cfi_offset 7, -8
 5911              		.cfi_offset 14, -4
 5912 284a 82B0     		sub	sp, sp, #8
 5913              	.LCFI165:
 5914              		.cfi_def_cfa_offset 16
 5915 284c 00AF     		add	r7, sp, #0
 5916              	.LCFI166:
 5917              		.cfi_def_cfa_register 7
2607:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t output=0;
 5918              		.loc 1 2607 0
 5919 284e 4FF00003 		mov	r3, #0
 5920 2852 FB71     		strb	r3, [r7, #7]
2608:openstack/02a-MAClow/IEEE802154Ecsl.c ****    output = ieee154e_vars.isSync;
 5921              		.loc 1 2608 0
 5922 2854 40F20003 		movw	r3, #:lower16:ieee154e_vars
 5923 2858 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 5924 285c 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
 5925 285e FB71     		strb	r3, [r7, #7]
2609:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printStatus(STATUS_ISSYNC,(uint8_t*)&output,sizeof(uint8_t));
 5926              		.loc 1 2609 0
 5927 2860 07F10703 		add	r3, r7, #7
 5928 2864 4FF00000 		mov	r0, #0
 5929 2868 1946     		mov	r1, r3
 5930 286a 4FF00102 		mov	r2, #1
 5931 286e FFF7FEFF 		bl	openserial_printStatus
2610:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return TRUE;
 5932              		.loc 1 2610 0
 5933 2872 4FF00103 		mov	r3, #1
2611:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5934              		.loc 1 2611 0
 5935 2876 1846     		mov	r0, r3
 5936 2878 07F10807 		add	r7, r7, #8
 5937 287c BD46     		mov	sp, r7
 5938 287e 80BD     		pop	{r7, pc}
 5939              		.cfi_endproc
 5940              	.LFE67:
 5942              		.align	2
 5943              		.global	debugPrint_macStats
 5944              		.thumb
 5945              		.thumb_func
 5947              	debugPrint_macStats:
 5948              	.LFB68:
2612:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2613:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2614:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Trigger this module to print status information, over serial.
2615:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2616:openstack/02a-MAClow/IEEE802154Ecsl.c **** debugPrint_* functions are used by the openserial module to continuously print
2617:openstack/02a-MAClow/IEEE802154Ecsl.c **** status information about several modules in the OpenWSN stack.
2618:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2619:openstack/02a-MAClow/IEEE802154Ecsl.c **** \returns TRUE if this function printed something, FALSE otherwise.
2620:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2621:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool debugPrint_macStats() {
 5949              		.loc 1 2621 0
 5950              		.cfi_startproc
 5951              		@ args = 0, pretend = 0, frame = 0
 5952              		@ frame_needed = 1, uses_anonymous_args = 0
 5953 2880 80B5     		push	{r7, lr}
 5954              	.LCFI167:
 5955              		.cfi_def_cfa_offset 8
 5956              		.cfi_offset 7, -8
 5957              		.cfi_offset 14, -4
 5958 2882 00AF     		add	r7, sp, #0
 5959              	.LCFI168:
 5960              		.cfi_def_cfa_register 7
2622:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // send current stats over serial
2623:openstack/02a-MAClow/IEEE802154Ecsl.c ****    openserial_printStatus(STATUS_MACSTATS,(uint8_t*)&ieee154e_stats,sizeof(ieee154e_stats_t));
 5961              		.loc 1 2623 0
 5962 2884 4FF00500 		mov	r0, #5
 5963 2888 40F20001 		movw	r1, #:lower16:ieee154e_stats
 5964 288c C0F20001 		movt	r1, #:upper16:ieee154e_stats
 5965 2890 4FF00F02 		mov	r2, #15
 5966 2894 FFF7FEFF 		bl	openserial_printStatus
2624:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return TRUE;
 5967              		.loc 1 2624 0
 5968 2898 4FF00103 		mov	r3, #1
2625:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 5969              		.loc 1 2625 0
 5970 289c 1846     		mov	r0, r3
 5971 289e 80BD     		pop	{r7, pc}
 5972              		.cfi_endproc
 5973              	.LFE68:
 5975              		.align	2
 5976              		.global	endOps
 5977              		.thumb
 5978              		.thumb_func
 5980              	endOps:
 5981              	.LFB69:
2626:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2627:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2628:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2629:openstack/02a-MAClow/IEEE802154Ecsl.c **** \brief Housekeeping tasks to do at the end of each slot.
2630:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2631:openstack/02a-MAClow/IEEE802154Ecsl.c **** This functions is called once in each slot, when there is nothing more
2632:openstack/02a-MAClow/IEEE802154Ecsl.c **** to do. This might be when an error occured, or when everything went well.
2633:openstack/02a-MAClow/IEEE802154Ecsl.c **** This function resets the state of the FSM so it is ready for the next slot.
2634:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2635:openstack/02a-MAClow/IEEE802154Ecsl.c **** Note that by the time this function is called, any received packet should already
2636:openstack/02a-MAClow/IEEE802154Ecsl.c **** have been sent to the upper layer. Similarly, in a Tx slot, the sendDone
2637:openstack/02a-MAClow/IEEE802154Ecsl.c **** function should already have been done. If this is not the case, this function
2638:openstack/02a-MAClow/IEEE802154Ecsl.c **** will do that for you, but assume that something went wrong.
2639:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2640:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2641:openstack/02a-MAClow/IEEE802154Ecsl.c **** //[CSL] – Modificación de firma del método endSlot.
2642:openstack/02a-MAClow/IEEE802154Ecsl.c **** void endOps() {
 5982              		.loc 1 2642 0
 5983              		.cfi_startproc
 5984              		@ args = 0, pretend = 0, frame = 0
 5985              		@ frame_needed = 1, uses_anonymous_args = 0
 5986 28a0 80B5     		push	{r7, lr}
 5987              	.LCFI169:
 5988              		.cfi_def_cfa_offset 8
 5989              		.cfi_offset 7, -8
 5990              		.cfi_offset 14, -4
 5991 28a2 00AF     		add	r7, sp, #0
 5992              	.LCFI170:
 5993              		.cfi_def_cfa_register 7
2643:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2644:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // turn off the radio
2645:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radio_rfOff();
 5994              		.loc 1 2645 0
 5995 28a4 FFF7FEFF 		bl	radio_rfOff
2646:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2647:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clear any pending timer
2648:openstack/02a-MAClow/IEEE802154Ecsl.c ****    radiotimer_cancel();
 5996              		.loc 1 2648 0
 5997 28a8 FFF7FEFF 		bl	radiotimer_cancel
2649:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2650:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // reset capturedTimes
2651:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.lastCapturedTime = 0;
 5998              		.loc 1 2651 0
 5999 28ac 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6000 28b0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6001 28b4 4FF00002 		mov	r2, #0
 6002 28b8 5A62     		str	r2, [r3, #36]
2652:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.syncCapturedTime = 0;
 6003              		.loc 1 2652 0
 6004 28ba 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6005 28be C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6006 28c2 4FF00002 		mov	r2, #0
 6007 28c6 9A62     		str	r2, [r3, #40]
2653:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2654:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //clear vars for duty cycle on this slot
2655:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnTics=0;
 6008              		.loc 1 2655 0
 6009 28c8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6010 28cc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6011 28d0 4FF00002 		mov	r2, #0
 6012 28d4 5A63     		str	r2, [r3, #52]
2656:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.radioOnThisSlot=FALSE;
 6013              		.loc 1 2656 0
 6014 28d6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6015 28da C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6016 28de 4FF00002 		mov	r2, #0
 6017 28e2 83F83820 		strb	r2, [r3, #56]
2657:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2658:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clean up dataToSend
2659:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.dataToSend!=NULL) {
 6018              		.loc 1 2659 0
 6019 28e6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6020 28ea C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6021 28ee 5B69     		ldr	r3, [r3, #20]
 6022 28f0 002B     		cmp	r3, #0
 6023 28f2 33D0     		beq	.L279
2660:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // if everything went well, dataToSend was set to NULL in ti9
2661:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // getting here means transmit failed
2662:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2663:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // indicate Tx fail to schedule to update stats
2664:openstack/02a-MAClow/IEEE802154Ecsl.c ****       schedule_indicateTx(&ieee154e_vars.asn,FALSE);
 6024              		.loc 1 2664 0
 6025 28f4 40F20000 		movw	r0, #:lower16:ieee154e_vars
 6026 28f8 C0F20000 		movt	r0, #:upper16:ieee154e_vars
 6027 28fc 4FF00001 		mov	r1, #0
 6028 2900 FFF7FEFF 		bl	schedule_indicateTx
2665:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2666:openstack/02a-MAClow/IEEE802154Ecsl.c ****       //decrement transmits left counter
2667:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataToSend->l2_retriesLeft--;
 6029              		.loc 1 2667 0
 6030 2904 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6031 2908 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6032 290c 5B69     		ldr	r3, [r3, #20]
 6033 290e 93F84B20 		ldrb	r2, [r3, #75]	@ zero_extendqisi2
 6034 2912 02F1FF32 		add	r2, r2, #-1
 6035 2916 D2B2     		uxtb	r2, r2
 6036 2918 83F84B20 		strb	r2, [r3, #75]
2668:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2669:openstack/02a-MAClow/IEEE802154Ecsl.c ****       if (ieee154e_vars.dataToSend->l2_retriesLeft==0) {
 6037              		.loc 1 2669 0
 6038 291c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6039 2920 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6040 2924 5B69     		ldr	r3, [r3, #20]
 6041 2926 93F84B30 		ldrb	r3, [r3, #75]	@ zero_extendqisi2
 6042 292a 002B     		cmp	r3, #0
 6043 292c 07D0     		beq	.L280
2670:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 // CSL TEST CODE (comment)
2671:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // indicate tx fail if no more retries left
2672:openstack/02a-MAClow/IEEE802154Ecsl.c ****          //notif_sendDone(ieee154e_vars.dataToSend,E_FAIL);
2673:openstack/02a-MAClow/IEEE802154Ecsl.c ****     	 // END TEST CODE
2674:openstack/02a-MAClow/IEEE802154Ecsl.c ****       } else {
2675:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // return packet to the virtual COMPONENT_SIXTOP_TO_IEEE802154E component
2676:openstack/02a-MAClow/IEEE802154Ecsl.c ****          ieee154e_vars.dataToSend->owner = COMPONENT_SIXTOP_TO_IEEE802154E;
 6044              		.loc 1 2676 0
 6045 292e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6046 2932 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6047 2936 5B69     		ldr	r3, [r3, #20]
 6048 2938 4FF00A02 		mov	r2, #10
 6049 293c 5A70     		strb	r2, [r3, #1]
 6050              	.L280:
2677:openstack/02a-MAClow/IEEE802154Ecsl.c ****       }
2678:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2679:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // CSL - Remove packet for testing because no high entity for packet processing.
2680:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openqueue_freePacketBuffer(ieee154e_vars.dataToSend);
 6051              		.loc 1 2680 0
 6052 293e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6053 2942 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6054 2946 5B69     		ldr	r3, [r3, #20]
 6055 2948 1846     		mov	r0, r3
 6056 294a FFF7FEFF 		bl	openqueue_freePacketBuffer
2681:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2682:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset local variable
2683:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataToSend = NULL;
 6057              		.loc 1 2683 0
 6058 294e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6059 2952 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6060 2956 4FF00002 		mov	r2, #0
 6061 295a 5A61     		str	r2, [r3, #20]
 6062              	.L279:
2684:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2685:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2686:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clean up dataReceived
2687:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.dataReceived!=NULL) {
 6063              		.loc 1 2687 0
 6064 295c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6065 2960 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6066 2964 9B69     		ldr	r3, [r3, #24]
 6067 2966 002B     		cmp	r3, #0
 6068 2968 18D0     		beq	.L281
2688:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // assume something went wrong. If everything went well, dataReceived
2689:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // would have been set to NULL in ri9.
2690:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // indicate  "received packet" to upper layer since we don't want to loose packets
2691:openstack/02a-MAClow/IEEE802154Ecsl.c ****       notif_receive(ieee154e_vars.dataReceived,0);
 6069              		.loc 1 2691 0
 6070 296a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6071 296e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6072 2972 9B69     		ldr	r3, [r3, #24]
 6073 2974 1846     		mov	r0, r3
 6074 2976 4FF00001 		mov	r1, #0
 6075 297a FFF7FEFF 		bl	notif_receive
2692:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2693:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // CSL - Remove packet for testing because no high entity for packet processing.
2694:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openqueue_freePacketBuffer(ieee154e_vars.dataReceived);
 6076              		.loc 1 2694 0
 6077 297e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6078 2982 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6079 2986 9B69     		ldr	r3, [r3, #24]
 6080 2988 1846     		mov	r0, r3
 6081 298a FFF7FEFF 		bl	openqueue_freePacketBuffer
2695:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2696:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset local variable
2697:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.dataReceived = NULL;
 6082              		.loc 1 2697 0
 6083 298e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6084 2992 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6085 2996 4FF00002 		mov	r2, #0
 6086 299a 9A61     		str	r2, [r3, #24]
 6087              	.L281:
2698:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2699:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2700:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clean up ackToSend
2701:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.ackToSend!=NULL) {
 6088              		.loc 1 2701 0
 6089 299c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6090 29a0 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6091 29a4 DB69     		ldr	r3, [r3, #28]
 6092 29a6 002B     		cmp	r3, #0
 6093 29a8 0ED0     		beq	.L282
2702:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // free ackToSend so corresponding RAM memory can be recycled
2703:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openqueue_freePacketBuffer(ieee154e_vars.ackToSend);
 6094              		.loc 1 2703 0
 6095 29aa 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6096 29ae C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6097 29b2 DB69     		ldr	r3, [r3, #28]
 6098 29b4 1846     		mov	r0, r3
 6099 29b6 FFF7FEFF 		bl	openqueue_freePacketBuffer
2704:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset local variable
2705:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.ackToSend = NULL;
 6100              		.loc 1 2705 0
 6101 29ba 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6102 29be C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6103 29c2 4FF00002 		mov	r2, #0
 6104 29c6 DA61     		str	r2, [r3, #28]
 6105              	.L282:
2706:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2707:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2708:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clean up ackReceived
2709:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.ackReceived!=NULL) {
 6106              		.loc 1 2709 0
 6107 29c8 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6108 29cc C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6109 29d0 1B6A     		ldr	r3, [r3, #32]
 6110 29d2 002B     		cmp	r3, #0
 6111 29d4 0ED0     		beq	.L283
2710:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // free ackReceived so corresponding RAM memory can be recycled
2711:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openqueue_freePacketBuffer(ieee154e_vars.ackReceived);
 6112              		.loc 1 2711 0
 6113 29d6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6114 29da C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6115 29de 1B6A     		ldr	r3, [r3, #32]
 6116 29e0 1846     		mov	r0, r3
 6117 29e2 FFF7FEFF 		bl	openqueue_freePacketBuffer
2712:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset local variable
2713:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.ackReceived = NULL;
 6118              		.loc 1 2713 0
 6119 29e6 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6120 29ea C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6121 29ee 4FF00002 		mov	r2, #0
 6122 29f2 1A62     		str	r2, [r3, #32]
 6123              	.L283:
2714:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2715:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2716:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clean up wakeupSend
2717:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.wakeupToSend!=NULL) {
 6124              		.loc 1 2717 0
 6125 29f4 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6126 29f8 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6127 29fc DB6B     		ldr	r3, [r3, #60]
 6128 29fe 002B     		cmp	r3, #0
 6129 2a00 0ED0     		beq	.L284
2718:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // free wakeupToSend so corresponding RAM memory can be recycled
2719:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openqueue_freePacketBuffer(ieee154e_vars.wakeupToSend);
 6130              		.loc 1 2719 0
 6131 2a02 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6132 2a06 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6133 2a0a DB6B     		ldr	r3, [r3, #60]
 6134 2a0c 1846     		mov	r0, r3
 6135 2a0e FFF7FEFF 		bl	openqueue_freePacketBuffer
2720:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset local variable
2721:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.wakeupToSend = NULL;
 6136              		.loc 1 2721 0
 6137 2a12 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6138 2a16 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6139 2a1a 4FF00002 		mov	r2, #0
 6140 2a1e DA63     		str	r2, [r3, #60]
 6141              	.L284:
2722:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2723:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2724:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // clean up wakeupReceived
2725:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.wakeupReceived !=NULL) {
 6142              		.loc 1 2725 0
 6143 2a20 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6144 2a24 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6145 2a28 1B6C     		ldr	r3, [r3, #64]
 6146 2a2a 002B     		cmp	r3, #0
 6147 2a2c 0ED0     		beq	.L285
2726:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // free wakeupReceived so corresponding RAM memory can be recycled
2727:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openqueue_freePacketBuffer(ieee154e_vars.wakeupReceived);
 6148              		.loc 1 2727 0
 6149 2a2e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6150 2a32 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6151 2a36 1B6C     		ldr	r3, [r3, #64]
 6152 2a38 1846     		mov	r0, r3
 6153 2a3a FFF7FEFF 		bl	openqueue_freePacketBuffer
2728:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // reset local variable
2729:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ieee154e_vars.wakeupReceived = NULL;
 6154              		.loc 1 2729 0
 6155 2a3e 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6156 2a42 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6157 2a46 4FF00002 		mov	r2, #0
 6158 2a4a 1A64     		str	r2, [r3, #64]
 6159              	.L285:
2730:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2731:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2732:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // change state
2733:openstack/02a-MAClow/IEEE802154Ecsl.c ****    changeState(S_SLEEP);
 6160              		.loc 1 2733 0
 6161 2a4c 4FF00000 		mov	r0, #0
 6162 2a50 FFF7FEFF 		bl	changeState
2734:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2735:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // update CSL Mode to SLEEP in order to allow new TX or RX.
2736:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.cslMode = CSL_SLEEP_MODE;
 6163              		.loc 1 2736 0
 6164 2a54 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6165 2a58 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6166 2a5c 4FF00002 		mov	r2, #0
 6167 2a60 83F84520 		strb	r2, [r3, #69]
2737:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2738:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 6168              		.loc 1 2738 0
 6169 2a64 80BD     		pop	{r7, pc}
 6170              		.cfi_endproc
 6171              	.LFE69:
 6173 2a66 00BF     		.align	2
 6174              		.global	ieee154e_isSynch
 6175              		.thumb
 6176              		.thumb_func
 6178              	ieee154e_isSynch:
 6179              	.LFB70:
2739:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2740:openstack/02a-MAClow/IEEE802154Ecsl.c **** bool ieee154e_isSynch(){
 6180              		.loc 1 2740 0
 6181              		.cfi_startproc
 6182              		@ args = 0, pretend = 0, frame = 0
 6183              		@ frame_needed = 1, uses_anonymous_args = 0
 6184              		@ link register save eliminated.
 6185 2a68 80B4     		push	{r7}
 6186              	.LCFI171:
 6187              		.cfi_def_cfa_offset 4
 6188              		.cfi_offset 7, -4
 6189 2a6a 00AF     		add	r7, sp, #0
 6190              	.LCFI172:
 6191              		.cfi_def_cfa_register 7
2741:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return ieee154e_vars.isSync;
 6192              		.loc 1 2741 0
 6193 2a6c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6194 2a70 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6195 2a74 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
2742:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 6196              		.loc 1 2742 0
 6197 2a76 1846     		mov	r0, r3
 6198 2a78 BD46     		mov	sp, r7
 6199 2a7a 80BC     		pop	{r7}
 6200 2a7c 7047     		bx	lr
 6201              		.cfi_endproc
 6202              	.LFE70:
 6204 2a7e 00BF     		.align	2
 6205              		.global	ieee154e_processIEs
 6206              		.thumb
 6207              		.thumb_func
 6209              	ieee154e_processIEs:
 6210              	.LFB71:
2743:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2744:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE bool ieee154e_processIEs(OpenQueueEntry_t* pkt, uint16_t* lenIE) {
 6211              		.loc 1 2744 0
 6212              		.cfi_startproc
 6213              		@ args = 0, pretend = 0, frame = 32
 6214              		@ frame_needed = 1, uses_anonymous_args = 0
 6215 2a80 80B5     		push	{r7, lr}
 6216              	.LCFI173:
 6217              		.cfi_def_cfa_offset 8
 6218              		.cfi_offset 7, -8
 6219              		.cfi_offset 14, -4
 6220 2a82 88B0     		sub	sp, sp, #32
 6221              	.LCFI174:
 6222              		.cfi_def_cfa_offset 40
 6223 2a84 00AF     		add	r7, sp, #0
 6224              	.LCFI175:
 6225              		.cfi_def_cfa_register 7
 6226 2a86 7860     		str	r0, [r7, #4]
 6227 2a88 3960     		str	r1, [r7, #0]
2745:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t               ptr;
2746:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t               byte0;
2747:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t               byte1;
2748:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t               temp_8b;
2749:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t               gr_elem_id;
2750:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint8_t               subid;
2751:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint16_t              temp_16b;
2752:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint16_t              len;
2753:openstack/02a-MAClow/IEEE802154Ecsl.c ****    uint16_t              sublen;
2754:openstack/02a-MAClow/IEEE802154Ecsl.c ****    PORT_SIGNED_INT_WIDTH timeCorrection;
2755:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2756:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ptr=0;
 6228              		.loc 1 2756 0
 6229 2a8a 4FF00003 		mov	r3, #0
 6230 2a8e FB73     		strb	r3, [r7, #15]
2757:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2758:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //===== header or payload IE header
2759:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2760:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //candidate IE header  if type ==0 header IE if type==1 payload IE
2761:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_8b    = *((uint8_t*)(pkt->payload)+ptr);
 6231              		.loc 1 2761 0
 6232 2a90 7B68     		ldr	r3, [r7, #4]
 6233 2a92 5A68     		ldr	r2, [r3, #4]
 6234 2a94 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6235 2a96 D318     		adds	r3, r2, r3
 6236 2a98 1B78     		ldrb	r3, [r3, #0]
 6237 2a9a 7B76     		strb	r3, [r7, #25]
2762:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ptr++;
 6238              		.loc 1 2762 0
 6239 2a9c FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6240 2a9e 03F10103 		add	r3, r3, #1
 6241 2aa2 DBB2     		uxtb	r3, r3
 6242 2aa4 FB73     		strb	r3, [r7, #15]
2763:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2764:openstack/02a-MAClow/IEEE802154Ecsl.c ****    temp_16b   = temp_8b + ((*((uint8_t*)(pkt->payload)+ptr))<< 8);
 6243              		.loc 1 2764 0
 6244 2aa6 7B7E     		ldrb	r3, [r7, #25]	@ zero_extendqisi2
 6245 2aa8 9AB2     		uxth	r2, r3
 6246 2aaa 7B68     		ldr	r3, [r7, #4]
 6247 2aac 5968     		ldr	r1, [r3, #4]
 6248 2aae FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6249 2ab0 CB18     		adds	r3, r1, r3
 6250 2ab2 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 6251 2ab4 4FEA0323 		lsl	r3, r3, #8
 6252 2ab8 9BB2     		uxth	r3, r3
 6253 2aba D318     		adds	r3, r2, r3
 6254 2abc FB82     		strh	r3, [r7, #22]	@ movhi
2765:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ptr++;
 6255              		.loc 1 2765 0
 6256 2abe FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6257 2ac0 03F10103 		add	r3, r3, #1
 6258 2ac4 DBB2     		uxtb	r3, r3
 6259 2ac6 FB73     		strb	r3, [r7, #15]
2766:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2767:openstack/02a-MAClow/IEEE802154Ecsl.c ****    *lenIE     = ptr;
 6260              		.loc 1 2767 0
 6261 2ac8 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6262 2aca 1A46     		mov	r2, r3
 6263 2acc 3B68     		ldr	r3, [r7, #0]
 6264 2ace 1A80     		strh	r2, [r3, #0]	@ movhi
2768:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2769:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if ((temp_16b & IEEE802154E_DESC_TYPE_PAYLOAD_IE) == IEEE802154E_DESC_TYPE_PAYLOAD_IE){
 6265              		.loc 1 2769 0
 6266 2ad0 FB8A     		ldrh	r3, [r7, #22]
 6267 2ad2 03F00103 		and	r3, r3, #1
 6268 2ad6 002B     		cmp	r3, #0
 6269 2ad8 0AD0     		beq	.L289
2770:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // payload IE
2771:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2772:openstack/02a-MAClow/IEEE802154Ecsl.c ****       len          = (temp_16b & IEEE802154E_DESC_LEN_PAYLOAD_IE_MASK)>>IEEE802154E_DESC_LEN_PAYLOA
 6270              		.loc 1 2772 0
 6271 2ada FB8A     		ldrh	r3, [r7, #22]
 6272 2adc 4FEA5313 		lsr	r3, r3, #5
 6273 2ae0 BB83     		strh	r3, [r7, #28]	@ movhi
2773:openstack/02a-MAClow/IEEE802154Ecsl.c ****       gr_elem_id   = (temp_16b & IEEE802154E_DESC_GROUPID_PAYLOAD_IE_MASK)>>IEEE802154E_DESC_GROUPI
 6274              		.loc 1 2773 0
 6275 2ae2 FB8A     		ldrh	r3, [r7, #22]
 6276 2ae4 03F01E03 		and	r3, r3, #30
 6277 2ae8 4FEA6303 		asr	r3, r3, #1
 6278 2aec FB77     		strb	r3, [r7, #31]
 6279 2aee 09E0     		b	.L290
 6280              	.L289:
2774:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
2775:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // header IE
2776:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2777:openstack/02a-MAClow/IEEE802154Ecsl.c ****       len          = (temp_16b & IEEE802154E_DESC_LEN_HEADER_IE_MASK)>>IEEE802154E_DESC_LEN_HEADER_
 6281              		.loc 1 2777 0
 6282 2af0 FB8A     		ldrh	r3, [r7, #22]
 6283 2af2 4FEA5323 		lsr	r3, r3, #9
 6284 2af6 BB83     		strh	r3, [r7, #28]	@ movhi
2778:openstack/02a-MAClow/IEEE802154Ecsl.c ****       gr_elem_id   = (temp_16b & IEEE802154E_DESC_ELEMENTID_HEADER_IE_MASK)>>IEEE802154E_DESC_ELEME
 6285              		.loc 1 2778 0
 6286 2af8 FB8A     		ldrh	r3, [r7, #22]
 6287 2afa 03F4FF73 		and	r3, r3, #510
 6288 2afe 4FEA6303 		asr	r3, r3, #1
 6289 2b02 FB77     		strb	r3, [r7, #31]
 6290              	.L290:
2779:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2780:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2781:openstack/02a-MAClow/IEEE802154Ecsl.c ****    *lenIE         += len;
 6291              		.loc 1 2781 0
 6292 2b04 3B68     		ldr	r3, [r7, #0]
 6293 2b06 1A88     		ldrh	r2, [r3, #0]
 6294 2b08 BB8B     		ldrh	r3, [r7, #28]	@ movhi
 6295 2b0a D318     		adds	r3, r2, r3
 6296 2b0c 9AB2     		uxth	r2, r3
 6297 2b0e 3B68     		ldr	r3, [r7, #0]
 6298 2b10 1A80     		strh	r2, [r3, #0]	@ movhi
2782:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2783:openstack/02a-MAClow/IEEE802154Ecsl.c ****    //===== sub-elements
2784:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2785:openstack/02a-MAClow/IEEE802154Ecsl.c ****    switch(gr_elem_id){
 6299              		.loc 1 2785 0
 6300 2b12 FB7F     		ldrb	r3, [r7, #31]	@ zero_extendqisi2
 6301 2b14 012B     		cmp	r3, #1
 6302 2b16 02D0     		beq	.L292
 6303 2b18 1E2B     		cmp	r3, #30
 6304 2b1a 78D0     		beq	.L293
 6305 2b1c BEE0     		b	.L307
 6306              	.L292:
2786:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2787:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case IEEE802154E_MLME_IE_GROUPID:
2788:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // MLME IE
2789:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2790:openstack/02a-MAClow/IEEE802154Ecsl.c ****          do {
2791:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2792:openstack/02a-MAClow/IEEE802154Ecsl.c ****             //read sub IE header
2793:openstack/02a-MAClow/IEEE802154Ecsl.c ****             temp_8b     = *((uint8_t*)(pkt->payload)+ptr);
 6307              		.loc 1 2793 0
 6308 2b1e 7B68     		ldr	r3, [r7, #4]
 6309 2b20 5A68     		ldr	r2, [r3, #4]
 6310 2b22 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6311 2b24 D318     		adds	r3, r2, r3
 6312 2b26 1B78     		ldrb	r3, [r3, #0]
 6313 2b28 7B76     		strb	r3, [r7, #25]
2794:openstack/02a-MAClow/IEEE802154Ecsl.c ****             ptr         = ptr + 1;
 6314              		.loc 1 2794 0
 6315 2b2a FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6316 2b2c 03F10103 		add	r3, r3, #1
 6317 2b30 DBB2     		uxtb	r3, r3
 6318 2b32 FB73     		strb	r3, [r7, #15]
2795:openstack/02a-MAClow/IEEE802154Ecsl.c ****             temp_16b    = temp_8b  +(*((uint8_t*)(pkt->payload)+ptr) << 8);
 6319              		.loc 1 2795 0
 6320 2b34 7B7E     		ldrb	r3, [r7, #25]	@ zero_extendqisi2
 6321 2b36 9AB2     		uxth	r2, r3
 6322 2b38 7B68     		ldr	r3, [r7, #4]
 6323 2b3a 5968     		ldr	r1, [r3, #4]
 6324 2b3c FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6325 2b3e CB18     		adds	r3, r1, r3
 6326 2b40 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 6327 2b42 4FEA0323 		lsl	r3, r3, #8
 6328 2b46 9BB2     		uxth	r3, r3
 6329 2b48 D318     		adds	r3, r2, r3
 6330 2b4a FB82     		strh	r3, [r7, #22]	@ movhi
2796:openstack/02a-MAClow/IEEE802154Ecsl.c ****             ptr         = ptr + 1;
 6331              		.loc 1 2796 0
 6332 2b4c FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6333 2b4e 03F10103 		add	r3, r3, #1
 6334 2b52 DBB2     		uxtb	r3, r3
 6335 2b54 FB73     		strb	r3, [r7, #15]
2797:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2798:openstack/02a-MAClow/IEEE802154Ecsl.c ****             len         = len - 2; //remove header fields len
 6336              		.loc 1 2798 0
 6337 2b56 BB8B     		ldrh	r3, [r7, #28]	@ movhi
 6338 2b58 A3F10203 		sub	r3, r3, #2
 6339 2b5c BB83     		strh	r3, [r7, #28]	@ movhi
2799:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2800:openstack/02a-MAClow/IEEE802154Ecsl.c ****             if ((temp_16b & IEEE802154E_DESC_TYPE_LONG) == IEEE802154E_DESC_TYPE_LONG){
 6340              		.loc 1 2800 0
 6341 2b5e FB8A     		ldrh	r3, [r7, #22]
 6342 2b60 03F00103 		and	r3, r3, #1
 6343 2b64 002B     		cmp	r3, #0
 6344 2b66 0AD0     		beq	.L294
2801:openstack/02a-MAClow/IEEE802154Ecsl.c ****                // long sub-IE
2802:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2803:openstack/02a-MAClow/IEEE802154Ecsl.c ****                sublen   = (temp_16b & IEEE802154E_DESC_LEN_LONG_MLME_IE_MASK)>>IEEE802154E_DESC_LEN
 6345              		.loc 1 2803 0
 6346 2b68 FB8A     		ldrh	r3, [r7, #22]
 6347 2b6a 4FEA5313 		lsr	r3, r3, #5
 6348 2b6e 7B83     		strh	r3, [r7, #26]	@ movhi
2804:openstack/02a-MAClow/IEEE802154Ecsl.c ****                subid    = (temp_16b & IEEE802154E_DESC_SUBID_LONG_MLME_IE_MASK)>>IEEE802154E_DESC_S
 6349              		.loc 1 2804 0
 6350 2b70 FB8A     		ldrh	r3, [r7, #22]
 6351 2b72 03F01E03 		and	r3, r3, #30
 6352 2b76 4FEA6303 		asr	r3, r3, #1
 6353 2b7a BB77     		strb	r3, [r7, #30]
 6354 2b7c 09E0     		b	.L295
 6355              	.L294:
2805:openstack/02a-MAClow/IEEE802154Ecsl.c ****             } else {
2806:openstack/02a-MAClow/IEEE802154Ecsl.c ****                // short sub-IE
2807:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2808:openstack/02a-MAClow/IEEE802154Ecsl.c ****                sublen   = (temp_16b & IEEE802154E_DESC_LEN_SHORT_MLME_IE_MASK)>>IEEE802154E_DESC_LE
 6356              		.loc 1 2808 0
 6357 2b7e FB8A     		ldrh	r3, [r7, #22]
 6358 2b80 4FEA1323 		lsr	r3, r3, #8
 6359 2b84 7B83     		strh	r3, [r7, #26]	@ movhi
2809:openstack/02a-MAClow/IEEE802154Ecsl.c ****                subid    = (temp_16b & IEEE802154E_DESC_SUBID_SHORT_MLME_IE_MASK)>>IEEE802154E_DESC_
 6360              		.loc 1 2809 0
 6361 2b86 FB8A     		ldrh	r3, [r7, #22]
 6362 2b88 03F0FE03 		and	r3, r3, #254
 6363 2b8c 4FEA6303 		asr	r3, r3, #1
 6364 2b90 BB77     		strb	r3, [r7, #30]
 6365              	.L295:
2810:openstack/02a-MAClow/IEEE802154Ecsl.c ****             }
2811:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2812:openstack/02a-MAClow/IEEE802154Ecsl.c ****             switch(subid){
 6366              		.loc 1 2812 0
 6367 2b92 BB7F     		ldrb	r3, [r7, #30]	@ zero_extendqisi2
 6368 2b94 1B2B     		cmp	r3, #27
 6369 2b96 25D0     		beq	.L298
 6370 2b98 1C2B     		cmp	r3, #28
 6371 2b9a 2DD0     		beq	.L309
 6372 2b9c 1A2B     		cmp	r3, #26
 6373 2b9e 28D1     		bne	.L308
 6374              	.L297:
2813:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2814:openstack/02a-MAClow/IEEE802154Ecsl.c ****                case IEEE802154E_MLME_SYNC_IE_SUBID:
2815:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   // Sync IE: ASN and Join Priority
2816:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2817:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   if (idmanager_getIsDAGroot()==FALSE) {
 6375              		.loc 1 2817 0
 6376 2ba0 FFF7FEFF 		bl	idmanager_getIsDAGroot
 6377 2ba4 0346     		mov	r3, r0
 6378 2ba6 83F00103 		eor	r3, r3, #1
 6379 2baa DBB2     		uxtb	r3, r3
 6380 2bac 002B     		cmp	r3, #0
 6381 2bae 25D0     		beq	.L310
2818:openstack/02a-MAClow/IEEE802154Ecsl.c ****                      // ASN
2819:openstack/02a-MAClow/IEEE802154Ecsl.c ****                      asnStoreFromAdv((uint8_t*)(pkt->payload)+ptr);
 6382              		.loc 1 2819 0
 6383 2bb0 7B68     		ldr	r3, [r7, #4]
 6384 2bb2 5A68     		ldr	r2, [r3, #4]
 6385 2bb4 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6386 2bb6 D318     		adds	r3, r2, r3
 6387 2bb8 1846     		mov	r0, r3
 6388 2bba FFF7FEFF 		bl	asnStoreFromAdv
2820:openstack/02a-MAClow/IEEE802154Ecsl.c ****                      ptr = ptr + 5;
 6389              		.loc 1 2820 0
 6390 2bbe FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6391 2bc0 03F10503 		add	r3, r3, #5
 6392 2bc4 DBB2     		uxtb	r3, r3
 6393 2bc6 FB73     		strb	r3, [r7, #15]
2821:openstack/02a-MAClow/IEEE802154Ecsl.c ****                      // join priority
2822:openstack/02a-MAClow/IEEE802154Ecsl.c ****                      joinPriorityStoreFromAdv(*((uint8_t*)(pkt->payload)+ptr));
 6394              		.loc 1 2822 0
 6395 2bc8 7B68     		ldr	r3, [r7, #4]
 6396 2bca 5A68     		ldr	r2, [r3, #4]
 6397 2bcc FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6398 2bce D318     		adds	r3, r2, r3
 6399 2bd0 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 6400 2bd2 1846     		mov	r0, r3
 6401 2bd4 FFF7FEFF 		bl	joinPriorityStoreFromAdv
2823:openstack/02a-MAClow/IEEE802154Ecsl.c ****                      ptr = ptr + 1;
 6402              		.loc 1 2823 0
 6403 2bd8 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6404 2bda 03F10103 		add	r3, r3, #1
 6405 2bde DBB2     		uxtb	r3, r3
 6406 2be0 FB73     		strb	r3, [r7, #15]
2824:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   }
2825:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   break;
 6407              		.loc 1 2825 0
 6408 2be2 0BE0     		b	.L310
 6409              	.L298:
2826:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2827:openstack/02a-MAClow/IEEE802154Ecsl.c ****                case IEEE802154E_MLME_SLOTFRAME_LINK_IE_SUBID:
2828:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   processIE_retrieveSlotframeLinkIE(pkt,&ptr);
 6410              		.loc 1 2828 0
 6411 2be4 07F10F03 		add	r3, r7, #15
 6412 2be8 7868     		ldr	r0, [r7, #4]
 6413 2bea 1946     		mov	r1, r3
 6414 2bec FFF7FEFF 		bl	processIE_retrieveSlotframeLinkIE
2829:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   break;
 6415              		.loc 1 2829 0
 6416 2bf0 05E0     		b	.L301
 6417              	.L308:
2830:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2831:openstack/02a-MAClow/IEEE802154Ecsl.c ****                case IEEE802154E_MLME_TIMESLOT_IE_SUBID:
2832:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   // to do
2833:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   break;
2834:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2835:openstack/02a-MAClow/IEEE802154Ecsl.c ****                default:
2836:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   return FALSE;
 6418              		.loc 1 2836 0
 6419 2bf2 4FF00003 		mov	r3, #0
 6420 2bf6 6AE0     		b	.L306
 6421              	.L309:
2833:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   break;
 6422              		.loc 1 2833 0
 6423 2bf8 00BF     		nop
 6424 2bfa 00E0     		b	.L301
 6425              	.L310:
2825:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   break;
 6426              		.loc 1 2825 0
 6427 2bfc 00BF     		nop
 6428              	.L301:
2837:openstack/02a-MAClow/IEEE802154Ecsl.c ****                   break;
2838:openstack/02a-MAClow/IEEE802154Ecsl.c ****             }
2839:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2840:openstack/02a-MAClow/IEEE802154Ecsl.c ****             len = len - sublen;
 6429              		.loc 1 2840 0
 6430 2bfe BA8B     		ldrh	r2, [r7, #28]	@ movhi
 6431 2c00 7B8B     		ldrh	r3, [r7, #26]	@ movhi
 6432 2c02 D31A     		subs	r3, r2, r3
 6433 2c04 BB83     		strh	r3, [r7, #28]	@ movhi
2841:openstack/02a-MAClow/IEEE802154Ecsl.c ****          } while(len>0);
 6434              		.loc 1 2841 0
 6435 2c06 BB8B     		ldrh	r3, [r7, #28]
 6436 2c08 002B     		cmp	r3, #0
 6437 2c0a 88D1     		bne	.L292
2842:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2843:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 6438              		.loc 1 2843 0
 6439 2c0c 4EE0     		b	.L303
 6440              	.L293:
2844:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2845:openstack/02a-MAClow/IEEE802154Ecsl.c ****       case IEEE802154E_ACK_NACK_TIMECORRECTION_ELEMENTID:
2846:openstack/02a-MAClow/IEEE802154Ecsl.c ****          // timecorrection IE
2847:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2848:openstack/02a-MAClow/IEEE802154Ecsl.c ****          if (
2849:openstack/02a-MAClow/IEEE802154Ecsl.c ****                idmanager_getIsDAGroot()==FALSE &&
 6441              		.loc 1 2849 0
 6442 2c0e FFF7FEFF 		bl	idmanager_getIsDAGroot
 6443 2c12 0346     		mov	r3, r0
 6444 2c14 83F00103 		eor	r3, r3, #1
 6445 2c18 DBB2     		uxtb	r3, r3
2848:openstack/02a-MAClow/IEEE802154Ecsl.c ****          if (
 6446              		.loc 1 2848 0
 6447 2c1a 002B     		cmp	r3, #0
 6448 2c1c 45D0     		beq	.L311
2850:openstack/02a-MAClow/IEEE802154Ecsl.c ****                neighbors_isPreferredParent(&(pkt->l2_nextORpreviousHop))
 6449              		.loc 1 2850 0
 6450 2c1e 7B68     		ldr	r3, [r7, #4]
 6451 2c20 03F13803 		add	r3, r3, #56
 6452 2c24 1846     		mov	r0, r3
 6453 2c26 FFF7FEFF 		bl	neighbors_isPreferredParent
 6454 2c2a 0346     		mov	r3, r0
2849:openstack/02a-MAClow/IEEE802154Ecsl.c ****                idmanager_getIsDAGroot()==FALSE &&
 6455              		.loc 1 2849 0
 6456 2c2c 002B     		cmp	r3, #0
 6457 2c2e 3CD0     		beq	.L311
2851:openstack/02a-MAClow/IEEE802154Ecsl.c ****             ) {
2852:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2853:openstack/02a-MAClow/IEEE802154Ecsl.c ****             byte0 = *((uint8_t*)(pkt->payload)+ptr);
 6458              		.loc 1 2853 0
 6459 2c30 7B68     		ldr	r3, [r7, #4]
 6460 2c32 5A68     		ldr	r2, [r3, #4]
 6461 2c34 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6462 2c36 D318     		adds	r3, r2, r3
 6463 2c38 1B78     		ldrb	r3, [r3, #0]
 6464 2c3a 7B75     		strb	r3, [r7, #21]
2854:openstack/02a-MAClow/IEEE802154Ecsl.c ****             ptr++;
 6465              		.loc 1 2854 0
 6466 2c3c FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6467 2c3e 03F10103 		add	r3, r3, #1
 6468 2c42 DBB2     		uxtb	r3, r3
 6469 2c44 FB73     		strb	r3, [r7, #15]
2855:openstack/02a-MAClow/IEEE802154Ecsl.c ****             byte1 = *((uint8_t*)(pkt->payload)+ptr);
 6470              		.loc 1 2855 0
 6471 2c46 7B68     		ldr	r3, [r7, #4]
 6472 2c48 5A68     		ldr	r2, [r3, #4]
 6473 2c4a FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6474 2c4c D318     		adds	r3, r2, r3
 6475 2c4e 1B78     		ldrb	r3, [r3, #0]
 6476 2c50 3B75     		strb	r3, [r7, #20]
2856:openstack/02a-MAClow/IEEE802154Ecsl.c ****             ptr++;
 6477              		.loc 1 2856 0
 6478 2c52 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 6479 2c54 03F10103 		add	r3, r3, #1
 6480 2c58 DBB2     		uxtb	r3, r3
 6481 2c5a FB73     		strb	r3, [r7, #15]
2857:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2858:openstack/02a-MAClow/IEEE802154Ecsl.c ****             timeCorrection  = (int16_t)((uint16_t)byte1<<8 | (uint16_t)byte0);
 6482              		.loc 1 2858 0
 6483 2c5c 3B7D     		ldrb	r3, [r7, #20]	@ zero_extendqisi2
 6484 2c5e 4FEA0323 		lsl	r3, r3, #8
 6485 2c62 9AB2     		uxth	r2, r3
 6486 2c64 7B7D     		ldrb	r3, [r7, #21]	@ zero_extendqisi2
 6487 2c66 9BB2     		uxth	r3, r3
 6488 2c68 1343     		orrs	r3, r3, r2
 6489 2c6a 9BB2     		uxth	r3, r3
 6490 2c6c 1BB2     		sxth	r3, r3
 6491 2c6e 3B61     		str	r3, [r7, #16]
2859:openstack/02a-MAClow/IEEE802154Ecsl.c ****             timeCorrection  = (timeCorrection / (PORT_SIGNED_INT_WIDTH)US_PER_TICK);
 6492              		.loc 1 2859 0
 6493 2c70 3B69     		ldr	r3, [r7, #16]
 6494 2c72 48F68902 		movw	r2, #34953
 6495 2c76 C8F68802 		movt	r2, 34952
 6496 2c7a 82FB0312 		smull	r1, r2, r2, r3
 6497 2c7e D218     		adds	r2, r2, r3
 6498 2c80 4FEA2212 		asr	r2, r2, #4
 6499 2c84 4FEAE373 		asr	r3, r3, #31
 6500 2c88 D31A     		subs	r3, r2, r3
 6501 2c8a 3B61     		str	r3, [r7, #16]
2860:openstack/02a-MAClow/IEEE802154Ecsl.c ****             timeCorrection  = -timeCorrection;
 6502              		.loc 1 2860 0
 6503 2c8c 3B69     		ldr	r3, [r7, #16]
 6504 2c8e C3F10003 		rsb	r3, r3, #0
 6505 2c92 3B61     		str	r3, [r7, #16]
2861:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2862:openstack/02a-MAClow/IEEE802154Ecsl.c ****             synchronizeAck(timeCorrection);
 6506              		.loc 1 2862 0
 6507 2c94 3869     		ldr	r0, [r7, #16]
 6508 2c96 FFF7FEFF 		bl	synchronizeAck
2863:openstack/02a-MAClow/IEEE802154Ecsl.c ****          }
2864:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 6509              		.loc 1 2864 0
 6510 2c9a 06E0     		b	.L311
 6511              	.L307:
2865:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2866:openstack/02a-MAClow/IEEE802154Ecsl.c ****       default:
2867:openstack/02a-MAClow/IEEE802154Ecsl.c ****          *lenIE = 0; //no header or not recognized.
 6512              		.loc 1 2867 0
 6513 2c9c 3B68     		ldr	r3, [r7, #0]
 6514 2c9e 4FF00002 		mov	r2, #0
 6515 2ca2 1A80     		strh	r2, [r3, #0]	@ movhi
2868:openstack/02a-MAClow/IEEE802154Ecsl.c ****          return FALSE;
 6516              		.loc 1 2868 0
 6517 2ca4 4FF00003 		mov	r3, #0
 6518 2ca8 11E0     		b	.L306
 6519              	.L311:
2864:openstack/02a-MAClow/IEEE802154Ecsl.c ****          break;
 6520              		.loc 1 2864 0
 6521 2caa 00BF     		nop
 6522              	.L303:
2869:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2870:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2871:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if(*lenIE>127) {
 6523              		.loc 1 2871 0
 6524 2cac 3B68     		ldr	r3, [r7, #0]
 6525 2cae 1B88     		ldrh	r3, [r3, #0]
 6526 2cb0 7F2B     		cmp	r3, #127
 6527 2cb2 0AD9     		bls	.L305
2872:openstack/02a-MAClow/IEEE802154Ecsl.c ****       // log the error
2873:openstack/02a-MAClow/IEEE802154Ecsl.c ****       openserial_printError(
 6528              		.loc 1 2873 0
 6529 2cb4 3B68     		ldr	r3, [r7, #0]
 6530 2cb6 1B88     		ldrh	r3, [r3, #0]
 6531 2cb8 4FF00900 		mov	r0, #9
 6532 2cbc 4FF03301 		mov	r1, #51
 6533 2cc0 1A46     		mov	r2, r3
 6534 2cc2 4FF00103 		mov	r3, #1
 6535 2cc6 FFF7FEFF 		bl	openserial_printError
 6536              	.L305:
2874:openstack/02a-MAClow/IEEE802154Ecsl.c ****          COMPONENT_IEEE802154E,
2875:openstack/02a-MAClow/IEEE802154Ecsl.c ****          ERR_HEADER_TOO_LONG,
2876:openstack/02a-MAClow/IEEE802154Ecsl.c ****          (errorparameter_t)*lenIE,
2877:openstack/02a-MAClow/IEEE802154Ecsl.c ****          (errorparameter_t)1
2878:openstack/02a-MAClow/IEEE802154Ecsl.c ****       );
2879:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2880:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return TRUE;
 6537              		.loc 1 2880 0
 6538 2cca 4FF00103 		mov	r3, #1
 6539              	.L306:
2881:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 6540              		.loc 1 2881 0
 6541 2cce 1846     		mov	r0, r3
 6542 2cd0 07F12007 		add	r7, r7, #32
 6543 2cd4 BD46     		mov	sp, r7
 6544 2cd6 80BD     		pop	{r7, pc}
 6545              		.cfi_endproc
 6546              	.LFE71:
 6548              		.align	2
 6549              		.global	joinPriorityStoreFromAdv
 6550              		.thumb
 6551              		.thumb_func
 6553              	joinPriorityStoreFromAdv:
 6554              	.LFB72:
2882:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2883:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void joinPriorityStoreFromAdv(uint8_t jp){
 6555              		.loc 1 2883 0
 6556              		.cfi_startproc
 6557              		@ args = 0, pretend = 0, frame = 8
 6558              		@ frame_needed = 1, uses_anonymous_args = 0
 6559              		@ link register save eliminated.
 6560 2cd8 80B4     		push	{r7}
 6561              	.LCFI176:
 6562              		.cfi_def_cfa_offset 4
 6563              		.cfi_offset 7, -4
 6564 2cda 83B0     		sub	sp, sp, #12
 6565              	.LCFI177:
 6566              		.cfi_def_cfa_offset 16
 6567 2cdc 00AF     		add	r7, sp, #0
 6568              	.LCFI178:
 6569              		.cfi_def_cfa_register 7
 6570 2cde 0346     		mov	r3, r0
 6571 2ce0 FB71     		strb	r3, [r7, #7]
2884:openstack/02a-MAClow/IEEE802154Ecsl.c ****   ieee154e_vars.dataReceived->l2_joinPriority = jp;
 6572              		.loc 1 2884 0
 6573 2ce2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6574 2ce6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6575 2cea 9B69     		ldr	r3, [r3, #24]
 6576 2cec FA79     		ldrb	r2, [r7, #7]
 6577 2cee 83F86420 		strb	r2, [r3, #100]
2885:openstack/02a-MAClow/IEEE802154Ecsl.c ****   ieee154e_vars.dataReceived->l2_joinPriorityPresent = TRUE;
 6578              		.loc 1 2885 0
 6579 2cf2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6580 2cf6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6581 2cfa 9B69     		ldr	r3, [r3, #24]
 6582 2cfc 4FF00102 		mov	r2, #1
 6583 2d00 83F86620 		strb	r2, [r3, #102]
2886:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 6584              		.loc 1 2886 0
 6585 2d04 07F10C07 		add	r7, r7, #12
 6586 2d08 BD46     		mov	sp, r7
 6587 2d0a 80BC     		pop	{r7}
 6588 2d0c 7047     		bx	lr
 6589              		.cfi_endproc
 6590              	.LFE72:
 6592 2d0e 00BF     		.align	2
 6593              		.global	asnStoreFromAdv
 6594              		.thumb
 6595              		.thumb_func
 6597              	asnStoreFromAdv:
 6598              	.LFB73:
2887:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2888:openstack/02a-MAClow/IEEE802154Ecsl.c **** port_INLINE void asnStoreFromAdv(uint8_t* asn) {
 6599              		.loc 1 2888 0
 6600              		.cfi_startproc
 6601              		@ args = 0, pretend = 0, frame = 8
 6602              		@ frame_needed = 1, uses_anonymous_args = 0
 6603 2d10 90B5     		push	{r4, r7, lr}
 6604              	.LCFI179:
 6605              		.cfi_def_cfa_offset 12
 6606              		.cfi_offset 4, -12
 6607              		.cfi_offset 7, -8
 6608              		.cfi_offset 14, -4
 6609 2d12 83B0     		sub	sp, sp, #12
 6610              	.LCFI180:
 6611              		.cfi_def_cfa_offset 24
 6612 2d14 00AF     		add	r7, sp, #0
 6613              	.LCFI181:
 6614              		.cfi_def_cfa_register 7
 6615 2d16 7860     		str	r0, [r7, #4]
2889:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2890:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // store the ASN
2891:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asn.bytes0and1   =     asn[0]+
 6616              		.loc 1 2891 0
 6617 2d18 7B68     		ldr	r3, [r7, #4]
 6618 2d1a 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 6619 2d1c 1A46     		mov	r2, r3
2892:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                     256*asn[1];
 6620              		.loc 1 2892 0
 6621 2d1e 7B68     		ldr	r3, [r7, #4]
 6622 2d20 03F10103 		add	r3, r3, #1
 6623 2d24 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
2891:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asn.bytes0and1   =     asn[0]+
 6624              		.loc 1 2891 0
 6625 2d26 4FEA0323 		lsl	r3, r3, #8
 6626 2d2a 9BB2     		uxth	r3, r3
 6627 2d2c D318     		adds	r3, r2, r3
 6628 2d2e 9AB2     		uxth	r2, r3
 6629 2d30 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6630 2d34 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6631 2d38 A3F80320 		strh	r2, [r3, #3]	@ unaligned
2893:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asn.bytes2and3   =     asn[2]+
 6632              		.loc 1 2893 0
 6633 2d3c 7B68     		ldr	r3, [r7, #4]
 6634 2d3e 03F10203 		add	r3, r3, #2
 6635 2d42 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 6636 2d44 1A46     		mov	r2, r3
2894:openstack/02a-MAClow/IEEE802154Ecsl.c ****                                     256*asn[3];
 6637              		.loc 1 2894 0
 6638 2d46 7B68     		ldr	r3, [r7, #4]
 6639 2d48 03F10303 		add	r3, r3, #3
 6640 2d4c 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
2893:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asn.bytes2and3   =     asn[2]+
 6641              		.loc 1 2893 0
 6642 2d4e 4FEA0323 		lsl	r3, r3, #8
 6643 2d52 9BB2     		uxth	r3, r3
 6644 2d54 D318     		adds	r3, r2, r3
 6645 2d56 9AB2     		uxth	r2, r3
 6646 2d58 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6647 2d5c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6648 2d60 A3F80120 		strh	r2, [r3, #1]	@ unaligned
2895:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asn.byte4        =     asn[4];
 6649              		.loc 1 2895 0
 6650 2d64 7B68     		ldr	r3, [r7, #4]
 6651 2d66 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 6652 2d68 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6653 2d6c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6654 2d70 1A70     		strb	r2, [r3, #0]
2896:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2897:openstack/02a-MAClow/IEEE802154Ecsl.c ****    // determine the current slotOffset
2898:openstack/02a-MAClow/IEEE802154Ecsl.c ****    /*
2899:openstack/02a-MAClow/IEEE802154Ecsl.c ****    Note: this is a bit of a hack. Normally, slotOffset=ASN%slotlength. But since
2900:openstack/02a-MAClow/IEEE802154Ecsl.c ****    the ADV is exchanged in slot 0, we know that we're currently at slotOffset==0
2901:openstack/02a-MAClow/IEEE802154Ecsl.c ****    */
2902:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.slotOffset       = 0;
 6655              		.loc 1 2902 0
 6656 2d72 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6657 2d76 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6658 2d7a 4FF00002 		mov	r2, #0
 6659 2d7e DA80     		strh	r2, [r3, #6]	@ movhi
2903:openstack/02a-MAClow/IEEE802154Ecsl.c ****    schedule_syncSlotOffset(ieee154e_vars.slotOffset);
 6660              		.loc 1 2903 0
 6661 2d80 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6662 2d84 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6663 2d88 DB88     		ldrh	r3, [r3, #6]
 6664 2d8a 1846     		mov	r0, r3
 6665 2d8c FFF7FEFF 		bl	schedule_syncSlotOffset
2904:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.nextActiveSlotOffset = schedule_getNextActiveSlotOffset();
 6666              		.loc 1 2904 0
 6667 2d90 FFF7FEFF 		bl	schedule_getNextActiveSlotOffset
 6668 2d94 0346     		mov	r3, r0
 6669 2d96 1A46     		mov	r2, r3
 6670 2d98 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6671 2d9c C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6672 2da0 1A81     		strh	r2, [r3, #8]	@ movhi
2905:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2906:openstack/02a-MAClow/IEEE802154Ecsl.c ****    /*
2907:openstack/02a-MAClow/IEEE802154Ecsl.c ****    infer the asnOffset based on the fact that
2908:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.freq = 11 + (asnOffset + channelOffset)%16
2909:openstack/02a-MAClow/IEEE802154Ecsl.c ****    */
2910:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ieee154e_vars.asnOffset = ieee154e_vars.freq - 11 - schedule_getChannelOffset();
 6673              		.loc 1 2910 0
 6674 2da2 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6675 2da6 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6676 2daa 93F82C40 		ldrb	r4, [r3, #44]	@ zero_extendqisi2
 6677 2dae FFF7FEFF 		bl	schedule_getChannelOffset
 6678 2db2 0346     		mov	r3, r0
 6679 2db4 E31A     		subs	r3, r4, r3
 6680 2db6 DBB2     		uxtb	r3, r3
 6681 2db8 A3F10B03 		sub	r3, r3, #11
 6682 2dbc DAB2     		uxtb	r2, r3
 6683 2dbe 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6684 2dc2 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6685 2dc6 83F82D20 		strb	r2, [r3, #45]
2911:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 6686              		.loc 1 2911 0
 6687 2dca 07F10C07 		add	r7, r7, #12
 6688 2dce BD46     		mov	sp, r7
 6689 2dd0 90BD     		pop	{r4, r7, pc}
 6690              		.cfi_endproc
 6691              	.LFE73:
 6693 2dd2 00BF     		.align	2
 6694              		.global	ieee154e_asnDiff
 6695              		.thumb
 6696              		.thumb_func
 6698              	ieee154e_asnDiff:
 6699              	.LFB74:
2912:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2913:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2914:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2915:openstack/02a-MAClow/IEEE802154Ecsl.c **** /**
2916:openstack/02a-MAClow/IEEE802154Ecsl.c **** /brief Difference between some older ASN and the current ASN.
2917:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2918:openstack/02a-MAClow/IEEE802154Ecsl.c **** \param[in] someASN some ASN to compare to the current
2919:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2920:openstack/02a-MAClow/IEEE802154Ecsl.c **** \returns The ASN difference, or 0xffff if more than 65535 different
2921:openstack/02a-MAClow/IEEE802154Ecsl.c **** */
2922:openstack/02a-MAClow/IEEE802154Ecsl.c **** PORT_RADIOTIMER_WIDTH ieee154e_asnDiff(asn_t* someASN) {
 6700              		.loc 1 2922 0
 6701              		.cfi_startproc
 6702              		@ args = 0, pretend = 0, frame = 16
 6703              		@ frame_needed = 1, uses_anonymous_args = 0
 6704 2dd4 80B5     		push	{r7, lr}
 6705              	.LCFI182:
 6706              		.cfi_def_cfa_offset 8
 6707              		.cfi_offset 7, -8
 6708              		.cfi_offset 14, -4
 6709 2dd6 84B0     		sub	sp, sp, #16
 6710              	.LCFI183:
 6711              		.cfi_def_cfa_offset 24
 6712 2dd8 00AF     		add	r7, sp, #0
 6713              	.LCFI184:
 6714              		.cfi_def_cfa_register 7
 6715 2dda 7860     		str	r0, [r7, #4]
2923:openstack/02a-MAClow/IEEE802154Ecsl.c ****    PORT_RADIOTIMER_WIDTH diff;
2924:openstack/02a-MAClow/IEEE802154Ecsl.c ****    INTERRUPT_DECLARATION();
2925:openstack/02a-MAClow/IEEE802154Ecsl.c ****    DISABLE_INTERRUPTS();
 6716              		.loc 1 2925 0
 6717 2ddc FFF7FEFF 		bl	IntMasterDisable
2926:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.asn.byte4 != someASN->byte4) {
 6718              		.loc 1 2926 0
 6719 2de0 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6720 2de4 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6721 2de8 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 6722 2dea 7B68     		ldr	r3, [r7, #4]
 6723 2dec 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 6724 2dee 9A42     		cmp	r2, r3
 6725 2df0 04D0     		beq	.L315
2927:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ENABLE_INTERRUPTS();
 6726              		.loc 1 2927 0
 6727 2df2 FFF7FEFF 		bl	IntMasterEnable
2928:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return (PORT_RADIOTIMER_WIDTH)0xFFFFFFFF;;
 6728              		.loc 1 2928 0
 6729 2df6 4FF0FF33 		mov	r3, #-1
 6730 2dfa 4CE0     		b	.L316
 6731              	.L315:
2929:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2930:openstack/02a-MAClow/IEEE802154Ecsl.c **** 
2931:openstack/02a-MAClow/IEEE802154Ecsl.c ****    diff = 0;
 6732              		.loc 1 2931 0
 6733 2dfc 4FF00003 		mov	r3, #0
 6734 2e00 FB60     		str	r3, [r7, #12]
2932:openstack/02a-MAClow/IEEE802154Ecsl.c ****    if (ieee154e_vars.asn.bytes2and3 == someASN->bytes2and3) {
 6735              		.loc 1 2932 0
 6736 2e02 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6737 2e06 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6738 2e0a B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 6739 2e0e 9AB2     		uxth	r2, r3
 6740 2e10 7B68     		ldr	r3, [r7, #4]
 6741 2e12 B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 6742 2e16 9BB2     		uxth	r3, r3
 6743 2e18 9A42     		cmp	r2, r3
 6744 2e1a 0FD1     		bne	.L317
2933:openstack/02a-MAClow/IEEE802154Ecsl.c ****       ENABLE_INTERRUPTS();
 6745              		.loc 1 2933 0
 6746 2e1c FFF7FEFF 		bl	IntMasterEnable
2934:openstack/02a-MAClow/IEEE802154Ecsl.c ****       return ieee154e_vars.asn.bytes0and1-someASN->bytes0and1;
 6747              		.loc 1 2934 0
 6748 2e20 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6749 2e24 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6750 2e28 B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 6751 2e2c 9BB2     		uxth	r3, r3
 6752 2e2e 1A46     		mov	r2, r3
 6753 2e30 7B68     		ldr	r3, [r7, #4]
 6754 2e32 B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 6755 2e36 9BB2     		uxth	r3, r3
 6756 2e38 D31A     		subs	r3, r2, r3
 6757 2e3a 2CE0     		b	.L316
 6758              	.L317:
2935:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else if (ieee154e_vars.asn.bytes2and3-someASN->bytes2and3==1) {
 6759              		.loc 1 2935 0
 6760 2e3c 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6761 2e40 C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6762 2e44 B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 6763 2e48 9BB2     		uxth	r3, r3
 6764 2e4a 1A46     		mov	r2, r3
 6765 2e4c 7B68     		ldr	r3, [r7, #4]
 6766 2e4e B3F80130 		ldrh	r3, [r3, #1]	@ unaligned
 6767 2e52 9BB2     		uxth	r3, r3
 6768 2e54 D31A     		subs	r3, r2, r3
 6769 2e56 012B     		cmp	r3, #1
 6770 2e58 17D1     		bne	.L318
2936:openstack/02a-MAClow/IEEE802154Ecsl.c ****       diff  = ieee154e_vars.asn.bytes0and1;
 6771              		.loc 1 2936 0
 6772 2e5a 40F20003 		movw	r3, #:lower16:ieee154e_vars
 6773 2e5e C0F20003 		movt	r3, #:upper16:ieee154e_vars
 6774 2e62 B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 6775 2e66 9BB2     		uxth	r3, r3
 6776 2e68 FB60     		str	r3, [r7, #12]
2937:openstack/02a-MAClow/IEEE802154Ecsl.c ****       diff += 0xffff-someASN->bytes0and1;
 6777              		.loc 1 2937 0
 6778 2e6a 7B68     		ldr	r3, [r7, #4]
 6779 2e6c B3F80330 		ldrh	r3, [r3, #3]	@ unaligned
 6780 2e70 9BB2     		uxth	r3, r3
 6781 2e72 FA68     		ldr	r2, [r7, #12]
 6782 2e74 D31A     		subs	r3, r2, r3
 6783 2e76 03F57F43 		add	r3, r3, #65280
 6784 2e7a 03F1FF03 		add	r3, r3, #255
 6785 2e7e FB60     		str	r3, [r7, #12]
2938:openstack/02a-MAClow/IEEE802154Ecsl.c ****       diff += 1;
 6786              		.loc 1 2938 0
 6787 2e80 FB68     		ldr	r3, [r7, #12]
 6788 2e82 03F10103 		add	r3, r3, #1
 6789 2e86 FB60     		str	r3, [r7, #12]
 6790 2e88 02E0     		b	.L319
 6791              	.L318:
2939:openstack/02a-MAClow/IEEE802154Ecsl.c ****    } else {
2940:openstack/02a-MAClow/IEEE802154Ecsl.c ****       diff = (PORT_RADIOTIMER_WIDTH)0xFFFFFFFF;;
 6792              		.loc 1 2940 0
 6793 2e8a 4FF0FF33 		mov	r3, #-1
 6794 2e8e FB60     		str	r3, [r7, #12]
 6795              	.L319:
2941:openstack/02a-MAClow/IEEE802154Ecsl.c ****    }
2942:openstack/02a-MAClow/IEEE802154Ecsl.c ****    ENABLE_INTERRUPTS();
 6796              		.loc 1 2942 0
 6797 2e90 FFF7FEFF 		bl	IntMasterEnable
2943:openstack/02a-MAClow/IEEE802154Ecsl.c ****    return diff;
 6798              		.loc 1 2943 0
 6799 2e94 FB68     		ldr	r3, [r7, #12]
 6800              	.L316:
2944:openstack/02a-MAClow/IEEE802154Ecsl.c **** }
 6801              		.loc 1 2944 0
 6802 2e96 1846     		mov	r0, r3
 6803 2e98 07F11007 		add	r7, r7, #16
 6804 2e9c BD46     		mov	sp, r7
 6805 2e9e 80BD     		pop	{r7, pc}
 6806              		.cfi_endproc
 6807              	.LFE74:
 6809              	.Letext0:
 6810              		.file 2 "/opt/gcc-arm-none-eabi-4_7-2013q3/bin/../lib/gcc/arm-none-eabi/4.7.4/../../../../arm-none
 6811              		.file 3 "inc/opendefs.h"
 6812              		.file 4 "openstack/02b-MAChigh/schedule.h"
 6813              		.file 5 "openstack/02b-MAChigh/processIE.h"
 6814              		.file 6 "drivers/common/opentimers.h"
 6815              		.file 7 "openstack/02a-MAClow/IEEE802154Ecsl.h"
 6816              		.file 8 "openstack/02a-MAClow/IEEE802154.h"
 6817              		.file 9 "kernel/scheduler.h"
 6818              		.file 10 "bsp/boards/OpenMote-CC2538/board_info.h"
 6819              		.file 11 "openstack/03b-IPv6/icmpv6rpl.h"
DEFINED SYMBOLS
                            *ABS*:00000000 IEEE802154Ecsl.c
     /tmp/ccppeInf.s:19     .rodata:00000000 $d
     /tmp/ccppeInf.s:22     .rodata:00000000 rreg_uriquery
     /tmp/ccppeInf.s:27     .rodata:00000008 infoBoardname
     /tmp/ccppeInf.s:32     .rodata:00000010 infouCName
     /tmp/ccppeInf.s:37     .rodata:00000018 infoRadioName
     /tmp/ccppeInf.s:42     .rodata:00000024 infoStackName
     /tmp/ccppeInf.s:47     .rodata:00000030 all_routers_multicast
                            *COM*:0000004c ieee154e_vars
                            *COM*:0000000f ieee154e_stats
                            *COM*:00000014 ieee154e_dbg
     /tmp/ccppeInf.s:68     .text:00000000 $t
     /tmp/ccppeInf.s:73     .text:00000000 ieee154e_init
     /tmp/ccppeInf.s:5451   .text:00002548 changeIsSync
     /tmp/ccppeInf.s:5601   .text:000025f8 resetStats
     /tmp/ccppeInf.s:186    .text:00000108 isr_ieee154ecsl_newChannelSample
     /tmp/ccppeInf.s:247    .text:0000016c isr_ieee154ecsl_timer
     /tmp/ccppeInf.s:516    .text:00000370 ieee154ecsl_startOfFrame
     /tmp/ccppeInf.s:670    .text:000004ac ieee154ecsl_endOfFrame
     /tmp/ccppeInf.s:813    .text:000005a8 isr_ieee154ecsl_txtimer_cb
     /tmp/ccppeInf.s:863    .text:000005ec isr_ieee154ecsl_addPacketToQueueForTestingCslTx_cb
     /tmp/ccppeInf.s:2597   .text:000011a0 activity_csl_wakeup_ri1
     /tmp/ccppeInf.s:278    .text:00000198 $d
     /tmp/ccppeInf.s:2665   .text:00001210 activity_csl_wakeup_ri2
     /tmp/ccppeInf.s:296    .text:000001d8 $t
     /tmp/ccppeInf.s:2715   .text:00001260 activity_csl_wakeup_rie1
     /tmp/ccppeInf.s:2756   .text:00001290 activity_csl_wakeup_ri3
     /tmp/ccppeInf.s:2788   .text:000012ac activity_csl_wakeup_rie2
     /tmp/ccppeInf.s:2876   .text:0000131c activity_csl_wakeup_rie3
     /tmp/ccppeInf.s:3273   .text:00001678 activity_csl_wakeup_rie4
     /tmp/ccppeInf.s:3299   .text:00001684 activity_csl_data_ri2
     /tmp/ccppeInf.s:3349   .text:000016d4 activity_csl_data_rie1
     /tmp/ccppeInf.s:3390   .text:00001704 activity_csl_data_ri3
     /tmp/ccppeInf.s:3422   .text:00001720 activity_csl_data_rie2
     /tmp/ccppeInf.s:3500   .text:00001774 activity_csl_data_rie3
     /tmp/ccppeInf.s:3898   .text:00001ab0 activity_csl_data_ri6
     /tmp/ccppeInf.s:4131   .text:00001ccc activity_csl_data_rie4
     /tmp/ccppeInf.s:4172   .text:00001cfc activity_csl_data_ri7
     /tmp/ccppeInf.s:4208   .text:00001d24 activity_csl_data_rie5
     /tmp/ccppeInf.s:4296   .text:00001d90 activity_csl_data_rie6
     /tmp/ccppeInf.s:5980   .text:000028a0 endOps
     /tmp/ccppeInf.s:397    .text:0000028c $d
     /tmp/ccppeInf.s:1165   .text:00000838 activity_csl_wakeup_ti2
     /tmp/ccppeInf.s:415    .text:000002cc $t
     /tmp/ccppeInf.s:1373   .text:00000a30 activity_csl_wakeup_tie1
     /tmp/ccppeInf.s:1411   .text:00000a5c activity_csl_wakeup_ti3
     /tmp/ccppeInf.s:1447   .text:00000a84 activity_csl_wakeup_tie2
     /tmp/ccppeInf.s:1532   .text:00000aec activity_csl_wakeup_tie3
     /tmp/ccppeInf.s:1615   .text:00000b50 activity_csl_data_ti1
     /tmp/ccppeInf.s:1649   .text:00000b74 activity_csl_data_ti2
     /tmp/ccppeInf.s:1713   .text:00000be4 activity_csl_data_tie1
     /tmp/ccppeInf.s:1751   .text:00000c10 activity_csl_data_ti3
     /tmp/ccppeInf.s:1787   .text:00000c38 activity_csl_data_tie2
     /tmp/ccppeInf.s:1872   .text:00000ca0 activity_csl_data_tie3
     /tmp/ccppeInf.s:2031   .text:00000dac activity_csl_data_ti6
     /tmp/ccppeInf.s:2081   .text:00000dfc activity_csl_data_tie4
     /tmp/ccppeInf.s:2119   .text:00000e28 activity_csl_data_ti7
     /tmp/ccppeInf.s:2155   .text:00000e50 activity_csl_data_tie5
     /tmp/ccppeInf.s:2255   .text:00000ee4 activity_csl_data_tie6
     /tmp/ccppeInf.s:551    .text:000003a0 $d
     /tmp/ccppeInf.s:565    .text:000003d0 $t
     /tmp/ccppeInf.s:2824   .text:000012d4 activity_csl_wakeup_ri4
     /tmp/ccppeInf.s:3448   .text:0000172c activity_csl_data_ri4
     /tmp/ccppeInf.s:4249   .text:00001d54 activity_csl_data_ri8
     /tmp/ccppeInf.s:602    .text:00000418 $d
     /tmp/ccppeInf.s:616    .text:00000448 $t
     /tmp/ccppeInf.s:2213   .text:00000eb4 activity_csl_data_ti8
     /tmp/ccppeInf.s:1485   .text:00000ab0 activity_csl_wakeup_ti4
     /tmp/ccppeInf.s:1825   .text:00000c64 activity_csl_data_ti4
     /tmp/ccppeInf.s:2917   .text:0000134c activity_csl_wakeup_ri5
     /tmp/ccppeInf.s:3541   .text:000017a4 activity_csl_data_ri5
     /tmp/ccppeInf.s:4337   .text:00001dc0 activity_csl_data_ri9
     /tmp/ccppeInf.s:1570   .text:00000b18 activity_csl_wakeup_ti5
     /tmp/ccppeInf.s:1910   .text:00000ccc activity_csl_data_ti5
     /tmp/ccppeInf.s:2281   .text:00000ef0 activity_csl_data_ti9
     /tmp/ccppeInf.s:1024   .text:00000724 activity_csl_wakeup_ti1
     /tmp/ccppeInf.s:5168   .text:0000231c incrementAsnOffset
     /tmp/ccppeInf.s:5724   .text:000026bc changeState
     /tmp/ccppeInf.s:4402   .text:00001e2c ieee802154_createWakeUpFrame
     /tmp/ccppeInf.s:5079   .text:0000229c isValidAck
     /tmp/ccppeInf.s:6209   .text:00002a80 ieee154e_processIEs
     /tmp/ccppeInf.s:4518   .text:00001ef4 ieee802154_retrieveWakeUpFrame
     /tmp/ccppeInf.s:4986   .text:00002220 isValidRxFrame
     /tmp/ccppeInf.s:5558   .text:000025d4 notif_receive
     /tmp/ccppeInf.s:5270   .text:00002404 ieee154e_getAsn
     /tmp/ccppeInf.s:5347   .text:00002490 synchronizeAck
     /tmp/ccppeInf.s:5663   .text:00002668 updateStats
     /tmp/ccppeInf.s:5504   .text:00002588 notif_sendDone
     /tmp/ccppeInf.s:5758   .text:000026e8 $d
     /tmp/ccppeInf.s:5820   .text:000027d8 $t
     /tmp/ccppeInf.s:5846   .text:000027f4 debugPrint_asn
     /tmp/ccppeInf.s:5901   .text:00002848 debugPrint_isSync
     /tmp/ccppeInf.s:5947   .text:00002880 debugPrint_macStats
     /tmp/ccppeInf.s:6178   .text:00002a68 ieee154e_isSynch
     /tmp/ccppeInf.s:6597   .text:00002d10 asnStoreFromAdv
     /tmp/ccppeInf.s:6553   .text:00002cd8 joinPriorityStoreFromAdv
     /tmp/ccppeInf.s:6698   .text:00002dd4 ieee154e_asnDiff
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.1.e96eee74da26538b12ac9582e3798382
                           .group:00000000 wm4.newlib.h.8.a9901dc52d1357e3e94003403d43f8b5
                           .group:00000000 wm4.features.h.22.b72b3baab2bb2eab3661375590100b6b
                           .group:00000000 wm4.config.h.193.5fb8ef056cdff92dec3dee9552839d8c
                           .group:00000000 wm4._ansi.h.23.b5bb84d7ba97d82b5b1dc1826a7ae811
                           .group:00000000 wm4.stdint.h.20.54ad762faa59e3c05491630641c8d8bf
                           .group:00000000 wm4.toolchain_defs.h.2.e4ebbe6e0a48032a9b79077dc42e1ffd
                           .group:00000000 wm4._default_types.h.6.5e12cd604db8ce00b62bb2f02708eaf3
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4.stddef.h.349.31f4c5baff3fa2689010b32028da9c47
                           .group:00000000 wm4.reent.h.16.9e42f0e588b85e70b2bf6572af57ce64
                           .group:00000000 wm4.stddef.h.187.9e651b6b8b16e149c1353259404973ea
                           .group:00000000 wm4.string.h.17.f8d12df81104836a3f2a5d589ae830d8
                           .group:00000000 wm4.stdbool.h.29.1c9ee6859ce8145f7838a4f2549ccec2
                           .group:00000000 wm4.hw_types.h.67.b10589a0806dcc2d274d6fab6b736519
                           .group:00000000 wm4.interrupt.h.41.272fc4ec0e276feb439e7974d0f77eaf
                           .group:00000000 wm4.board_info.h.21.847e72606a2fc49b1c228f268b8a62aa
                           .group:00000000 wm4.opendefs.h.19.05852eb648ac65e48c7817e5cbf03346
                           .group:00000000 wm4.schedule.h.2.74f699399ee9cbf3b59178f1204d8511
                           .group:00000000 wm4.processIE.h.2.1848f1e3c653035e9779472584ce0441
                           .group:00000000 wm4.opentimers.h.8.044f2d040a134cdb0ddb58adfc2508be
                           .group:00000000 wm4.IEEE802154Ecsl.h.21.4a27f1f1ecd53a3f77f305e2d49a8f4a
                           .group:00000000 wm4.idmanager.h.2.8c0e2159b32ef3125cbb1e984805cbfe
                           .group:00000000 wm4.openserial.h.8.8c63e3800d2936b44b5370ce1aae62b7
                           .group:00000000 wm4.scheduler.h.2.ca320b72942c5204a6e225e3c9c0814e
                           .group:00000000 wm4.icmpv6rpl.h.2.0ce84dbe8c203c7079b39e7e96c7c01e
                           .group:00000000 wm4.neighbors.h.15.9f35f180a0332d1bc442efb0ec51905c
                           .group:00000000 wm4.sixtop.h.2.0b8613e8e48e9109b53e6143f3ed1895

UNDEFINED SYMBOLS
memset
idmanager_getIsDAGroot
radio_rfOn
radio_setOverflowCb
radio_setCompareCb
radio_setStartFrameCb
radio_setEndFrameCb
opentimers_start
radio_startTimer
radio_setTimerPeriod
openserial_printInfo
openserial_printError
leds_all_off
openqueue_macGetDataPacket
openqueue_getFreePacketBuffer
ieee802154_prependHeader
packetfunctions_reserveFooterSize
debugpins_slot_toggle
debugpins_frame_toggle
schedule_advanceSlot
openserial_stop
schedule_getType
schedule_getOkToSend
schedule_getNeighbor
radiotimer_schedule
radio_loadPacket
radio_txEnable
radio_getTimerValue
radio_txNow
radiotimer_cancel
radio_rfOff
packetfunctions_isBroadcastMulticast
leds_sync_blink
schedule_indicateTx
radio_rxEnable
radio_rxNow
radio_getReceivedFrame
packetfunctions_tossFooter
ieee802154_retrieveHeader
packetfunctions_tossHeader
openqueue_freePacketBuffer
packetfunctions_mac64bToMac16b
packetfunctions_sameAddress
idmanager_getMyID
packetfunctions_reserveHeaderSize
packetfunctions_writeAddress
packetfunctions_readAddress
idmanager_isMyAddress
schedule_getFrameLength
radio_getTimerPeriod
adaptive_sync_indicateTimeCorrection
leds_sync_on
leds_sync_off
schedule_resetBackoff
task_sixtopNotifSendDone
scheduler_push_task
leds_error_toggle
debugpins_fsm_set
debugpins_fsm_clr
debugpins_fsm_toggle
openserial_printStatus
processIE_retrieveSlotframeLinkIE
neighbors_isPreferredParent
schedule_syncSlotOffset
schedule_getNextActiveSlotOffset
schedule_getChannelOffset
IntMasterDisable
IntMasterEnable
